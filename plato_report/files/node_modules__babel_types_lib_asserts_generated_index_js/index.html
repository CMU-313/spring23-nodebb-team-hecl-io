<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@babel/types/lib/asserts/generated/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@babel/types/lib/asserts/generated/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">94.36</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1231</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">28.88</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">13.51</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

Object.defineProperty(exports, &quot;__esModule&quot;, {
  value: true
});
exports.assertAccessor = assertAccessor;
exports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
exports.assertArgumentPlaceholder = assertArgumentPlaceholder;
exports.assertArrayExpression = assertArrayExpression;
exports.assertArrayPattern = assertArrayPattern;
exports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
exports.assertArrowFunctionExpression = assertArrowFunctionExpression;
exports.assertAssignmentExpression = assertAssignmentExpression;
exports.assertAssignmentPattern = assertAssignmentPattern;
exports.assertAwaitExpression = assertAwaitExpression;
exports.assertBigIntLiteral = assertBigIntLiteral;
exports.assertBinary = assertBinary;
exports.assertBinaryExpression = assertBinaryExpression;
exports.assertBindExpression = assertBindExpression;
exports.assertBlock = assertBlock;
exports.assertBlockParent = assertBlockParent;
exports.assertBlockStatement = assertBlockStatement;
exports.assertBooleanLiteral = assertBooleanLiteral;
exports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
exports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
exports.assertBreakStatement = assertBreakStatement;
exports.assertCallExpression = assertCallExpression;
exports.assertCatchClause = assertCatchClause;
exports.assertClass = assertClass;
exports.assertClassAccessorProperty = assertClassAccessorProperty;
exports.assertClassBody = assertClassBody;
exports.assertClassDeclaration = assertClassDeclaration;
exports.assertClassExpression = assertClassExpression;
exports.assertClassImplements = assertClassImplements;
exports.assertClassMethod = assertClassMethod;
exports.assertClassPrivateMethod = assertClassPrivateMethod;
exports.assertClassPrivateProperty = assertClassPrivateProperty;
exports.assertClassProperty = assertClassProperty;
exports.assertCompletionStatement = assertCompletionStatement;
exports.assertConditional = assertConditional;
exports.assertConditionalExpression = assertConditionalExpression;
exports.assertContinueStatement = assertContinueStatement;
exports.assertDebuggerStatement = assertDebuggerStatement;
exports.assertDecimalLiteral = assertDecimalLiteral;
exports.assertDeclaration = assertDeclaration;
exports.assertDeclareClass = assertDeclareClass;
exports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
exports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
exports.assertDeclareFunction = assertDeclareFunction;
exports.assertDeclareInterface = assertDeclareInterface;
exports.assertDeclareModule = assertDeclareModule;
exports.assertDeclareModuleExports = assertDeclareModuleExports;
exports.assertDeclareOpaqueType = assertDeclareOpaqueType;
exports.assertDeclareTypeAlias = assertDeclareTypeAlias;
exports.assertDeclareVariable = assertDeclareVariable;
exports.assertDeclaredPredicate = assertDeclaredPredicate;
exports.assertDecorator = assertDecorator;
exports.assertDirective = assertDirective;
exports.assertDirectiveLiteral = assertDirectiveLiteral;
exports.assertDoExpression = assertDoExpression;
exports.assertDoWhileStatement = assertDoWhileStatement;
exports.assertEmptyStatement = assertEmptyStatement;
exports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
exports.assertEnumBody = assertEnumBody;
exports.assertEnumBooleanBody = assertEnumBooleanBody;
exports.assertEnumBooleanMember = assertEnumBooleanMember;
exports.assertEnumDeclaration = assertEnumDeclaration;
exports.assertEnumDefaultedMember = assertEnumDefaultedMember;
exports.assertEnumMember = assertEnumMember;
exports.assertEnumNumberBody = assertEnumNumberBody;
exports.assertEnumNumberMember = assertEnumNumberMember;
exports.assertEnumStringBody = assertEnumStringBody;
exports.assertEnumStringMember = assertEnumStringMember;
exports.assertEnumSymbolBody = assertEnumSymbolBody;
exports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
exports.assertExportAllDeclaration = assertExportAllDeclaration;
exports.assertExportDeclaration = assertExportDeclaration;
exports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
exports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
exports.assertExportNamedDeclaration = assertExportNamedDeclaration;
exports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
exports.assertExportSpecifier = assertExportSpecifier;
exports.assertExpression = assertExpression;
exports.assertExpressionStatement = assertExpressionStatement;
exports.assertExpressionWrapper = assertExpressionWrapper;
exports.assertFile = assertFile;
exports.assertFlow = assertFlow;
exports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
exports.assertFlowDeclaration = assertFlowDeclaration;
exports.assertFlowPredicate = assertFlowPredicate;
exports.assertFlowType = assertFlowType;
exports.assertFor = assertFor;
exports.assertForInStatement = assertForInStatement;
exports.assertForOfStatement = assertForOfStatement;
exports.assertForStatement = assertForStatement;
exports.assertForXStatement = assertForXStatement;
exports.assertFunction = assertFunction;
exports.assertFunctionDeclaration = assertFunctionDeclaration;
exports.assertFunctionExpression = assertFunctionExpression;
exports.assertFunctionParent = assertFunctionParent;
exports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
exports.assertFunctionTypeParam = assertFunctionTypeParam;
exports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
exports.assertIdentifier = assertIdentifier;
exports.assertIfStatement = assertIfStatement;
exports.assertImmutable = assertImmutable;
exports.assertImport = assertImport;
exports.assertImportAttribute = assertImportAttribute;
exports.assertImportDeclaration = assertImportDeclaration;
exports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
exports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
exports.assertImportOrExportDeclaration = assertImportOrExportDeclaration;
exports.assertImportSpecifier = assertImportSpecifier;
exports.assertIndexedAccessType = assertIndexedAccessType;
exports.assertInferredPredicate = assertInferredPredicate;
exports.assertInterfaceDeclaration = assertInterfaceDeclaration;
exports.assertInterfaceExtends = assertInterfaceExtends;
exports.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
exports.assertInterpreterDirective = assertInterpreterDirective;
exports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
exports.assertJSX = assertJSX;
exports.assertJSXAttribute = assertJSXAttribute;
exports.assertJSXClosingElement = assertJSXClosingElement;
exports.assertJSXClosingFragment = assertJSXClosingFragment;
exports.assertJSXElement = assertJSXElement;
exports.assertJSXEmptyExpression = assertJSXEmptyExpression;
exports.assertJSXExpressionContainer = assertJSXExpressionContainer;
exports.assertJSXFragment = assertJSXFragment;
exports.assertJSXIdentifier = assertJSXIdentifier;
exports.assertJSXMemberExpression = assertJSXMemberExpression;
exports.assertJSXNamespacedName = assertJSXNamespacedName;
exports.assertJSXOpeningElement = assertJSXOpeningElement;
exports.assertJSXOpeningFragment = assertJSXOpeningFragment;
exports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
exports.assertJSXSpreadChild = assertJSXSpreadChild;
exports.assertJSXText = assertJSXText;
exports.assertLVal = assertLVal;
exports.assertLabeledStatement = assertLabeledStatement;
exports.assertLiteral = assertLiteral;
exports.assertLogicalExpression = assertLogicalExpression;
exports.assertLoop = assertLoop;
exports.assertMemberExpression = assertMemberExpression;
exports.assertMetaProperty = assertMetaProperty;
exports.assertMethod = assertMethod;
exports.assertMiscellaneous = assertMiscellaneous;
exports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
exports.assertModuleDeclaration = assertModuleDeclaration;
exports.assertModuleExpression = assertModuleExpression;
exports.assertModuleSpecifier = assertModuleSpecifier;
exports.assertNewExpression = assertNewExpression;
exports.assertNoop = assertNoop;
exports.assertNullLiteral = assertNullLiteral;
exports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
exports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
exports.assertNumberLiteral = assertNumberLiteral;
exports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
exports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
exports.assertNumericLiteral = assertNumericLiteral;
exports.assertObjectExpression = assertObjectExpression;
exports.assertObjectMember = assertObjectMember;
exports.assertObjectMethod = assertObjectMethod;
exports.assertObjectPattern = assertObjectPattern;
exports.assertObjectProperty = assertObjectProperty;
exports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
exports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
exports.assertObjectTypeIndexer = assertObjectTypeIndexer;
exports.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
exports.assertObjectTypeProperty = assertObjectTypeProperty;
exports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
exports.assertOpaqueType = assertOpaqueType;
exports.assertOptionalCallExpression = assertOptionalCallExpression;
exports.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
exports.assertOptionalMemberExpression = assertOptionalMemberExpression;
exports.assertParenthesizedExpression = assertParenthesizedExpression;
exports.assertPattern = assertPattern;
exports.assertPatternLike = assertPatternLike;
exports.assertPipelineBareFunction = assertPipelineBareFunction;
exports.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
exports.assertPipelineTopicExpression = assertPipelineTopicExpression;
exports.assertPlaceholder = assertPlaceholder;
exports.assertPrivate = assertPrivate;
exports.assertPrivateName = assertPrivateName;
exports.assertProgram = assertProgram;
exports.assertProperty = assertProperty;
exports.assertPureish = assertPureish;
exports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
exports.assertRecordExpression = assertRecordExpression;
exports.assertRegExpLiteral = assertRegExpLiteral;
exports.assertRegexLiteral = assertRegexLiteral;
exports.assertRestElement = assertRestElement;
exports.assertRestProperty = assertRestProperty;
exports.assertReturnStatement = assertReturnStatement;
exports.assertScopable = assertScopable;
exports.assertSequenceExpression = assertSequenceExpression;
exports.assertSpreadElement = assertSpreadElement;
exports.assertSpreadProperty = assertSpreadProperty;
exports.assertStandardized = assertStandardized;
exports.assertStatement = assertStatement;
exports.assertStaticBlock = assertStaticBlock;
exports.assertStringLiteral = assertStringLiteral;
exports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
exports.assertStringTypeAnnotation = assertStringTypeAnnotation;
exports.assertSuper = assertSuper;
exports.assertSwitchCase = assertSwitchCase;
exports.assertSwitchStatement = assertSwitchStatement;
exports.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
exports.assertTSAnyKeyword = assertTSAnyKeyword;
exports.assertTSArrayType = assertTSArrayType;
exports.assertTSAsExpression = assertTSAsExpression;
exports.assertTSBaseType = assertTSBaseType;
exports.assertTSBigIntKeyword = assertTSBigIntKeyword;
exports.assertTSBooleanKeyword = assertTSBooleanKeyword;
exports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
exports.assertTSConditionalType = assertTSConditionalType;
exports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
exports.assertTSConstructorType = assertTSConstructorType;
exports.assertTSDeclareFunction = assertTSDeclareFunction;
exports.assertTSDeclareMethod = assertTSDeclareMethod;
exports.assertTSEntityName = assertTSEntityName;
exports.assertTSEnumDeclaration = assertTSEnumDeclaration;
exports.assertTSEnumMember = assertTSEnumMember;
exports.assertTSExportAssignment = assertTSExportAssignment;
exports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
exports.assertTSExternalModuleReference = assertTSExternalModuleReference;
exports.assertTSFunctionType = assertTSFunctionType;
exports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
exports.assertTSImportType = assertTSImportType;
exports.assertTSIndexSignature = assertTSIndexSignature;
exports.assertTSIndexedAccessType = assertTSIndexedAccessType;
exports.assertTSInferType = assertTSInferType;
exports.assertTSInstantiationExpression = assertTSInstantiationExpression;
exports.assertTSInterfaceBody = assertTSInterfaceBody;
exports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
exports.assertTSIntersectionType = assertTSIntersectionType;
exports.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
exports.assertTSLiteralType = assertTSLiteralType;
exports.assertTSMappedType = assertTSMappedType;
exports.assertTSMethodSignature = assertTSMethodSignature;
exports.assertTSModuleBlock = assertTSModuleBlock;
exports.assertTSModuleDeclaration = assertTSModuleDeclaration;
exports.assertTSNamedTupleMember = assertTSNamedTupleMember;
exports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
exports.assertTSNeverKeyword = assertTSNeverKeyword;
exports.assertTSNonNullExpression = assertTSNonNullExpression;
exports.assertTSNullKeyword = assertTSNullKeyword;
exports.assertTSNumberKeyword = assertTSNumberKeyword;
exports.assertTSObjectKeyword = assertTSObjectKeyword;
exports.assertTSOptionalType = assertTSOptionalType;
exports.assertTSParameterProperty = assertTSParameterProperty;
exports.assertTSParenthesizedType = assertTSParenthesizedType;
exports.assertTSPropertySignature = assertTSPropertySignature;
exports.assertTSQualifiedName = assertTSQualifiedName;
exports.assertTSRestType = assertTSRestType;
exports.assertTSSatisfiesExpression = assertTSSatisfiesExpression;
exports.assertTSStringKeyword = assertTSStringKeyword;
exports.assertTSSymbolKeyword = assertTSSymbolKeyword;
exports.assertTSThisType = assertTSThisType;
exports.assertTSTupleType = assertTSTupleType;
exports.assertTSType = assertTSType;
exports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
exports.assertTSTypeAnnotation = assertTSTypeAnnotation;
exports.assertTSTypeAssertion = assertTSTypeAssertion;
exports.assertTSTypeElement = assertTSTypeElement;
exports.assertTSTypeLiteral = assertTSTypeLiteral;
exports.assertTSTypeOperator = assertTSTypeOperator;
exports.assertTSTypeParameter = assertTSTypeParameter;
exports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
exports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
exports.assertTSTypePredicate = assertTSTypePredicate;
exports.assertTSTypeQuery = assertTSTypeQuery;
exports.assertTSTypeReference = assertTSTypeReference;
exports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
exports.assertTSUnionType = assertTSUnionType;
exports.assertTSUnknownKeyword = assertTSUnknownKeyword;
exports.assertTSVoidKeyword = assertTSVoidKeyword;
exports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
exports.assertTemplateElement = assertTemplateElement;
exports.assertTemplateLiteral = assertTemplateLiteral;
exports.assertTerminatorless = assertTerminatorless;
exports.assertThisExpression = assertThisExpression;
exports.assertThisTypeAnnotation = assertThisTypeAnnotation;
exports.assertThrowStatement = assertThrowStatement;
exports.assertTopicReference = assertTopicReference;
exports.assertTryStatement = assertTryStatement;
exports.assertTupleExpression = assertTupleExpression;
exports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
exports.assertTypeAlias = assertTypeAlias;
exports.assertTypeAnnotation = assertTypeAnnotation;
exports.assertTypeCastExpression = assertTypeCastExpression;
exports.assertTypeParameter = assertTypeParameter;
exports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
exports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
exports.assertTypeScript = assertTypeScript;
exports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
exports.assertUnaryExpression = assertUnaryExpression;
exports.assertUnaryLike = assertUnaryLike;
exports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
exports.assertUpdateExpression = assertUpdateExpression;
exports.assertUserWhitespacable = assertUserWhitespacable;
exports.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
exports.assertVariableDeclaration = assertVariableDeclaration;
exports.assertVariableDeclarator = assertVariableDeclarator;
exports.assertVariance = assertVariance;
exports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
exports.assertWhile = assertWhile;
exports.assertWhileStatement = assertWhileStatement;
exports.assertWithStatement = assertWithStatement;
exports.assertYieldExpression = assertYieldExpression;
var _is = require(&quot;../../validators/is&quot;);
var _deprecationWarning = require(&quot;../../utils/deprecationWarning&quot;);
function assert(type, node, opts) {
  if (!(0, _is.default)(type, node, opts)) {
    throw new Error(`Expected type &quot;${type}&quot; with option ${JSON.stringify(opts)}, ` + `but instead got &quot;${node.type}&quot;.`);
  }
}
function assertArrayExpression(node, opts) {
  assert(&quot;ArrayExpression&quot;, node, opts);
}
function assertAssignmentExpression(node, opts) {
  assert(&quot;AssignmentExpression&quot;, node, opts);
}
function assertBinaryExpression(node, opts) {
  assert(&quot;BinaryExpression&quot;, node, opts);
}
function assertInterpreterDirective(node, opts) {
  assert(&quot;InterpreterDirective&quot;, node, opts);
}
function assertDirective(node, opts) {
  assert(&quot;Directive&quot;, node, opts);
}
function assertDirectiveLiteral(node, opts) {
  assert(&quot;DirectiveLiteral&quot;, node, opts);
}
function assertBlockStatement(node, opts) {
  assert(&quot;BlockStatement&quot;, node, opts);
}
function assertBreakStatement(node, opts) {
  assert(&quot;BreakStatement&quot;, node, opts);
}
function assertCallExpression(node, opts) {
  assert(&quot;CallExpression&quot;, node, opts);
}
function assertCatchClause(node, opts) {
  assert(&quot;CatchClause&quot;, node, opts);
}
function assertConditionalExpression(node, opts) {
  assert(&quot;ConditionalExpression&quot;, node, opts);
}
function assertContinueStatement(node, opts) {
  assert(&quot;ContinueStatement&quot;, node, opts);
}
function assertDebuggerStatement(node, opts) {
  assert(&quot;DebuggerStatement&quot;, node, opts);
}
function assertDoWhileStatement(node, opts) {
  assert(&quot;DoWhileStatement&quot;, node, opts);
}
function assertEmptyStatement(node, opts) {
  assert(&quot;EmptyStatement&quot;, node, opts);
}
function assertExpressionStatement(node, opts) {
  assert(&quot;ExpressionStatement&quot;, node, opts);
}
function assertFile(node, opts) {
  assert(&quot;File&quot;, node, opts);
}
function assertForInStatement(node, opts) {
  assert(&quot;ForInStatement&quot;, node, opts);
}
function assertForStatement(node, opts) {
  assert(&quot;ForStatement&quot;, node, opts);
}
function assertFunctionDeclaration(node, opts) {
  assert(&quot;FunctionDeclaration&quot;, node, opts);
}
function assertFunctionExpression(node, opts) {
  assert(&quot;FunctionExpression&quot;, node, opts);
}
function assertIdentifier(node, opts) {
  assert(&quot;Identifier&quot;, node, opts);
}
function assertIfStatement(node, opts) {
  assert(&quot;IfStatement&quot;, node, opts);
}
function assertLabeledStatement(node, opts) {
  assert(&quot;LabeledStatement&quot;, node, opts);
}
function assertStringLiteral(node, opts) {
  assert(&quot;StringLiteral&quot;, node, opts);
}
function assertNumericLiteral(node, opts) {
  assert(&quot;NumericLiteral&quot;, node, opts);
}
function assertNullLiteral(node, opts) {
  assert(&quot;NullLiteral&quot;, node, opts);
}
function assertBooleanLiteral(node, opts) {
  assert(&quot;BooleanLiteral&quot;, node, opts);
}
function assertRegExpLiteral(node, opts) {
  assert(&quot;RegExpLiteral&quot;, node, opts);
}
function assertLogicalExpression(node, opts) {
  assert(&quot;LogicalExpression&quot;, node, opts);
}
function assertMemberExpression(node, opts) {
  assert(&quot;MemberExpression&quot;, node, opts);
}
function assertNewExpression(node, opts) {
  assert(&quot;NewExpression&quot;, node, opts);
}
function assertProgram(node, opts) {
  assert(&quot;Program&quot;, node, opts);
}
function assertObjectExpression(node, opts) {
  assert(&quot;ObjectExpression&quot;, node, opts);
}
function assertObjectMethod(node, opts) {
  assert(&quot;ObjectMethod&quot;, node, opts);
}
function assertObjectProperty(node, opts) {
  assert(&quot;ObjectProperty&quot;, node, opts);
}
function assertRestElement(node, opts) {
  assert(&quot;RestElement&quot;, node, opts);
}
function assertReturnStatement(node, opts) {
  assert(&quot;ReturnStatement&quot;, node, opts);
}
function assertSequenceExpression(node, opts) {
  assert(&quot;SequenceExpression&quot;, node, opts);
}
function assertParenthesizedExpression(node, opts) {
  assert(&quot;ParenthesizedExpression&quot;, node, opts);
}
function assertSwitchCase(node, opts) {
  assert(&quot;SwitchCase&quot;, node, opts);
}
function assertSwitchStatement(node, opts) {
  assert(&quot;SwitchStatement&quot;, node, opts);
}
function assertThisExpression(node, opts) {
  assert(&quot;ThisExpression&quot;, node, opts);
}
function assertThrowStatement(node, opts) {
  assert(&quot;ThrowStatement&quot;, node, opts);
}
function assertTryStatement(node, opts) {
  assert(&quot;TryStatement&quot;, node, opts);
}
function assertUnaryExpression(node, opts) {
  assert(&quot;UnaryExpression&quot;, node, opts);
}
function assertUpdateExpression(node, opts) {
  assert(&quot;UpdateExpression&quot;, node, opts);
}
function assertVariableDeclaration(node, opts) {
  assert(&quot;VariableDeclaration&quot;, node, opts);
}
function assertVariableDeclarator(node, opts) {
  assert(&quot;VariableDeclarator&quot;, node, opts);
}
function assertWhileStatement(node, opts) {
  assert(&quot;WhileStatement&quot;, node, opts);
}
function assertWithStatement(node, opts) {
  assert(&quot;WithStatement&quot;, node, opts);
}
function assertAssignmentPattern(node, opts) {
  assert(&quot;AssignmentPattern&quot;, node, opts);
}
function assertArrayPattern(node, opts) {
  assert(&quot;ArrayPattern&quot;, node, opts);
}
function assertArrowFunctionExpression(node, opts) {
  assert(&quot;ArrowFunctionExpression&quot;, node, opts);
}
function assertClassBody(node, opts) {
  assert(&quot;ClassBody&quot;, node, opts);
}
function assertClassExpression(node, opts) {
  assert(&quot;ClassExpression&quot;, node, opts);
}
function assertClassDeclaration(node, opts) {
  assert(&quot;ClassDeclaration&quot;, node, opts);
}
function assertExportAllDeclaration(node, opts) {
  assert(&quot;ExportAllDeclaration&quot;, node, opts);
}
function assertExportDefaultDeclaration(node, opts) {
  assert(&quot;ExportDefaultDeclaration&quot;, node, opts);
}
function assertExportNamedDeclaration(node, opts) {
  assert(&quot;ExportNamedDeclaration&quot;, node, opts);
}
function assertExportSpecifier(node, opts) {
  assert(&quot;ExportSpecifier&quot;, node, opts);
}
function assertForOfStatement(node, opts) {
  assert(&quot;ForOfStatement&quot;, node, opts);
}
function assertImportDeclaration(node, opts) {
  assert(&quot;ImportDeclaration&quot;, node, opts);
}
function assertImportDefaultSpecifier(node, opts) {
  assert(&quot;ImportDefaultSpecifier&quot;, node, opts);
}
function assertImportNamespaceSpecifier(node, opts) {
  assert(&quot;ImportNamespaceSpecifier&quot;, node, opts);
}
function assertImportSpecifier(node, opts) {
  assert(&quot;ImportSpecifier&quot;, node, opts);
}
function assertMetaProperty(node, opts) {
  assert(&quot;MetaProperty&quot;, node, opts);
}
function assertClassMethod(node, opts) {
  assert(&quot;ClassMethod&quot;, node, opts);
}
function assertObjectPattern(node, opts) {
  assert(&quot;ObjectPattern&quot;, node, opts);
}
function assertSpreadElement(node, opts) {
  assert(&quot;SpreadElement&quot;, node, opts);
}
function assertSuper(node, opts) {
  assert(&quot;Super&quot;, node, opts);
}
function assertTaggedTemplateExpression(node, opts) {
  assert(&quot;TaggedTemplateExpression&quot;, node, opts);
}
function assertTemplateElement(node, opts) {
  assert(&quot;TemplateElement&quot;, node, opts);
}
function assertTemplateLiteral(node, opts) {
  assert(&quot;TemplateLiteral&quot;, node, opts);
}
function assertYieldExpression(node, opts) {
  assert(&quot;YieldExpression&quot;, node, opts);
}
function assertAwaitExpression(node, opts) {
  assert(&quot;AwaitExpression&quot;, node, opts);
}
function assertImport(node, opts) {
  assert(&quot;Import&quot;, node, opts);
}
function assertBigIntLiteral(node, opts) {
  assert(&quot;BigIntLiteral&quot;, node, opts);
}
function assertExportNamespaceSpecifier(node, opts) {
  assert(&quot;ExportNamespaceSpecifier&quot;, node, opts);
}
function assertOptionalMemberExpression(node, opts) {
  assert(&quot;OptionalMemberExpression&quot;, node, opts);
}
function assertOptionalCallExpression(node, opts) {
  assert(&quot;OptionalCallExpression&quot;, node, opts);
}
function assertClassProperty(node, opts) {
  assert(&quot;ClassProperty&quot;, node, opts);
}
function assertClassAccessorProperty(node, opts) {
  assert(&quot;ClassAccessorProperty&quot;, node, opts);
}
function assertClassPrivateProperty(node, opts) {
  assert(&quot;ClassPrivateProperty&quot;, node, opts);
}
function assertClassPrivateMethod(node, opts) {
  assert(&quot;ClassPrivateMethod&quot;, node, opts);
}
function assertPrivateName(node, opts) {
  assert(&quot;PrivateName&quot;, node, opts);
}
function assertStaticBlock(node, opts) {
  assert(&quot;StaticBlock&quot;, node, opts);
}
function assertAnyTypeAnnotation(node, opts) {
  assert(&quot;AnyTypeAnnotation&quot;, node, opts);
}
function assertArrayTypeAnnotation(node, opts) {
  assert(&quot;ArrayTypeAnnotation&quot;, node, opts);
}
function assertBooleanTypeAnnotation(node, opts) {
  assert(&quot;BooleanTypeAnnotation&quot;, node, opts);
}
function assertBooleanLiteralTypeAnnotation(node, opts) {
  assert(&quot;BooleanLiteralTypeAnnotation&quot;, node, opts);
}
function assertNullLiteralTypeAnnotation(node, opts) {
  assert(&quot;NullLiteralTypeAnnotation&quot;, node, opts);
}
function assertClassImplements(node, opts) {
  assert(&quot;ClassImplements&quot;, node, opts);
}
function assertDeclareClass(node, opts) {
  assert(&quot;DeclareClass&quot;, node, opts);
}
function assertDeclareFunction(node, opts) {
  assert(&quot;DeclareFunction&quot;, node, opts);
}
function assertDeclareInterface(node, opts) {
  assert(&quot;DeclareInterface&quot;, node, opts);
}
function assertDeclareModule(node, opts) {
  assert(&quot;DeclareModule&quot;, node, opts);
}
function assertDeclareModuleExports(node, opts) {
  assert(&quot;DeclareModuleExports&quot;, node, opts);
}
function assertDeclareTypeAlias(node, opts) {
  assert(&quot;DeclareTypeAlias&quot;, node, opts);
}
function assertDeclareOpaqueType(node, opts) {
  assert(&quot;DeclareOpaqueType&quot;, node, opts);
}
function assertDeclareVariable(node, opts) {
  assert(&quot;DeclareVariable&quot;, node, opts);
}
function assertDeclareExportDeclaration(node, opts) {
  assert(&quot;DeclareExportDeclaration&quot;, node, opts);
}
function assertDeclareExportAllDeclaration(node, opts) {
  assert(&quot;DeclareExportAllDeclaration&quot;, node, opts);
}
function assertDeclaredPredicate(node, opts) {
  assert(&quot;DeclaredPredicate&quot;, node, opts);
}
function assertExistsTypeAnnotation(node, opts) {
  assert(&quot;ExistsTypeAnnotation&quot;, node, opts);
}
function assertFunctionTypeAnnotation(node, opts) {
  assert(&quot;FunctionTypeAnnotation&quot;, node, opts);
}
function assertFunctionTypeParam(node, opts) {
  assert(&quot;FunctionTypeParam&quot;, node, opts);
}
function assertGenericTypeAnnotation(node, opts) {
  assert(&quot;GenericTypeAnnotation&quot;, node, opts);
}
function assertInferredPredicate(node, opts) {
  assert(&quot;InferredPredicate&quot;, node, opts);
}
function assertInterfaceExtends(node, opts) {
  assert(&quot;InterfaceExtends&quot;, node, opts);
}
function assertInterfaceDeclaration(node, opts) {
  assert(&quot;InterfaceDeclaration&quot;, node, opts);
}
function assertInterfaceTypeAnnotation(node, opts) {
  assert(&quot;InterfaceTypeAnnotation&quot;, node, opts);
}
function assertIntersectionTypeAnnotation(node, opts) {
  assert(&quot;IntersectionTypeAnnotation&quot;, node, opts);
}
function assertMixedTypeAnnotation(node, opts) {
  assert(&quot;MixedTypeAnnotation&quot;, node, opts);
}
function assertEmptyTypeAnnotation(node, opts) {
  assert(&quot;EmptyTypeAnnotation&quot;, node, opts);
}
function assertNullableTypeAnnotation(node, opts) {
  assert(&quot;NullableTypeAnnotation&quot;, node, opts);
}
function assertNumberLiteralTypeAnnotation(node, opts) {
  assert(&quot;NumberLiteralTypeAnnotation&quot;, node, opts);
}
function assertNumberTypeAnnotation(node, opts) {
  assert(&quot;NumberTypeAnnotation&quot;, node, opts);
}
function assertObjectTypeAnnotation(node, opts) {
  assert(&quot;ObjectTypeAnnotation&quot;, node, opts);
}
function assertObjectTypeInternalSlot(node, opts) {
  assert(&quot;ObjectTypeInternalSlot&quot;, node, opts);
}
function assertObjectTypeCallProperty(node, opts) {
  assert(&quot;ObjectTypeCallProperty&quot;, node, opts);
}
function assertObjectTypeIndexer(node, opts) {
  assert(&quot;ObjectTypeIndexer&quot;, node, opts);
}
function assertObjectTypeProperty(node, opts) {
  assert(&quot;ObjectTypeProperty&quot;, node, opts);
}
function assertObjectTypeSpreadProperty(node, opts) {
  assert(&quot;ObjectTypeSpreadProperty&quot;, node, opts);
}
function assertOpaqueType(node, opts) {
  assert(&quot;OpaqueType&quot;, node, opts);
}
function assertQualifiedTypeIdentifier(node, opts) {
  assert(&quot;QualifiedTypeIdentifier&quot;, node, opts);
}
function assertStringLiteralTypeAnnotation(node, opts) {
  assert(&quot;StringLiteralTypeAnnotation&quot;, node, opts);
}
function assertStringTypeAnnotation(node, opts) {
  assert(&quot;StringTypeAnnotation&quot;, node, opts);
}
function assertSymbolTypeAnnotation(node, opts) {
  assert(&quot;SymbolTypeAnnotation&quot;, node, opts);
}
function assertThisTypeAnnotation(node, opts) {
  assert(&quot;ThisTypeAnnotation&quot;, node, opts);
}
function assertTupleTypeAnnotation(node, opts) {
  assert(&quot;TupleTypeAnnotation&quot;, node, opts);
}
function assertTypeofTypeAnnotation(node, opts) {
  assert(&quot;TypeofTypeAnnotation&quot;, node, opts);
}
function assertTypeAlias(node, opts) {
  assert(&quot;TypeAlias&quot;, node, opts);
}
function assertTypeAnnotation(node, opts) {
  assert(&quot;TypeAnnotation&quot;, node, opts);
}
function assertTypeCastExpression(node, opts) {
  assert(&quot;TypeCastExpression&quot;, node, opts);
}
function assertTypeParameter(node, opts) {
  assert(&quot;TypeParameter&quot;, node, opts);
}
function assertTypeParameterDeclaration(node, opts) {
  assert(&quot;TypeParameterDeclaration&quot;, node, opts);
}
function assertTypeParameterInstantiation(node, opts) {
  assert(&quot;TypeParameterInstantiation&quot;, node, opts);
}
function assertUnionTypeAnnotation(node, opts) {
  assert(&quot;UnionTypeAnnotation&quot;, node, opts);
}
function assertVariance(node, opts) {
  assert(&quot;Variance&quot;, node, opts);
}
function assertVoidTypeAnnotation(node, opts) {
  assert(&quot;VoidTypeAnnotation&quot;, node, opts);
}
function assertEnumDeclaration(node, opts) {
  assert(&quot;EnumDeclaration&quot;, node, opts);
}
function assertEnumBooleanBody(node, opts) {
  assert(&quot;EnumBooleanBody&quot;, node, opts);
}
function assertEnumNumberBody(node, opts) {
  assert(&quot;EnumNumberBody&quot;, node, opts);
}
function assertEnumStringBody(node, opts) {
  assert(&quot;EnumStringBody&quot;, node, opts);
}
function assertEnumSymbolBody(node, opts) {
  assert(&quot;EnumSymbolBody&quot;, node, opts);
}
function assertEnumBooleanMember(node, opts) {
  assert(&quot;EnumBooleanMember&quot;, node, opts);
}
function assertEnumNumberMember(node, opts) {
  assert(&quot;EnumNumberMember&quot;, node, opts);
}
function assertEnumStringMember(node, opts) {
  assert(&quot;EnumStringMember&quot;, node, opts);
}
function assertEnumDefaultedMember(node, opts) {
  assert(&quot;EnumDefaultedMember&quot;, node, opts);
}
function assertIndexedAccessType(node, opts) {
  assert(&quot;IndexedAccessType&quot;, node, opts);
}
function assertOptionalIndexedAccessType(node, opts) {
  assert(&quot;OptionalIndexedAccessType&quot;, node, opts);
}
function assertJSXAttribute(node, opts) {
  assert(&quot;JSXAttribute&quot;, node, opts);
}
function assertJSXClosingElement(node, opts) {
  assert(&quot;JSXClosingElement&quot;, node, opts);
}
function assertJSXElement(node, opts) {
  assert(&quot;JSXElement&quot;, node, opts);
}
function assertJSXEmptyExpression(node, opts) {
  assert(&quot;JSXEmptyExpression&quot;, node, opts);
}
function assertJSXExpressionContainer(node, opts) {
  assert(&quot;JSXExpressionContainer&quot;, node, opts);
}
function assertJSXSpreadChild(node, opts) {
  assert(&quot;JSXSpreadChild&quot;, node, opts);
}
function assertJSXIdentifier(node, opts) {
  assert(&quot;JSXIdentifier&quot;, node, opts);
}
function assertJSXMemberExpression(node, opts) {
  assert(&quot;JSXMemberExpression&quot;, node, opts);
}
function assertJSXNamespacedName(node, opts) {
  assert(&quot;JSXNamespacedName&quot;, node, opts);
}
function assertJSXOpeningElement(node, opts) {
  assert(&quot;JSXOpeningElement&quot;, node, opts);
}
function assertJSXSpreadAttribute(node, opts) {
  assert(&quot;JSXSpreadAttribute&quot;, node, opts);
}
function assertJSXText(node, opts) {
  assert(&quot;JSXText&quot;, node, opts);
}
function assertJSXFragment(node, opts) {
  assert(&quot;JSXFragment&quot;, node, opts);
}
function assertJSXOpeningFragment(node, opts) {
  assert(&quot;JSXOpeningFragment&quot;, node, opts);
}
function assertJSXClosingFragment(node, opts) {
  assert(&quot;JSXClosingFragment&quot;, node, opts);
}
function assertNoop(node, opts) {
  assert(&quot;Noop&quot;, node, opts);
}
function assertPlaceholder(node, opts) {
  assert(&quot;Placeholder&quot;, node, opts);
}
function assertV8IntrinsicIdentifier(node, opts) {
  assert(&quot;V8IntrinsicIdentifier&quot;, node, opts);
}
function assertArgumentPlaceholder(node, opts) {
  assert(&quot;ArgumentPlaceholder&quot;, node, opts);
}
function assertBindExpression(node, opts) {
  assert(&quot;BindExpression&quot;, node, opts);
}
function assertImportAttribute(node, opts) {
  assert(&quot;ImportAttribute&quot;, node, opts);
}
function assertDecorator(node, opts) {
  assert(&quot;Decorator&quot;, node, opts);
}
function assertDoExpression(node, opts) {
  assert(&quot;DoExpression&quot;, node, opts);
}
function assertExportDefaultSpecifier(node, opts) {
  assert(&quot;ExportDefaultSpecifier&quot;, node, opts);
}
function assertRecordExpression(node, opts) {
  assert(&quot;RecordExpression&quot;, node, opts);
}
function assertTupleExpression(node, opts) {
  assert(&quot;TupleExpression&quot;, node, opts);
}
function assertDecimalLiteral(node, opts) {
  assert(&quot;DecimalLiteral&quot;, node, opts);
}
function assertModuleExpression(node, opts) {
  assert(&quot;ModuleExpression&quot;, node, opts);
}
function assertTopicReference(node, opts) {
  assert(&quot;TopicReference&quot;, node, opts);
}
function assertPipelineTopicExpression(node, opts) {
  assert(&quot;PipelineTopicExpression&quot;, node, opts);
}
function assertPipelineBareFunction(node, opts) {
  assert(&quot;PipelineBareFunction&quot;, node, opts);
}
function assertPipelinePrimaryTopicReference(node, opts) {
  assert(&quot;PipelinePrimaryTopicReference&quot;, node, opts);
}
function assertTSParameterProperty(node, opts) {
  assert(&quot;TSParameterProperty&quot;, node, opts);
}
function assertTSDeclareFunction(node, opts) {
  assert(&quot;TSDeclareFunction&quot;, node, opts);
}
function assertTSDeclareMethod(node, opts) {
  assert(&quot;TSDeclareMethod&quot;, node, opts);
}
function assertTSQualifiedName(node, opts) {
  assert(&quot;TSQualifiedName&quot;, node, opts);
}
function assertTSCallSignatureDeclaration(node, opts) {
  assert(&quot;TSCallSignatureDeclaration&quot;, node, opts);
}
function assertTSConstructSignatureDeclaration(node, opts) {
  assert(&quot;TSConstructSignatureDeclaration&quot;, node, opts);
}
function assertTSPropertySignature(node, opts) {
  assert(&quot;TSPropertySignature&quot;, node, opts);
}
function assertTSMethodSignature(node, opts) {
  assert(&quot;TSMethodSignature&quot;, node, opts);
}
function assertTSIndexSignature(node, opts) {
  assert(&quot;TSIndexSignature&quot;, node, opts);
}
function assertTSAnyKeyword(node, opts) {
  assert(&quot;TSAnyKeyword&quot;, node, opts);
}
function assertTSBooleanKeyword(node, opts) {
  assert(&quot;TSBooleanKeyword&quot;, node, opts);
}
function assertTSBigIntKeyword(node, opts) {
  assert(&quot;TSBigIntKeyword&quot;, node, opts);
}
function assertTSIntrinsicKeyword(node, opts) {
  assert(&quot;TSIntrinsicKeyword&quot;, node, opts);
}
function assertTSNeverKeyword(node, opts) {
  assert(&quot;TSNeverKeyword&quot;, node, opts);
}
function assertTSNullKeyword(node, opts) {
  assert(&quot;TSNullKeyword&quot;, node, opts);
}
function assertTSNumberKeyword(node, opts) {
  assert(&quot;TSNumberKeyword&quot;, node, opts);
}
function assertTSObjectKeyword(node, opts) {
  assert(&quot;TSObjectKeyword&quot;, node, opts);
}
function assertTSStringKeyword(node, opts) {
  assert(&quot;TSStringKeyword&quot;, node, opts);
}
function assertTSSymbolKeyword(node, opts) {
  assert(&quot;TSSymbolKeyword&quot;, node, opts);
}
function assertTSUndefinedKeyword(node, opts) {
  assert(&quot;TSUndefinedKeyword&quot;, node, opts);
}
function assertTSUnknownKeyword(node, opts) {
  assert(&quot;TSUnknownKeyword&quot;, node, opts);
}
function assertTSVoidKeyword(node, opts) {
  assert(&quot;TSVoidKeyword&quot;, node, opts);
}
function assertTSThisType(node, opts) {
  assert(&quot;TSThisType&quot;, node, opts);
}
function assertTSFunctionType(node, opts) {
  assert(&quot;TSFunctionType&quot;, node, opts);
}
function assertTSConstructorType(node, opts) {
  assert(&quot;TSConstructorType&quot;, node, opts);
}
function assertTSTypeReference(node, opts) {
  assert(&quot;TSTypeReference&quot;, node, opts);
}
function assertTSTypePredicate(node, opts) {
  assert(&quot;TSTypePredicate&quot;, node, opts);
}
function assertTSTypeQuery(node, opts) {
  assert(&quot;TSTypeQuery&quot;, node, opts);
}
function assertTSTypeLiteral(node, opts) {
  assert(&quot;TSTypeLiteral&quot;, node, opts);
}
function assertTSArrayType(node, opts) {
  assert(&quot;TSArrayType&quot;, node, opts);
}
function assertTSTupleType(node, opts) {
  assert(&quot;TSTupleType&quot;, node, opts);
}
function assertTSOptionalType(node, opts) {
  assert(&quot;TSOptionalType&quot;, node, opts);
}
function assertTSRestType(node, opts) {
  assert(&quot;TSRestType&quot;, node, opts);
}
function assertTSNamedTupleMember(node, opts) {
  assert(&quot;TSNamedTupleMember&quot;, node, opts);
}
function assertTSUnionType(node, opts) {
  assert(&quot;TSUnionType&quot;, node, opts);
}
function assertTSIntersectionType(node, opts) {
  assert(&quot;TSIntersectionType&quot;, node, opts);
}
function assertTSConditionalType(node, opts) {
  assert(&quot;TSConditionalType&quot;, node, opts);
}
function assertTSInferType(node, opts) {
  assert(&quot;TSInferType&quot;, node, opts);
}
function assertTSParenthesizedType(node, opts) {
  assert(&quot;TSParenthesizedType&quot;, node, opts);
}
function assertTSTypeOperator(node, opts) {
  assert(&quot;TSTypeOperator&quot;, node, opts);
}
function assertTSIndexedAccessType(node, opts) {
  assert(&quot;TSIndexedAccessType&quot;, node, opts);
}
function assertTSMappedType(node, opts) {
  assert(&quot;TSMappedType&quot;, node, opts);
}
function assertTSLiteralType(node, opts) {
  assert(&quot;TSLiteralType&quot;, node, opts);
}
function assertTSExpressionWithTypeArguments(node, opts) {
  assert(&quot;TSExpressionWithTypeArguments&quot;, node, opts);
}
function assertTSInterfaceDeclaration(node, opts) {
  assert(&quot;TSInterfaceDeclaration&quot;, node, opts);
}
function assertTSInterfaceBody(node, opts) {
  assert(&quot;TSInterfaceBody&quot;, node, opts);
}
function assertTSTypeAliasDeclaration(node, opts) {
  assert(&quot;TSTypeAliasDeclaration&quot;, node, opts);
}
function assertTSInstantiationExpression(node, opts) {
  assert(&quot;TSInstantiationExpression&quot;, node, opts);
}
function assertTSAsExpression(node, opts) {
  assert(&quot;TSAsExpression&quot;, node, opts);
}
function assertTSSatisfiesExpression(node, opts) {
  assert(&quot;TSSatisfiesExpression&quot;, node, opts);
}
function assertTSTypeAssertion(node, opts) {
  assert(&quot;TSTypeAssertion&quot;, node, opts);
}
function assertTSEnumDeclaration(node, opts) {
  assert(&quot;TSEnumDeclaration&quot;, node, opts);
}
function assertTSEnumMember(node, opts) {
  assert(&quot;TSEnumMember&quot;, node, opts);
}
function assertTSModuleDeclaration(node, opts) {
  assert(&quot;TSModuleDeclaration&quot;, node, opts);
}
function assertTSModuleBlock(node, opts) {
  assert(&quot;TSModuleBlock&quot;, node, opts);
}
function assertTSImportType(node, opts) {
  assert(&quot;TSImportType&quot;, node, opts);
}
function assertTSImportEqualsDeclaration(node, opts) {
  assert(&quot;TSImportEqualsDeclaration&quot;, node, opts);
}
function assertTSExternalModuleReference(node, opts) {
  assert(&quot;TSExternalModuleReference&quot;, node, opts);
}
function assertTSNonNullExpression(node, opts) {
  assert(&quot;TSNonNullExpression&quot;, node, opts);
}
function assertTSExportAssignment(node, opts) {
  assert(&quot;TSExportAssignment&quot;, node, opts);
}
function assertTSNamespaceExportDeclaration(node, opts) {
  assert(&quot;TSNamespaceExportDeclaration&quot;, node, opts);
}
function assertTSTypeAnnotation(node, opts) {
  assert(&quot;TSTypeAnnotation&quot;, node, opts);
}
function assertTSTypeParameterInstantiation(node, opts) {
  assert(&quot;TSTypeParameterInstantiation&quot;, node, opts);
}
function assertTSTypeParameterDeclaration(node, opts) {
  assert(&quot;TSTypeParameterDeclaration&quot;, node, opts);
}
function assertTSTypeParameter(node, opts) {
  assert(&quot;TSTypeParameter&quot;, node, opts);
}
function assertStandardized(node, opts) {
  assert(&quot;Standardized&quot;, node, opts);
}
function assertExpression(node, opts) {
  assert(&quot;Expression&quot;, node, opts);
}
function assertBinary(node, opts) {
  assert(&quot;Binary&quot;, node, opts);
}
function assertScopable(node, opts) {
  assert(&quot;Scopable&quot;, node, opts);
}
function assertBlockParent(node, opts) {
  assert(&quot;BlockParent&quot;, node, opts);
}
function assertBlock(node, opts) {
  assert(&quot;Block&quot;, node, opts);
}
function assertStatement(node, opts) {
  assert(&quot;Statement&quot;, node, opts);
}
function assertTerminatorless(node, opts) {
  assert(&quot;Terminatorless&quot;, node, opts);
}
function assertCompletionStatement(node, opts) {
  assert(&quot;CompletionStatement&quot;, node, opts);
}
function assertConditional(node, opts) {
  assert(&quot;Conditional&quot;, node, opts);
}
function assertLoop(node, opts) {
  assert(&quot;Loop&quot;, node, opts);
}
function assertWhile(node, opts) {
  assert(&quot;While&quot;, node, opts);
}
function assertExpressionWrapper(node, opts) {
  assert(&quot;ExpressionWrapper&quot;, node, opts);
}
function assertFor(node, opts) {
  assert(&quot;For&quot;, node, opts);
}
function assertForXStatement(node, opts) {
  assert(&quot;ForXStatement&quot;, node, opts);
}
function assertFunction(node, opts) {
  assert(&quot;Function&quot;, node, opts);
}
function assertFunctionParent(node, opts) {
  assert(&quot;FunctionParent&quot;, node, opts);
}
function assertPureish(node, opts) {
  assert(&quot;Pureish&quot;, node, opts);
}
function assertDeclaration(node, opts) {
  assert(&quot;Declaration&quot;, node, opts);
}
function assertPatternLike(node, opts) {
  assert(&quot;PatternLike&quot;, node, opts);
}
function assertLVal(node, opts) {
  assert(&quot;LVal&quot;, node, opts);
}
function assertTSEntityName(node, opts) {
  assert(&quot;TSEntityName&quot;, node, opts);
}
function assertLiteral(node, opts) {
  assert(&quot;Literal&quot;, node, opts);
}
function assertImmutable(node, opts) {
  assert(&quot;Immutable&quot;, node, opts);
}
function assertUserWhitespacable(node, opts) {
  assert(&quot;UserWhitespacable&quot;, node, opts);
}
function assertMethod(node, opts) {
  assert(&quot;Method&quot;, node, opts);
}
function assertObjectMember(node, opts) {
  assert(&quot;ObjectMember&quot;, node, opts);
}
function assertProperty(node, opts) {
  assert(&quot;Property&quot;, node, opts);
}
function assertUnaryLike(node, opts) {
  assert(&quot;UnaryLike&quot;, node, opts);
}
function assertPattern(node, opts) {
  assert(&quot;Pattern&quot;, node, opts);
}
function assertClass(node, opts) {
  assert(&quot;Class&quot;, node, opts);
}
function assertImportOrExportDeclaration(node, opts) {
  assert(&quot;ImportOrExportDeclaration&quot;, node, opts);
}
function assertExportDeclaration(node, opts) {
  assert(&quot;ExportDeclaration&quot;, node, opts);
}
function assertModuleSpecifier(node, opts) {
  assert(&quot;ModuleSpecifier&quot;, node, opts);
}
function assertAccessor(node, opts) {
  assert(&quot;Accessor&quot;, node, opts);
}
function assertPrivate(node, opts) {
  assert(&quot;Private&quot;, node, opts);
}
function assertFlow(node, opts) {
  assert(&quot;Flow&quot;, node, opts);
}
function assertFlowType(node, opts) {
  assert(&quot;FlowType&quot;, node, opts);
}
function assertFlowBaseAnnotation(node, opts) {
  assert(&quot;FlowBaseAnnotation&quot;, node, opts);
}
function assertFlowDeclaration(node, opts) {
  assert(&quot;FlowDeclaration&quot;, node, opts);
}
function assertFlowPredicate(node, opts) {
  assert(&quot;FlowPredicate&quot;, node, opts);
}
function assertEnumBody(node, opts) {
  assert(&quot;EnumBody&quot;, node, opts);
}
function assertEnumMember(node, opts) {
  assert(&quot;EnumMember&quot;, node, opts);
}
function assertJSX(node, opts) {
  assert(&quot;JSX&quot;, node, opts);
}
function assertMiscellaneous(node, opts) {
  assert(&quot;Miscellaneous&quot;, node, opts);
}
function assertTypeScript(node, opts) {
  assert(&quot;TypeScript&quot;, node, opts);
}
function assertTSTypeElement(node, opts) {
  assert(&quot;TSTypeElement&quot;, node, opts);
}
function assertTSType(node, opts) {
  assert(&quot;TSType&quot;, node, opts);
}
function assertTSBaseType(node, opts) {
  assert(&quot;TSBaseType&quot;, node, opts);
}
function assertNumberLiteral(node, opts) {
  (0, _deprecationWarning.default)(&quot;assertNumberLiteral&quot;, &quot;assertNumericLiteral&quot;);
  assert(&quot;NumberLiteral&quot;, node, opts);
}
function assertRegexLiteral(node, opts) {
  (0, _deprecationWarning.default)(&quot;assertRegexLiteral&quot;, &quot;assertRegExpLiteral&quot;);
  assert(&quot;RegexLiteral&quot;, node, opts);
}
function assertRestProperty(node, opts) {
  (0, _deprecationWarning.default)(&quot;assertRestProperty&quot;, &quot;assertRestElement&quot;);
  assert(&quot;RestProperty&quot;, node, opts);
}
function assertSpreadProperty(node, opts) {
  (0, _deprecationWarning.default)(&quot;assertSpreadProperty&quot;, &quot;assertSpreadElement&quot;);
  assert(&quot;SpreadProperty&quot;, node, opts);
}
function assertModuleDeclaration(node, opts) {
  (0, _deprecationWarning.default)(&quot;assertModuleDeclaration&quot;, &quot;assertImportOrExportDeclaration&quot;);
  assert(&quot;ModuleDeclaration&quot;, node, opts);
}

//# sourceMappingURL=index.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
