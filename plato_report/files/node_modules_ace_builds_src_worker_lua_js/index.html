<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/ace-builds/src/worker-lua.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/ace-builds/src/worker-lua.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">62.64</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">3510</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">218.48</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">49.86</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;no use strict&quot;;
!(function(window) {
if (typeof window.window != &quot;undefined&quot; &amp;&amp; window.document)
    return;
if (window.require &amp;&amp; window.define)
    return;

if (!window.console) {
    window.console = function() {
        var msgs = Array.prototype.slice.call(arguments, 0);
        postMessage({type: &quot;log&quot;, data: msgs});
    };
    window.console.error =
    window.console.warn = 
    window.console.log =
    window.console.trace = window.console;
}
window.window = window;
window.ace = window;

window.onerror = function(message, file, line, col, err) {
    postMessage({type: &quot;error&quot;, data: {
        message: message,
        data: err &amp;&amp; err.data,
        file: file,
        line: line, 
        col: col,
        stack: err &amp;&amp; err.stack
    }});
};

window.normalizeModule = function(parentId, moduleName) {
    // normalize plugin requires
    if (moduleName.indexOf(&quot;!&quot;) !== -1) {
        var chunks = moduleName.split(&quot;!&quot;);
        return window.normalizeModule(parentId, chunks[0]) + &quot;!&quot; + window.normalizeModule(parentId, chunks[1]);
    }
    // normalize relative requires
    if (moduleName.charAt(0) == &quot;.&quot;) {
        var base = parentId.split(&quot;/&quot;).slice(0, -1).join(&quot;/&quot;);
        moduleName = (base ? base + &quot;/&quot; : &quot;&quot;) + moduleName;
        
        while (moduleName.indexOf(&quot;.&quot;) !== -1 &amp;&amp; previous != moduleName) {
            var previous = moduleName;
            moduleName = moduleName.replace(/^\.\//, &quot;&quot;).replace(/\/\.\//, &quot;/&quot;).replace(/[^\/]+\/\.\.\//, &quot;&quot;);
        }
    }
    
    return moduleName;
};

window.require = function require(parentId, id) {
    if (!id) {
        id = parentId;
        parentId = null;
    }
    if (!id.charAt)
        throw new Error(&quot;worker.js require() accepts only (parentId, id) as arguments&quot;);

    id = window.normalizeModule(parentId, id);

    var module = window.require.modules[id];
    if (module) {
        if (!module.initialized) {
            module.initialized = true;
            module.exports = module.factory().exports;
        }
        return module.exports;
    }
   
    if (!window.require.tlns)
        return console.log(&quot;unable to load &quot; + id);
    
    var path = resolveModuleId(id, window.require.tlns);
    if (path.slice(-3) != &quot;.js&quot;) path += &quot;.js&quot;;
    
    window.require.id = id;
    window.require.modules[id] = {}; // prevent infinite loop on broken modules
    importScripts(path);
    return window.require(parentId, id);
};
function resolveModuleId(id, paths) {
    var testPath = id, tail = &quot;&quot;;
    while (testPath) {
        var alias = paths[testPath];
        if (typeof alias == &quot;string&quot;) {
            return alias + tail;
        } else if (alias) {
            return  alias.location.replace(/\/*$/, &quot;/&quot;) + (tail || alias.main || alias.name);
        } else if (alias === false) {
            return &quot;&quot;;
        }
        var i = testPath.lastIndexOf(&quot;/&quot;);
        if (i === -1) break;
        tail = testPath.substr(i) + tail;
        testPath = testPath.slice(0, i);
    }
    return id;
}
window.require.modules = {};
window.require.tlns = {};

window.define = function(id, deps, factory) {
    if (arguments.length == 2) {
        factory = deps;
        if (typeof id != &quot;string&quot;) {
            deps = id;
            id = window.require.id;
        }
    } else if (arguments.length == 1) {
        factory = id;
        deps = [];
        id = window.require.id;
    }
    
    if (typeof factory != &quot;function&quot;) {
        window.require.modules[id] = {
            exports: factory,
            initialized: true
        };
        return;
    }

    if (!deps.length)
        // If there is no dependencies, we inject &quot;require&quot;, &quot;exports&quot; and
        // &quot;module&quot; as dependencies, to provide CommonJS compatibility.
        deps = [&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;];

    var req = function(childId) {
        return window.require(id, childId);
    };

    window.require.modules[id] = {
        exports: {},
        factory: function() {
            var module = this;
            var returnExports = factory.apply(this, deps.slice(0, factory.length).map(function(dep) {
                switch (dep) {
                    // Because &quot;require&quot;, &quot;exports&quot; and &quot;module&quot; aren&#039;t actual
                    // dependencies, we must handle them seperately.
                    case &quot;require&quot;: return req;
                    case &quot;exports&quot;: return module.exports;
                    case &quot;module&quot;:  return module;
                    // But for all other dependencies, we can just go ahead and
                    // require them.
                    default:        return req(dep);
                }
            }));
            if (returnExports)
                module.exports = returnExports;
            return module;
        }
    };
};
window.define.amd = {};
window.require.tlns = {};
window.initBaseUrls  = function initBaseUrls(topLevelNamespaces) {
    for (var i in topLevelNamespaces)
        this.require.tlns[i] = topLevelNamespaces[i];
};

window.initSender = function initSender() {

    var EventEmitter = window.require(&quot;ace/lib/event_emitter&quot;).EventEmitter;
    var oop = window.require(&quot;ace/lib/oop&quot;);
    
    var Sender = function() {};
    
    (function() {
        
        oop.implement(this, EventEmitter);
                
        this.callback = function(data, callbackId) {
            postMessage({
                type: &quot;call&quot;,
                id: callbackId,
                data: data
            });
        };
    
        this.emit = function(name, data) {
            postMessage({
                type: &quot;event&quot;,
                name: name,
                data: data
            });
        };
        
    }).call(Sender.prototype);
    
    return new Sender();
};

var main = window.main = null;
var sender = window.sender = null;

window.onmessage = function(e) {
    var msg = e.data;
    if (msg.event &amp;&amp; sender) {
        sender._signal(msg.event, msg.data);
    }
    else if (msg.command) {
        if (main[msg.command])
            main[msg.command].apply(main, msg.args);
        else if (window[msg.command])
            window[msg.command].apply(window, msg.args);
        else
            throw new Error(&quot;Unknown command:&quot; + msg.command);
    }
    else if (msg.init) {
        window.initBaseUrls(msg.tlns);
        sender = window.sender = window.initSender();
        var clazz = this.require(msg.module)[msg.classname];
        main = window.main = new clazz(sender);
    }
};
})(this);

define(&quot;ace/lib/oop&quot;,[], function(require, exports, module){&quot;use strict&quot;;
exports.inherits = function (ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
};
exports.mixin = function (obj, mixin) {
    for (var key in mixin) {
        obj[key] = mixin[key];
    }
    return obj;
};
exports.implement = function (proto, mixin) {
    exports.mixin(proto, mixin);
};

});

define(&quot;ace/apply_delta&quot;,[], function(require, exports, module){&quot;use strict&quot;;
function throwDeltaError(delta, errorText) {
    console.log(&quot;Invalid Delta:&quot;, delta);
    throw &quot;Invalid Delta: &quot; + errorText;
}
function positionInDocument(docLines, position) {
    return position.row &gt;= 0 &amp;&amp; position.row &lt; docLines.length &amp;&amp;
        position.column &gt;= 0 &amp;&amp; position.column &lt;= docLines[position.row].length;
}
function validateDelta(docLines, delta) {
    if (delta.action != &quot;insert&quot; &amp;&amp; delta.action != &quot;remove&quot;)
        throwDeltaError(delta, &quot;delta.action must be &#039;insert&#039; or &#039;remove&#039;&quot;);
    if (!(delta.lines instanceof Array))
        throwDeltaError(delta, &quot;delta.lines must be an Array&quot;);
    if (!delta.start || !delta.end)
        throwDeltaError(delta, &quot;delta.start/end must be an present&quot;);
    var start = delta.start;
    if (!positionInDocument(docLines, delta.start))
        throwDeltaError(delta, &quot;delta.start must be contained in document&quot;);
    var end = delta.end;
    if (delta.action == &quot;remove&quot; &amp;&amp; !positionInDocument(docLines, end))
        throwDeltaError(delta, &quot;delta.end must contained in document for &#039;remove&#039; actions&quot;);
    var numRangeRows = end.row - start.row;
    var numRangeLastLineChars = (end.column - (numRangeRows == 0 ? start.column : 0));
    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars)
        throwDeltaError(delta, &quot;delta.range must match delta lines&quot;);
}
exports.applyDelta = function (docLines, delta, doNotValidate) {
    var row = delta.start.row;
    var startColumn = delta.start.column;
    var line = docLines[row] || &quot;&quot;;
    switch (delta.action) {
        case &quot;insert&quot;:
            var lines = delta.lines;
            if (lines.length === 1) {
                docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
            }
            else {
                var args = [row, 1].concat(delta.lines);
                docLines.splice.apply(docLines, args);
                docLines[row] = line.substring(0, startColumn) + docLines[row];
                docLines[row + delta.lines.length - 1] += line.substring(startColumn);
            }
            break;
        case &quot;remove&quot;:
            var endColumn = delta.end.column;
            var endRow = delta.end.row;
            if (row === endRow) {
                docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
            }
            else {
                docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));
            }
            break;
    }
};

});

define(&quot;ace/lib/event_emitter&quot;,[], function(require, exports, module){&quot;use strict&quot;;
var EventEmitter = {};
var stopPropagation = function () { this.propagationStopped = true; };
var preventDefault = function () { this.defaultPrevented = true; };
EventEmitter._emit =
    EventEmitter._dispatchEvent = function (eventName, e) {
        this._eventRegistry || (this._eventRegistry = {});
        this._defaultHandlers || (this._defaultHandlers = {});
        var listeners = this._eventRegistry[eventName] || [];
        var defaultHandler = this._defaultHandlers[eventName];
        if (!listeners.length &amp;&amp; !defaultHandler)
            return;
        if (typeof e != &quot;object&quot; || !e)
            e = {};
        if (!e.type)
            e.type = eventName;
        if (!e.stopPropagation)
            e.stopPropagation = stopPropagation;
        if (!e.preventDefault)
            e.preventDefault = preventDefault;
        listeners = listeners.slice();
        for (var i = 0; i &lt; listeners.length; i++) {
            listeners[i](e, this);
            if (e.propagationStopped)
                break;
        }
        if (defaultHandler &amp;&amp; !e.defaultPrevented)
            return defaultHandler(e, this);
    };
EventEmitter._signal = function (eventName, e) {
    var listeners = (this._eventRegistry || {})[eventName];
    if (!listeners)
        return;
    listeners = listeners.slice();
    for (var i = 0; i &lt; listeners.length; i++)
        listeners[i](e, this);
};
EventEmitter.once = function (eventName, callback) {
    var _self = this;
    this.on(eventName, function newCallback() {
        _self.off(eventName, newCallback);
        callback.apply(null, arguments);
    });
    if (!callback) {
        return new Promise(function (resolve) {
            callback = resolve;
        });
    }
};
EventEmitter.setDefaultHandler = function (eventName, callback) {
    var handlers = this._defaultHandlers;
    if (!handlers)
        handlers = this._defaultHandlers = { _disabled_: {} };
    if (handlers[eventName]) {
        var old = handlers[eventName];
        var disabled = handlers._disabled_[eventName];
        if (!disabled)
            handlers._disabled_[eventName] = disabled = [];
        disabled.push(old);
        var i = disabled.indexOf(callback);
        if (i != -1)
            disabled.splice(i, 1);
    }
    handlers[eventName] = callback;
};
EventEmitter.removeDefaultHandler = function (eventName, callback) {
    var handlers = this._defaultHandlers;
    if (!handlers)
        return;
    var disabled = handlers._disabled_[eventName];
    if (handlers[eventName] == callback) {
        if (disabled)
            this.setDefaultHandler(eventName, disabled.pop());
    }
    else if (disabled) {
        var i = disabled.indexOf(callback);
        if (i != -1)
            disabled.splice(i, 1);
    }
};
EventEmitter.on =
    EventEmitter.addEventListener = function (eventName, callback, capturing) {
        this._eventRegistry = this._eventRegistry || {};
        var listeners = this._eventRegistry[eventName];
        if (!listeners)
            listeners = this._eventRegistry[eventName] = [];
        if (listeners.indexOf(callback) == -1)
            listeners[capturing ? &quot;unshift&quot; : &quot;push&quot;](callback);
        return callback;
    };
EventEmitter.off =
    EventEmitter.removeListener =
        EventEmitter.removeEventListener = function (eventName, callback) {
            this._eventRegistry = this._eventRegistry || {};
            var listeners = this._eventRegistry[eventName];
            if (!listeners)
                return;
            var index = listeners.indexOf(callback);
            if (index !== -1)
                listeners.splice(index, 1);
        };
EventEmitter.removeAllListeners = function (eventName) {
    if (!eventName)
        this._eventRegistry = this._defaultHandlers = undefined;
    if (this._eventRegistry)
        this._eventRegistry[eventName] = undefined;
    if (this._defaultHandlers)
        this._defaultHandlers[eventName] = undefined;
};
exports.EventEmitter = EventEmitter;

});

define(&quot;ace/range&quot;,[], function(require, exports, module){&quot;use strict&quot;;
var comparePoints = function (p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
};
var Range = function (startRow, startColumn, endRow, endColumn) {
    this.start = {
        row: startRow,
        column: startColumn
    };
    this.end = {
        row: endRow,
        column: endColumn
    };
};
(function () {
    this.isEqual = function (range) {
        return this.start.row === range.start.row &amp;&amp;
            this.end.row === range.end.row &amp;&amp;
            this.start.column === range.start.column &amp;&amp;
            this.end.column === range.end.column;
    };
    this.toString = function () {
        return (&quot;Range: [&quot; + this.start.row + &quot;/&quot; + this.start.column +
            &quot;] -&gt; [&quot; + this.end.row + &quot;/&quot; + this.end.column + &quot;]&quot;);
    };
    this.contains = function (row, column) {
        return this.compare(row, column) == 0;
    };
    this.compareRange = function (range) {
        var cmp, end = range.end, start = range.start;
        cmp = this.compare(end.row, end.column);
        if (cmp == 1) {
            cmp = this.compare(start.row, start.column);
            if (cmp == 1) {
                return 2;
            }
            else if (cmp == 0) {
                return 1;
            }
            else {
                return 0;
            }
        }
        else if (cmp == -1) {
            return -2;
        }
        else {
            cmp = this.compare(start.row, start.column);
            if (cmp == -1) {
                return -1;
            }
            else if (cmp == 1) {
                return 42;
            }
            else {
                return 0;
            }
        }
    };
    this.comparePoint = function (p) {
        return this.compare(p.row, p.column);
    };
    this.containsRange = function (range) {
        return this.comparePoint(range.start) == 0 &amp;&amp; this.comparePoint(range.end) == 0;
    };
    this.intersects = function (range) {
        var cmp = this.compareRange(range);
        return (cmp == -1 || cmp == 0 || cmp == 1);
    };
    this.isEnd = function (row, column) {
        return this.end.row == row &amp;&amp; this.end.column == column;
    };
    this.isStart = function (row, column) {
        return this.start.row == row &amp;&amp; this.start.column == column;
    };
    this.setStart = function (row, column) {
        if (typeof row == &quot;object&quot;) {
            this.start.column = row.column;
            this.start.row = row.row;
        }
        else {
            this.start.row = row;
            this.start.column = column;
        }
    };
    this.setEnd = function (row, column) {
        if (typeof row == &quot;object&quot;) {
            this.end.column = row.column;
            this.end.row = row.row;
        }
        else {
            this.end.row = row;
            this.end.column = column;
        }
    };
    this.inside = function (row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column) || this.isStart(row, column)) {
                return false;
            }
            else {
                return true;
            }
        }
        return false;
    };
    this.insideStart = function (row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column)) {
                return false;
            }
            else {
                return true;
            }
        }
        return false;
    };
    this.insideEnd = function (row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isStart(row, column)) {
                return false;
            }
            else {
                return true;
            }
        }
        return false;
    };
    this.compare = function (row, column) {
        if (!this.isMultiLine()) {
            if (row === this.start.row) {
                return column &lt; this.start.column ? -1 : (column &gt; this.end.column ? 1 : 0);
            }
        }
        if (row &lt; this.start.row)
            return -1;
        if (row &gt; this.end.row)
            return 1;
        if (this.start.row === row)
            return column &gt;= this.start.column ? 0 : -1;
        if (this.end.row === row)
            return column &lt;= this.end.column ? 0 : 1;
        return 0;
    };
    this.compareStart = function (row, column) {
        if (this.start.row == row &amp;&amp; this.start.column == column) {
            return -1;
        }
        else {
            return this.compare(row, column);
        }
    };
    this.compareEnd = function (row, column) {
        if (this.end.row == row &amp;&amp; this.end.column == column) {
            return 1;
        }
        else {
            return this.compare(row, column);
        }
    };
    this.compareInside = function (row, column) {
        if (this.end.row == row &amp;&amp; this.end.column == column) {
            return 1;
        }
        else if (this.start.row == row &amp;&amp; this.start.column == column) {
            return -1;
        }
        else {
            return this.compare(row, column);
        }
    };
    this.clipRows = function (firstRow, lastRow) {
        if (this.end.row &gt; lastRow)
            var end = { row: lastRow + 1, column: 0 };
        else if (this.end.row &lt; firstRow)
            var end = { row: firstRow, column: 0 };
        if (this.start.row &gt; lastRow)
            var start = { row: lastRow + 1, column: 0 };
        else if (this.start.row &lt; firstRow)
            var start = { row: firstRow, column: 0 };
        return Range.fromPoints(start || this.start, end || this.end);
    };
    this.extend = function (row, column) {
        var cmp = this.compare(row, column);
        if (cmp == 0)
            return this;
        else if (cmp == -1)
            var start = { row: row, column: column };
        else
            var end = { row: row, column: column };
        return Range.fromPoints(start || this.start, end || this.end);
    };
    this.isEmpty = function () {
        return (this.start.row === this.end.row &amp;&amp; this.start.column === this.end.column);
    };
    this.isMultiLine = function () {
        return (this.start.row !== this.end.row);
    };
    this.clone = function () {
        return Range.fromPoints(this.start, this.end);
    };
    this.collapseRows = function () {
        if (this.end.column == 0)
            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);
        else
            return new Range(this.start.row, 0, this.end.row, 0);
    };
    this.toScreenRange = function (session) {
        var screenPosStart = session.documentToScreenPosition(this.start);
        var screenPosEnd = session.documentToScreenPosition(this.end);
        return new Range(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);
    };
    this.moveBy = function (row, column) {
        this.start.row += row;
        this.start.column += column;
        this.end.row += row;
        this.end.column += column;
    };
}).call(Range.prototype);
Range.fromPoints = function (start, end) {
    return new Range(start.row, start.column, end.row, end.column);
};
Range.comparePoints = comparePoints;
Range.comparePoints = function (p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
};
exports.Range = Range;

});

define(&quot;ace/anchor&quot;,[], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;./lib/oop&quot;);
var EventEmitter = require(&quot;./lib/event_emitter&quot;).EventEmitter;
var Anchor = exports.Anchor = function (doc, row, column) {
    this.$onChange = this.onChange.bind(this);
    this.attach(doc);
    if (typeof column == &quot;undefined&quot;)
        this.setPosition(row.row, row.column);
    else
        this.setPosition(row, column);
};
(function () {
    oop.implement(this, EventEmitter);
    this.getPosition = function () {
        return this.$clipPositionToDocument(this.row, this.column);
    };
    this.getDocument = function () {
        return this.document;
    };
    this.$insertRight = false;
    this.onChange = function (delta) {
        if (delta.start.row == delta.end.row &amp;&amp; delta.start.row != this.row)
            return;
        if (delta.start.row &gt; this.row)
            return;
        var point = $getTransformedPoint(delta, { row: this.row, column: this.column }, this.$insertRight);
        this.setPosition(point.row, point.column, true);
    };
    function $pointsInOrder(point1, point2, equalPointsInOrder) {
        var bColIsAfter = equalPointsInOrder ? point1.column &lt;= point2.column : point1.column &lt; point2.column;
        return (point1.row &lt; point2.row) || (point1.row == point2.row &amp;&amp; bColIsAfter);
    }
    function $getTransformedPoint(delta, point, moveIfEqual) {
        var deltaIsInsert = delta.action == &quot;insert&quot;;
        var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);
        var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
        var deltaStart = delta.start;
        var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.
        if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
            return {
                row: point.row,
                column: point.column
            };
        }
        if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
            return {
                row: point.row + deltaRowShift,
                column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
            };
        }
        return {
            row: deltaStart.row,
            column: deltaStart.column
        };
    }
    this.setPosition = function (row, column, noClip) {
        var pos;
        if (noClip) {
            pos = {
                row: row,
                column: column
            };
        }
        else {
            pos = this.$clipPositionToDocument(row, column);
        }
        if (this.row == pos.row &amp;&amp; this.column == pos.column)
            return;
        var old = {
            row: this.row,
            column: this.column
        };
        this.row = pos.row;
        this.column = pos.column;
        this._signal(&quot;change&quot;, {
            old: old,
            value: pos
        });
    };
    this.detach = function () {
        this.document.off(&quot;change&quot;, this.$onChange);
    };
    this.attach = function (doc) {
        this.document = doc || this.document;
        this.document.on(&quot;change&quot;, this.$onChange);
    };
    this.$clipPositionToDocument = function (row, column) {
        var pos = {};
        if (row &gt;= this.document.getLength()) {
            pos.row = Math.max(0, this.document.getLength() - 1);
            pos.column = this.document.getLine(pos.row).length;
        }
        else if (row &lt; 0) {
            pos.row = 0;
            pos.column = 0;
        }
        else {
            pos.row = row;
            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
        }
        if (column &lt; 0)
            pos.column = 0;
        return pos;
    };
}).call(Anchor.prototype);

});

define(&quot;ace/document&quot;,[], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;./lib/oop&quot;);
var applyDelta = require(&quot;./apply_delta&quot;).applyDelta;
var EventEmitter = require(&quot;./lib/event_emitter&quot;).EventEmitter;
var Range = require(&quot;./range&quot;).Range;
var Anchor = require(&quot;./anchor&quot;).Anchor;
var Document = function (textOrLines) {
    this.$lines = [&quot;&quot;];
    if (textOrLines.length === 0) {
        this.$lines = [&quot;&quot;];
    }
    else if (Array.isArray(textOrLines)) {
        this.insertMergedLines({ row: 0, column: 0 }, textOrLines);
    }
    else {
        this.insert({ row: 0, column: 0 }, textOrLines);
    }
};
(function () {
    oop.implement(this, EventEmitter);
    this.setValue = function (text) {
        var len = this.getLength() - 1;
        this.remove(new Range(0, 0, len, this.getLine(len).length));
        this.insert({ row: 0, column: 0 }, text || &quot;&quot;);
    };
    this.getValue = function () {
        return this.getAllLines().join(this.getNewLineCharacter());
    };
    this.createAnchor = function (row, column) {
        return new Anchor(this, row, column);
    };
    if (&quot;aaa&quot;.split(/a/).length === 0) {
        this.$split = function (text) {
            return text.replace(/\r\n|\r/g, &quot;\n&quot;).split(&quot;\n&quot;);
        };
    }
    else {
        this.$split = function (text) {
            return text.split(/\r\n|\r|\n/);
        };
    }
    this.$detectNewLine = function (text) {
        var match = text.match(/^.*?(\r\n|\r|\n)/m);
        this.$autoNewLine = match ? match[1] : &quot;\n&quot;;
        this._signal(&quot;changeNewLineMode&quot;);
    };
    this.getNewLineCharacter = function () {
        switch (this.$newLineMode) {
            case &quot;windows&quot;:
                return &quot;\r\n&quot;;
            case &quot;unix&quot;:
                return &quot;\n&quot;;
            default:
                return this.$autoNewLine || &quot;\n&quot;;
        }
    };
    this.$autoNewLine = &quot;&quot;;
    this.$newLineMode = &quot;auto&quot;;
    this.setNewLineMode = function (newLineMode) {
        if (this.$newLineMode === newLineMode)
            return;
        this.$newLineMode = newLineMode;
        this._signal(&quot;changeNewLineMode&quot;);
    };
    this.getNewLineMode = function () {
        return this.$newLineMode;
    };
    this.isNewLine = function (text) {
        return (text == &quot;\r\n&quot; || text == &quot;\r&quot; || text == &quot;\n&quot;);
    };
    this.getLine = function (row) {
        return this.$lines[row] || &quot;&quot;;
    };
    this.getLines = function (firstRow, lastRow) {
        return this.$lines.slice(firstRow, lastRow + 1);
    };
    this.getAllLines = function () {
        return this.getLines(0, this.getLength());
    };
    this.getLength = function () {
        return this.$lines.length;
    };
    this.getTextRange = function (range) {
        return this.getLinesForRange(range).join(this.getNewLineCharacter());
    };
    this.getLinesForRange = function (range) {
        var lines;
        if (range.start.row === range.end.row) {
            lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
        }
        else {
            lines = this.getLines(range.start.row, range.end.row);
            lines[0] = (lines[0] || &quot;&quot;).substring(range.start.column);
            var l = lines.length - 1;
            if (range.end.row - range.start.row == l)
                lines[l] = lines[l].substring(0, range.end.column);
        }
        return lines;
    };
    this.insertLines = function (row, lines) {
        console.warn(&quot;Use of document.insertLines is deprecated. Use the insertFullLines method instead.&quot;);
        return this.insertFullLines(row, lines);
    };
    this.removeLines = function (firstRow, lastRow) {
        console.warn(&quot;Use of document.removeLines is deprecated. Use the removeFullLines method instead.&quot;);
        return this.removeFullLines(firstRow, lastRow);
    };
    this.insertNewLine = function (position) {
        console.warn(&quot;Use of document.insertNewLine is deprecated. Use insertMergedLines(position, [&#039;&#039;, &#039;&#039;]) instead.&quot;);
        return this.insertMergedLines(position, [&quot;&quot;, &quot;&quot;]);
    };
    this.insert = function (position, text) {
        if (this.getLength() &lt;= 1)
            this.$detectNewLine(text);
        return this.insertMergedLines(position, this.$split(text));
    };
    this.insertInLine = function (position, text) {
        var start = this.clippedPos(position.row, position.column);
        var end = this.pos(position.row, position.column + text.length);
        this.applyDelta({
            start: start,
            end: end,
            action: &quot;insert&quot;,
            lines: [text]
        }, true);
        return this.clonePos(end);
    };
    this.clippedPos = function (row, column) {
        var length = this.getLength();
        if (row === undefined) {
            row = length;
        }
        else if (row &lt; 0) {
            row = 0;
        }
        else if (row &gt;= length) {
            row = length - 1;
            column = undefined;
        }
        var line = this.getLine(row);
        if (column == undefined)
            column = line.length;
        column = Math.min(Math.max(column, 0), line.length);
        return { row: row, column: column };
    };
    this.clonePos = function (pos) {
        return { row: pos.row, column: pos.column };
    };
    this.pos = function (row, column) {
        return { row: row, column: column };
    };
    this.$clipPosition = function (position) {
        var length = this.getLength();
        if (position.row &gt;= length) {
            position.row = Math.max(0, length - 1);
            position.column = this.getLine(length - 1).length;
        }
        else {
            position.row = Math.max(0, position.row);
            position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
        }
        return position;
    };
    this.insertFullLines = function (row, lines) {
        row = Math.min(Math.max(row, 0), this.getLength());
        var column = 0;
        if (row &lt; this.getLength()) {
            lines = lines.concat([&quot;&quot;]);
            column = 0;
        }
        else {
            lines = [&quot;&quot;].concat(lines);
            row--;
            column = this.$lines[row].length;
        }
        this.insertMergedLines({ row: row, column: column }, lines);
    };
    this.insertMergedLines = function (position, lines) {
        var start = this.clippedPos(position.row, position.column);
        var end = {
            row: start.row + lines.length - 1,
            column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
        };
        this.applyDelta({
            start: start,
            end: end,
            action: &quot;insert&quot;,
            lines: lines
        });
        return this.clonePos(end);
    };
    this.remove = function (range) {
        var start = this.clippedPos(range.start.row, range.start.column);
        var end = this.clippedPos(range.end.row, range.end.column);
        this.applyDelta({
            start: start,
            end: end,
            action: &quot;remove&quot;,
            lines: this.getLinesForRange({ start: start, end: end })
        });
        return this.clonePos(start);
    };
    this.removeInLine = function (row, startColumn, endColumn) {
        var start = this.clippedPos(row, startColumn);
        var end = this.clippedPos(row, endColumn);
        this.applyDelta({
            start: start,
            end: end,
            action: &quot;remove&quot;,
            lines: this.getLinesForRange({ start: start, end: end })
        }, true);
        return this.clonePos(start);
    };
    this.removeFullLines = function (firstRow, lastRow) {
        firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
        lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);
        var deleteFirstNewLine = lastRow == this.getLength() - 1 &amp;&amp; firstRow &gt; 0;
        var deleteLastNewLine = lastRow &lt; this.getLength() - 1;
        var startRow = (deleteFirstNewLine ? firstRow - 1 : firstRow);
        var startCol = (deleteFirstNewLine ? this.getLine(startRow).length : 0);
        var endRow = (deleteLastNewLine ? lastRow + 1 : lastRow);
        var endCol = (deleteLastNewLine ? 0 : this.getLine(endRow).length);
        var range = new Range(startRow, startCol, endRow, endCol);
        var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
        this.applyDelta({
            start: range.start,
            end: range.end,
            action: &quot;remove&quot;,
            lines: this.getLinesForRange(range)
        });
        return deletedLines;
    };
    this.removeNewLine = function (row) {
        if (row &lt; this.getLength() - 1 &amp;&amp; row &gt;= 0) {
            this.applyDelta({
                start: this.pos(row, this.getLine(row).length),
                end: this.pos(row + 1, 0),
                action: &quot;remove&quot;,
                lines: [&quot;&quot;, &quot;&quot;]
            });
        }
    };
    this.replace = function (range, text) {
        if (!(range instanceof Range))
            range = Range.fromPoints(range.start, range.end);
        if (text.length === 0 &amp;&amp; range.isEmpty())
            return range.start;
        if (text == this.getTextRange(range))
            return range.end;
        this.remove(range);
        var end;
        if (text) {
            end = this.insert(range.start, text);
        }
        else {
            end = range.start;
        }
        return end;
    };
    this.applyDeltas = function (deltas) {
        for (var i = 0; i &lt; deltas.length; i++) {
            this.applyDelta(deltas[i]);
        }
    };
    this.revertDeltas = function (deltas) {
        for (var i = deltas.length - 1; i &gt;= 0; i--) {
            this.revertDelta(deltas[i]);
        }
    };
    this.applyDelta = function (delta, doNotValidate) {
        var isInsert = delta.action == &quot;insert&quot;;
        if (isInsert ? delta.lines.length &lt;= 1 &amp;&amp; !delta.lines[0]
            : !Range.comparePoints(delta.start, delta.end)) {
            return;
        }
        if (isInsert &amp;&amp; delta.lines.length &gt; 20000) {
            this.$splitAndapplyLargeDelta(delta, 20000);
        }
        else {
            applyDelta(this.$lines, delta, doNotValidate);
            this._signal(&quot;change&quot;, delta);
        }
    };
    this.$safeApplyDelta = function (delta) {
        var docLength = this.$lines.length;
        if (delta.action == &quot;remove&quot; &amp;&amp; delta.start.row &lt; docLength &amp;&amp; delta.end.row &lt; docLength
            || delta.action == &quot;insert&quot; &amp;&amp; delta.start.row &lt;= docLength) {
            this.applyDelta(delta);
        }
    };
    this.$splitAndapplyLargeDelta = function (delta, MAX) {
        var lines = delta.lines;
        var l = lines.length - MAX + 1;
        var row = delta.start.row;
        var column = delta.start.column;
        for (var from = 0, to = 0; from &lt; l; from = to) {
            to += MAX - 1;
            var chunk = lines.slice(from, to);
            chunk.push(&quot;&quot;);
            this.applyDelta({
                start: this.pos(row + from, column),
                end: this.pos(row + to, column = 0),
                action: delta.action,
                lines: chunk
            }, true);
        }
        delta.lines = lines.slice(from);
        delta.start.row = row + from;
        delta.start.column = column;
        this.applyDelta(delta, true);
    };
    this.revertDelta = function (delta) {
        this.$safeApplyDelta({
            start: this.clonePos(delta.start),
            end: this.clonePos(delta.end),
            action: (delta.action == &quot;insert&quot; ? &quot;remove&quot; : &quot;insert&quot;),
            lines: delta.lines.slice()
        });
    };
    this.indexToPosition = function (index, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        for (var i = startRow || 0, l = lines.length; i &lt; l; i++) {
            index -= lines[i].length + newlineLength;
            if (index &lt; 0)
                return { row: i, column: index + lines[i].length + newlineLength };
        }
        return { row: l - 1, column: index + lines[l - 1].length + newlineLength };
    };
    this.positionToIndex = function (pos, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        var index = 0;
        var row = Math.min(pos.row, lines.length);
        for (var i = startRow || 0; i &lt; row; ++i)
            index += lines[i].length + newlineLength;
        return index + pos.column;
    };
}).call(Document.prototype);
exports.Document = Document;

});

define(&quot;ace/lib/lang&quot;,[], function(require, exports, module){&quot;use strict&quot;;
exports.last = function (a) {
    return a[a.length - 1];
};
exports.stringReverse = function (string) {
    return string.split(&quot;&quot;).reverse().join(&quot;&quot;);
};
exports.stringRepeat = function (string, count) {
    var result = &#039;&#039;;
    while (count &gt; 0) {
        if (count &amp; 1)
            result += string;
        if (count &gt;&gt;= 1)
            string += string;
    }
    return result;
};
var trimBeginRegexp = /^\s\s*/;
var trimEndRegexp = /\s\s*$/;
exports.stringTrimLeft = function (string) {
    return string.replace(trimBeginRegexp, &#039;&#039;);
};
exports.stringTrimRight = function (string) {
    return string.replace(trimEndRegexp, &#039;&#039;);
};
exports.copyObject = function (obj) {
    var copy = {};
    for (var key in obj) {
        copy[key] = obj[key];
    }
    return copy;
};
exports.copyArray = function (array) {
    var copy = [];
    for (var i = 0, l = array.length; i &lt; l; i++) {
        if (array[i] &amp;&amp; typeof array[i] == &quot;object&quot;)
            copy[i] = this.copyObject(array[i]);
        else
            copy[i] = array[i];
    }
    return copy;
};
exports.deepCopy = function deepCopy(obj) {
    if (typeof obj !== &quot;object&quot; || !obj)
        return obj;
    var copy;
    if (Array.isArray(obj)) {
        copy = [];
        for (var key = 0; key &lt; obj.length; key++) {
            copy[key] = deepCopy(obj[key]);
        }
        return copy;
    }
    if (Object.prototype.toString.call(obj) !== &quot;[object Object]&quot;)
        return obj;
    copy = {};
    for (var key in obj)
        copy[key] = deepCopy(obj[key]);
    return copy;
};
exports.arrayToMap = function (arr) {
    var map = {};
    for (var i = 0; i &lt; arr.length; i++) {
        map[arr[i]] = 1;
    }
    return map;
};
exports.createMap = function (props) {
    var map = Object.create(null);
    for (var i in props) {
        map[i] = props[i];
    }
    return map;
};
exports.arrayRemove = function (array, value) {
    for (var i = 0; i &lt;= array.length; i++) {
        if (value === array[i]) {
            array.splice(i, 1);
        }
    }
};
exports.escapeRegExp = function (str) {
    return str.replace(/([.*+?^${}()|[\]\/\\])/g, &#039;\\$1&#039;);
};
exports.escapeHTML = function (str) {
    return (&quot;&quot; + str).replace(/&amp;/g, &quot;&amp;#38;&quot;).replace(/&quot;/g, &quot;&amp;#34;&quot;).replace(/&#039;/g, &quot;&amp;#39;&quot;).replace(/&lt;/g, &quot;&amp;#60;&quot;);
};
exports.getMatchOffsets = function (string, regExp) {
    var matches = [];
    string.replace(regExp, function (str) {
        matches.push({
            offset: arguments[arguments.length - 2],
            length: str.length
        });
    });
    return matches;
};
exports.deferredCall = function (fcn) {
    var timer = null;
    var callback = function () {
        timer = null;
        fcn();
    };
    var deferred = function (timeout) {
        deferred.cancel();
        timer = setTimeout(callback, timeout || 0);
        return deferred;
    };
    deferred.schedule = deferred;
    deferred.call = function () {
        this.cancel();
        fcn();
        return deferred;
    };
    deferred.cancel = function () {
        clearTimeout(timer);
        timer = null;
        return deferred;
    };
    deferred.isPending = function () {
        return timer;
    };
    return deferred;
};
exports.delayedCall = function (fcn, defaultTimeout) {
    var timer = null;
    var callback = function () {
        timer = null;
        fcn();
    };
    var _self = function (timeout) {
        if (timer == null)
            timer = setTimeout(callback, timeout || defaultTimeout);
    };
    _self.delay = function (timeout) {
        timer &amp;&amp; clearTimeout(timer);
        timer = setTimeout(callback, timeout || defaultTimeout);
    };
    _self.schedule = _self;
    _self.call = function () {
        this.cancel();
        fcn();
    };
    _self.cancel = function () {
        timer &amp;&amp; clearTimeout(timer);
        timer = null;
    };
    _self.isPending = function () {
        return timer;
    };
    return _self;
};

});

define(&quot;ace/worker/mirror&quot;,[], function(require, exports, module) {
&quot;use strict&quot;;

var Document = require(&quot;../document&quot;).Document;
var lang = require(&quot;../lib/lang&quot;);
    
var Mirror = exports.Mirror = function(sender) {
    this.sender = sender;
    var doc = this.doc = new Document(&quot;&quot;);
    
    var deferredUpdate = this.deferredUpdate = lang.delayedCall(this.onUpdate.bind(this));
    
    var _self = this;
    sender.on(&quot;change&quot;, function(e) {
        var data = e.data;
        if (data[0].start) {
            doc.applyDeltas(data);
        } else {
            for (var i = 0; i &lt; data.length; i += 2) {
                var d, err; 
                if (Array.isArray(data[i+1])) {
                    d = {action: &quot;insert&quot;, start: data[i], lines: data[i+1]};
                } else {
                    d = {action: &quot;remove&quot;, start: data[i], end: data[i+1]};
                }
                
                if ((d.action == &quot;insert&quot; ? d.start : d.end).row &gt;= doc.$lines.length) {
                    err = new Error(&quot;Invalid delta&quot;);
                    err.data = {
                        path: _self.$path,
                        linesLength: doc.$lines.length,
                        start: d.start,
                        end: d.end
                    };
                    throw err;
                }

                doc.applyDelta(d, true);
            }
        }
        if (_self.$timeout)
            return deferredUpdate.schedule(_self.$timeout);
        _self.onUpdate();
    });
};

(function() {
    
    this.$timeout = 500;
    
    this.setTimeout = function(timeout) {
        this.$timeout = timeout;
    };
    
    this.setValue = function(value) {
        this.doc.setValue(value);
        this.deferredUpdate.schedule(this.$timeout);
    };
    
    this.getValue = function(callbackId) {
        this.sender.callback(this.doc.getValue(), callbackId);
    };
    
    this.onUpdate = function() {
    };
    
    this.isPending = function() {
        return this.deferredUpdate.isPending();
    };
    
}).call(Mirror.prototype);

});

define(&quot;ace/mode/lua/luaparse&quot;,[], function(require, exports, module) {

(function (root, name, factory) {
   factory(exports)
}(this, &#039;luaparse&#039;, function (exports) {
  &#039;use strict&#039;;

  exports.version = &quot;0.3.1&quot;;

  var input, options, length, features, encodingMode;
  var defaultOptions = exports.defaultOptions = {
      wait: false
    , comments: true
    , scope: false
    , locations: false
    , ranges: false
    , onCreateNode: null
    , onCreateScope: null
    , onDestroyScope: null
    , onLocalDeclaration: null
    , luaVersion: &#039;5.3&#039;
    , encodingMode: &#039;none&#039;
  };

  function encodeUTF8(codepoint, highMask) {
    highMask = highMask || 0;

    if (codepoint &lt; 0x80) {
      return String.fromCharCode(codepoint);
    } else if (codepoint &lt; 0x800) {
      return String.fromCharCode(
        highMask | 0xc0 |  (codepoint &gt;&gt;  6)        ,
        highMask | 0x80 | ( codepoint        &amp; 0x3f)
      );
    } else if (codepoint &lt; 0x10000) {
      return String.fromCharCode(
        highMask | 0xe0 |  (codepoint &gt;&gt; 12)        ,
        highMask | 0x80 | ((codepoint &gt;&gt;  6) &amp; 0x3f),
        highMask | 0x80 | ( codepoint        &amp; 0x3f)
      );
    } else /* istanbul ignore else */ if (codepoint &lt; 0x110000) {
      return String.fromCharCode(
        highMask | 0xf0 |  (codepoint &gt;&gt; 18)        ,
        highMask | 0x80 | ((codepoint &gt;&gt; 12) &amp; 0x3f),
        highMask | 0x80 | ((codepoint &gt;&gt;  6) &amp; 0x3f),
        highMask | 0x80 | ( codepoint        &amp; 0x3f)
      );
    } else {
      return null;
    }
  }

  function toHex(num, digits) {
    var result = num.toString(16);
    while (result.length &lt; digits)
      result = &#039;0&#039; + result;
    return result;
  }

  function checkChars(rx) {
    return function (s) {
      var m = rx.exec(s);
      if (!m)
        return s;
      raise(null, errors.invalidCodeUnit, toHex(m[0].charCodeAt(0), 4).toUpperCase());
    };
  }

  var encodingModes = {
    &#039;pseudo-latin1&#039;: {
      fixup: checkChars(/[^\x00-\xff]/),
      encodeByte: function (value) {
        if (value === null)
          return &#039;&#039;;
        return String.fromCharCode(value);
      },
      encodeUTF8: function (codepoint) {
        return encodeUTF8(codepoint);
      },
    },
    &#039;x-user-defined&#039;: {
      fixup: checkChars(/[^\x00-\x7f\uf780-\uf7ff]/),
      encodeByte: function (value) {
        if (value === null)
          return &#039;&#039;;
        if (value &gt;= 0x80)
          return String.fromCharCode(value | 0xf700);
        return String.fromCharCode(value);
      },
      encodeUTF8: function (codepoint) {
        return encodeUTF8(codepoint, 0xf700);
      }
    },
    &#039;none&#039;: {
      discardStrings: true,
      fixup: function (s) {
        return s;
      },
      encodeByte: function (value) {
        return &#039;&#039;;
      },
      encodeUTF8: function (codepoint) {
        return &#039;&#039;;
      }
    }
  };

  var EOF = 1, StringLiteral = 2, Keyword = 4, Identifier = 8
    , NumericLiteral = 16, Punctuator = 32, BooleanLiteral = 64
    , NilLiteral = 128, VarargLiteral = 256;

  exports.tokenTypes = { EOF: EOF, StringLiteral: StringLiteral
    , Keyword: Keyword, Identifier: Identifier, NumericLiteral: NumericLiteral
    , Punctuator: Punctuator, BooleanLiteral: BooleanLiteral
    , NilLiteral: NilLiteral, VarargLiteral: VarargLiteral
  };

  var errors = exports.errors = {
      unexpected: &#039;unexpected %1 \&#039;%2\&#039; near \&#039;%3\&#039;&#039;
    , unexpectedEOF: &#039;unexpected symbol near \&#039;&lt;eof&gt;\&#039;&#039;
    , expected: &#039;\&#039;%1\&#039; expected near \&#039;%2\&#039;&#039;
    , expectedToken: &#039;%1 expected near \&#039;%2\&#039;&#039;
    , unfinishedString: &#039;unfinished string near \&#039;%1\&#039;&#039;
    , malformedNumber: &#039;malformed number near \&#039;%1\&#039;&#039;
    , decimalEscapeTooLarge: &#039;decimal escape too large near \&#039;%1\&#039;&#039;
    , invalidEscape: &#039;invalid escape sequence near \&#039;%1\&#039;&#039;
    , hexadecimalDigitExpected: &#039;hexadecimal digit expected near \&#039;%1\&#039;&#039;
    , braceExpected: &#039;missing \&#039;%1\&#039; near \&#039;%2\&#039;&#039;
    , tooLargeCodepoint: &#039;UTF-8 value too large near \&#039;%1\&#039;&#039;
    , unfinishedLongString: &#039;unfinished long string (starting at line %1) near \&#039;%2\&#039;&#039;
    , unfinishedLongComment: &#039;unfinished long comment (starting at line %1) near \&#039;%2\&#039;&#039;
    , ambiguousSyntax: &#039;ambiguous syntax (function call x new statement) near \&#039;%1\&#039;&#039;
    , noLoopToBreak: &#039;no loop to break near \&#039;%1\&#039;&#039;
    , labelAlreadyDefined: &#039;label \&#039;%1\&#039; already defined on line %2&#039;
    , labelNotVisible: &#039;no visible label \&#039;%1\&#039; for &lt;goto&gt;&#039;
    , gotoJumpInLocalScope: &#039;&lt;goto %1&gt; jumps into the scope of local \&#039;%2\&#039;&#039;
    , cannotUseVararg: &#039;cannot use \&#039;...\&#039; outside a vararg function near \&#039;%1\&#039;&#039;
    , invalidCodeUnit: &#039;code unit U+%1 is not allowed in the current encoding mode&#039;
  };

  var ast = exports.ast = {
      labelStatement: function(label) {
      return {
          type: &#039;LabelStatement&#039;
        , label: label
      };
    }

    , breakStatement: function() {
      return {
          type: &#039;BreakStatement&#039;
      };
    }

    , gotoStatement: function(label) {
      return {
          type: &#039;GotoStatement&#039;
        , label: label
      };
    }

    , returnStatement: function(args) {
      return {
          type: &#039;ReturnStatement&#039;
        , &#039;arguments&#039;: args
      };
    }

    , ifStatement: function(clauses) {
      return {
          type: &#039;IfStatement&#039;
        , clauses: clauses
      };
    }
    , ifClause: function(condition, body) {
      return {
          type: &#039;IfClause&#039;
        , condition: condition
        , body: body
      };
    }
    , elseifClause: function(condition, body) {
      return {
          type: &#039;ElseifClause&#039;
        , condition: condition
        , body: body
      };
    }
    , elseClause: function(body) {
      return {
          type: &#039;ElseClause&#039;
        , body: body
      };
    }

    , whileStatement: function(condition, body) {
      return {
          type: &#039;WhileStatement&#039;
        , condition: condition
        , body: body
      };
    }

    , doStatement: function(body) {
      return {
          type: &#039;DoStatement&#039;
        , body: body
      };
    }

    , repeatStatement: function(condition, body) {
      return {
          type: &#039;RepeatStatement&#039;
        , condition: condition
        , body: body
      };
    }

    , localStatement: function(variables, init) {
      return {
          type: &#039;LocalStatement&#039;
        , variables: variables
        , init: init
      };
    }

    , assignmentStatement: function(variables, init) {
      return {
          type: &#039;AssignmentStatement&#039;
        , variables: variables
        , init: init
      };
    }

    , callStatement: function(expression) {
      return {
          type: &#039;CallStatement&#039;
        , expression: expression
      };
    }

    , functionStatement: function(identifier, parameters, isLocal, body) {
      return {
          type: &#039;FunctionDeclaration&#039;
        , identifier: identifier
        , isLocal: isLocal
        , parameters: parameters
        , body: body
      };
    }

    , forNumericStatement: function(variable, start, end, step, body) {
      return {
          type: &#039;ForNumericStatement&#039;
        , variable: variable
        , start: start
        , end: end
        , step: step
        , body: body
      };
    }

    , forGenericStatement: function(variables, iterators, body) {
      return {
          type: &#039;ForGenericStatement&#039;
        , variables: variables
        , iterators: iterators
        , body: body
      };
    }

    , chunk: function(body) {
      return {
          type: &#039;Chunk&#039;
        , body: body
      };
    }

    , identifier: function(name) {
      return {
          type: &#039;Identifier&#039;
        , name: name
      };
    }

    , literal: function(type, value, raw) {
      type = (type === StringLiteral) ? &#039;StringLiteral&#039;
        : (type === NumericLiteral) ? &#039;NumericLiteral&#039;
        : (type === BooleanLiteral) ? &#039;BooleanLiteral&#039;
        : (type === NilLiteral) ? &#039;NilLiteral&#039;
        : &#039;VarargLiteral&#039;;

      return {
          type: type
        , value: value
        , raw: raw
      };
    }

    , tableKey: function(key, value) {
      return {
          type: &#039;TableKey&#039;
        , key: key
        , value: value
      };
    }
    , tableKeyString: function(key, value) {
      return {
          type: &#039;TableKeyString&#039;
        , key: key
        , value: value
      };
    }
    , tableValue: function(value) {
      return {
          type: &#039;TableValue&#039;
        , value: value
      };
    }


    , tableConstructorExpression: function(fields) {
      return {
          type: &#039;TableConstructorExpression&#039;
        , fields: fields
      };
    }
    , binaryExpression: function(operator, left, right) {
      var type = (&#039;and&#039; === operator || &#039;or&#039; === operator) ?
        &#039;LogicalExpression&#039; :
        &#039;BinaryExpression&#039;;

      return {
          type: type
        , operator: operator
        , left: left
        , right: right
      };
    }
    , unaryExpression: function(operator, argument) {
      return {
          type: &#039;UnaryExpression&#039;
        , operator: operator
        , argument: argument
      };
    }
    , memberExpression: function(base, indexer, identifier) {
      return {
          type: &#039;MemberExpression&#039;
        , indexer: indexer
        , identifier: identifier
        , base: base
      };
    }

    , indexExpression: function(base, index) {
      return {
          type: &#039;IndexExpression&#039;
        , base: base
        , index: index
      };
    }

    , callExpression: function(base, args) {
      return {
          type: &#039;CallExpression&#039;
        , base: base
        , &#039;arguments&#039;: args
      };
    }

    , tableCallExpression: function(base, args) {
      return {
          type: &#039;TableCallExpression&#039;
        , base: base
        , &#039;arguments&#039;: args
      };
    }

    , stringCallExpression: function(base, argument) {
      return {
          type: &#039;StringCallExpression&#039;
        , base: base
        , argument: argument
      };
    }

    , comment: function(value, raw) {
      return {
          type: &#039;Comment&#039;
        , value: value
        , raw: raw
      };
    }
  };

  function finishNode(node) {
    if (trackLocations) {
      var location = locations.pop();
      location.complete();
      location.bless(node);
    }
    if (options.onCreateNode) options.onCreateNode(node);
    return node;
  }

  var slice = Array.prototype.slice
    , toString = Object.prototype.toString
    ;

  var indexOf = /* istanbul ignore next */ function (array, element) {
    for (var i = 0, length = array.length; i &lt; length; ++i) {
      if (array[i] === element) return i;
    }
    return -1;
  };
  if (Array.prototype.indexOf)
    indexOf = function (array, element) {
      return array.indexOf(element);
    };

  function indexOfObject(array, property, element) {
    for (var i = 0, length = array.length; i &lt; length; ++i) {
      if (array[i][property] === element) return i;
    }
    return -1;
  }

  function sprintf(format) {
    var args = slice.call(arguments, 1);
    format = format.replace(/%(\d)/g, function (match, index) {
      return &#039;&#039; + args[index - 1] || /* istanbul ignore next */ &#039;&#039;;
    });
    return format;
  }

  var assign = /* istanbul ignore next */ function (dest) {
    var args = slice.call(arguments, 1)
      , src, prop;

    for (var i = 0, length = args.length; i &lt; length; ++i) {
      src = args[i];
      for (prop in src)
        if (Object.prototype.hasOwnProperty.call(src, prop)) {
          dest[prop] = src[prop];
        }
    }

    return dest;
  };
  if (Object.assign)
    assign = Object.assign;

  exports.SyntaxError = SyntaxError;

  function fixupError(e) {
    if (!Object.create)
      return e;
    return Object.create(e, {
      &#039;line&#039;: { &#039;writable&#039;: true, value: e.line },
      &#039;index&#039;: { &#039;writable&#039;: true, value: e.index },
      &#039;column&#039;: { &#039;writable&#039;: true, value: e.column }
    });
  }

  function raise(token) {
    var message = sprintf.apply(null, slice.call(arguments, 1))
      , error, col;

    if (token === null || typeof token.line === &#039;undefined&#039;) {
      col = index - lineStart + 1;
      error = fixupError(new SyntaxError(sprintf(&#039;[%1:%2] %3&#039;, line, col, message)));
      error.index = index;
      error.line = line;
      error.column = col;
    } else {
      col = token.range[0] - token.lineStart;
      error = fixupError(new SyntaxError(sprintf(&#039;[%1:%2] %3&#039;, token.line, col, message)));
      error.line = token.line;
      error.index = token.range[0];
      error.column = col;
    }
    throw error;
  }

  function tokenValue(token) {
    var raw = input.slice(token.range[0], token.range[1]);
    if (raw)
      return raw;
    return token.value;
  }

  function raiseUnexpectedToken(type, token) {
    raise(token, errors.expectedToken, type, tokenValue(token));
  }

  function unexpected(found) {
    var near = tokenValue(lookahead);
    if (&#039;undefined&#039; !== typeof found.type) {
      var type;
      switch (found.type) {
        case StringLiteral:   type = &#039;string&#039;;      break;
        case Keyword:         type = &#039;keyword&#039;;     break;
        case Identifier:      type = &#039;identifier&#039;;  break;
        case NumericLiteral:  type = &#039;number&#039;;      break;
        case Punctuator:      type = &#039;symbol&#039;;      break;
        case BooleanLiteral:  type = &#039;boolean&#039;;     break;
        case NilLiteral:
          return raise(found, errors.unexpected, &#039;symbol&#039;, &#039;nil&#039;, near);
        case EOF:
          return raise(found, errors.unexpectedEOF);
      }
      return raise(found, errors.unexpected, type, tokenValue(found), near);
    }
    return raise(found, errors.unexpected, &#039;symbol&#039;, found, near);
  }

  var index
    , token
    , previousToken
    , lookahead
    , comments
    , tokenStart
    , line
    , lineStart;

  exports.lex = lex;

  function lex() {
    skipWhiteSpace();
    while (45 === input.charCodeAt(index) &amp;&amp;
           45 === input.charCodeAt(index + 1)) {
      scanComment();
      skipWhiteSpace();
    }
    if (index &gt;= length) return {
        type : EOF
      , value: &#039;&lt;eof&gt;&#039;
      , line: line
      , lineStart: lineStart
      , range: [index, index]
    };

    var charCode = input.charCodeAt(index)
      , next = input.charCodeAt(index + 1);
    tokenStart = index;
    if (isIdentifierStart(charCode)) return scanIdentifierOrKeyword();

    switch (charCode) {
      case 39: case 34: // &#039;&quot;
        return scanStringLiteral();

      case 48: case 49: case 50: case 51: case 52: case 53:
      case 54: case 55: case 56: case 57: // 0-9
        return scanNumericLiteral();

      case 46: // .
        if (isDecDigit(next)) return scanNumericLiteral();
        if (46 === next) {
          if (46 === input.charCodeAt(index + 2)) return scanVarargLiteral();
          return scanPunctuator(&#039;..&#039;);
        }
        return scanPunctuator(&#039;.&#039;);

      case 61: // =
        if (61 === next) return scanPunctuator(&#039;==&#039;);
        return scanPunctuator(&#039;=&#039;);

      case 62: // &gt;
        if (features.bitwiseOperators)
          if (62 === next) return scanPunctuator(&#039;&gt;&gt;&#039;);
        if (61 === next) return scanPunctuator(&#039;&gt;=&#039;);
        return scanPunctuator(&#039;&gt;&#039;);

      case 60: // &lt;
        if (features.bitwiseOperators)
          if (60 === next) return scanPunctuator(&#039;&lt;&lt;&#039;);
        if (61 === next) return scanPunctuator(&#039;&lt;=&#039;);
        return scanPunctuator(&#039;&lt;&#039;);

      case 126: // ~
        if (61 === next) return scanPunctuator(&#039;~=&#039;);
        if (!features.bitwiseOperators)
          break;
        return scanPunctuator(&#039;~&#039;);

      case 58: // :
        if (features.labels)
          if (58 === next) return scanPunctuator(&#039;::&#039;);
        return scanPunctuator(&#039;:&#039;);

      case 91: // [
        if (91 === next || 61 === next) return scanLongStringLiteral();
        return scanPunctuator(&#039;[&#039;);

      case 47: // /
        if (features.integerDivision)
          if (47 === next) return scanPunctuator(&#039;//&#039;);
        return scanPunctuator(&#039;/&#039;);

      case 38: case 124: // &amp; |
        if (!features.bitwiseOperators)
          break;
      case 42: case 94: case 37: case 44: case 123: case 125:
      case 93: case 40: case 41: case 59: case 35: case 45:
      case 43: // * ^ % , { } ] ( ) ; # - +
        return scanPunctuator(input.charAt(index));
    }

    return unexpected(input.charAt(index));
  }

  function consumeEOL() {
    var charCode = input.charCodeAt(index)
      , peekCharCode = input.charCodeAt(index + 1);

    if (isLineTerminator(charCode)) {
      if (10 === charCode &amp;&amp; 13 === peekCharCode) ++index;
      if (13 === charCode &amp;&amp; 10 === peekCharCode) ++index;
      ++line;
      lineStart = ++index;

      return true;
    }
    return false;
  }

  function skipWhiteSpace() {
    while (index &lt; length) {
      var charCode = input.charCodeAt(index);
      if (isWhiteSpace(charCode)) {
        ++index;
      } else if (!consumeEOL()) {
        break;
      }
    }
  }

  function scanIdentifierOrKeyword() {
    var value, type;
    while (isIdentifierPart(input.charCodeAt(++index)));
    value = encodingMode.fixup(input.slice(tokenStart, index));
    if (isKeyword(value)) {
      type = Keyword;
    } else if (&#039;true&#039; === value || &#039;false&#039; === value) {
      type = BooleanLiteral;
      value = (&#039;true&#039; === value);
    } else if (&#039;nil&#039; === value) {
      type = NilLiteral;
      value = null;
    } else {
      type = Identifier;
    }

    return {
        type: type
      , value: value
      , line: line
      , lineStart: lineStart
      , range: [tokenStart, index]
    };
  }

  function scanPunctuator(value) {
    index += value.length;
    return {
        type: Punctuator
      , value: value
      , line: line
      , lineStart: lineStart
      , range: [tokenStart, index]
    };
  }

  function scanVarargLiteral() {
    index += 3;
    return {
        type: VarargLiteral
      , value: &#039;...&#039;
      , line: line
      , lineStart: lineStart
      , range: [tokenStart, index]
    };
  }

  function scanStringLiteral() {
    var delimiter = input.charCodeAt(index++)
      , beginLine = line
      , beginLineStart = lineStart
      , stringStart = index
      , string = encodingMode.discardStrings ? null : &#039;&#039;
      , charCode;

    for (;;) {
      charCode = input.charCodeAt(index++);
      if (delimiter === charCode) break;
      if (index &gt; length || isLineTerminator(charCode)) {
        string += input.slice(stringStart, index - 1);
        raise(null, errors.unfinishedString, input.slice(tokenStart, index - 1));
      }
      if (92 === charCode) { // backslash
        if (!encodingMode.discardStrings) {
          var beforeEscape = input.slice(stringStart, index - 1);
          string += encodingMode.fixup(beforeEscape);
        }
        var escapeValue = readEscapeSequence();
        if (!encodingMode.discardStrings)
          string += escapeValue;
        stringStart = index;
      }
    }
    if (!encodingMode.discardStrings) {
      string += encodingMode.encodeByte(null);
      string += encodingMode.fixup(input.slice(stringStart, index - 1));
    }

    return {
        type: StringLiteral
      , value: string
      , line: beginLine
      , lineStart: beginLineStart
      , lastLine: line
      , lastLineStart: lineStart
      , range: [tokenStart, index]
    };
  }

  function scanLongStringLiteral() {
    var beginLine = line
      , beginLineStart = lineStart
      , string = readLongString(false);
    if (false === string) raise(token, errors.expected, &#039;[&#039;, tokenValue(token));

    return {
        type: StringLiteral
      , value: encodingMode.discardStrings ? null : encodingMode.fixup(string)
      , line: beginLine
      , lineStart: beginLineStart
      , lastLine: line
      , lastLineStart: lineStart
      , range: [tokenStart, index]
    };
  }

  function scanNumericLiteral() {
    var character = input.charAt(index)
      , next = input.charAt(index + 1);

    var literal = (&#039;0&#039; === character &amp;&amp; &#039;xX&#039;.indexOf(next || null) &gt;= 0) ?
      readHexLiteral() : readDecLiteral();

    var foundImaginaryUnit = readImaginaryUnitSuffix()
      , foundInt64Suffix = readInt64Suffix();

    if (foundInt64Suffix &amp;&amp; (foundImaginaryUnit || literal.hasFractionPart)) {
      raise(null, errors.malformedNumber, input.slice(tokenStart, index));
    }

    return {
        type: NumericLiteral
      , value: literal.value
      , line: line
      , lineStart: lineStart
      , range: [tokenStart, index]
    };
  }

  function readImaginaryUnitSuffix() {
    if (!features.imaginaryNumbers) return;
    if (&#039;iI&#039;.indexOf(input.charAt(index) || null) &gt;= 0) {
      ++index;
      return true;
    } else {
      return false;
    }
  }

  function readInt64Suffix() {
    if (!features.integerSuffixes) return;

    if (&#039;uU&#039;.indexOf(input.charAt(index) || null) &gt;= 0) {
      ++index;
      if (&#039;lL&#039;.indexOf(input.charAt(index) || null) &gt;= 0) {
        ++index;
        if (&#039;lL&#039;.indexOf(input.charAt(index) || null) &gt;= 0) {
          ++index;
          return &#039;ULL&#039;;
        } else {
          raise(null, errors.malformedNumber, input.slice(tokenStart, index));
        }
      } else {
        raise(null, errors.malformedNumber, input.slice(tokenStart, index));
      }
    } else if (&#039;lL&#039;.indexOf(input.charAt(index) || null) &gt;= 0) {
        ++index;
        if (&#039;lL&#039;.indexOf(input.charAt(index) || null) &gt;= 0) {
          ++index;
          return &#039;LL&#039;;
        } else {
          raise(null, errors.malformedNumber, input.slice(tokenStart, index));
        }
    }
  }

  function readHexLiteral() {
    var fraction = 0 // defaults to 0 as it gets summed
      , binaryExponent = 1 // defaults to 1 as it gets multiplied
      , binarySign = 1 // positive
      , digit, fractionStart, exponentStart, digitStart;

    digitStart = index += 2; // Skip 0x part
    if (!isHexDigit(input.charCodeAt(index)))
      raise(null, errors.malformedNumber, input.slice(tokenStart, index));

    while (isHexDigit(input.charCodeAt(index))) ++index;
    digit = parseInt(input.slice(digitStart, index), 16);
    var foundFraction = false;
    if (&#039;.&#039; === input.charAt(index)) {
      foundFraction = true;
      fractionStart = ++index;

      while (isHexDigit(input.charCodeAt(index))) ++index;
      fraction = input.slice(fractionStart, index);
      fraction = (fractionStart === index) ? 0
        : parseInt(fraction, 16) / Math.pow(16, index - fractionStart);
    }
    var foundBinaryExponent = false;
    if (&#039;pP&#039;.indexOf(input.charAt(index) || null) &gt;= 0) {
      foundBinaryExponent = true;
      ++index;
      if (&#039;+-&#039;.indexOf(input.charAt(index) || null) &gt;= 0)
        binarySign = (&#039;+&#039; === input.charAt(index++)) ? 1 : -1;

      exponentStart = index;
      if (!isDecDigit(input.charCodeAt(index)))
        raise(null, errors.malformedNumber, input.slice(tokenStart, index));

      while (isDecDigit(input.charCodeAt(index))) ++index;
      binaryExponent = input.slice(exponentStart, index);
      binaryExponent = Math.pow(2, binaryExponent * binarySign);
    }

    return {
      value: (digit + fraction) * binaryExponent,
      hasFractionPart: foundFraction || foundBinaryExponent
    };
  }

  function readDecLiteral() {
    while (isDecDigit(input.charCodeAt(index))) ++index;
    var foundFraction = false;
    if (&#039;.&#039; === input.charAt(index)) {
      foundFraction = true;
      ++index;
      while (isDecDigit(input.charCodeAt(index))) ++index;
    }
    var foundExponent = false;
    if (&#039;eE&#039;.indexOf(input.charAt(index) || null) &gt;= 0) {
      foundExponent = true;
      ++index;
      if (&#039;+-&#039;.indexOf(input.charAt(index) || null) &gt;= 0) ++index;
      if (!isDecDigit(input.charCodeAt(index)))
        raise(null, errors.malformedNumber, input.slice(tokenStart, index));

      while (isDecDigit(input.charCodeAt(index))) ++index;
    }

    return {
      value: parseFloat(input.slice(tokenStart, index)),
      hasFractionPart: foundFraction || foundExponent
    };
  }

  function readUnicodeEscapeSequence() {
    var sequenceStart = index++;

    if (input.charAt(index++) !== &#039;{&#039;)
      raise(null, errors.braceExpected, &#039;{&#039;, &#039;\\&#039; + input.slice(sequenceStart, index));
    if (!isHexDigit(input.charCodeAt(index)))
      raise(null, errors.hexadecimalDigitExpected, &#039;\\&#039; + input.slice(sequenceStart, index));

    while (input.charCodeAt(index) === 0x30) ++index;
    var escStart = index;

    while (isHexDigit(input.charCodeAt(index))) {
      ++index;
      if (index - escStart &gt; 6)
        raise(null, errors.tooLargeCodepoint, &#039;\\&#039; + input.slice(sequenceStart, index));
    }

    var b = input.charAt(index++);
    if (b !== &#039;}&#039;) {
      if ((b === &#039;&quot;&#039;) || (b === &quot;&#039;&quot;))
        raise(null, errors.braceExpected, &#039;}&#039;, &#039;\\&#039; + input.slice(sequenceStart, index--));
      else
        raise(null, errors.hexadecimalDigitExpected, &#039;\\&#039; + input.slice(sequenceStart, index));
    }

    var codepoint = parseInt(input.slice(escStart, index - 1) || &#039;0&#039;, 16);
    var frag = &#039;\\&#039; + input.slice(sequenceStart, index);

    if (codepoint &gt; 0x10ffff) {
      raise(null, errors.tooLargeCodepoint, frag);
    }

    return encodingMode.encodeUTF8(codepoint, frag);
  }
  function readEscapeSequence() {
    var sequenceStart = index;
    switch (input.charAt(index)) {
      case &#039;a&#039;: ++index; return &#039;\x07&#039;;
      case &#039;n&#039;: ++index; return &#039;\n&#039;;
      case &#039;r&#039;: ++index; return &#039;\r&#039;;
      case &#039;t&#039;: ++index; return &#039;\t&#039;;
      case &#039;v&#039;: ++index; return &#039;\x0b&#039;;
      case &#039;b&#039;: ++index; return &#039;\b&#039;;
      case &#039;f&#039;: ++index; return &#039;\f&#039;;
      case &#039;\r&#039;:
      case &#039;\n&#039;:
        consumeEOL();
        return &#039;\n&#039;;

      case &#039;0&#039;: case &#039;1&#039;: case &#039;2&#039;: case &#039;3&#039;: case &#039;4&#039;:
      case &#039;5&#039;: case &#039;6&#039;: case &#039;7&#039;: case &#039;8&#039;: case &#039;9&#039;:
        while (isDecDigit(input.charCodeAt(index)) &amp;&amp; index - sequenceStart &lt; 3) ++index;

        var frag = input.slice(sequenceStart, index);
        var ddd = parseInt(frag, 10);
        if (ddd &gt; 255) {
          raise(null, errors.decimalEscapeTooLarge, &#039;\\&#039; + ddd);
        }
        return encodingMode.encodeByte(ddd, &#039;\\&#039; + frag);

      case &#039;z&#039;:
        if (features.skipWhitespaceEscape) {
          ++index;
          skipWhiteSpace();
          return &#039;&#039;;
        }
        break;

      case &#039;x&#039;:
        if (features.hexEscapes) {
          if (isHexDigit(input.charCodeAt(index + 1)) &amp;&amp;
              isHexDigit(input.charCodeAt(index + 2))) {
            index += 3;
            return encodingMode.encodeByte(parseInt(input.slice(sequenceStart + 1, index), 16), &#039;\\&#039; + input.slice(sequenceStart, index));
          }
          raise(null, errors.hexadecimalDigitExpected, &#039;\\&#039; + input.slice(sequenceStart, index + 2));
        }
        break;

      case &#039;u&#039;:
        if (features.unicodeEscapes)
          return readUnicodeEscapeSequence();
        break;

      case &#039;\\&#039;: case &#039;&quot;&#039;: case &quot;&#039;&quot;:
        return input.charAt(index++);
    }

    if (features.strictEscapes)
      raise(null, errors.invalidEscape, &#039;\\&#039; + input.slice(sequenceStart, index + 1));
    return input.charAt(index++);
  }

  function scanComment() {
    tokenStart = index;
    index += 2; // --

    var character = input.charAt(index)
      , content = &#039;&#039;
      , isLong = false
      , commentStart = index
      , lineStartComment = lineStart
      , lineComment = line;

    if (&#039;[&#039; === character) {
      content = readLongString(true);
      if (false === content) content = character;
      else isLong = true;
    }
    if (!isLong) {
      while (index &lt; length) {
        if (isLineTerminator(input.charCodeAt(index))) break;
        ++index;
      }
      if (options.comments) content = input.slice(commentStart, index);
    }

    if (options.comments) {
      var node = ast.comment(content, input.slice(tokenStart, index));
      if (options.locations) {
        node.loc = {
            start: { line: lineComment, column: tokenStart - lineStartComment }
          , end: { line: line, column: index - lineStart }
        };
      }
      if (options.ranges) {
        node.range = [tokenStart, index];
      }
      if (options.onCreateNode) options.onCreateNode(node);
      comments.push(node);
    }
  }

  function readLongString(isComment) {
    var level = 0
      , content = &#039;&#039;
      , terminator = false
      , character, stringStart, firstLine = line;

    ++index; // [
    while (&#039;=&#039; === input.charAt(index + level)) ++level;
    if (&#039;[&#039; !== input.charAt(index + level)) return false;

    index += level + 1;
    if (isLineTerminator(input.charCodeAt(index))) consumeEOL();

    stringStart = index;
    while (index &lt; length) {
      while (isLineTerminator(input.charCodeAt(index))) consumeEOL();

      character = input.charAt(index++);
      if (&#039;]&#039; === character) {
        terminator = true;
        for (var i = 0; i &lt; level; ++i) {
          if (&#039;=&#039; !== input.charAt(index + i)) terminator = false;
        }
        if (&#039;]&#039; !== input.charAt(index + level)) terminator = false;
      }
      if (terminator) {
        content += input.slice(stringStart, index - 1);
        index += level + 1;
        return content;
      }
    }

    raise(null, isComment ?
                errors.unfinishedLongComment :
                errors.unfinishedLongString,
          firstLine, &#039;&lt;eof&gt;&#039;);
  }

  function next() {
    previousToken = token;
    token = lookahead;
    lookahead = lex();
  }

  function consume(value) {
    if (value === token.value) {
      next();
      return true;
    }
    return false;
  }

  function expect(value) {
    if (value === token.value) next();
    else raise(token, errors.expected, value, tokenValue(token));
  }

  function isWhiteSpace(charCode) {
    return 9 === charCode || 32 === charCode || 0xB === charCode || 0xC === charCode;
  }

  function isLineTerminator(charCode) {
    return 10 === charCode || 13 === charCode;
  }

  function isDecDigit(charCode) {
    return charCode &gt;= 48 &amp;&amp; charCode &lt;= 57;
  }

  function isHexDigit(charCode) {
    return (charCode &gt;= 48 &amp;&amp; charCode &lt;= 57) || (charCode &gt;= 97 &amp;&amp; charCode &lt;= 102) || (charCode &gt;= 65 &amp;&amp; charCode &lt;= 70);
  }

  function isIdentifierStart(charCode) {
    if ((charCode &gt;= 65 &amp;&amp; charCode &lt;= 90) || (charCode &gt;= 97 &amp;&amp; charCode &lt;= 122) || 95 === charCode)
      return true;
    if (features.extendedIdentifiers &amp;&amp; charCode &gt;= 128)
      return true;
    return false;
  }

  function isIdentifierPart(charCode) {
    if ((charCode &gt;= 65 &amp;&amp; charCode &lt;= 90) || (charCode &gt;= 97 &amp;&amp; charCode &lt;= 122) || 95 === charCode || (charCode &gt;= 48 &amp;&amp; charCode &lt;= 57))
      return true;
    if (features.extendedIdentifiers &amp;&amp; charCode &gt;= 128)
      return true;
    return false;
  }

  function isKeyword(id) {
    switch (id.length) {
      case 2:
        return &#039;do&#039; === id || &#039;if&#039; === id || &#039;in&#039; === id || &#039;or&#039; === id;
      case 3:
        return &#039;and&#039; === id || &#039;end&#039; === id || &#039;for&#039; === id || &#039;not&#039; === id;
      case 4:
        if (&#039;else&#039; === id || &#039;then&#039; === id)
          return true;
        if (features.labels &amp;&amp; !features.contextualGoto)
          return (&#039;goto&#039; === id);
        return false;
      case 5:
        return &#039;break&#039; === id || &#039;local&#039; === id || &#039;until&#039; === id || &#039;while&#039; === id;
      case 6:
        return &#039;elseif&#039; === id || &#039;repeat&#039; === id || &#039;return&#039; === id;
      case 8:
        return &#039;function&#039; === id;
    }
    return false;
  }

  function isUnary(token) {
    if (Punctuator === token.type) return &#039;#-~&#039;.indexOf(token.value) &gt;= 0;
    if (Keyword === token.type) return &#039;not&#039; === token.value;
    return false;
  }

  function isBlockFollow(token) {
    if (EOF === token.type) return true;
    if (Keyword !== token.type) return false;
    switch (token.value) {
      case &#039;else&#039;: case &#039;elseif&#039;:
      case &#039;end&#039;: case &#039;until&#039;:
        return true;
      default:
        return false;
    }
  }
  var scopes
    , scopeDepth
    , globals;
  function createScope() {
    var scope = scopes[scopeDepth++].slice();
    scopes.push(scope);
    if (options.onCreateScope) options.onCreateScope();
  }
  function destroyScope() {
    var scope = scopes.pop();
    --scopeDepth;
    if (options.onDestroyScope) options.onDestroyScope();
  }
  function scopeIdentifierName(name) {
    if (options.onLocalDeclaration) options.onLocalDeclaration(name);
    if (-1 !== indexOf(scopes[scopeDepth], name)) return;
    scopes[scopeDepth].push(name);
  }
  function scopeIdentifier(node) {
    scopeIdentifierName(node.name);
    attachScope(node, true);
  }
  function attachScope(node, isLocal) {
    if (!isLocal &amp;&amp; -1 === indexOfObject(globals, &#039;name&#039;, node.name))
      globals.push(node);

    node.isLocal = isLocal;
  }
  function scopeHasName(name) {
    return (-1 !== indexOf(scopes[scopeDepth], name));
  }

  var locations = []
    , trackLocations;

  function createLocationMarker() {
    return new Marker(token);
  }

  function Marker(token) {
    if (options.locations) {
      this.loc = {
          start: {
            line: token.line
          , column: token.range[0] - token.lineStart
        }
        , end: {
            line: 0
          , column: 0
        }
      };
    }
    if (options.ranges) this.range = [token.range[0], 0];
  }
  Marker.prototype.complete = function() {
    if (options.locations) {
      this.loc.end.line = previousToken.lastLine || previousToken.line;
      this.loc.end.column = previousToken.range[1] - (previousToken.lastLineStart || previousToken.lineStart);
    }
    if (options.ranges) {
      this.range[1] = previousToken.range[1];
    }
  };

  Marker.prototype.bless = function (node) {
    if (this.loc) {
      var loc = this.loc;
      node.loc = {
        start: {
          line: loc.start.line,
          column: loc.start.column
        },
        end: {
          line: loc.end.line,
          column: loc.end.column
        }
      };
    }
    if (this.range) {
      node.range = [
        this.range[0],
        this.range[1]
      ];
    }
  };
  function markLocation() {
    if (trackLocations) locations.push(createLocationMarker());
  }
  function pushLocation(marker) {
    if (trackLocations) locations.push(marker);
  }

  function FullFlowContext() {
    this.scopes = [];
    this.pendingGotos = [];
  }

  FullFlowContext.prototype.isInLoop = function () {
    var i = this.scopes.length;
    while (i --&gt; 0) {
      if (this.scopes[i].isLoop)
        return true;
    }
    return false;
  };

  FullFlowContext.prototype.pushScope = function (isLoop) {
    var scope = {
      labels: {},
      locals: [],
      deferredGotos: [],
      isLoop: !!isLoop
    };
    this.scopes.push(scope);
  };

  FullFlowContext.prototype.popScope = function () {
    for (var i = 0; i &lt; this.pendingGotos.length; ++i) {
      var theGoto = this.pendingGotos[i];
      if (theGoto.maxDepth &gt;= this.scopes.length)
        if (--theGoto.maxDepth &lt;= 0)
          raise(theGoto.token, errors.labelNotVisible, theGoto.target);
    }

    this.scopes.pop();
  };

  FullFlowContext.prototype.addGoto = function (target, token) {
    var localCounts = [];

    for (var i = 0; i &lt; this.scopes.length; ++i) {
      var scope = this.scopes[i];
      localCounts.push(scope.locals.length);
      if (Object.prototype.hasOwnProperty.call(scope.labels, target))
        return;
    }

    this.pendingGotos.push({
      maxDepth: this.scopes.length,
      target: target,
      token: token,
      localCounts: localCounts
    });
  };

  FullFlowContext.prototype.addLabel = function (name, token) {
    var scope = this.currentScope();

    if (Object.prototype.hasOwnProperty.call(scope.labels, name)) {
      raise(token, errors.labelAlreadyDefined, name, scope.labels[name].line);
    } else {
      var newGotos = [];

      for (var i = 0; i &lt; this.pendingGotos.length; ++i) {
        var theGoto = this.pendingGotos[i];

        if (theGoto.maxDepth &gt;= this.scopes.length &amp;&amp; theGoto.target === name) {
          if (theGoto.localCounts[this.scopes.length - 1] &lt; scope.locals.length) {
            scope.deferredGotos.push(theGoto);
          }
          continue;
        }

        newGotos.push(theGoto);
      }

      this.pendingGotos = newGotos;
    }

    scope.labels[name] = {
      localCount: scope.locals.length,
      line: token.line
    };
  };

  FullFlowContext.prototype.addLocal = function (name, token) {
    this.currentScope().locals.push({
      name: name,
      token: token
    });
  };

  FullFlowContext.prototype.currentScope = function () {
    return this.scopes[this.scopes.length - 1];
  };

  FullFlowContext.prototype.raiseDeferredErrors = function () {
    var scope = this.currentScope();
    var bads = scope.deferredGotos;
    for (var i = 0; i &lt; bads.length; ++i) {
      var theGoto = bads[i];
      raise(theGoto.token, errors.gotoJumpInLocalScope, theGoto.target, scope.locals[theGoto.localCounts[this.scopes.length - 1]].name);
    }
  };

  function LoopFlowContext() {
    this.level = 0;
    this.loopLevels = [];
  }

  LoopFlowContext.prototype.isInLoop = function () {
    return !!this.loopLevels.length;
  };

  LoopFlowContext.prototype.pushScope = function (isLoop) {
    ++this.level;
    if (isLoop)
      this.loopLevels.push(this.level);
  };

  LoopFlowContext.prototype.popScope = function () {
    var levels = this.loopLevels;
    var levlen = levels.length;
    if (levlen) {
      if (levels[levlen - 1] === this.level)
        levels.pop();
    }
    --this.level;
  };

  LoopFlowContext.prototype.addGoto =
  LoopFlowContext.prototype.addLabel =
  function () { throw new Error(&#039;This should never happen&#039;); };

  LoopFlowContext.prototype.addLocal =
  LoopFlowContext.prototype.raiseDeferredErrors =
  function () {};

  function makeFlowContext() {
    return features.labels ? new FullFlowContext() : new LoopFlowContext();
  }

  function parseChunk() {
    next();
    markLocation();
    if (options.scope) createScope();
    var flowContext = makeFlowContext();
    flowContext.allowVararg = true;
    flowContext.pushScope();
    var body = parseBlock(flowContext);
    flowContext.popScope();
    if (options.scope) destroyScope();
    if (EOF !== token.type) unexpected(token);
    if (trackLocations &amp;&amp; !body.length) previousToken = token;
    return finishNode(ast.chunk(body));
  }

  function parseBlock(flowContext) {
    var block = []
      , statement;

    while (!isBlockFollow(token)) {
      if (&#039;return&#039; === token.value || (!features.relaxedBreak &amp;&amp; &#039;break&#039; === token.value)) {
        block.push(parseStatement(flowContext));
        break;
      }
      statement = parseStatement(flowContext);
      consume(&#039;;&#039;);
      if (statement) block.push(statement);
    }
    return block;
  }

  function parseStatement(flowContext) {
    markLocation();

    if (Punctuator === token.type) {
      if (consume(&#039;::&#039;)) return parseLabelStatement(flowContext);
    }
    if (features.emptyStatement) {
      if (consume(&#039;;&#039;)) {
        if (trackLocations) locations.pop();
        return;
      }
    }

    flowContext.raiseDeferredErrors();

    if (Keyword === token.type) {
      switch (token.value) {
        case &#039;local&#039;:    next(); return parseLocalStatement(flowContext);
        case &#039;if&#039;:       next(); return parseIfStatement(flowContext);
        case &#039;return&#039;:   next(); return parseReturnStatement(flowContext);
        case &#039;function&#039;: next();
          var name = parseFunctionName();
          return parseFunctionDeclaration(name);
        case &#039;while&#039;:    next(); return parseWhileStatement(flowContext);
        case &#039;for&#039;:      next(); return parseForStatement(flowContext);
        case &#039;repeat&#039;:   next(); return parseRepeatStatement(flowContext);
        case &#039;break&#039;:    next();
          if (!flowContext.isInLoop())
            raise(token, errors.noLoopToBreak, token.value);
          return parseBreakStatement();
        case &#039;do&#039;:       next(); return parseDoStatement(flowContext);
        case &#039;goto&#039;:     next(); return parseGotoStatement(flowContext);
      }
    }

    if (features.contextualGoto &amp;&amp;
        token.type === Identifier &amp;&amp; token.value === &#039;goto&#039; &amp;&amp;
        lookahead.type === Identifier &amp;&amp; lookahead.value !== &#039;goto&#039;) {
      next(); return parseGotoStatement(flowContext);
    }
    if (trackLocations) locations.pop();

    return parseAssignmentOrCallStatement(flowContext);
  }

  function parseLabelStatement(flowContext) {
    var nameToken = token
      , label = parseIdentifier();

    if (options.scope) {
      scopeIdentifierName(&#039;::&#039; + nameToken.value + &#039;::&#039;);
      attachScope(label, true);
    }

    expect(&#039;::&#039;);

    flowContext.addLabel(nameToken.value, nameToken);
    return finishNode(ast.labelStatement(label));
  }

  function parseBreakStatement() {
    return finishNode(ast.breakStatement());
  }

  function parseGotoStatement(flowContext) {
    var name = token.value
      , gotoToken = previousToken
      , label = parseIdentifier();

    flowContext.addGoto(name, gotoToken);
    return finishNode(ast.gotoStatement(label));
  }

  function parseDoStatement(flowContext) {
    if (options.scope) createScope();
    flowContext.pushScope();
    var body = parseBlock(flowContext);
    flowContext.popScope();
    if (options.scope) destroyScope();
    expect(&#039;end&#039;);
    return finishNode(ast.doStatement(body));
  }

  function parseWhileStatement(flowContext) {
    var condition = parseExpectedExpression(flowContext);
    expect(&#039;do&#039;);
    if (options.scope) createScope();
    flowContext.pushScope(true);
    var body = parseBlock(flowContext);
    flowContext.popScope();
    if (options.scope) destroyScope();
    expect(&#039;end&#039;);
    return finishNode(ast.whileStatement(condition, body));
  }

  function parseRepeatStatement(flowContext) {
    if (options.scope) createScope();
    flowContext.pushScope(true);
    var body = parseBlock(flowContext);
    expect(&#039;until&#039;);
    flowContext.raiseDeferredErrors();
    var condition = parseExpectedExpression(flowContext);
    flowContext.popScope();
    if (options.scope) destroyScope();
    return finishNode(ast.repeatStatement(condition, body));
  }

  function parseReturnStatement(flowContext) {
    var expressions = [];

    if (&#039;end&#039; !== token.value) {
      var expression = parseExpression(flowContext);
      if (null != expression) expressions.push(expression);
      while (consume(&#039;,&#039;)) {
        expression = parseExpectedExpression(flowContext);
        expressions.push(expression);
      }
      consume(&#039;;&#039;); // grammar tells us ; is optional here.
    }
    return finishNode(ast.returnStatement(expressions));
  }

  function parseIfStatement(flowContext) {
    var clauses = []
      , condition
      , body
      , marker;
    if (trackLocations) {
      marker = locations[locations.length - 1];
      locations.push(marker);
    }
    condition = parseExpectedExpression(flowContext);
    expect(&#039;then&#039;);
    if (options.scope) createScope();
    flowContext.pushScope();
    body = parseBlock(flowContext);
    flowContext.popScope();
    if (options.scope) destroyScope();
    clauses.push(finishNode(ast.ifClause(condition, body)));

    if (trackLocations) marker = createLocationMarker();
    while (consume(&#039;elseif&#039;)) {
      pushLocation(marker);
      condition = parseExpectedExpression(flowContext);
      expect(&#039;then&#039;);
      if (options.scope) createScope();
      flowContext.pushScope();
      body = parseBlock(flowContext);
      flowContext.popScope();
      if (options.scope) destroyScope();
      clauses.push(finishNode(ast.elseifClause(condition, body)));
      if (trackLocations) marker = createLocationMarker();
    }

    if (consume(&#039;else&#039;)) {
      if (trackLocations) {
        marker = new Marker(previousToken);
        locations.push(marker);
      }
      if (options.scope) createScope();
      flowContext.pushScope();
      body = parseBlock(flowContext);
      flowContext.popScope();
      if (options.scope) destroyScope();
      clauses.push(finishNode(ast.elseClause(body)));
    }

    expect(&#039;end&#039;);
    return finishNode(ast.ifStatement(clauses));
  }

  function parseForStatement(flowContext) {
    var variable = parseIdentifier()
      , body;

    if (options.scope) {
      createScope();
      scopeIdentifier(variable);
    }
    if (consume(&#039;=&#039;)) {
      var start = parseExpectedExpression(flowContext);
      expect(&#039;,&#039;);
      var end = parseExpectedExpression(flowContext);
      var step = consume(&#039;,&#039;) ? parseExpectedExpression(flowContext) : null;

      expect(&#039;do&#039;);
      flowContext.pushScope(true);
      body = parseBlock(flowContext);
      flowContext.popScope();
      expect(&#039;end&#039;);
      if (options.scope) destroyScope();

      return finishNode(ast.forNumericStatement(variable, start, end, step, body));
    }
    else {
      var variables = [variable];
      while (consume(&#039;,&#039;)) {
        variable = parseIdentifier();
        if (options.scope) scopeIdentifier(variable);
        variables.push(variable);
      }
      expect(&#039;in&#039;);
      var iterators = [];
      do {
        var expression = parseExpectedExpression(flowContext);
        iterators.push(expression);
      } while (consume(&#039;,&#039;));

      expect(&#039;do&#039;);
      flowContext.pushScope(true);
      body = parseBlock(flowContext);
      flowContext.popScope();
      expect(&#039;end&#039;);
      if (options.scope) destroyScope();

      return finishNode(ast.forGenericStatement(variables, iterators, body));
    }
  }

  function parseLocalStatement(flowContext) {
    var name
      , declToken = previousToken;

    if (Identifier === token.type) {
      var variables = []
        , init = [];

      do {
        name = parseIdentifier();

        variables.push(name);
        flowContext.addLocal(name.name, declToken);
      } while (consume(&#039;,&#039;));

      if (consume(&#039;=&#039;)) {
        do {
          var expression = parseExpectedExpression(flowContext);
          init.push(expression);
        } while (consume(&#039;,&#039;));
      }
      if (options.scope) {
        for (var i = 0, l = variables.length; i &lt; l; ++i) {
          scopeIdentifier(variables[i]);
        }
      }

      return finishNode(ast.localStatement(variables, init));
    }
    if (consume(&#039;function&#039;)) {
      name = parseIdentifier();
      flowContext.addLocal(name.name, declToken);

      if (options.scope) {
        scopeIdentifier(name);
        createScope();
      }
      return parseFunctionDeclaration(name, true);
    } else {
      raiseUnexpectedToken(&#039;&lt;name&gt;&#039;, token);
    }
  }

  function parseAssignmentOrCallStatement(flowContext) {
    var previous = token
      , marker, startMarker;
    var lvalue, base, name;

    var targets = [];

    if (trackLocations) startMarker = createLocationMarker();

    do {
      if (trackLocations) marker = createLocationMarker();

      if (Identifier === token.type) {
        name = token.value;
        base = parseIdentifier();
        if (options.scope) attachScope(base, scopeHasName(name));
        lvalue = true;
      } else if (&#039;(&#039; === token.value) {
        next();
        base = parseExpectedExpression(flowContext);
        expect(&#039;)&#039;);
        lvalue = false;
      } else {
        return unexpected(token);
      }

      both: for (;;) {
        var newBase;

        switch (StringLiteral === token.type ? &#039;&quot;&#039; : token.value) {
        case &#039;.&#039;:
        case &#039;[&#039;:
          lvalue = true;
          break;
        case &#039;:&#039;:
        case &#039;(&#039;:
        case &#039;{&#039;:
        case &#039;&quot;&#039;:
          lvalue = null;
          break;
        default:
          break both;
        }

        base = parsePrefixExpressionPart(base, marker, flowContext);
      }

      targets.push(base);

      if (&#039;,&#039; !== token.value)
        break;

      if (!lvalue) {
        return unexpected(token);
      }

      next();
    } while (true);

    if (targets.length === 1 &amp;&amp; lvalue === null) {
      pushLocation(marker);
      return finishNode(ast.callStatement(targets[0]));
    } else if (!lvalue) {
      return unexpected(token);
    }

    expect(&#039;=&#039;);

    var values = [];

    do {
      values.push(parseExpectedExpression(flowContext));
    } while (consume(&#039;,&#039;));

    pushLocation(startMarker);
    return finishNode(ast.assignmentStatement(targets, values));
  }

  function parseIdentifier() {
    markLocation();
    var identifier = token.value;
    if (Identifier !== token.type) raiseUnexpectedToken(&#039;&lt;name&gt;&#039;, token);
    next();
    return finishNode(ast.identifier(identifier));
  }

  function parseFunctionDeclaration(name, isLocal) {
    var flowContext = makeFlowContext();
    flowContext.pushScope();

    var parameters = [];
    expect(&#039;(&#039;);
    if (!consume(&#039;)&#039;)) {
      while (true) {
        if (Identifier === token.type) {
          var parameter = parseIdentifier();
          if (options.scope) scopeIdentifier(parameter);

          parameters.push(parameter);

          if (consume(&#039;,&#039;)) continue;
        }
        else if (VarargLiteral === token.type) {
          flowContext.allowVararg = true;
          parameters.push(parsePrimaryExpression(flowContext));
        } else {
          raiseUnexpectedToken(&#039;&lt;name&gt; or \&#039;...\&#039;&#039;, token);
        }
        expect(&#039;)&#039;);
        break;
      }
    }

    var body = parseBlock(flowContext);
    flowContext.popScope();
    expect(&#039;end&#039;);
    if (options.scope) destroyScope();

    isLocal = isLocal || false;
    return finishNode(ast.functionStatement(name, parameters, isLocal, body));
  }

  function parseFunctionName() {
    var base, name, marker;

    if (trackLocations) marker = createLocationMarker();
    base = parseIdentifier();

    if (options.scope) {
      attachScope(base, scopeHasName(base.name));
      createScope();
    }

    while (consume(&#039;.&#039;)) {
      pushLocation(marker);
      name = parseIdentifier();
      base = finishNode(ast.memberExpression(base, &#039;.&#039;, name));
    }

    if (consume(&#039;:&#039;)) {
      pushLocation(marker);
      name = parseIdentifier();
      base = finishNode(ast.memberExpression(base, &#039;:&#039;, name));
      if (options.scope) scopeIdentifierName(&#039;self&#039;);
    }

    return base;
  }

  function parseTableConstructor(flowContext) {
    var fields = []
      , key, value;

    while (true) {
      markLocation();
      if (Punctuator === token.type &amp;&amp; consume(&#039;[&#039;)) {
        key = parseExpectedExpression(flowContext);
        expect(&#039;]&#039;);
        expect(&#039;=&#039;);
        value = parseExpectedExpression(flowContext);
        fields.push(finishNode(ast.tableKey(key, value)));
      } else if (Identifier === token.type) {
        if (&#039;=&#039; === lookahead.value) {
          key = parseIdentifier();
          next();
          value = parseExpectedExpression(flowContext);
          fields.push(finishNode(ast.tableKeyString(key, value)));
        } else {
          value = parseExpectedExpression(flowContext);
          fields.push(finishNode(ast.tableValue(value)));
        }
      } else {
        if (null == (value = parseExpression(flowContext))) {
          locations.pop();
          break;
        }
        fields.push(finishNode(ast.tableValue(value)));
      }
      if (&#039;,;&#039;.indexOf(token.value) &gt;= 0) {
        next();
        continue;
      }
      break;
    }
    expect(&#039;}&#039;);
    return finishNode(ast.tableConstructorExpression(fields));
  }

  function parseExpression(flowContext) {
    var expression = parseSubExpression(0, flowContext);
    return expression;
  }

  function parseExpectedExpression(flowContext) {
    var expression = parseExpression(flowContext);
    if (null == expression) raiseUnexpectedToken(&#039;&lt;expression&gt;&#039;, token);
    else return expression;
  }

  function binaryPrecedence(operator) {
    var charCode = operator.charCodeAt(0)
      , length = operator.length;

    if (1 === length) {
      switch (charCode) {
        case 94: return 12; // ^
        case 42: case 47: case 37: return 10; // * / %
        case 43: case 45: return 9; // + -
        case 38: return 6; // &amp;
        case 126: return 5; // ~
        case 124: return 4; // |
        case 60: case 62: return 3; // &lt; &gt;
      }
    } else if (2 === length) {
      switch (charCode) {
        case 47: return 10; // //
        case 46: return 8; // ..
        case 60: case 62:
            if(&#039;&lt;&lt;&#039; === operator || &#039;&gt;&gt;&#039; === operator) return 7; // &lt;&lt; &gt;&gt;
            return 3; // &lt;= &gt;=
        case 61: case 126: return 3; // == ~=
        case 111: return 1; // or
      }
    } else if (97 === charCode &amp;&amp; &#039;and&#039; === operator) return 2;
    return 0;
  }

  function parseSubExpression(minPrecedence, flowContext) {
    var operator = token.value
      , expression, marker;

    if (trackLocations) marker = createLocationMarker();
    if (isUnary(token)) {
      markLocation();
      next();
      var argument = parseSubExpression(10, flowContext);
      if (argument == null) raiseUnexpectedToken(&#039;&lt;expression&gt;&#039;, token);
      expression = finishNode(ast.unaryExpression(operator, argument));
    }
    if (null == expression) {
      expression = parsePrimaryExpression(flowContext);
      if (null == expression) {
        expression = parsePrefixExpression(flowContext);
      }
    }
    if (null == expression) return null;

    var precedence;
    while (true) {
      operator = token.value;

      precedence = (Punctuator === token.type || Keyword === token.type) ?
        binaryPrecedence(operator) : 0;

      if (precedence === 0 || precedence &lt;= minPrecedence) break;
      if (&#039;^&#039; === operator || &#039;..&#039; === operator) --precedence;
      next();
      var right = parseSubExpression(precedence, flowContext);
      if (null == right) raiseUnexpectedToken(&#039;&lt;expression&gt;&#039;, token);
      if (trackLocations) locations.push(marker);
      expression = finishNode(ast.binaryExpression(operator, expression, right));

    }
    return expression;
  }

  function parsePrefixExpressionPart(base, marker, flowContext) {
    var expression, identifier;

    if (Punctuator === token.type) {
      switch (token.value) {
        case &#039;[&#039;:
          pushLocation(marker);
          next();
          expression = parseExpectedExpression(flowContext);
          expect(&#039;]&#039;);
          return finishNode(ast.indexExpression(base, expression));
        case &#039;.&#039;:
          pushLocation(marker);
          next();
          identifier = parseIdentifier();
          return finishNode(ast.memberExpression(base, &#039;.&#039;, identifier));
        case &#039;:&#039;:
          pushLocation(marker);
          next();
          identifier = parseIdentifier();
          base = finishNode(ast.memberExpression(base, &#039;:&#039;, identifier));
          pushLocation(marker);
          return parseCallExpression(base, flowContext);
        case &#039;(&#039;: case &#039;{&#039;: // args
          pushLocation(marker);
          return parseCallExpression(base, flowContext);
      }
    } else if (StringLiteral === token.type) {
      pushLocation(marker);
      return parseCallExpression(base, flowContext);
    }

    return null;
  }

  function parsePrefixExpression(flowContext) {
    var base, name, marker;

    if (trackLocations) marker = createLocationMarker();
    if (Identifier === token.type) {
      name = token.value;
      base = parseIdentifier();
      if (options.scope) attachScope(base, scopeHasName(name));
    } else if (consume(&#039;(&#039;)) {
      base = parseExpectedExpression(flowContext);
      expect(&#039;)&#039;);
    } else {
      return null;
    }
    for (;;) {
      var newBase = parsePrefixExpressionPart(base, marker, flowContext);
      if (newBase === null)
        break;
      base = newBase;
    }

    return base;
  }

  function parseCallExpression(base, flowContext) {
    if (Punctuator === token.type) {
      switch (token.value) {
        case &#039;(&#039;:
          if (!features.emptyStatement) {
            if (token.line !== previousToken.line)
              raise(null, errors.ambiguousSyntax, token.value);
          }
          next();
          var expressions = [];
          var expression = parseExpression(flowContext);
          if (null != expression) expressions.push(expression);
          while (consume(&#039;,&#039;)) {
            expression = parseExpectedExpression(flowContext);
            expressions.push(expression);
          }

          expect(&#039;)&#039;);
          return finishNode(ast.callExpression(base, expressions));

        case &#039;{&#039;:
          markLocation();
          next();
          var table = parseTableConstructor(flowContext);
          return finishNode(ast.tableCallExpression(base, table));
      }
    } else if (StringLiteral === token.type) {
      return finishNode(ast.stringCallExpression(base, parsePrimaryExpression(flowContext)));
    }

    raiseUnexpectedToken(&#039;function arguments&#039;, token);
  }

  function parsePrimaryExpression(flowContext) {
    var literals = StringLiteral | NumericLiteral | BooleanLiteral | NilLiteral | VarargLiteral
      , value = token.value
      , type = token.type
      , marker;

    if (trackLocations) marker = createLocationMarker();

    if (type === VarargLiteral &amp;&amp; !flowContext.allowVararg) {
      raise(token, errors.cannotUseVararg, token.value);
    }

    if (type &amp; literals) {
      pushLocation(marker);
      var raw = input.slice(token.range[0], token.range[1]);
      next();
      return finishNode(ast.literal(type, value, raw));
    } else if (Keyword === type &amp;&amp; &#039;function&#039; === value) {
      pushLocation(marker);
      next();
      if (options.scope) createScope();
      return parseFunctionDeclaration(null);
    } else if (consume(&#039;{&#039;)) {
      pushLocation(marker);
      return parseTableConstructor(flowContext);
    }
  }

  exports.parse = parse;

  var versionFeatures = {
    &#039;5.1&#039;: {
    },
    &#039;5.2&#039;: {
      labels: true,
      emptyStatement: true,
      hexEscapes: true,
      skipWhitespaceEscape: true,
      strictEscapes: true,
      relaxedBreak: true
    },
    &#039;5.3&#039;: {
      labels: true,
      emptyStatement: true,
      hexEscapes: true,
      skipWhitespaceEscape: true,
      strictEscapes: true,
      unicodeEscapes: true,
      bitwiseOperators: true,
      integerDivision: true,
      relaxedBreak: true
    },
    &#039;LuaJIT&#039;: {
      labels: true,
      contextualGoto: true,
      hexEscapes: true,
      skipWhitespaceEscape: true,
      strictEscapes: true,
      unicodeEscapes: true,
      imaginaryNumbers: true,
      integerSuffixes: true
    }
  };

  function parse(_input, _options) {
    if (&#039;undefined&#039; === typeof _options &amp;&amp; &#039;object&#039; === typeof _input) {
      _options = _input;
      _input = undefined;
    }
    if (!_options) _options = {};

    input = _input || &#039;&#039;;
    options = assign({}, defaultOptions, _options);
    index = 0;
    line = 1;
    lineStart = 0;
    length = input.length;
    scopes = [[]];
    scopeDepth = 0;
    globals = [];
    locations = [];

    if (!Object.prototype.hasOwnProperty.call(versionFeatures, options.luaVersion)) {
      throw new Error(sprintf(&quot;Lua version &#039;%1&#039; not supported&quot;, options.luaVersion));
    }

    features = assign({}, versionFeatures[options.luaVersion]);
    if (options.extendedIdentifiers !== void 0)
      features.extendedIdentifiers = !!options.extendedIdentifiers;

    if (!Object.prototype.hasOwnProperty.call(encodingModes, options.encodingMode)) {
      throw new Error(sprintf(&quot;Encoding mode &#039;%1&#039; not supported&quot;, options.encodingMode));
    }

    encodingMode = encodingModes[options.encodingMode];

    if (options.comments) comments = [];
    if (!options.wait) return end();
    return exports;
  }
  exports.write = write;

  function write(_input) {
    input += String(_input);
    length = input.length;
    return exports;
  }
  exports.end = end;

  function end(_input) {
    if (&#039;undefined&#039; !== typeof _input) write(_input);
    if (input &amp;&amp; input.substr(0, 2) === &#039;#!&#039;) input = input.replace(/^.*/, function (line) {
      return line.replace(/./g, &#039; &#039;);
    });

    length = input.length;
    trackLocations = options.locations || options.ranges;
    lookahead = lex();

    var chunk = parseChunk();
    if (options.comments) chunk.comments = comments;
    if (options.scope) chunk.globals = globals;
    if (locations.length &gt; 0)
      throw new Error(&#039;Location tracking failed. This is most likely a bug in luaparse&#039;);

    return chunk;
  }

}));

});

define(&quot;ace/mode/lua_worker&quot;,[], function(require, exports, module) {
&quot;use strict&quot;;

var oop = require(&quot;../lib/oop&quot;);
var Mirror = require(&quot;../worker/mirror&quot;).Mirror;
var luaparse = require(&quot;../mode/lua/luaparse&quot;);

var Worker = exports.Worker = function(sender) {
    Mirror.call(this, sender);
    this.setTimeout(500);
};

oop.inherits(Worker, Mirror);

(function() {

    this.onUpdate = function() {
        var value = this.doc.getValue();
        var errors = [];
        try {
            luaparse.parse(value);
        } catch(e) {
            if (e instanceof luaparse.SyntaxError) {
                errors.push({
                    row: e.line - 1,
                    column: e.column,
                    text: e.message,
                    type: &quot;error&quot;
                });
            }
        }
        this.sender.emit(&quot;annotate&quot;, errors);
    };

}).call(Worker.prototype);

});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
