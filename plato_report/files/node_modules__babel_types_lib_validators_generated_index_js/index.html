<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@babel/types/lib/validators/generated/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@babel/types/lib/validators/generated/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">63.85</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">3944</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">108.18</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">47.33</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

Object.defineProperty(exports, &quot;__esModule&quot;, {
  value: true
});
exports.isAccessor = isAccessor;
exports.isAnyTypeAnnotation = isAnyTypeAnnotation;
exports.isArgumentPlaceholder = isArgumentPlaceholder;
exports.isArrayExpression = isArrayExpression;
exports.isArrayPattern = isArrayPattern;
exports.isArrayTypeAnnotation = isArrayTypeAnnotation;
exports.isArrowFunctionExpression = isArrowFunctionExpression;
exports.isAssignmentExpression = isAssignmentExpression;
exports.isAssignmentPattern = isAssignmentPattern;
exports.isAwaitExpression = isAwaitExpression;
exports.isBigIntLiteral = isBigIntLiteral;
exports.isBinary = isBinary;
exports.isBinaryExpression = isBinaryExpression;
exports.isBindExpression = isBindExpression;
exports.isBlock = isBlock;
exports.isBlockParent = isBlockParent;
exports.isBlockStatement = isBlockStatement;
exports.isBooleanLiteral = isBooleanLiteral;
exports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
exports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
exports.isBreakStatement = isBreakStatement;
exports.isCallExpression = isCallExpression;
exports.isCatchClause = isCatchClause;
exports.isClass = isClass;
exports.isClassAccessorProperty = isClassAccessorProperty;
exports.isClassBody = isClassBody;
exports.isClassDeclaration = isClassDeclaration;
exports.isClassExpression = isClassExpression;
exports.isClassImplements = isClassImplements;
exports.isClassMethod = isClassMethod;
exports.isClassPrivateMethod = isClassPrivateMethod;
exports.isClassPrivateProperty = isClassPrivateProperty;
exports.isClassProperty = isClassProperty;
exports.isCompletionStatement = isCompletionStatement;
exports.isConditional = isConditional;
exports.isConditionalExpression = isConditionalExpression;
exports.isContinueStatement = isContinueStatement;
exports.isDebuggerStatement = isDebuggerStatement;
exports.isDecimalLiteral = isDecimalLiteral;
exports.isDeclaration = isDeclaration;
exports.isDeclareClass = isDeclareClass;
exports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
exports.isDeclareExportDeclaration = isDeclareExportDeclaration;
exports.isDeclareFunction = isDeclareFunction;
exports.isDeclareInterface = isDeclareInterface;
exports.isDeclareModule = isDeclareModule;
exports.isDeclareModuleExports = isDeclareModuleExports;
exports.isDeclareOpaqueType = isDeclareOpaqueType;
exports.isDeclareTypeAlias = isDeclareTypeAlias;
exports.isDeclareVariable = isDeclareVariable;
exports.isDeclaredPredicate = isDeclaredPredicate;
exports.isDecorator = isDecorator;
exports.isDirective = isDirective;
exports.isDirectiveLiteral = isDirectiveLiteral;
exports.isDoExpression = isDoExpression;
exports.isDoWhileStatement = isDoWhileStatement;
exports.isEmptyStatement = isEmptyStatement;
exports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
exports.isEnumBody = isEnumBody;
exports.isEnumBooleanBody = isEnumBooleanBody;
exports.isEnumBooleanMember = isEnumBooleanMember;
exports.isEnumDeclaration = isEnumDeclaration;
exports.isEnumDefaultedMember = isEnumDefaultedMember;
exports.isEnumMember = isEnumMember;
exports.isEnumNumberBody = isEnumNumberBody;
exports.isEnumNumberMember = isEnumNumberMember;
exports.isEnumStringBody = isEnumStringBody;
exports.isEnumStringMember = isEnumStringMember;
exports.isEnumSymbolBody = isEnumSymbolBody;
exports.isExistsTypeAnnotation = isExistsTypeAnnotation;
exports.isExportAllDeclaration = isExportAllDeclaration;
exports.isExportDeclaration = isExportDeclaration;
exports.isExportDefaultDeclaration = isExportDefaultDeclaration;
exports.isExportDefaultSpecifier = isExportDefaultSpecifier;
exports.isExportNamedDeclaration = isExportNamedDeclaration;
exports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
exports.isExportSpecifier = isExportSpecifier;
exports.isExpression = isExpression;
exports.isExpressionStatement = isExpressionStatement;
exports.isExpressionWrapper = isExpressionWrapper;
exports.isFile = isFile;
exports.isFlow = isFlow;
exports.isFlowBaseAnnotation = isFlowBaseAnnotation;
exports.isFlowDeclaration = isFlowDeclaration;
exports.isFlowPredicate = isFlowPredicate;
exports.isFlowType = isFlowType;
exports.isFor = isFor;
exports.isForInStatement = isForInStatement;
exports.isForOfStatement = isForOfStatement;
exports.isForStatement = isForStatement;
exports.isForXStatement = isForXStatement;
exports.isFunction = isFunction;
exports.isFunctionDeclaration = isFunctionDeclaration;
exports.isFunctionExpression = isFunctionExpression;
exports.isFunctionParent = isFunctionParent;
exports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
exports.isFunctionTypeParam = isFunctionTypeParam;
exports.isGenericTypeAnnotation = isGenericTypeAnnotation;
exports.isIdentifier = isIdentifier;
exports.isIfStatement = isIfStatement;
exports.isImmutable = isImmutable;
exports.isImport = isImport;
exports.isImportAttribute = isImportAttribute;
exports.isImportDeclaration = isImportDeclaration;
exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
exports.isImportOrExportDeclaration = isImportOrExportDeclaration;
exports.isImportSpecifier = isImportSpecifier;
exports.isIndexedAccessType = isIndexedAccessType;
exports.isInferredPredicate = isInferredPredicate;
exports.isInterfaceDeclaration = isInterfaceDeclaration;
exports.isInterfaceExtends = isInterfaceExtends;
exports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
exports.isInterpreterDirective = isInterpreterDirective;
exports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
exports.isJSX = isJSX;
exports.isJSXAttribute = isJSXAttribute;
exports.isJSXClosingElement = isJSXClosingElement;
exports.isJSXClosingFragment = isJSXClosingFragment;
exports.isJSXElement = isJSXElement;
exports.isJSXEmptyExpression = isJSXEmptyExpression;
exports.isJSXExpressionContainer = isJSXExpressionContainer;
exports.isJSXFragment = isJSXFragment;
exports.isJSXIdentifier = isJSXIdentifier;
exports.isJSXMemberExpression = isJSXMemberExpression;
exports.isJSXNamespacedName = isJSXNamespacedName;
exports.isJSXOpeningElement = isJSXOpeningElement;
exports.isJSXOpeningFragment = isJSXOpeningFragment;
exports.isJSXSpreadAttribute = isJSXSpreadAttribute;
exports.isJSXSpreadChild = isJSXSpreadChild;
exports.isJSXText = isJSXText;
exports.isLVal = isLVal;
exports.isLabeledStatement = isLabeledStatement;
exports.isLiteral = isLiteral;
exports.isLogicalExpression = isLogicalExpression;
exports.isLoop = isLoop;
exports.isMemberExpression = isMemberExpression;
exports.isMetaProperty = isMetaProperty;
exports.isMethod = isMethod;
exports.isMiscellaneous = isMiscellaneous;
exports.isMixedTypeAnnotation = isMixedTypeAnnotation;
exports.isModuleDeclaration = isModuleDeclaration;
exports.isModuleExpression = isModuleExpression;
exports.isModuleSpecifier = isModuleSpecifier;
exports.isNewExpression = isNewExpression;
exports.isNoop = isNoop;
exports.isNullLiteral = isNullLiteral;
exports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
exports.isNullableTypeAnnotation = isNullableTypeAnnotation;
exports.isNumberLiteral = isNumberLiteral;
exports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
exports.isNumberTypeAnnotation = isNumberTypeAnnotation;
exports.isNumericLiteral = isNumericLiteral;
exports.isObjectExpression = isObjectExpression;
exports.isObjectMember = isObjectMember;
exports.isObjectMethod = isObjectMethod;
exports.isObjectPattern = isObjectPattern;
exports.isObjectProperty = isObjectProperty;
exports.isObjectTypeAnnotation = isObjectTypeAnnotation;
exports.isObjectTypeCallProperty = isObjectTypeCallProperty;
exports.isObjectTypeIndexer = isObjectTypeIndexer;
exports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
exports.isObjectTypeProperty = isObjectTypeProperty;
exports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
exports.isOpaqueType = isOpaqueType;
exports.isOptionalCallExpression = isOptionalCallExpression;
exports.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
exports.isOptionalMemberExpression = isOptionalMemberExpression;
exports.isParenthesizedExpression = isParenthesizedExpression;
exports.isPattern = isPattern;
exports.isPatternLike = isPatternLike;
exports.isPipelineBareFunction = isPipelineBareFunction;
exports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
exports.isPipelineTopicExpression = isPipelineTopicExpression;
exports.isPlaceholder = isPlaceholder;
exports.isPrivate = isPrivate;
exports.isPrivateName = isPrivateName;
exports.isProgram = isProgram;
exports.isProperty = isProperty;
exports.isPureish = isPureish;
exports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
exports.isRecordExpression = isRecordExpression;
exports.isRegExpLiteral = isRegExpLiteral;
exports.isRegexLiteral = isRegexLiteral;
exports.isRestElement = isRestElement;
exports.isRestProperty = isRestProperty;
exports.isReturnStatement = isReturnStatement;
exports.isScopable = isScopable;
exports.isSequenceExpression = isSequenceExpression;
exports.isSpreadElement = isSpreadElement;
exports.isSpreadProperty = isSpreadProperty;
exports.isStandardized = isStandardized;
exports.isStatement = isStatement;
exports.isStaticBlock = isStaticBlock;
exports.isStringLiteral = isStringLiteral;
exports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
exports.isStringTypeAnnotation = isStringTypeAnnotation;
exports.isSuper = isSuper;
exports.isSwitchCase = isSwitchCase;
exports.isSwitchStatement = isSwitchStatement;
exports.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
exports.isTSAnyKeyword = isTSAnyKeyword;
exports.isTSArrayType = isTSArrayType;
exports.isTSAsExpression = isTSAsExpression;
exports.isTSBaseType = isTSBaseType;
exports.isTSBigIntKeyword = isTSBigIntKeyword;
exports.isTSBooleanKeyword = isTSBooleanKeyword;
exports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
exports.isTSConditionalType = isTSConditionalType;
exports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
exports.isTSConstructorType = isTSConstructorType;
exports.isTSDeclareFunction = isTSDeclareFunction;
exports.isTSDeclareMethod = isTSDeclareMethod;
exports.isTSEntityName = isTSEntityName;
exports.isTSEnumDeclaration = isTSEnumDeclaration;
exports.isTSEnumMember = isTSEnumMember;
exports.isTSExportAssignment = isTSExportAssignment;
exports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
exports.isTSExternalModuleReference = isTSExternalModuleReference;
exports.isTSFunctionType = isTSFunctionType;
exports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
exports.isTSImportType = isTSImportType;
exports.isTSIndexSignature = isTSIndexSignature;
exports.isTSIndexedAccessType = isTSIndexedAccessType;
exports.isTSInferType = isTSInferType;
exports.isTSInstantiationExpression = isTSInstantiationExpression;
exports.isTSInterfaceBody = isTSInterfaceBody;
exports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
exports.isTSIntersectionType = isTSIntersectionType;
exports.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
exports.isTSLiteralType = isTSLiteralType;
exports.isTSMappedType = isTSMappedType;
exports.isTSMethodSignature = isTSMethodSignature;
exports.isTSModuleBlock = isTSModuleBlock;
exports.isTSModuleDeclaration = isTSModuleDeclaration;
exports.isTSNamedTupleMember = isTSNamedTupleMember;
exports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
exports.isTSNeverKeyword = isTSNeverKeyword;
exports.isTSNonNullExpression = isTSNonNullExpression;
exports.isTSNullKeyword = isTSNullKeyword;
exports.isTSNumberKeyword = isTSNumberKeyword;
exports.isTSObjectKeyword = isTSObjectKeyword;
exports.isTSOptionalType = isTSOptionalType;
exports.isTSParameterProperty = isTSParameterProperty;
exports.isTSParenthesizedType = isTSParenthesizedType;
exports.isTSPropertySignature = isTSPropertySignature;
exports.isTSQualifiedName = isTSQualifiedName;
exports.isTSRestType = isTSRestType;
exports.isTSSatisfiesExpression = isTSSatisfiesExpression;
exports.isTSStringKeyword = isTSStringKeyword;
exports.isTSSymbolKeyword = isTSSymbolKeyword;
exports.isTSThisType = isTSThisType;
exports.isTSTupleType = isTSTupleType;
exports.isTSType = isTSType;
exports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
exports.isTSTypeAnnotation = isTSTypeAnnotation;
exports.isTSTypeAssertion = isTSTypeAssertion;
exports.isTSTypeElement = isTSTypeElement;
exports.isTSTypeLiteral = isTSTypeLiteral;
exports.isTSTypeOperator = isTSTypeOperator;
exports.isTSTypeParameter = isTSTypeParameter;
exports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
exports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
exports.isTSTypePredicate = isTSTypePredicate;
exports.isTSTypeQuery = isTSTypeQuery;
exports.isTSTypeReference = isTSTypeReference;
exports.isTSUndefinedKeyword = isTSUndefinedKeyword;
exports.isTSUnionType = isTSUnionType;
exports.isTSUnknownKeyword = isTSUnknownKeyword;
exports.isTSVoidKeyword = isTSVoidKeyword;
exports.isTaggedTemplateExpression = isTaggedTemplateExpression;
exports.isTemplateElement = isTemplateElement;
exports.isTemplateLiteral = isTemplateLiteral;
exports.isTerminatorless = isTerminatorless;
exports.isThisExpression = isThisExpression;
exports.isThisTypeAnnotation = isThisTypeAnnotation;
exports.isThrowStatement = isThrowStatement;
exports.isTopicReference = isTopicReference;
exports.isTryStatement = isTryStatement;
exports.isTupleExpression = isTupleExpression;
exports.isTupleTypeAnnotation = isTupleTypeAnnotation;
exports.isTypeAlias = isTypeAlias;
exports.isTypeAnnotation = isTypeAnnotation;
exports.isTypeCastExpression = isTypeCastExpression;
exports.isTypeParameter = isTypeParameter;
exports.isTypeParameterDeclaration = isTypeParameterDeclaration;
exports.isTypeParameterInstantiation = isTypeParameterInstantiation;
exports.isTypeScript = isTypeScript;
exports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
exports.isUnaryExpression = isUnaryExpression;
exports.isUnaryLike = isUnaryLike;
exports.isUnionTypeAnnotation = isUnionTypeAnnotation;
exports.isUpdateExpression = isUpdateExpression;
exports.isUserWhitespacable = isUserWhitespacable;
exports.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
exports.isVariableDeclaration = isVariableDeclaration;
exports.isVariableDeclarator = isVariableDeclarator;
exports.isVariance = isVariance;
exports.isVoidTypeAnnotation = isVoidTypeAnnotation;
exports.isWhile = isWhile;
exports.isWhileStatement = isWhileStatement;
exports.isWithStatement = isWithStatement;
exports.isYieldExpression = isYieldExpression;
var _shallowEqual = require(&quot;../../utils/shallowEqual&quot;);
var _deprecationWarning = require(&quot;../../utils/deprecationWarning&quot;);
function isArrayExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ArrayExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isAssignmentExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;AssignmentExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isBinaryExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;BinaryExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isInterpreterDirective(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;InterpreterDirective&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDirective(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;Directive&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDirectiveLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;DirectiveLiteral&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isBlockStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;BlockStatement&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isBreakStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;BreakStatement&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isCallExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;CallExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isCatchClause(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;CatchClause&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isConditionalExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ConditionalExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isContinueStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ContinueStatement&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDebuggerStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;DebuggerStatement&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDoWhileStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;DoWhileStatement&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isEmptyStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;EmptyStatement&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isExpressionStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ExpressionStatement&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isFile(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;File&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isForInStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ForInStatement&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isForStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ForStatement&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isFunctionDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;FunctionDeclaration&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isFunctionExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;FunctionExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isIdentifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;Identifier&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isIfStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;IfStatement&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isLabeledStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;LabeledStatement&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isStringLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;StringLiteral&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isNumericLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;NumericLiteral&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isNullLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;NullLiteral&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isBooleanLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;BooleanLiteral&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isRegExpLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;RegExpLiteral&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isLogicalExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;LogicalExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isMemberExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;MemberExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isNewExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;NewExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isProgram(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;Program&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isObjectExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ObjectExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isObjectMethod(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ObjectMethod&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isObjectProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ObjectProperty&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isRestElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;RestElement&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isReturnStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ReturnStatement&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isSequenceExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;SequenceExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isParenthesizedExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ParenthesizedExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isSwitchCase(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;SwitchCase&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isSwitchStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;SwitchStatement&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isThisExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ThisExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isThrowStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ThrowStatement&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTryStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TryStatement&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isUnaryExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;UnaryExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isUpdateExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;UpdateExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isVariableDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;VariableDeclaration&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isVariableDeclarator(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;VariableDeclarator&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isWhileStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;WhileStatement&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isWithStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;WithStatement&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isAssignmentPattern(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;AssignmentPattern&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isArrayPattern(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ArrayPattern&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isArrowFunctionExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ArrowFunctionExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isClassBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ClassBody&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isClassExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ClassExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isClassDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ClassDeclaration&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isExportAllDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ExportAllDeclaration&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isExportDefaultDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ExportDefaultDeclaration&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isExportNamedDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ExportNamedDeclaration&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isExportSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ExportSpecifier&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isForOfStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ForOfStatement&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isImportDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ImportDeclaration&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isImportDefaultSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ImportDefaultSpecifier&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isImportNamespaceSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ImportNamespaceSpecifier&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isImportSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ImportSpecifier&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isMetaProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;MetaProperty&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isClassMethod(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ClassMethod&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isObjectPattern(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ObjectPattern&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isSpreadElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;SpreadElement&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isSuper(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;Super&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTaggedTemplateExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TaggedTemplateExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTemplateElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TemplateElement&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTemplateLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TemplateLiteral&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isYieldExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;YieldExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isAwaitExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;AwaitExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isImport(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;Import&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isBigIntLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;BigIntLiteral&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isExportNamespaceSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ExportNamespaceSpecifier&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isOptionalMemberExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;OptionalMemberExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isOptionalCallExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;OptionalCallExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isClassProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ClassProperty&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isClassAccessorProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ClassAccessorProperty&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isClassPrivateProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ClassPrivateProperty&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isClassPrivateMethod(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ClassPrivateMethod&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isPrivateName(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;PrivateName&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isStaticBlock(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;StaticBlock&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isAnyTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;AnyTypeAnnotation&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isArrayTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ArrayTypeAnnotation&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isBooleanTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;BooleanTypeAnnotation&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isBooleanLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;BooleanLiteralTypeAnnotation&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isNullLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;NullLiteralTypeAnnotation&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isClassImplements(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ClassImplements&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDeclareClass(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;DeclareClass&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDeclareFunction(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;DeclareFunction&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDeclareInterface(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;DeclareInterface&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDeclareModule(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;DeclareModule&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDeclareModuleExports(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;DeclareModuleExports&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDeclareTypeAlias(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;DeclareTypeAlias&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDeclareOpaqueType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;DeclareOpaqueType&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDeclareVariable(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;DeclareVariable&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDeclareExportDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;DeclareExportDeclaration&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDeclareExportAllDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;DeclareExportAllDeclaration&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDeclaredPredicate(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;DeclaredPredicate&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isExistsTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ExistsTypeAnnotation&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isFunctionTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;FunctionTypeAnnotation&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isFunctionTypeParam(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;FunctionTypeParam&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isGenericTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;GenericTypeAnnotation&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isInferredPredicate(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;InferredPredicate&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isInterfaceExtends(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;InterfaceExtends&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isInterfaceDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;InterfaceDeclaration&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isInterfaceTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;InterfaceTypeAnnotation&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isIntersectionTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;IntersectionTypeAnnotation&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isMixedTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;MixedTypeAnnotation&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isEmptyTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;EmptyTypeAnnotation&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isNullableTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;NullableTypeAnnotation&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isNumberLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;NumberLiteralTypeAnnotation&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isNumberTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;NumberTypeAnnotation&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isObjectTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ObjectTypeAnnotation&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isObjectTypeInternalSlot(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ObjectTypeInternalSlot&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isObjectTypeCallProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ObjectTypeCallProperty&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isObjectTypeIndexer(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ObjectTypeIndexer&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isObjectTypeProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ObjectTypeProperty&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isObjectTypeSpreadProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ObjectTypeSpreadProperty&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isOpaqueType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;OpaqueType&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isQualifiedTypeIdentifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;QualifiedTypeIdentifier&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isStringLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;StringLiteralTypeAnnotation&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isStringTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;StringTypeAnnotation&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isSymbolTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;SymbolTypeAnnotation&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isThisTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ThisTypeAnnotation&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTupleTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TupleTypeAnnotation&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTypeofTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TypeofTypeAnnotation&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTypeAlias(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TypeAlias&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TypeAnnotation&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTypeCastExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TypeCastExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTypeParameter(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TypeParameter&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTypeParameterDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TypeParameterDeclaration&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTypeParameterInstantiation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TypeParameterInstantiation&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isUnionTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;UnionTypeAnnotation&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isVariance(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;Variance&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isVoidTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;VoidTypeAnnotation&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isEnumDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;EnumDeclaration&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isEnumBooleanBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;EnumBooleanBody&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isEnumNumberBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;EnumNumberBody&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isEnumStringBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;EnumStringBody&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isEnumSymbolBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;EnumSymbolBody&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isEnumBooleanMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;EnumBooleanMember&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isEnumNumberMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;EnumNumberMember&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isEnumStringMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;EnumStringMember&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isEnumDefaultedMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;EnumDefaultedMember&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isIndexedAccessType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;IndexedAccessType&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isOptionalIndexedAccessType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;OptionalIndexedAccessType&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSXAttribute(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;JSXAttribute&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSXClosingElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;JSXClosingElement&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSXElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;JSXElement&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSXEmptyExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;JSXEmptyExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSXExpressionContainer(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;JSXExpressionContainer&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSXSpreadChild(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;JSXSpreadChild&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSXIdentifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;JSXIdentifier&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSXMemberExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;JSXMemberExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSXNamespacedName(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;JSXNamespacedName&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSXOpeningElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;JSXOpeningElement&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSXSpreadAttribute(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;JSXSpreadAttribute&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSXText(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;JSXText&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSXFragment(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;JSXFragment&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSXOpeningFragment(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;JSXOpeningFragment&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSXClosingFragment(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;JSXClosingFragment&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isNoop(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;Noop&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isPlaceholder(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;Placeholder&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isV8IntrinsicIdentifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;V8IntrinsicIdentifier&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isArgumentPlaceholder(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ArgumentPlaceholder&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isBindExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;BindExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isImportAttribute(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ImportAttribute&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDecorator(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;Decorator&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDoExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;DoExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isExportDefaultSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ExportDefaultSpecifier&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isRecordExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;RecordExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTupleExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TupleExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDecimalLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;DecimalLiteral&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isModuleExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;ModuleExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTopicReference(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TopicReference&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isPipelineTopicExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;PipelineTopicExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isPipelineBareFunction(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;PipelineBareFunction&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isPipelinePrimaryTopicReference(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;PipelinePrimaryTopicReference&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSParameterProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSParameterProperty&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSDeclareFunction(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSDeclareFunction&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSDeclareMethod(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSDeclareMethod&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSQualifiedName(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSQualifiedName&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSCallSignatureDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSCallSignatureDeclaration&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSConstructSignatureDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSConstructSignatureDeclaration&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSPropertySignature(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSPropertySignature&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSMethodSignature(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSMethodSignature&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSIndexSignature(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSIndexSignature&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSAnyKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSAnyKeyword&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSBooleanKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSBooleanKeyword&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSBigIntKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSBigIntKeyword&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSIntrinsicKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSIntrinsicKeyword&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSNeverKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSNeverKeyword&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSNullKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSNullKeyword&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSNumberKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSNumberKeyword&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSObjectKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSObjectKeyword&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSStringKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSStringKeyword&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSSymbolKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSSymbolKeyword&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSUndefinedKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSUndefinedKeyword&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSUnknownKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSUnknownKeyword&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSVoidKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSVoidKeyword&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSThisType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSThisType&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSFunctionType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSFunctionType&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSConstructorType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSConstructorType&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSTypeReference(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSTypeReference&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSTypePredicate(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSTypePredicate&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSTypeQuery(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSTypeQuery&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSTypeLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSTypeLiteral&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSArrayType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSArrayType&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSTupleType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSTupleType&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSOptionalType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSOptionalType&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSRestType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSRestType&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSNamedTupleMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSNamedTupleMember&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSUnionType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSUnionType&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSIntersectionType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSIntersectionType&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSConditionalType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSConditionalType&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSInferType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSInferType&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSParenthesizedType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSParenthesizedType&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSTypeOperator(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSTypeOperator&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSIndexedAccessType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSIndexedAccessType&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSMappedType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSMappedType&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSLiteralType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSLiteralType&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSExpressionWithTypeArguments(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSExpressionWithTypeArguments&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSInterfaceDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSInterfaceDeclaration&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSInterfaceBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSInterfaceBody&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSTypeAliasDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSTypeAliasDeclaration&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSInstantiationExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSInstantiationExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSAsExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSAsExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSSatisfiesExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSSatisfiesExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSTypeAssertion(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSTypeAssertion&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSEnumDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSEnumDeclaration&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSEnumMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSEnumMember&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSModuleDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSModuleDeclaration&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSModuleBlock(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSModuleBlock&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSImportType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSImportType&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSImportEqualsDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSImportEqualsDeclaration&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSExternalModuleReference(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSExternalModuleReference&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSNonNullExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSNonNullExpression&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSExportAssignment(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSExportAssignment&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSNamespaceExportDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSNamespaceExportDeclaration&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSTypeAnnotation&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSTypeParameterInstantiation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSTypeParameterInstantiation&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSTypeParameterDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSTypeParameterDeclaration&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSTypeParameter(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;TSTypeParameter&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isStandardized(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;ArrayExpression&quot; === nodeType || &quot;AssignmentExpression&quot; === nodeType || &quot;BinaryExpression&quot; === nodeType || &quot;InterpreterDirective&quot; === nodeType || &quot;Directive&quot; === nodeType || &quot;DirectiveLiteral&quot; === nodeType || &quot;BlockStatement&quot; === nodeType || &quot;BreakStatement&quot; === nodeType || &quot;CallExpression&quot; === nodeType || &quot;CatchClause&quot; === nodeType || &quot;ConditionalExpression&quot; === nodeType || &quot;ContinueStatement&quot; === nodeType || &quot;DebuggerStatement&quot; === nodeType || &quot;DoWhileStatement&quot; === nodeType || &quot;EmptyStatement&quot; === nodeType || &quot;ExpressionStatement&quot; === nodeType || &quot;File&quot; === nodeType || &quot;ForInStatement&quot; === nodeType || &quot;ForStatement&quot; === nodeType || &quot;FunctionDeclaration&quot; === nodeType || &quot;FunctionExpression&quot; === nodeType || &quot;Identifier&quot; === nodeType || &quot;IfStatement&quot; === nodeType || &quot;LabeledStatement&quot; === nodeType || &quot;StringLiteral&quot; === nodeType || &quot;NumericLiteral&quot; === nodeType || &quot;NullLiteral&quot; === nodeType || &quot;BooleanLiteral&quot; === nodeType || &quot;RegExpLiteral&quot; === nodeType || &quot;LogicalExpression&quot; === nodeType || &quot;MemberExpression&quot; === nodeType || &quot;NewExpression&quot; === nodeType || &quot;Program&quot; === nodeType || &quot;ObjectExpression&quot; === nodeType || &quot;ObjectMethod&quot; === nodeType || &quot;ObjectProperty&quot; === nodeType || &quot;RestElement&quot; === nodeType || &quot;ReturnStatement&quot; === nodeType || &quot;SequenceExpression&quot; === nodeType || &quot;ParenthesizedExpression&quot; === nodeType || &quot;SwitchCase&quot; === nodeType || &quot;SwitchStatement&quot; === nodeType || &quot;ThisExpression&quot; === nodeType || &quot;ThrowStatement&quot; === nodeType || &quot;TryStatement&quot; === nodeType || &quot;UnaryExpression&quot; === nodeType || &quot;UpdateExpression&quot; === nodeType || &quot;VariableDeclaration&quot; === nodeType || &quot;VariableDeclarator&quot; === nodeType || &quot;WhileStatement&quot; === nodeType || &quot;WithStatement&quot; === nodeType || &quot;AssignmentPattern&quot; === nodeType || &quot;ArrayPattern&quot; === nodeType || &quot;ArrowFunctionExpression&quot; === nodeType || &quot;ClassBody&quot; === nodeType || &quot;ClassExpression&quot; === nodeType || &quot;ClassDeclaration&quot; === nodeType || &quot;ExportAllDeclaration&quot; === nodeType || &quot;ExportDefaultDeclaration&quot; === nodeType || &quot;ExportNamedDeclaration&quot; === nodeType || &quot;ExportSpecifier&quot; === nodeType || &quot;ForOfStatement&quot; === nodeType || &quot;ImportDeclaration&quot; === nodeType || &quot;ImportDefaultSpecifier&quot; === nodeType || &quot;ImportNamespaceSpecifier&quot; === nodeType || &quot;ImportSpecifier&quot; === nodeType || &quot;MetaProperty&quot; === nodeType || &quot;ClassMethod&quot; === nodeType || &quot;ObjectPattern&quot; === nodeType || &quot;SpreadElement&quot; === nodeType || &quot;Super&quot; === nodeType || &quot;TaggedTemplateExpression&quot; === nodeType || &quot;TemplateElement&quot; === nodeType || &quot;TemplateLiteral&quot; === nodeType || &quot;YieldExpression&quot; === nodeType || &quot;AwaitExpression&quot; === nodeType || &quot;Import&quot; === nodeType || &quot;BigIntLiteral&quot; === nodeType || &quot;ExportNamespaceSpecifier&quot; === nodeType || &quot;OptionalMemberExpression&quot; === nodeType || &quot;OptionalCallExpression&quot; === nodeType || &quot;ClassProperty&quot; === nodeType || &quot;ClassAccessorProperty&quot; === nodeType || &quot;ClassPrivateProperty&quot; === nodeType || &quot;ClassPrivateMethod&quot; === nodeType || &quot;PrivateName&quot; === nodeType || &quot;StaticBlock&quot; === nodeType || nodeType === &quot;Placeholder&quot; &amp;&amp; (&quot;Identifier&quot; === node.expectedNode || &quot;StringLiteral&quot; === node.expectedNode || &quot;BlockStatement&quot; === node.expectedNode || &quot;ClassBody&quot; === node.expectedNode)) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;ArrayExpression&quot; === nodeType || &quot;AssignmentExpression&quot; === nodeType || &quot;BinaryExpression&quot; === nodeType || &quot;CallExpression&quot; === nodeType || &quot;ConditionalExpression&quot; === nodeType || &quot;FunctionExpression&quot; === nodeType || &quot;Identifier&quot; === nodeType || &quot;StringLiteral&quot; === nodeType || &quot;NumericLiteral&quot; === nodeType || &quot;NullLiteral&quot; === nodeType || &quot;BooleanLiteral&quot; === nodeType || &quot;RegExpLiteral&quot; === nodeType || &quot;LogicalExpression&quot; === nodeType || &quot;MemberExpression&quot; === nodeType || &quot;NewExpression&quot; === nodeType || &quot;ObjectExpression&quot; === nodeType || &quot;SequenceExpression&quot; === nodeType || &quot;ParenthesizedExpression&quot; === nodeType || &quot;ThisExpression&quot; === nodeType || &quot;UnaryExpression&quot; === nodeType || &quot;UpdateExpression&quot; === nodeType || &quot;ArrowFunctionExpression&quot; === nodeType || &quot;ClassExpression&quot; === nodeType || &quot;MetaProperty&quot; === nodeType || &quot;Super&quot; === nodeType || &quot;TaggedTemplateExpression&quot; === nodeType || &quot;TemplateLiteral&quot; === nodeType || &quot;YieldExpression&quot; === nodeType || &quot;AwaitExpression&quot; === nodeType || &quot;Import&quot; === nodeType || &quot;BigIntLiteral&quot; === nodeType || &quot;OptionalMemberExpression&quot; === nodeType || &quot;OptionalCallExpression&quot; === nodeType || &quot;TypeCastExpression&quot; === nodeType || &quot;JSXElement&quot; === nodeType || &quot;JSXFragment&quot; === nodeType || &quot;BindExpression&quot; === nodeType || &quot;DoExpression&quot; === nodeType || &quot;RecordExpression&quot; === nodeType || &quot;TupleExpression&quot; === nodeType || &quot;DecimalLiteral&quot; === nodeType || &quot;ModuleExpression&quot; === nodeType || &quot;TopicReference&quot; === nodeType || &quot;PipelineTopicExpression&quot; === nodeType || &quot;PipelineBareFunction&quot; === nodeType || &quot;PipelinePrimaryTopicReference&quot; === nodeType || &quot;TSInstantiationExpression&quot; === nodeType || &quot;TSAsExpression&quot; === nodeType || &quot;TSSatisfiesExpression&quot; === nodeType || &quot;TSTypeAssertion&quot; === nodeType || &quot;TSNonNullExpression&quot; === nodeType || nodeType === &quot;Placeholder&quot; &amp;&amp; (&quot;Expression&quot; === node.expectedNode || &quot;Identifier&quot; === node.expectedNode || &quot;StringLiteral&quot; === node.expectedNode)) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isBinary(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;BinaryExpression&quot; === nodeType || &quot;LogicalExpression&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isScopable(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;BlockStatement&quot; === nodeType || &quot;CatchClause&quot; === nodeType || &quot;DoWhileStatement&quot; === nodeType || &quot;ForInStatement&quot; === nodeType || &quot;ForStatement&quot; === nodeType || &quot;FunctionDeclaration&quot; === nodeType || &quot;FunctionExpression&quot; === nodeType || &quot;Program&quot; === nodeType || &quot;ObjectMethod&quot; === nodeType || &quot;SwitchStatement&quot; === nodeType || &quot;WhileStatement&quot; === nodeType || &quot;ArrowFunctionExpression&quot; === nodeType || &quot;ClassExpression&quot; === nodeType || &quot;ClassDeclaration&quot; === nodeType || &quot;ForOfStatement&quot; === nodeType || &quot;ClassMethod&quot; === nodeType || &quot;ClassPrivateMethod&quot; === nodeType || &quot;StaticBlock&quot; === nodeType || &quot;TSModuleBlock&quot; === nodeType || nodeType === &quot;Placeholder&quot; &amp;&amp; &quot;BlockStatement&quot; === node.expectedNode) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isBlockParent(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;BlockStatement&quot; === nodeType || &quot;CatchClause&quot; === nodeType || &quot;DoWhileStatement&quot; === nodeType || &quot;ForInStatement&quot; === nodeType || &quot;ForStatement&quot; === nodeType || &quot;FunctionDeclaration&quot; === nodeType || &quot;FunctionExpression&quot; === nodeType || &quot;Program&quot; === nodeType || &quot;ObjectMethod&quot; === nodeType || &quot;SwitchStatement&quot; === nodeType || &quot;WhileStatement&quot; === nodeType || &quot;ArrowFunctionExpression&quot; === nodeType || &quot;ForOfStatement&quot; === nodeType || &quot;ClassMethod&quot; === nodeType || &quot;ClassPrivateMethod&quot; === nodeType || &quot;StaticBlock&quot; === nodeType || &quot;TSModuleBlock&quot; === nodeType || nodeType === &quot;Placeholder&quot; &amp;&amp; &quot;BlockStatement&quot; === node.expectedNode) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isBlock(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;BlockStatement&quot; === nodeType || &quot;Program&quot; === nodeType || &quot;TSModuleBlock&quot; === nodeType || nodeType === &quot;Placeholder&quot; &amp;&amp; &quot;BlockStatement&quot; === node.expectedNode) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;BlockStatement&quot; === nodeType || &quot;BreakStatement&quot; === nodeType || &quot;ContinueStatement&quot; === nodeType || &quot;DebuggerStatement&quot; === nodeType || &quot;DoWhileStatement&quot; === nodeType || &quot;EmptyStatement&quot; === nodeType || &quot;ExpressionStatement&quot; === nodeType || &quot;ForInStatement&quot; === nodeType || &quot;ForStatement&quot; === nodeType || &quot;FunctionDeclaration&quot; === nodeType || &quot;IfStatement&quot; === nodeType || &quot;LabeledStatement&quot; === nodeType || &quot;ReturnStatement&quot; === nodeType || &quot;SwitchStatement&quot; === nodeType || &quot;ThrowStatement&quot; === nodeType || &quot;TryStatement&quot; === nodeType || &quot;VariableDeclaration&quot; === nodeType || &quot;WhileStatement&quot; === nodeType || &quot;WithStatement&quot; === nodeType || &quot;ClassDeclaration&quot; === nodeType || &quot;ExportAllDeclaration&quot; === nodeType || &quot;ExportDefaultDeclaration&quot; === nodeType || &quot;ExportNamedDeclaration&quot; === nodeType || &quot;ForOfStatement&quot; === nodeType || &quot;ImportDeclaration&quot; === nodeType || &quot;DeclareClass&quot; === nodeType || &quot;DeclareFunction&quot; === nodeType || &quot;DeclareInterface&quot; === nodeType || &quot;DeclareModule&quot; === nodeType || &quot;DeclareModuleExports&quot; === nodeType || &quot;DeclareTypeAlias&quot; === nodeType || &quot;DeclareOpaqueType&quot; === nodeType || &quot;DeclareVariable&quot; === nodeType || &quot;DeclareExportDeclaration&quot; === nodeType || &quot;DeclareExportAllDeclaration&quot; === nodeType || &quot;InterfaceDeclaration&quot; === nodeType || &quot;OpaqueType&quot; === nodeType || &quot;TypeAlias&quot; === nodeType || &quot;EnumDeclaration&quot; === nodeType || &quot;TSDeclareFunction&quot; === nodeType || &quot;TSInterfaceDeclaration&quot; === nodeType || &quot;TSTypeAliasDeclaration&quot; === nodeType || &quot;TSEnumDeclaration&quot; === nodeType || &quot;TSModuleDeclaration&quot; === nodeType || &quot;TSImportEqualsDeclaration&quot; === nodeType || &quot;TSExportAssignment&quot; === nodeType || &quot;TSNamespaceExportDeclaration&quot; === nodeType || nodeType === &quot;Placeholder&quot; &amp;&amp; (&quot;Statement&quot; === node.expectedNode || &quot;Declaration&quot; === node.expectedNode || &quot;BlockStatement&quot; === node.expectedNode)) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTerminatorless(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;BreakStatement&quot; === nodeType || &quot;ContinueStatement&quot; === nodeType || &quot;ReturnStatement&quot; === nodeType || &quot;ThrowStatement&quot; === nodeType || &quot;YieldExpression&quot; === nodeType || &quot;AwaitExpression&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isCompletionStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;BreakStatement&quot; === nodeType || &quot;ContinueStatement&quot; === nodeType || &quot;ReturnStatement&quot; === nodeType || &quot;ThrowStatement&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isConditional(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;ConditionalExpression&quot; === nodeType || &quot;IfStatement&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isLoop(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;DoWhileStatement&quot; === nodeType || &quot;ForInStatement&quot; === nodeType || &quot;ForStatement&quot; === nodeType || &quot;WhileStatement&quot; === nodeType || &quot;ForOfStatement&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isWhile(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;DoWhileStatement&quot; === nodeType || &quot;WhileStatement&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isExpressionWrapper(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;ExpressionStatement&quot; === nodeType || &quot;ParenthesizedExpression&quot; === nodeType || &quot;TypeCastExpression&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isFor(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;ForInStatement&quot; === nodeType || &quot;ForStatement&quot; === nodeType || &quot;ForOfStatement&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isForXStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;ForInStatement&quot; === nodeType || &quot;ForOfStatement&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isFunction(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;FunctionDeclaration&quot; === nodeType || &quot;FunctionExpression&quot; === nodeType || &quot;ObjectMethod&quot; === nodeType || &quot;ArrowFunctionExpression&quot; === nodeType || &quot;ClassMethod&quot; === nodeType || &quot;ClassPrivateMethod&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isFunctionParent(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;FunctionDeclaration&quot; === nodeType || &quot;FunctionExpression&quot; === nodeType || &quot;ObjectMethod&quot; === nodeType || &quot;ArrowFunctionExpression&quot; === nodeType || &quot;ClassMethod&quot; === nodeType || &quot;ClassPrivateMethod&quot; === nodeType || &quot;StaticBlock&quot; === nodeType || &quot;TSModuleBlock&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isPureish(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;FunctionDeclaration&quot; === nodeType || &quot;FunctionExpression&quot; === nodeType || &quot;StringLiteral&quot; === nodeType || &quot;NumericLiteral&quot; === nodeType || &quot;NullLiteral&quot; === nodeType || &quot;BooleanLiteral&quot; === nodeType || &quot;RegExpLiteral&quot; === nodeType || &quot;ArrowFunctionExpression&quot; === nodeType || &quot;BigIntLiteral&quot; === nodeType || &quot;DecimalLiteral&quot; === nodeType || nodeType === &quot;Placeholder&quot; &amp;&amp; &quot;StringLiteral&quot; === node.expectedNode) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;FunctionDeclaration&quot; === nodeType || &quot;VariableDeclaration&quot; === nodeType || &quot;ClassDeclaration&quot; === nodeType || &quot;ExportAllDeclaration&quot; === nodeType || &quot;ExportDefaultDeclaration&quot; === nodeType || &quot;ExportNamedDeclaration&quot; === nodeType || &quot;ImportDeclaration&quot; === nodeType || &quot;DeclareClass&quot; === nodeType || &quot;DeclareFunction&quot; === nodeType || &quot;DeclareInterface&quot; === nodeType || &quot;DeclareModule&quot; === nodeType || &quot;DeclareModuleExports&quot; === nodeType || &quot;DeclareTypeAlias&quot; === nodeType || &quot;DeclareOpaqueType&quot; === nodeType || &quot;DeclareVariable&quot; === nodeType || &quot;DeclareExportDeclaration&quot; === nodeType || &quot;DeclareExportAllDeclaration&quot; === nodeType || &quot;InterfaceDeclaration&quot; === nodeType || &quot;OpaqueType&quot; === nodeType || &quot;TypeAlias&quot; === nodeType || &quot;EnumDeclaration&quot; === nodeType || &quot;TSDeclareFunction&quot; === nodeType || &quot;TSInterfaceDeclaration&quot; === nodeType || &quot;TSTypeAliasDeclaration&quot; === nodeType || &quot;TSEnumDeclaration&quot; === nodeType || &quot;TSModuleDeclaration&quot; === nodeType || nodeType === &quot;Placeholder&quot; &amp;&amp; &quot;Declaration&quot; === node.expectedNode) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isPatternLike(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;Identifier&quot; === nodeType || &quot;RestElement&quot; === nodeType || &quot;AssignmentPattern&quot; === nodeType || &quot;ArrayPattern&quot; === nodeType || &quot;ObjectPattern&quot; === nodeType || &quot;TSAsExpression&quot; === nodeType || &quot;TSSatisfiesExpression&quot; === nodeType || &quot;TSTypeAssertion&quot; === nodeType || &quot;TSNonNullExpression&quot; === nodeType || nodeType === &quot;Placeholder&quot; &amp;&amp; (&quot;Pattern&quot; === node.expectedNode || &quot;Identifier&quot; === node.expectedNode)) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isLVal(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;Identifier&quot; === nodeType || &quot;MemberExpression&quot; === nodeType || &quot;RestElement&quot; === nodeType || &quot;AssignmentPattern&quot; === nodeType || &quot;ArrayPattern&quot; === nodeType || &quot;ObjectPattern&quot; === nodeType || &quot;TSParameterProperty&quot; === nodeType || &quot;TSAsExpression&quot; === nodeType || &quot;TSSatisfiesExpression&quot; === nodeType || &quot;TSTypeAssertion&quot; === nodeType || &quot;TSNonNullExpression&quot; === nodeType || nodeType === &quot;Placeholder&quot; &amp;&amp; (&quot;Pattern&quot; === node.expectedNode || &quot;Identifier&quot; === node.expectedNode)) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSEntityName(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;Identifier&quot; === nodeType || &quot;TSQualifiedName&quot; === nodeType || nodeType === &quot;Placeholder&quot; &amp;&amp; &quot;Identifier&quot; === node.expectedNode) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;StringLiteral&quot; === nodeType || &quot;NumericLiteral&quot; === nodeType || &quot;NullLiteral&quot; === nodeType || &quot;BooleanLiteral&quot; === nodeType || &quot;RegExpLiteral&quot; === nodeType || &quot;TemplateLiteral&quot; === nodeType || &quot;BigIntLiteral&quot; === nodeType || &quot;DecimalLiteral&quot; === nodeType || nodeType === &quot;Placeholder&quot; &amp;&amp; &quot;StringLiteral&quot; === node.expectedNode) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isImmutable(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;StringLiteral&quot; === nodeType || &quot;NumericLiteral&quot; === nodeType || &quot;NullLiteral&quot; === nodeType || &quot;BooleanLiteral&quot; === nodeType || &quot;BigIntLiteral&quot; === nodeType || &quot;JSXAttribute&quot; === nodeType || &quot;JSXClosingElement&quot; === nodeType || &quot;JSXElement&quot; === nodeType || &quot;JSXExpressionContainer&quot; === nodeType || &quot;JSXSpreadChild&quot; === nodeType || &quot;JSXOpeningElement&quot; === nodeType || &quot;JSXText&quot; === nodeType || &quot;JSXFragment&quot; === nodeType || &quot;JSXOpeningFragment&quot; === nodeType || &quot;JSXClosingFragment&quot; === nodeType || &quot;DecimalLiteral&quot; === nodeType || nodeType === &quot;Placeholder&quot; &amp;&amp; &quot;StringLiteral&quot; === node.expectedNode) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isUserWhitespacable(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;ObjectMethod&quot; === nodeType || &quot;ObjectProperty&quot; === nodeType || &quot;ObjectTypeInternalSlot&quot; === nodeType || &quot;ObjectTypeCallProperty&quot; === nodeType || &quot;ObjectTypeIndexer&quot; === nodeType || &quot;ObjectTypeProperty&quot; === nodeType || &quot;ObjectTypeSpreadProperty&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isMethod(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;ObjectMethod&quot; === nodeType || &quot;ClassMethod&quot; === nodeType || &quot;ClassPrivateMethod&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isObjectMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;ObjectMethod&quot; === nodeType || &quot;ObjectProperty&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;ObjectProperty&quot; === nodeType || &quot;ClassProperty&quot; === nodeType || &quot;ClassAccessorProperty&quot; === nodeType || &quot;ClassPrivateProperty&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isUnaryLike(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;UnaryExpression&quot; === nodeType || &quot;SpreadElement&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isPattern(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;AssignmentPattern&quot; === nodeType || &quot;ArrayPattern&quot; === nodeType || &quot;ObjectPattern&quot; === nodeType || nodeType === &quot;Placeholder&quot; &amp;&amp; &quot;Pattern&quot; === node.expectedNode) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isClass(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;ClassExpression&quot; === nodeType || &quot;ClassDeclaration&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isImportOrExportDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;ExportAllDeclaration&quot; === nodeType || &quot;ExportDefaultDeclaration&quot; === nodeType || &quot;ExportNamedDeclaration&quot; === nodeType || &quot;ImportDeclaration&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isExportDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;ExportAllDeclaration&quot; === nodeType || &quot;ExportDefaultDeclaration&quot; === nodeType || &quot;ExportNamedDeclaration&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isModuleSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;ExportSpecifier&quot; === nodeType || &quot;ImportDefaultSpecifier&quot; === nodeType || &quot;ImportNamespaceSpecifier&quot; === nodeType || &quot;ImportSpecifier&quot; === nodeType || &quot;ExportNamespaceSpecifier&quot; === nodeType || &quot;ExportDefaultSpecifier&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isAccessor(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;ClassAccessorProperty&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isPrivate(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;ClassPrivateProperty&quot; === nodeType || &quot;ClassPrivateMethod&quot; === nodeType || &quot;PrivateName&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isFlow(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;AnyTypeAnnotation&quot; === nodeType || &quot;ArrayTypeAnnotation&quot; === nodeType || &quot;BooleanTypeAnnotation&quot; === nodeType || &quot;BooleanLiteralTypeAnnotation&quot; === nodeType || &quot;NullLiteralTypeAnnotation&quot; === nodeType || &quot;ClassImplements&quot; === nodeType || &quot;DeclareClass&quot; === nodeType || &quot;DeclareFunction&quot; === nodeType || &quot;DeclareInterface&quot; === nodeType || &quot;DeclareModule&quot; === nodeType || &quot;DeclareModuleExports&quot; === nodeType || &quot;DeclareTypeAlias&quot; === nodeType || &quot;DeclareOpaqueType&quot; === nodeType || &quot;DeclareVariable&quot; === nodeType || &quot;DeclareExportDeclaration&quot; === nodeType || &quot;DeclareExportAllDeclaration&quot; === nodeType || &quot;DeclaredPredicate&quot; === nodeType || &quot;ExistsTypeAnnotation&quot; === nodeType || &quot;FunctionTypeAnnotation&quot; === nodeType || &quot;FunctionTypeParam&quot; === nodeType || &quot;GenericTypeAnnotation&quot; === nodeType || &quot;InferredPredicate&quot; === nodeType || &quot;InterfaceExtends&quot; === nodeType || &quot;InterfaceDeclaration&quot; === nodeType || &quot;InterfaceTypeAnnotation&quot; === nodeType || &quot;IntersectionTypeAnnotation&quot; === nodeType || &quot;MixedTypeAnnotation&quot; === nodeType || &quot;EmptyTypeAnnotation&quot; === nodeType || &quot;NullableTypeAnnotation&quot; === nodeType || &quot;NumberLiteralTypeAnnotation&quot; === nodeType || &quot;NumberTypeAnnotation&quot; === nodeType || &quot;ObjectTypeAnnotation&quot; === nodeType || &quot;ObjectTypeInternalSlot&quot; === nodeType || &quot;ObjectTypeCallProperty&quot; === nodeType || &quot;ObjectTypeIndexer&quot; === nodeType || &quot;ObjectTypeProperty&quot; === nodeType || &quot;ObjectTypeSpreadProperty&quot; === nodeType || &quot;OpaqueType&quot; === nodeType || &quot;QualifiedTypeIdentifier&quot; === nodeType || &quot;StringLiteralTypeAnnotation&quot; === nodeType || &quot;StringTypeAnnotation&quot; === nodeType || &quot;SymbolTypeAnnotation&quot; === nodeType || &quot;ThisTypeAnnotation&quot; === nodeType || &quot;TupleTypeAnnotation&quot; === nodeType || &quot;TypeofTypeAnnotation&quot; === nodeType || &quot;TypeAlias&quot; === nodeType || &quot;TypeAnnotation&quot; === nodeType || &quot;TypeCastExpression&quot; === nodeType || &quot;TypeParameter&quot; === nodeType || &quot;TypeParameterDeclaration&quot; === nodeType || &quot;TypeParameterInstantiation&quot; === nodeType || &quot;UnionTypeAnnotation&quot; === nodeType || &quot;Variance&quot; === nodeType || &quot;VoidTypeAnnotation&quot; === nodeType || &quot;EnumDeclaration&quot; === nodeType || &quot;EnumBooleanBody&quot; === nodeType || &quot;EnumNumberBody&quot; === nodeType || &quot;EnumStringBody&quot; === nodeType || &quot;EnumSymbolBody&quot; === nodeType || &quot;EnumBooleanMember&quot; === nodeType || &quot;EnumNumberMember&quot; === nodeType || &quot;EnumStringMember&quot; === nodeType || &quot;EnumDefaultedMember&quot; === nodeType || &quot;IndexedAccessType&quot; === nodeType || &quot;OptionalIndexedAccessType&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isFlowType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;AnyTypeAnnotation&quot; === nodeType || &quot;ArrayTypeAnnotation&quot; === nodeType || &quot;BooleanTypeAnnotation&quot; === nodeType || &quot;BooleanLiteralTypeAnnotation&quot; === nodeType || &quot;NullLiteralTypeAnnotation&quot; === nodeType || &quot;ExistsTypeAnnotation&quot; === nodeType || &quot;FunctionTypeAnnotation&quot; === nodeType || &quot;GenericTypeAnnotation&quot; === nodeType || &quot;InterfaceTypeAnnotation&quot; === nodeType || &quot;IntersectionTypeAnnotation&quot; === nodeType || &quot;MixedTypeAnnotation&quot; === nodeType || &quot;EmptyTypeAnnotation&quot; === nodeType || &quot;NullableTypeAnnotation&quot; === nodeType || &quot;NumberLiteralTypeAnnotation&quot; === nodeType || &quot;NumberTypeAnnotation&quot; === nodeType || &quot;ObjectTypeAnnotation&quot; === nodeType || &quot;StringLiteralTypeAnnotation&quot; === nodeType || &quot;StringTypeAnnotation&quot; === nodeType || &quot;SymbolTypeAnnotation&quot; === nodeType || &quot;ThisTypeAnnotation&quot; === nodeType || &quot;TupleTypeAnnotation&quot; === nodeType || &quot;TypeofTypeAnnotation&quot; === nodeType || &quot;UnionTypeAnnotation&quot; === nodeType || &quot;VoidTypeAnnotation&quot; === nodeType || &quot;IndexedAccessType&quot; === nodeType || &quot;OptionalIndexedAccessType&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isFlowBaseAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;AnyTypeAnnotation&quot; === nodeType || &quot;BooleanTypeAnnotation&quot; === nodeType || &quot;NullLiteralTypeAnnotation&quot; === nodeType || &quot;MixedTypeAnnotation&quot; === nodeType || &quot;EmptyTypeAnnotation&quot; === nodeType || &quot;NumberTypeAnnotation&quot; === nodeType || &quot;StringTypeAnnotation&quot; === nodeType || &quot;SymbolTypeAnnotation&quot; === nodeType || &quot;ThisTypeAnnotation&quot; === nodeType || &quot;VoidTypeAnnotation&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isFlowDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;DeclareClass&quot; === nodeType || &quot;DeclareFunction&quot; === nodeType || &quot;DeclareInterface&quot; === nodeType || &quot;DeclareModule&quot; === nodeType || &quot;DeclareModuleExports&quot; === nodeType || &quot;DeclareTypeAlias&quot; === nodeType || &quot;DeclareOpaqueType&quot; === nodeType || &quot;DeclareVariable&quot; === nodeType || &quot;DeclareExportDeclaration&quot; === nodeType || &quot;DeclareExportAllDeclaration&quot; === nodeType || &quot;InterfaceDeclaration&quot; === nodeType || &quot;OpaqueType&quot; === nodeType || &quot;TypeAlias&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isFlowPredicate(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;DeclaredPredicate&quot; === nodeType || &quot;InferredPredicate&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isEnumBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;EnumBooleanBody&quot; === nodeType || &quot;EnumNumberBody&quot; === nodeType || &quot;EnumStringBody&quot; === nodeType || &quot;EnumSymbolBody&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isEnumMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;EnumBooleanMember&quot; === nodeType || &quot;EnumNumberMember&quot; === nodeType || &quot;EnumStringMember&quot; === nodeType || &quot;EnumDefaultedMember&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSX(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;JSXAttribute&quot; === nodeType || &quot;JSXClosingElement&quot; === nodeType || &quot;JSXElement&quot; === nodeType || &quot;JSXEmptyExpression&quot; === nodeType || &quot;JSXExpressionContainer&quot; === nodeType || &quot;JSXSpreadChild&quot; === nodeType || &quot;JSXIdentifier&quot; === nodeType || &quot;JSXMemberExpression&quot; === nodeType || &quot;JSXNamespacedName&quot; === nodeType || &quot;JSXOpeningElement&quot; === nodeType || &quot;JSXSpreadAttribute&quot; === nodeType || &quot;JSXText&quot; === nodeType || &quot;JSXFragment&quot; === nodeType || &quot;JSXOpeningFragment&quot; === nodeType || &quot;JSXClosingFragment&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isMiscellaneous(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;Noop&quot; === nodeType || &quot;Placeholder&quot; === nodeType || &quot;V8IntrinsicIdentifier&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTypeScript(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;TSParameterProperty&quot; === nodeType || &quot;TSDeclareFunction&quot; === nodeType || &quot;TSDeclareMethod&quot; === nodeType || &quot;TSQualifiedName&quot; === nodeType || &quot;TSCallSignatureDeclaration&quot; === nodeType || &quot;TSConstructSignatureDeclaration&quot; === nodeType || &quot;TSPropertySignature&quot; === nodeType || &quot;TSMethodSignature&quot; === nodeType || &quot;TSIndexSignature&quot; === nodeType || &quot;TSAnyKeyword&quot; === nodeType || &quot;TSBooleanKeyword&quot; === nodeType || &quot;TSBigIntKeyword&quot; === nodeType || &quot;TSIntrinsicKeyword&quot; === nodeType || &quot;TSNeverKeyword&quot; === nodeType || &quot;TSNullKeyword&quot; === nodeType || &quot;TSNumberKeyword&quot; === nodeType || &quot;TSObjectKeyword&quot; === nodeType || &quot;TSStringKeyword&quot; === nodeType || &quot;TSSymbolKeyword&quot; === nodeType || &quot;TSUndefinedKeyword&quot; === nodeType || &quot;TSUnknownKeyword&quot; === nodeType || &quot;TSVoidKeyword&quot; === nodeType || &quot;TSThisType&quot; === nodeType || &quot;TSFunctionType&quot; === nodeType || &quot;TSConstructorType&quot; === nodeType || &quot;TSTypeReference&quot; === nodeType || &quot;TSTypePredicate&quot; === nodeType || &quot;TSTypeQuery&quot; === nodeType || &quot;TSTypeLiteral&quot; === nodeType || &quot;TSArrayType&quot; === nodeType || &quot;TSTupleType&quot; === nodeType || &quot;TSOptionalType&quot; === nodeType || &quot;TSRestType&quot; === nodeType || &quot;TSNamedTupleMember&quot; === nodeType || &quot;TSUnionType&quot; === nodeType || &quot;TSIntersectionType&quot; === nodeType || &quot;TSConditionalType&quot; === nodeType || &quot;TSInferType&quot; === nodeType || &quot;TSParenthesizedType&quot; === nodeType || &quot;TSTypeOperator&quot; === nodeType || &quot;TSIndexedAccessType&quot; === nodeType || &quot;TSMappedType&quot; === nodeType || &quot;TSLiteralType&quot; === nodeType || &quot;TSExpressionWithTypeArguments&quot; === nodeType || &quot;TSInterfaceDeclaration&quot; === nodeType || &quot;TSInterfaceBody&quot; === nodeType || &quot;TSTypeAliasDeclaration&quot; === nodeType || &quot;TSInstantiationExpression&quot; === nodeType || &quot;TSAsExpression&quot; === nodeType || &quot;TSSatisfiesExpression&quot; === nodeType || &quot;TSTypeAssertion&quot; === nodeType || &quot;TSEnumDeclaration&quot; === nodeType || &quot;TSEnumMember&quot; === nodeType || &quot;TSModuleDeclaration&quot; === nodeType || &quot;TSModuleBlock&quot; === nodeType || &quot;TSImportType&quot; === nodeType || &quot;TSImportEqualsDeclaration&quot; === nodeType || &quot;TSExternalModuleReference&quot; === nodeType || &quot;TSNonNullExpression&quot; === nodeType || &quot;TSExportAssignment&quot; === nodeType || &quot;TSNamespaceExportDeclaration&quot; === nodeType || &quot;TSTypeAnnotation&quot; === nodeType || &quot;TSTypeParameterInstantiation&quot; === nodeType || &quot;TSTypeParameterDeclaration&quot; === nodeType || &quot;TSTypeParameter&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSTypeElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;TSCallSignatureDeclaration&quot; === nodeType || &quot;TSConstructSignatureDeclaration&quot; === nodeType || &quot;TSPropertySignature&quot; === nodeType || &quot;TSMethodSignature&quot; === nodeType || &quot;TSIndexSignature&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;TSAnyKeyword&quot; === nodeType || &quot;TSBooleanKeyword&quot; === nodeType || &quot;TSBigIntKeyword&quot; === nodeType || &quot;TSIntrinsicKeyword&quot; === nodeType || &quot;TSNeverKeyword&quot; === nodeType || &quot;TSNullKeyword&quot; === nodeType || &quot;TSNumberKeyword&quot; === nodeType || &quot;TSObjectKeyword&quot; === nodeType || &quot;TSStringKeyword&quot; === nodeType || &quot;TSSymbolKeyword&quot; === nodeType || &quot;TSUndefinedKeyword&quot; === nodeType || &quot;TSUnknownKeyword&quot; === nodeType || &quot;TSVoidKeyword&quot; === nodeType || &quot;TSThisType&quot; === nodeType || &quot;TSFunctionType&quot; === nodeType || &quot;TSConstructorType&quot; === nodeType || &quot;TSTypeReference&quot; === nodeType || &quot;TSTypePredicate&quot; === nodeType || &quot;TSTypeQuery&quot; === nodeType || &quot;TSTypeLiteral&quot; === nodeType || &quot;TSArrayType&quot; === nodeType || &quot;TSTupleType&quot; === nodeType || &quot;TSOptionalType&quot; === nodeType || &quot;TSRestType&quot; === nodeType || &quot;TSUnionType&quot; === nodeType || &quot;TSIntersectionType&quot; === nodeType || &quot;TSConditionalType&quot; === nodeType || &quot;TSInferType&quot; === nodeType || &quot;TSParenthesizedType&quot; === nodeType || &quot;TSTypeOperator&quot; === nodeType || &quot;TSIndexedAccessType&quot; === nodeType || &quot;TSMappedType&quot; === nodeType || &quot;TSLiteralType&quot; === nodeType || &quot;TSExpressionWithTypeArguments&quot; === nodeType || &quot;TSImportType&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSBaseType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (&quot;TSAnyKeyword&quot; === nodeType || &quot;TSBooleanKeyword&quot; === nodeType || &quot;TSBigIntKeyword&quot; === nodeType || &quot;TSIntrinsicKeyword&quot; === nodeType || &quot;TSNeverKeyword&quot; === nodeType || &quot;TSNullKeyword&quot; === nodeType || &quot;TSNumberKeyword&quot; === nodeType || &quot;TSObjectKeyword&quot; === nodeType || &quot;TSStringKeyword&quot; === nodeType || &quot;TSSymbolKeyword&quot; === nodeType || &quot;TSUndefinedKeyword&quot; === nodeType || &quot;TSUnknownKeyword&quot; === nodeType || &quot;TSVoidKeyword&quot; === nodeType || &quot;TSThisType&quot; === nodeType || &quot;TSLiteralType&quot; === nodeType) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isNumberLiteral(node, opts) {
  (0, _deprecationWarning.default)(&quot;isNumberLiteral&quot;, &quot;isNumericLiteral&quot;);
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;NumberLiteral&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isRegexLiteral(node, opts) {
  (0, _deprecationWarning.default)(&quot;isRegexLiteral&quot;, &quot;isRegExpLiteral&quot;);
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;RegexLiteral&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isRestProperty(node, opts) {
  (0, _deprecationWarning.default)(&quot;isRestProperty&quot;, &quot;isRestElement&quot;);
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;RestProperty&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isSpreadProperty(node, opts) {
  (0, _deprecationWarning.default)(&quot;isSpreadProperty&quot;, &quot;isSpreadElement&quot;);
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === &quot;SpreadProperty&quot;) {
    if (typeof opts === &quot;undefined&quot;) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isModuleDeclaration(node, opts) {
  (0, _deprecationWarning.default)(&quot;isModuleDeclaration&quot;, &quot;isImportOrExportDeclaration&quot;);
  return isImportOrExportDeclaration(node, opts);
}

//# sourceMappingURL=index.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
