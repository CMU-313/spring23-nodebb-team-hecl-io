<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@babel/traverse/lib/path/conversion.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@babel/traverse/lib/path/conversion.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">61.55</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">468</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">67.05</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.06</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

Object.defineProperty(exports, &quot;__esModule&quot;, {
  value: true
});
exports.arrowFunctionToExpression = arrowFunctionToExpression;
exports.arrowFunctionToShadowed = arrowFunctionToShadowed;
exports.ensureBlock = ensureBlock;
exports.toComputedKey = toComputedKey;
exports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;
var _t = require(&quot;@babel/types&quot;);
var _helperEnvironmentVisitor = require(&quot;@babel/helper-environment-visitor&quot;);
var _helperFunctionName = require(&quot;@babel/helper-function-name&quot;);
var _visitors = require(&quot;../visitors&quot;);
const {
  arrowFunctionExpression,
  assignmentExpression,
  binaryExpression,
  blockStatement,
  callExpression,
  conditionalExpression,
  expressionStatement,
  identifier,
  isIdentifier,
  jsxIdentifier,
  logicalExpression,
  LOGICAL_OPERATORS,
  memberExpression,
  metaProperty,
  numericLiteral,
  objectExpression,
  restElement,
  returnStatement,
  sequenceExpression,
  spreadElement,
  stringLiteral,
  super: _super,
  thisExpression,
  toExpression,
  unaryExpression
} = _t;
function toComputedKey() {
  let key;
  if (this.isMemberExpression()) {
    key = this.node.property;
  } else if (this.isProperty() || this.isMethod()) {
    key = this.node.key;
  } else {
    throw new ReferenceError(&quot;todo&quot;);
  }
  if (!this.node.computed) {
    if (isIdentifier(key)) key = stringLiteral(key.name);
  }
  return key;
}
function ensureBlock() {
  const body = this.get(&quot;body&quot;);
  const bodyNode = body.node;
  if (Array.isArray(body)) {
    throw new Error(&quot;Can&#039;t convert array path to a block statement&quot;);
  }
  if (!bodyNode) {
    throw new Error(&quot;Can&#039;t convert node without a body&quot;);
  }
  if (body.isBlockStatement()) {
    return bodyNode;
  }
  const statements = [];
  let stringPath = &quot;body&quot;;
  let key;
  let listKey;
  if (body.isStatement()) {
    listKey = &quot;body&quot;;
    key = 0;
    statements.push(body.node);
  } else {
    stringPath += &quot;.body.0&quot;;
    if (this.isFunction()) {
      key = &quot;argument&quot;;
      statements.push(returnStatement(body.node));
    } else {
      key = &quot;expression&quot;;
      statements.push(expressionStatement(body.node));
    }
  }
  this.node.body = blockStatement(statements);
  const parentPath = this.get(stringPath);
  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);
  return this.node;
}
function arrowFunctionToShadowed() {
  if (!this.isArrowFunctionExpression()) return;
  this.arrowFunctionToExpression();
}
function unwrapFunctionEnvironment() {
  if (!this.isArrowFunctionExpression() &amp;&amp; !this.isFunctionExpression() &amp;&amp; !this.isFunctionDeclaration()) {
    throw this.buildCodeFrameError(&quot;Can only unwrap the environment of a function.&quot;);
  }
  hoistFunctionEnvironment(this);
}
function setType(path, type) {
  path.node.type = type;
}
function arrowFunctionToExpression({
  allowInsertArrow = true,
  allowInsertArrowWithRest = allowInsertArrow,
  specCompliant = false,
  noNewArrows = !specCompliant
} = {}) {
  if (!this.isArrowFunctionExpression()) {
    throw this.buildCodeFrameError(&quot;Cannot convert non-arrow function to a function expression.&quot;);
  }
  const {
    thisBinding,
    fnPath: fn
  } = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow, allowInsertArrowWithRest);
  fn.ensureBlock();
  setType(fn, &quot;FunctionExpression&quot;);
  if (!noNewArrows) {
    const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier(&quot;arrowCheckId&quot;);
    if (checkBinding) {
      fn.parentPath.scope.push({
        id: checkBinding,
        init: objectExpression([])
      });
    }
    fn.get(&quot;body&quot;).unshiftContainer(&quot;body&quot;, expressionStatement(callExpression(this.hub.addHelper(&quot;newArrowCheck&quot;), [thisExpression(), checkBinding ? identifier(checkBinding.name) : identifier(thisBinding)])));
    fn.replaceWith(callExpression(memberExpression((0, _helperFunctionName.default)(this, true) || fn.node, identifier(&quot;bind&quot;)), [checkBinding ? identifier(checkBinding.name) : thisExpression()]));
    return fn.get(&quot;callee.object&quot;);
  }
  return fn;
}
const getSuperCallsVisitor = (0, _visitors.merge)([{
  CallExpression(child, {
    allSuperCalls
  }) {
    if (!child.get(&quot;callee&quot;).isSuper()) return;
    allSuperCalls.push(child);
  }
}, _helperEnvironmentVisitor.default]);
function hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true, allowInsertArrowWithRest = true) {
  let arrowParent;
  let thisEnvFn = fnPath.findParent(p =&gt; {
    if (p.isArrowFunctionExpression()) {
      var _arrowParent;
      (_arrowParent = arrowParent) != null ? _arrowParent : arrowParent = p;
      return false;
    }
    return p.isFunction() || p.isProgram() || p.isClassProperty({
      static: false
    }) || p.isClassPrivateProperty({
      static: false
    });
  });
  const inConstructor = thisEnvFn.isClassMethod({
    kind: &quot;constructor&quot;
  });
  if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {
    if (arrowParent) {
      thisEnvFn = arrowParent;
    } else if (allowInsertArrow) {
      fnPath.replaceWith(callExpression(arrowFunctionExpression([], toExpression(fnPath.node)), []));
      thisEnvFn = fnPath.get(&quot;callee&quot;);
      fnPath = thisEnvFn.get(&quot;body&quot;);
    } else {
      throw fnPath.buildCodeFrameError(&quot;Unable to transform arrow inside class property&quot;);
    }
  }
  const {
    thisPaths,
    argumentsPaths,
    newTargetPaths,
    superProps,
    superCalls
  } = getScopeInformation(fnPath);
  if (inConstructor &amp;&amp; superCalls.length &gt; 0) {
    if (!allowInsertArrow) {
      throw superCalls[0].buildCodeFrameError(&quot;When using &#039;@babel/plugin-transform-arrow-functions&#039;, &quot; + &quot;it&#039;s not possible to compile `super()` in an arrow function without compiling classes.\n&quot; + &quot;Please add &#039;@babel/plugin-transform-classes&#039; to your Babel configuration.&quot;);
    }
    if (!allowInsertArrowWithRest) {
      throw superCalls[0].buildCodeFrameError(&quot;When using &#039;@babel/plugin-transform-parameters&#039;, &quot; + &quot;it&#039;s not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\n&quot; + &quot;Please add &#039;@babel/plugin-transform-classes&#039; to your Babel configuration.&quot;);
    }
    const allSuperCalls = [];
    thisEnvFn.traverse(getSuperCallsVisitor, {
      allSuperCalls
    });
    const superBinding = getSuperBinding(thisEnvFn);
    allSuperCalls.forEach(superCall =&gt; {
      const callee = identifier(superBinding);
      callee.loc = superCall.node.callee.loc;
      superCall.get(&quot;callee&quot;).replaceWith(callee);
    });
  }
  if (argumentsPaths.length &gt; 0) {
    const argumentsBinding = getBinding(thisEnvFn, &quot;arguments&quot;, () =&gt; {
      const args = () =&gt; identifier(&quot;arguments&quot;);
      if (thisEnvFn.scope.path.isProgram()) {
        return conditionalExpression(binaryExpression(&quot;===&quot;, unaryExpression(&quot;typeof&quot;, args()), stringLiteral(&quot;undefined&quot;)), thisEnvFn.scope.buildUndefinedNode(), args());
      } else {
        return args();
      }
    });
    argumentsPaths.forEach(argumentsChild =&gt; {
      const argsRef = identifier(argumentsBinding);
      argsRef.loc = argumentsChild.node.loc;
      argumentsChild.replaceWith(argsRef);
    });
  }
  if (newTargetPaths.length &gt; 0) {
    const newTargetBinding = getBinding(thisEnvFn, &quot;newtarget&quot;, () =&gt; metaProperty(identifier(&quot;new&quot;), identifier(&quot;target&quot;)));
    newTargetPaths.forEach(targetChild =&gt; {
      const targetRef = identifier(newTargetBinding);
      targetRef.loc = targetChild.node.loc;
      targetChild.replaceWith(targetRef);
    });
  }
  if (superProps.length &gt; 0) {
    if (!allowInsertArrow) {
      throw superProps[0].buildCodeFrameError(&quot;When using &#039;@babel/plugin-transform-arrow-functions&#039;, &quot; + &quot;it&#039;s not possible to compile `super.prop` in an arrow function without compiling classes.\n&quot; + &quot;Please add &#039;@babel/plugin-transform-classes&#039; to your Babel configuration.&quot;);
    }
    const flatSuperProps = superProps.reduce((acc, superProp) =&gt; acc.concat(standardizeSuperProperty(superProp)), []);
    flatSuperProps.forEach(superProp =&gt; {
      const key = superProp.node.computed ? &quot;&quot; : superProp.get(&quot;property&quot;).node.name;
      const superParentPath = superProp.parentPath;
      const isAssignment = superParentPath.isAssignmentExpression({
        left: superProp.node
      });
      const isCall = superParentPath.isCallExpression({
        callee: superProp.node
      });
      const isTaggedTemplate = superParentPath.isTaggedTemplateExpression({
        tag: superProp.node
      });
      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);
      const args = [];
      if (superProp.node.computed) {
        args.push(superProp.get(&quot;property&quot;).node);
      }
      if (isAssignment) {
        const value = superParentPath.node.right;
        args.push(value);
      }
      const call = callExpression(identifier(superBinding), args);
      if (isCall) {
        superParentPath.unshiftContainer(&quot;arguments&quot;, thisExpression());
        superProp.replaceWith(memberExpression(call, identifier(&quot;call&quot;)));
        thisPaths.push(superParentPath.get(&quot;arguments.0&quot;));
      } else if (isAssignment) {
        superParentPath.replaceWith(call);
      } else if (isTaggedTemplate) {
        superProp.replaceWith(callExpression(memberExpression(call, identifier(&quot;bind&quot;), false), [thisExpression()]));
        thisPaths.push(superProp.get(&quot;arguments.0&quot;));
      } else {
        superProp.replaceWith(call);
      }
    });
  }
  let thisBinding;
  if (thisPaths.length &gt; 0 || !noNewArrows) {
    thisBinding = getThisBinding(thisEnvFn, inConstructor);
    if (noNewArrows || inConstructor &amp;&amp; hasSuperClass(thisEnvFn)) {
      thisPaths.forEach(thisChild =&gt; {
        const thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);
        thisRef.loc = thisChild.node.loc;
        thisChild.replaceWith(thisRef);
      });
      if (!noNewArrows) thisBinding = null;
    }
  }
  return {
    thisBinding,
    fnPath
  };
}
function isLogicalOp(op) {
  return LOGICAL_OPERATORS.includes(op);
}
function standardizeSuperProperty(superProp) {
  if (superProp.parentPath.isAssignmentExpression() &amp;&amp; superProp.parentPath.node.operator !== &quot;=&quot;) {
    const assignmentPath = superProp.parentPath;
    const op = assignmentPath.node.operator.slice(0, -1);
    const value = assignmentPath.node.right;
    const isLogicalAssignment = isLogicalOp(op);
    if (superProp.node.computed) {
      const tmp = superProp.scope.generateDeclaredUidIdentifier(&quot;tmp&quot;);
      const object = superProp.node.object;
      const property = superProp.node.property;
      assignmentPath.get(&quot;left&quot;).replaceWith(memberExpression(object, assignmentExpression(&quot;=&quot;, tmp, property), true));
      assignmentPath.get(&quot;right&quot;).replaceWith(rightExpression(isLogicalAssignment ? &quot;=&quot; : op, memberExpression(object, identifier(tmp.name), true), value));
    } else {
      const object = superProp.node.object;
      const property = superProp.node.property;
      assignmentPath.get(&quot;left&quot;).replaceWith(memberExpression(object, property));
      assignmentPath.get(&quot;right&quot;).replaceWith(rightExpression(isLogicalAssignment ? &quot;=&quot; : op, memberExpression(object, identifier(property.name)), value));
    }
    if (isLogicalAssignment) {
      assignmentPath.replaceWith(logicalExpression(op, assignmentPath.node.left, assignmentPath.node.right));
    } else {
      assignmentPath.node.operator = &quot;=&quot;;
    }
    return [assignmentPath.get(&quot;left&quot;), assignmentPath.get(&quot;right&quot;).get(&quot;left&quot;)];
  } else if (superProp.parentPath.isUpdateExpression()) {
    const updateExpr = superProp.parentPath;
    const tmp = superProp.scope.generateDeclaredUidIdentifier(&quot;tmp&quot;);
    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier(&quot;prop&quot;) : null;
    const parts = [assignmentExpression(&quot;=&quot;, tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression(&quot;=&quot;, computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression(&quot;=&quot;, memberExpression(superProp.node.object, computedKey ? identifier(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression(superProp.parentPath.node.operator[0], identifier(tmp.name), numericLiteral(1)))];
    if (!superProp.parentPath.node.prefix) {
      parts.push(identifier(tmp.name));
    }
    updateExpr.replaceWith(sequenceExpression(parts));
    const left = updateExpr.get(&quot;expressions.0.right&quot;);
    const right = updateExpr.get(&quot;expressions.1.left&quot;);
    return [left, right];
  }
  return [superProp];
  function rightExpression(op, left, right) {
    if (op === &quot;=&quot;) {
      return assignmentExpression(&quot;=&quot;, left, right);
    } else {
      return binaryExpression(op, left, right);
    }
  }
}
function hasSuperClass(thisEnvFn) {
  return thisEnvFn.isClassMethod() &amp;&amp; !!thisEnvFn.parentPath.parentPath.node.superClass;
}
const assignSuperThisVisitor = (0, _visitors.merge)([{
  CallExpression(child, {
    supers,
    thisBinding
  }) {
    if (!child.get(&quot;callee&quot;).isSuper()) return;
    if (supers.has(child.node)) return;
    supers.add(child.node);
    child.replaceWithMultiple([child.node, assignmentExpression(&quot;=&quot;, identifier(thisBinding), identifier(&quot;this&quot;))]);
  }
}, _helperEnvironmentVisitor.default]);
function getThisBinding(thisEnvFn, inConstructor) {
  return getBinding(thisEnvFn, &quot;this&quot;, thisBinding =&gt; {
    if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();
    thisEnvFn.traverse(assignSuperThisVisitor, {
      supers: new WeakSet(),
      thisBinding
    });
  });
}
function getSuperBinding(thisEnvFn) {
  return getBinding(thisEnvFn, &quot;supercall&quot;, () =&gt; {
    const argsBinding = thisEnvFn.scope.generateUidIdentifier(&quot;args&quot;);
    return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier(argsBinding.name))]));
  });
}
function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
  const op = isAssignment ? &quot;set&quot; : &quot;get&quot;;
  return getBinding(thisEnvFn, `superprop_${op}:${propName || &quot;&quot;}`, () =&gt; {
    const argsList = [];
    let fnBody;
    if (propName) {
      fnBody = memberExpression(_super(), identifier(propName));
    } else {
      const method = thisEnvFn.scope.generateUidIdentifier(&quot;prop&quot;);
      argsList.unshift(method);
      fnBody = memberExpression(_super(), identifier(method.name), true);
    }
    if (isAssignment) {
      const valueIdent = thisEnvFn.scope.generateUidIdentifier(&quot;value&quot;);
      argsList.push(valueIdent);
      fnBody = assignmentExpression(&quot;=&quot;, fnBody, identifier(valueIdent.name));
    }
    return arrowFunctionExpression(argsList, fnBody);
  });
}
function getBinding(thisEnvFn, key, init) {
  const cacheKey = &quot;binding:&quot; + key;
  let data = thisEnvFn.getData(cacheKey);
  if (!data) {
    const id = thisEnvFn.scope.generateUidIdentifier(key);
    data = id.name;
    thisEnvFn.setData(cacheKey, data);
    thisEnvFn.scope.push({
      id: id,
      init: init(data)
    });
  }
  return data;
}
const getScopeInformationVisitor = (0, _visitors.merge)([{
  ThisExpression(child, {
    thisPaths
  }) {
    thisPaths.push(child);
  },
  JSXIdentifier(child, {
    thisPaths
  }) {
    if (child.node.name !== &quot;this&quot;) return;
    if (!child.parentPath.isJSXMemberExpression({
      object: child.node
    }) &amp;&amp; !child.parentPath.isJSXOpeningElement({
      name: child.node
    })) {
      return;
    }
    thisPaths.push(child);
  },
  CallExpression(child, {
    superCalls
  }) {
    if (child.get(&quot;callee&quot;).isSuper()) superCalls.push(child);
  },
  MemberExpression(child, {
    superProps
  }) {
    if (child.get(&quot;object&quot;).isSuper()) superProps.push(child);
  },
  Identifier(child, {
    argumentsPaths
  }) {
    if (!child.isReferencedIdentifier({
      name: &quot;arguments&quot;
    })) return;
    let curr = child.scope;
    do {
      if (curr.hasOwnBinding(&quot;arguments&quot;)) {
        curr.rename(&quot;arguments&quot;);
        return;
      }
      if (curr.path.isFunction() &amp;&amp; !curr.path.isArrowFunctionExpression()) {
        break;
      }
    } while (curr = curr.parent);
    argumentsPaths.push(child);
  },
  MetaProperty(child, {
    newTargetPaths
  }) {
    if (!child.get(&quot;meta&quot;).isIdentifier({
      name: &quot;new&quot;
    })) return;
    if (!child.get(&quot;property&quot;).isIdentifier({
      name: &quot;target&quot;
    })) return;
    newTargetPaths.push(child);
  }
}, _helperEnvironmentVisitor.default]);
function getScopeInformation(fnPath) {
  const thisPaths = [];
  const argumentsPaths = [];
  const newTargetPaths = [];
  const superProps = [];
  const superCalls = [];
  fnPath.traverse(getScopeInformationVisitor, {
    thisPaths,
    argumentsPaths,
    newTargetPaths,
    superProps,
    superCalls
  });
  return {
    thisPaths,
    argumentsPaths,
    newTargetPaths,
    superProps,
    superCalls
  };
}

//# sourceMappingURL=conversion.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
