<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@babel/types/lib/builders/generated/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@babel/types/lib/builders/generated/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">76.51</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1985</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">23.85</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">19.09</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

Object.defineProperty(exports, &quot;__esModule&quot;, {
  value: true
});
exports.anyTypeAnnotation = anyTypeAnnotation;
exports.argumentPlaceholder = argumentPlaceholder;
exports.arrayExpression = arrayExpression;
exports.arrayPattern = arrayPattern;
exports.arrayTypeAnnotation = arrayTypeAnnotation;
exports.arrowFunctionExpression = arrowFunctionExpression;
exports.assignmentExpression = assignmentExpression;
exports.assignmentPattern = assignmentPattern;
exports.awaitExpression = awaitExpression;
exports.bigIntLiteral = bigIntLiteral;
exports.binaryExpression = binaryExpression;
exports.bindExpression = bindExpression;
exports.blockStatement = blockStatement;
exports.booleanLiteral = booleanLiteral;
exports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
exports.booleanTypeAnnotation = booleanTypeAnnotation;
exports.breakStatement = breakStatement;
exports.callExpression = callExpression;
exports.catchClause = catchClause;
exports.classAccessorProperty = classAccessorProperty;
exports.classBody = classBody;
exports.classDeclaration = classDeclaration;
exports.classExpression = classExpression;
exports.classImplements = classImplements;
exports.classMethod = classMethod;
exports.classPrivateMethod = classPrivateMethod;
exports.classPrivateProperty = classPrivateProperty;
exports.classProperty = classProperty;
exports.conditionalExpression = conditionalExpression;
exports.continueStatement = continueStatement;
exports.debuggerStatement = debuggerStatement;
exports.decimalLiteral = decimalLiteral;
exports.declareClass = declareClass;
exports.declareExportAllDeclaration = declareExportAllDeclaration;
exports.declareExportDeclaration = declareExportDeclaration;
exports.declareFunction = declareFunction;
exports.declareInterface = declareInterface;
exports.declareModule = declareModule;
exports.declareModuleExports = declareModuleExports;
exports.declareOpaqueType = declareOpaqueType;
exports.declareTypeAlias = declareTypeAlias;
exports.declareVariable = declareVariable;
exports.declaredPredicate = declaredPredicate;
exports.decorator = decorator;
exports.directive = directive;
exports.directiveLiteral = directiveLiteral;
exports.doExpression = doExpression;
exports.doWhileStatement = doWhileStatement;
exports.emptyStatement = emptyStatement;
exports.emptyTypeAnnotation = emptyTypeAnnotation;
exports.enumBooleanBody = enumBooleanBody;
exports.enumBooleanMember = enumBooleanMember;
exports.enumDeclaration = enumDeclaration;
exports.enumDefaultedMember = enumDefaultedMember;
exports.enumNumberBody = enumNumberBody;
exports.enumNumberMember = enumNumberMember;
exports.enumStringBody = enumStringBody;
exports.enumStringMember = enumStringMember;
exports.enumSymbolBody = enumSymbolBody;
exports.existsTypeAnnotation = existsTypeAnnotation;
exports.exportAllDeclaration = exportAllDeclaration;
exports.exportDefaultDeclaration = exportDefaultDeclaration;
exports.exportDefaultSpecifier = exportDefaultSpecifier;
exports.exportNamedDeclaration = exportNamedDeclaration;
exports.exportNamespaceSpecifier = exportNamespaceSpecifier;
exports.exportSpecifier = exportSpecifier;
exports.expressionStatement = expressionStatement;
exports.file = file;
exports.forInStatement = forInStatement;
exports.forOfStatement = forOfStatement;
exports.forStatement = forStatement;
exports.functionDeclaration = functionDeclaration;
exports.functionExpression = functionExpression;
exports.functionTypeAnnotation = functionTypeAnnotation;
exports.functionTypeParam = functionTypeParam;
exports.genericTypeAnnotation = genericTypeAnnotation;
exports.identifier = identifier;
exports.ifStatement = ifStatement;
exports.import = _import;
exports.importAttribute = importAttribute;
exports.importDeclaration = importDeclaration;
exports.importDefaultSpecifier = importDefaultSpecifier;
exports.importNamespaceSpecifier = importNamespaceSpecifier;
exports.importSpecifier = importSpecifier;
exports.indexedAccessType = indexedAccessType;
exports.inferredPredicate = inferredPredicate;
exports.interfaceDeclaration = interfaceDeclaration;
exports.interfaceExtends = interfaceExtends;
exports.interfaceTypeAnnotation = interfaceTypeAnnotation;
exports.interpreterDirective = interpreterDirective;
exports.intersectionTypeAnnotation = intersectionTypeAnnotation;
exports.jSXAttribute = exports.jsxAttribute = jsxAttribute;
exports.jSXClosingElement = exports.jsxClosingElement = jsxClosingElement;
exports.jSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;
exports.jSXElement = exports.jsxElement = jsxElement;
exports.jSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;
exports.jSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;
exports.jSXFragment = exports.jsxFragment = jsxFragment;
exports.jSXIdentifier = exports.jsxIdentifier = jsxIdentifier;
exports.jSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;
exports.jSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;
exports.jSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;
exports.jSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;
exports.jSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;
exports.jSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;
exports.jSXText = exports.jsxText = jsxText;
exports.labeledStatement = labeledStatement;
exports.logicalExpression = logicalExpression;
exports.memberExpression = memberExpression;
exports.metaProperty = metaProperty;
exports.mixedTypeAnnotation = mixedTypeAnnotation;
exports.moduleExpression = moduleExpression;
exports.newExpression = newExpression;
exports.noop = noop;
exports.nullLiteral = nullLiteral;
exports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
exports.nullableTypeAnnotation = nullableTypeAnnotation;
exports.numberLiteral = NumberLiteral;
exports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
exports.numberTypeAnnotation = numberTypeAnnotation;
exports.numericLiteral = numericLiteral;
exports.objectExpression = objectExpression;
exports.objectMethod = objectMethod;
exports.objectPattern = objectPattern;
exports.objectProperty = objectProperty;
exports.objectTypeAnnotation = objectTypeAnnotation;
exports.objectTypeCallProperty = objectTypeCallProperty;
exports.objectTypeIndexer = objectTypeIndexer;
exports.objectTypeInternalSlot = objectTypeInternalSlot;
exports.objectTypeProperty = objectTypeProperty;
exports.objectTypeSpreadProperty = objectTypeSpreadProperty;
exports.opaqueType = opaqueType;
exports.optionalCallExpression = optionalCallExpression;
exports.optionalIndexedAccessType = optionalIndexedAccessType;
exports.optionalMemberExpression = optionalMemberExpression;
exports.parenthesizedExpression = parenthesizedExpression;
exports.pipelineBareFunction = pipelineBareFunction;
exports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
exports.pipelineTopicExpression = pipelineTopicExpression;
exports.placeholder = placeholder;
exports.privateName = privateName;
exports.program = program;
exports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
exports.recordExpression = recordExpression;
exports.regExpLiteral = regExpLiteral;
exports.regexLiteral = RegexLiteral;
exports.restElement = restElement;
exports.restProperty = RestProperty;
exports.returnStatement = returnStatement;
exports.sequenceExpression = sequenceExpression;
exports.spreadElement = spreadElement;
exports.spreadProperty = SpreadProperty;
exports.staticBlock = staticBlock;
exports.stringLiteral = stringLiteral;
exports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
exports.stringTypeAnnotation = stringTypeAnnotation;
exports.super = _super;
exports.switchCase = switchCase;
exports.switchStatement = switchStatement;
exports.symbolTypeAnnotation = symbolTypeAnnotation;
exports.taggedTemplateExpression = taggedTemplateExpression;
exports.templateElement = templateElement;
exports.templateLiteral = templateLiteral;
exports.thisExpression = thisExpression;
exports.thisTypeAnnotation = thisTypeAnnotation;
exports.throwStatement = throwStatement;
exports.topicReference = topicReference;
exports.tryStatement = tryStatement;
exports.tSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;
exports.tSArrayType = exports.tsArrayType = tsArrayType;
exports.tSAsExpression = exports.tsAsExpression = tsAsExpression;
exports.tSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;
exports.tSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;
exports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
exports.tSConditionalType = exports.tsConditionalType = tsConditionalType;
exports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
exports.tSConstructorType = exports.tsConstructorType = tsConstructorType;
exports.tSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;
exports.tSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;
exports.tSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;
exports.tSEnumMember = exports.tsEnumMember = tsEnumMember;
exports.tSExportAssignment = exports.tsExportAssignment = tsExportAssignment;
exports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
exports.tSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;
exports.tSFunctionType = exports.tsFunctionType = tsFunctionType;
exports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
exports.tSImportType = exports.tsImportType = tsImportType;
exports.tSIndexSignature = exports.tsIndexSignature = tsIndexSignature;
exports.tSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;
exports.tSInferType = exports.tsInferType = tsInferType;
exports.tSInstantiationExpression = exports.tsInstantiationExpression = tsInstantiationExpression;
exports.tSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;
exports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;
exports.tSIntersectionType = exports.tsIntersectionType = tsIntersectionType;
exports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword = tsIntrinsicKeyword;
exports.tSLiteralType = exports.tsLiteralType = tsLiteralType;
exports.tSMappedType = exports.tsMappedType = tsMappedType;
exports.tSMethodSignature = exports.tsMethodSignature = tsMethodSignature;
exports.tSModuleBlock = exports.tsModuleBlock = tsModuleBlock;
exports.tSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;
exports.tSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;
exports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
exports.tSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;
exports.tSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;
exports.tSNullKeyword = exports.tsNullKeyword = tsNullKeyword;
exports.tSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;
exports.tSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;
exports.tSOptionalType = exports.tsOptionalType = tsOptionalType;
exports.tSParameterProperty = exports.tsParameterProperty = tsParameterProperty;
exports.tSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;
exports.tSPropertySignature = exports.tsPropertySignature = tsPropertySignature;
exports.tSQualifiedName = exports.tsQualifiedName = tsQualifiedName;
exports.tSRestType = exports.tsRestType = tsRestType;
exports.tSSatisfiesExpression = exports.tsSatisfiesExpression = tsSatisfiesExpression;
exports.tSStringKeyword = exports.tsStringKeyword = tsStringKeyword;
exports.tSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;
exports.tSThisType = exports.tsThisType = tsThisType;
exports.tSTupleType = exports.tsTupleType = tsTupleType;
exports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
exports.tSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;
exports.tSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;
exports.tSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;
exports.tSTypeOperator = exports.tsTypeOperator = tsTypeOperator;
exports.tSTypeParameter = exports.tsTypeParameter = tsTypeParameter;
exports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
exports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
exports.tSTypePredicate = exports.tsTypePredicate = tsTypePredicate;
exports.tSTypeQuery = exports.tsTypeQuery = tsTypeQuery;
exports.tSTypeReference = exports.tsTypeReference = tsTypeReference;
exports.tSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;
exports.tSUnionType = exports.tsUnionType = tsUnionType;
exports.tSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;
exports.tSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;
exports.tupleExpression = tupleExpression;
exports.tupleTypeAnnotation = tupleTypeAnnotation;
exports.typeAlias = typeAlias;
exports.typeAnnotation = typeAnnotation;
exports.typeCastExpression = typeCastExpression;
exports.typeParameter = typeParameter;
exports.typeParameterDeclaration = typeParameterDeclaration;
exports.typeParameterInstantiation = typeParameterInstantiation;
exports.typeofTypeAnnotation = typeofTypeAnnotation;
exports.unaryExpression = unaryExpression;
exports.unionTypeAnnotation = unionTypeAnnotation;
exports.updateExpression = updateExpression;
exports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
exports.variableDeclaration = variableDeclaration;
exports.variableDeclarator = variableDeclarator;
exports.variance = variance;
exports.voidTypeAnnotation = voidTypeAnnotation;
exports.whileStatement = whileStatement;
exports.withStatement = withStatement;
exports.yieldExpression = yieldExpression;
var _validateNode = require(&quot;../validateNode&quot;);
var _deprecationWarning = require(&quot;../../utils/deprecationWarning&quot;);
function arrayExpression(elements = []) {
  return (0, _validateNode.default)({
    type: &quot;ArrayExpression&quot;,
    elements
  });
}
function assignmentExpression(operator, left, right) {
  return (0, _validateNode.default)({
    type: &quot;AssignmentExpression&quot;,
    operator,
    left,
    right
  });
}
function binaryExpression(operator, left, right) {
  return (0, _validateNode.default)({
    type: &quot;BinaryExpression&quot;,
    operator,
    left,
    right
  });
}
function interpreterDirective(value) {
  return (0, _validateNode.default)({
    type: &quot;InterpreterDirective&quot;,
    value
  });
}
function directive(value) {
  return (0, _validateNode.default)({
    type: &quot;Directive&quot;,
    value
  });
}
function directiveLiteral(value) {
  return (0, _validateNode.default)({
    type: &quot;DirectiveLiteral&quot;,
    value
  });
}
function blockStatement(body, directives = []) {
  return (0, _validateNode.default)({
    type: &quot;BlockStatement&quot;,
    body,
    directives
  });
}
function breakStatement(label = null) {
  return (0, _validateNode.default)({
    type: &quot;BreakStatement&quot;,
    label
  });
}
function callExpression(callee, _arguments) {
  return (0, _validateNode.default)({
    type: &quot;CallExpression&quot;,
    callee,
    arguments: _arguments
  });
}
function catchClause(param = null, body) {
  return (0, _validateNode.default)({
    type: &quot;CatchClause&quot;,
    param,
    body
  });
}
function conditionalExpression(test, consequent, alternate) {
  return (0, _validateNode.default)({
    type: &quot;ConditionalExpression&quot;,
    test,
    consequent,
    alternate
  });
}
function continueStatement(label = null) {
  return (0, _validateNode.default)({
    type: &quot;ContinueStatement&quot;,
    label
  });
}
function debuggerStatement() {
  return {
    type: &quot;DebuggerStatement&quot;
  };
}
function doWhileStatement(test, body) {
  return (0, _validateNode.default)({
    type: &quot;DoWhileStatement&quot;,
    test,
    body
  });
}
function emptyStatement() {
  return {
    type: &quot;EmptyStatement&quot;
  };
}
function expressionStatement(expression) {
  return (0, _validateNode.default)({
    type: &quot;ExpressionStatement&quot;,
    expression
  });
}
function file(program, comments = null, tokens = null) {
  return (0, _validateNode.default)({
    type: &quot;File&quot;,
    program,
    comments,
    tokens
  });
}
function forInStatement(left, right, body) {
  return (0, _validateNode.default)({
    type: &quot;ForInStatement&quot;,
    left,
    right,
    body
  });
}
function forStatement(init = null, test = null, update = null, body) {
  return (0, _validateNode.default)({
    type: &quot;ForStatement&quot;,
    init,
    test,
    update,
    body
  });
}
function functionDeclaration(id = null, params, body, generator = false, async = false) {
  return (0, _validateNode.default)({
    type: &quot;FunctionDeclaration&quot;,
    id,
    params,
    body,
    generator,
    async
  });
}
function functionExpression(id = null, params, body, generator = false, async = false) {
  return (0, _validateNode.default)({
    type: &quot;FunctionExpression&quot;,
    id,
    params,
    body,
    generator,
    async
  });
}
function identifier(name) {
  return (0, _validateNode.default)({
    type: &quot;Identifier&quot;,
    name
  });
}
function ifStatement(test, consequent, alternate = null) {
  return (0, _validateNode.default)({
    type: &quot;IfStatement&quot;,
    test,
    consequent,
    alternate
  });
}
function labeledStatement(label, body) {
  return (0, _validateNode.default)({
    type: &quot;LabeledStatement&quot;,
    label,
    body
  });
}
function stringLiteral(value) {
  return (0, _validateNode.default)({
    type: &quot;StringLiteral&quot;,
    value
  });
}
function numericLiteral(value) {
  return (0, _validateNode.default)({
    type: &quot;NumericLiteral&quot;,
    value
  });
}
function nullLiteral() {
  return {
    type: &quot;NullLiteral&quot;
  };
}
function booleanLiteral(value) {
  return (0, _validateNode.default)({
    type: &quot;BooleanLiteral&quot;,
    value
  });
}
function regExpLiteral(pattern, flags = &quot;&quot;) {
  return (0, _validateNode.default)({
    type: &quot;RegExpLiteral&quot;,
    pattern,
    flags
  });
}
function logicalExpression(operator, left, right) {
  return (0, _validateNode.default)({
    type: &quot;LogicalExpression&quot;,
    operator,
    left,
    right
  });
}
function memberExpression(object, property, computed = false, optional = null) {
  return (0, _validateNode.default)({
    type: &quot;MemberExpression&quot;,
    object,
    property,
    computed,
    optional
  });
}
function newExpression(callee, _arguments) {
  return (0, _validateNode.default)({
    type: &quot;NewExpression&quot;,
    callee,
    arguments: _arguments
  });
}
function program(body, directives = [], sourceType = &quot;script&quot;, interpreter = null) {
  return (0, _validateNode.default)({
    type: &quot;Program&quot;,
    body,
    directives,
    sourceType,
    interpreter,
    sourceFile: null
  });
}
function objectExpression(properties) {
  return (0, _validateNode.default)({
    type: &quot;ObjectExpression&quot;,
    properties
  });
}
function objectMethod(kind = &quot;method&quot;, key, params, body, computed = false, generator = false, async = false) {
  return (0, _validateNode.default)({
    type: &quot;ObjectMethod&quot;,
    kind,
    key,
    params,
    body,
    computed,
    generator,
    async
  });
}
function objectProperty(key, value, computed = false, shorthand = false, decorators = null) {
  return (0, _validateNode.default)({
    type: &quot;ObjectProperty&quot;,
    key,
    value,
    computed,
    shorthand,
    decorators
  });
}
function restElement(argument) {
  return (0, _validateNode.default)({
    type: &quot;RestElement&quot;,
    argument
  });
}
function returnStatement(argument = null) {
  return (0, _validateNode.default)({
    type: &quot;ReturnStatement&quot;,
    argument
  });
}
function sequenceExpression(expressions) {
  return (0, _validateNode.default)({
    type: &quot;SequenceExpression&quot;,
    expressions
  });
}
function parenthesizedExpression(expression) {
  return (0, _validateNode.default)({
    type: &quot;ParenthesizedExpression&quot;,
    expression
  });
}
function switchCase(test = null, consequent) {
  return (0, _validateNode.default)({
    type: &quot;SwitchCase&quot;,
    test,
    consequent
  });
}
function switchStatement(discriminant, cases) {
  return (0, _validateNode.default)({
    type: &quot;SwitchStatement&quot;,
    discriminant,
    cases
  });
}
function thisExpression() {
  return {
    type: &quot;ThisExpression&quot;
  };
}
function throwStatement(argument) {
  return (0, _validateNode.default)({
    type: &quot;ThrowStatement&quot;,
    argument
  });
}
function tryStatement(block, handler = null, finalizer = null) {
  return (0, _validateNode.default)({
    type: &quot;TryStatement&quot;,
    block,
    handler,
    finalizer
  });
}
function unaryExpression(operator, argument, prefix = true) {
  return (0, _validateNode.default)({
    type: &quot;UnaryExpression&quot;,
    operator,
    argument,
    prefix
  });
}
function updateExpression(operator, argument, prefix = false) {
  return (0, _validateNode.default)({
    type: &quot;UpdateExpression&quot;,
    operator,
    argument,
    prefix
  });
}
function variableDeclaration(kind, declarations) {
  return (0, _validateNode.default)({
    type: &quot;VariableDeclaration&quot;,
    kind,
    declarations
  });
}
function variableDeclarator(id, init = null) {
  return (0, _validateNode.default)({
    type: &quot;VariableDeclarator&quot;,
    id,
    init
  });
}
function whileStatement(test, body) {
  return (0, _validateNode.default)({
    type: &quot;WhileStatement&quot;,
    test,
    body
  });
}
function withStatement(object, body) {
  return (0, _validateNode.default)({
    type: &quot;WithStatement&quot;,
    object,
    body
  });
}
function assignmentPattern(left, right) {
  return (0, _validateNode.default)({
    type: &quot;AssignmentPattern&quot;,
    left,
    right
  });
}
function arrayPattern(elements) {
  return (0, _validateNode.default)({
    type: &quot;ArrayPattern&quot;,
    elements
  });
}
function arrowFunctionExpression(params, body, async = false) {
  return (0, _validateNode.default)({
    type: &quot;ArrowFunctionExpression&quot;,
    params,
    body,
    async,
    expression: null
  });
}
function classBody(body) {
  return (0, _validateNode.default)({
    type: &quot;ClassBody&quot;,
    body
  });
}
function classExpression(id = null, superClass = null, body, decorators = null) {
  return (0, _validateNode.default)({
    type: &quot;ClassExpression&quot;,
    id,
    superClass,
    body,
    decorators
  });
}
function classDeclaration(id, superClass = null, body, decorators = null) {
  return (0, _validateNode.default)({
    type: &quot;ClassDeclaration&quot;,
    id,
    superClass,
    body,
    decorators
  });
}
function exportAllDeclaration(source) {
  return (0, _validateNode.default)({
    type: &quot;ExportAllDeclaration&quot;,
    source
  });
}
function exportDefaultDeclaration(declaration) {
  return (0, _validateNode.default)({
    type: &quot;ExportDefaultDeclaration&quot;,
    declaration
  });
}
function exportNamedDeclaration(declaration = null, specifiers = [], source = null) {
  return (0, _validateNode.default)({
    type: &quot;ExportNamedDeclaration&quot;,
    declaration,
    specifiers,
    source
  });
}
function exportSpecifier(local, exported) {
  return (0, _validateNode.default)({
    type: &quot;ExportSpecifier&quot;,
    local,
    exported
  });
}
function forOfStatement(left, right, body, _await = false) {
  return (0, _validateNode.default)({
    type: &quot;ForOfStatement&quot;,
    left,
    right,
    body,
    await: _await
  });
}
function importDeclaration(specifiers, source) {
  return (0, _validateNode.default)({
    type: &quot;ImportDeclaration&quot;,
    specifiers,
    source
  });
}
function importDefaultSpecifier(local) {
  return (0, _validateNode.default)({
    type: &quot;ImportDefaultSpecifier&quot;,
    local
  });
}
function importNamespaceSpecifier(local) {
  return (0, _validateNode.default)({
    type: &quot;ImportNamespaceSpecifier&quot;,
    local
  });
}
function importSpecifier(local, imported) {
  return (0, _validateNode.default)({
    type: &quot;ImportSpecifier&quot;,
    local,
    imported
  });
}
function metaProperty(meta, property) {
  return (0, _validateNode.default)({
    type: &quot;MetaProperty&quot;,
    meta,
    property
  });
}
function classMethod(kind = &quot;method&quot;, key, params, body, computed = false, _static = false, generator = false, async = false) {
  return (0, _validateNode.default)({
    type: &quot;ClassMethod&quot;,
    kind,
    key,
    params,
    body,
    computed,
    static: _static,
    generator,
    async
  });
}
function objectPattern(properties) {
  return (0, _validateNode.default)({
    type: &quot;ObjectPattern&quot;,
    properties
  });
}
function spreadElement(argument) {
  return (0, _validateNode.default)({
    type: &quot;SpreadElement&quot;,
    argument
  });
}
function _super() {
  return {
    type: &quot;Super&quot;
  };
}
function taggedTemplateExpression(tag, quasi) {
  return (0, _validateNode.default)({
    type: &quot;TaggedTemplateExpression&quot;,
    tag,
    quasi
  });
}
function templateElement(value, tail = false) {
  return (0, _validateNode.default)({
    type: &quot;TemplateElement&quot;,
    value,
    tail
  });
}
function templateLiteral(quasis, expressions) {
  return (0, _validateNode.default)({
    type: &quot;TemplateLiteral&quot;,
    quasis,
    expressions
  });
}
function yieldExpression(argument = null, delegate = false) {
  return (0, _validateNode.default)({
    type: &quot;YieldExpression&quot;,
    argument,
    delegate
  });
}
function awaitExpression(argument) {
  return (0, _validateNode.default)({
    type: &quot;AwaitExpression&quot;,
    argument
  });
}
function _import() {
  return {
    type: &quot;Import&quot;
  };
}
function bigIntLiteral(value) {
  return (0, _validateNode.default)({
    type: &quot;BigIntLiteral&quot;,
    value
  });
}
function exportNamespaceSpecifier(exported) {
  return (0, _validateNode.default)({
    type: &quot;ExportNamespaceSpecifier&quot;,
    exported
  });
}
function optionalMemberExpression(object, property, computed = false, optional) {
  return (0, _validateNode.default)({
    type: &quot;OptionalMemberExpression&quot;,
    object,
    property,
    computed,
    optional
  });
}
function optionalCallExpression(callee, _arguments, optional) {
  return (0, _validateNode.default)({
    type: &quot;OptionalCallExpression&quot;,
    callee,
    arguments: _arguments,
    optional
  });
}
function classProperty(key, value = null, typeAnnotation = null, decorators = null, computed = false, _static = false) {
  return (0, _validateNode.default)({
    type: &quot;ClassProperty&quot;,
    key,
    value,
    typeAnnotation,
    decorators,
    computed,
    static: _static
  });
}
function classAccessorProperty(key, value = null, typeAnnotation = null, decorators = null, computed = false, _static = false) {
  return (0, _validateNode.default)({
    type: &quot;ClassAccessorProperty&quot;,
    key,
    value,
    typeAnnotation,
    decorators,
    computed,
    static: _static
  });
}
function classPrivateProperty(key, value = null, decorators = null, _static = false) {
  return (0, _validateNode.default)({
    type: &quot;ClassPrivateProperty&quot;,
    key,
    value,
    decorators,
    static: _static
  });
}
function classPrivateMethod(kind = &quot;method&quot;, key, params, body, _static = false) {
  return (0, _validateNode.default)({
    type: &quot;ClassPrivateMethod&quot;,
    kind,
    key,
    params,
    body,
    static: _static
  });
}
function privateName(id) {
  return (0, _validateNode.default)({
    type: &quot;PrivateName&quot;,
    id
  });
}
function staticBlock(body) {
  return (0, _validateNode.default)({
    type: &quot;StaticBlock&quot;,
    body
  });
}
function anyTypeAnnotation() {
  return {
    type: &quot;AnyTypeAnnotation&quot;
  };
}
function arrayTypeAnnotation(elementType) {
  return (0, _validateNode.default)({
    type: &quot;ArrayTypeAnnotation&quot;,
    elementType
  });
}
function booleanTypeAnnotation() {
  return {
    type: &quot;BooleanTypeAnnotation&quot;
  };
}
function booleanLiteralTypeAnnotation(value) {
  return (0, _validateNode.default)({
    type: &quot;BooleanLiteralTypeAnnotation&quot;,
    value
  });
}
function nullLiteralTypeAnnotation() {
  return {
    type: &quot;NullLiteralTypeAnnotation&quot;
  };
}
function classImplements(id, typeParameters = null) {
  return (0, _validateNode.default)({
    type: &quot;ClassImplements&quot;,
    id,
    typeParameters
  });
}
function declareClass(id, typeParameters = null, _extends = null, body) {
  return (0, _validateNode.default)({
    type: &quot;DeclareClass&quot;,
    id,
    typeParameters,
    extends: _extends,
    body
  });
}
function declareFunction(id) {
  return (0, _validateNode.default)({
    type: &quot;DeclareFunction&quot;,
    id
  });
}
function declareInterface(id, typeParameters = null, _extends = null, body) {
  return (0, _validateNode.default)({
    type: &quot;DeclareInterface&quot;,
    id,
    typeParameters,
    extends: _extends,
    body
  });
}
function declareModule(id, body, kind = null) {
  return (0, _validateNode.default)({
    type: &quot;DeclareModule&quot;,
    id,
    body,
    kind
  });
}
function declareModuleExports(typeAnnotation) {
  return (0, _validateNode.default)({
    type: &quot;DeclareModuleExports&quot;,
    typeAnnotation
  });
}
function declareTypeAlias(id, typeParameters = null, right) {
  return (0, _validateNode.default)({
    type: &quot;DeclareTypeAlias&quot;,
    id,
    typeParameters,
    right
  });
}
function declareOpaqueType(id, typeParameters = null, supertype = null) {
  return (0, _validateNode.default)({
    type: &quot;DeclareOpaqueType&quot;,
    id,
    typeParameters,
    supertype
  });
}
function declareVariable(id) {
  return (0, _validateNode.default)({
    type: &quot;DeclareVariable&quot;,
    id
  });
}
function declareExportDeclaration(declaration = null, specifiers = null, source = null) {
  return (0, _validateNode.default)({
    type: &quot;DeclareExportDeclaration&quot;,
    declaration,
    specifiers,
    source
  });
}
function declareExportAllDeclaration(source) {
  return (0, _validateNode.default)({
    type: &quot;DeclareExportAllDeclaration&quot;,
    source
  });
}
function declaredPredicate(value) {
  return (0, _validateNode.default)({
    type: &quot;DeclaredPredicate&quot;,
    value
  });
}
function existsTypeAnnotation() {
  return {
    type: &quot;ExistsTypeAnnotation&quot;
  };
}
function functionTypeAnnotation(typeParameters = null, params, rest = null, returnType) {
  return (0, _validateNode.default)({
    type: &quot;FunctionTypeAnnotation&quot;,
    typeParameters,
    params,
    rest,
    returnType
  });
}
function functionTypeParam(name = null, typeAnnotation) {
  return (0, _validateNode.default)({
    type: &quot;FunctionTypeParam&quot;,
    name,
    typeAnnotation
  });
}
function genericTypeAnnotation(id, typeParameters = null) {
  return (0, _validateNode.default)({
    type: &quot;GenericTypeAnnotation&quot;,
    id,
    typeParameters
  });
}
function inferredPredicate() {
  return {
    type: &quot;InferredPredicate&quot;
  };
}
function interfaceExtends(id, typeParameters = null) {
  return (0, _validateNode.default)({
    type: &quot;InterfaceExtends&quot;,
    id,
    typeParameters
  });
}
function interfaceDeclaration(id, typeParameters = null, _extends = null, body) {
  return (0, _validateNode.default)({
    type: &quot;InterfaceDeclaration&quot;,
    id,
    typeParameters,
    extends: _extends,
    body
  });
}
function interfaceTypeAnnotation(_extends = null, body) {
  return (0, _validateNode.default)({
    type: &quot;InterfaceTypeAnnotation&quot;,
    extends: _extends,
    body
  });
}
function intersectionTypeAnnotation(types) {
  return (0, _validateNode.default)({
    type: &quot;IntersectionTypeAnnotation&quot;,
    types
  });
}
function mixedTypeAnnotation() {
  return {
    type: &quot;MixedTypeAnnotation&quot;
  };
}
function emptyTypeAnnotation() {
  return {
    type: &quot;EmptyTypeAnnotation&quot;
  };
}
function nullableTypeAnnotation(typeAnnotation) {
  return (0, _validateNode.default)({
    type: &quot;NullableTypeAnnotation&quot;,
    typeAnnotation
  });
}
function numberLiteralTypeAnnotation(value) {
  return (0, _validateNode.default)({
    type: &quot;NumberLiteralTypeAnnotation&quot;,
    value
  });
}
function numberTypeAnnotation() {
  return {
    type: &quot;NumberTypeAnnotation&quot;
  };
}
function objectTypeAnnotation(properties, indexers = [], callProperties = [], internalSlots = [], exact = false) {
  return (0, _validateNode.default)({
    type: &quot;ObjectTypeAnnotation&quot;,
    properties,
    indexers,
    callProperties,
    internalSlots,
    exact
  });
}
function objectTypeInternalSlot(id, value, optional, _static, method) {
  return (0, _validateNode.default)({
    type: &quot;ObjectTypeInternalSlot&quot;,
    id,
    value,
    optional,
    static: _static,
    method
  });
}
function objectTypeCallProperty(value) {
  return (0, _validateNode.default)({
    type: &quot;ObjectTypeCallProperty&quot;,
    value,
    static: null
  });
}
function objectTypeIndexer(id = null, key, value, variance = null) {
  return (0, _validateNode.default)({
    type: &quot;ObjectTypeIndexer&quot;,
    id,
    key,
    value,
    variance,
    static: null
  });
}
function objectTypeProperty(key, value, variance = null) {
  return (0, _validateNode.default)({
    type: &quot;ObjectTypeProperty&quot;,
    key,
    value,
    variance,
    kind: null,
    method: null,
    optional: null,
    proto: null,
    static: null
  });
}
function objectTypeSpreadProperty(argument) {
  return (0, _validateNode.default)({
    type: &quot;ObjectTypeSpreadProperty&quot;,
    argument
  });
}
function opaqueType(id, typeParameters = null, supertype = null, impltype) {
  return (0, _validateNode.default)({
    type: &quot;OpaqueType&quot;,
    id,
    typeParameters,
    supertype,
    impltype
  });
}
function qualifiedTypeIdentifier(id, qualification) {
  return (0, _validateNode.default)({
    type: &quot;QualifiedTypeIdentifier&quot;,
    id,
    qualification
  });
}
function stringLiteralTypeAnnotation(value) {
  return (0, _validateNode.default)({
    type: &quot;StringLiteralTypeAnnotation&quot;,
    value
  });
}
function stringTypeAnnotation() {
  return {
    type: &quot;StringTypeAnnotation&quot;
  };
}
function symbolTypeAnnotation() {
  return {
    type: &quot;SymbolTypeAnnotation&quot;
  };
}
function thisTypeAnnotation() {
  return {
    type: &quot;ThisTypeAnnotation&quot;
  };
}
function tupleTypeAnnotation(types) {
  return (0, _validateNode.default)({
    type: &quot;TupleTypeAnnotation&quot;,
    types
  });
}
function typeofTypeAnnotation(argument) {
  return (0, _validateNode.default)({
    type: &quot;TypeofTypeAnnotation&quot;,
    argument
  });
}
function typeAlias(id, typeParameters = null, right) {
  return (0, _validateNode.default)({
    type: &quot;TypeAlias&quot;,
    id,
    typeParameters,
    right
  });
}
function typeAnnotation(typeAnnotation) {
  return (0, _validateNode.default)({
    type: &quot;TypeAnnotation&quot;,
    typeAnnotation
  });
}
function typeCastExpression(expression, typeAnnotation) {
  return (0, _validateNode.default)({
    type: &quot;TypeCastExpression&quot;,
    expression,
    typeAnnotation
  });
}
function typeParameter(bound = null, _default = null, variance = null) {
  return (0, _validateNode.default)({
    type: &quot;TypeParameter&quot;,
    bound,
    default: _default,
    variance,
    name: null
  });
}
function typeParameterDeclaration(params) {
  return (0, _validateNode.default)({
    type: &quot;TypeParameterDeclaration&quot;,
    params
  });
}
function typeParameterInstantiation(params) {
  return (0, _validateNode.default)({
    type: &quot;TypeParameterInstantiation&quot;,
    params
  });
}
function unionTypeAnnotation(types) {
  return (0, _validateNode.default)({
    type: &quot;UnionTypeAnnotation&quot;,
    types
  });
}
function variance(kind) {
  return (0, _validateNode.default)({
    type: &quot;Variance&quot;,
    kind
  });
}
function voidTypeAnnotation() {
  return {
    type: &quot;VoidTypeAnnotation&quot;
  };
}
function enumDeclaration(id, body) {
  return (0, _validateNode.default)({
    type: &quot;EnumDeclaration&quot;,
    id,
    body
  });
}
function enumBooleanBody(members) {
  return (0, _validateNode.default)({
    type: &quot;EnumBooleanBody&quot;,
    members,
    explicitType: null,
    hasUnknownMembers: null
  });
}
function enumNumberBody(members) {
  return (0, _validateNode.default)({
    type: &quot;EnumNumberBody&quot;,
    members,
    explicitType: null,
    hasUnknownMembers: null
  });
}
function enumStringBody(members) {
  return (0, _validateNode.default)({
    type: &quot;EnumStringBody&quot;,
    members,
    explicitType: null,
    hasUnknownMembers: null
  });
}
function enumSymbolBody(members) {
  return (0, _validateNode.default)({
    type: &quot;EnumSymbolBody&quot;,
    members,
    hasUnknownMembers: null
  });
}
function enumBooleanMember(id) {
  return (0, _validateNode.default)({
    type: &quot;EnumBooleanMember&quot;,
    id,
    init: null
  });
}
function enumNumberMember(id, init) {
  return (0, _validateNode.default)({
    type: &quot;EnumNumberMember&quot;,
    id,
    init
  });
}
function enumStringMember(id, init) {
  return (0, _validateNode.default)({
    type: &quot;EnumStringMember&quot;,
    id,
    init
  });
}
function enumDefaultedMember(id) {
  return (0, _validateNode.default)({
    type: &quot;EnumDefaultedMember&quot;,
    id
  });
}
function indexedAccessType(objectType, indexType) {
  return (0, _validateNode.default)({
    type: &quot;IndexedAccessType&quot;,
    objectType,
    indexType
  });
}
function optionalIndexedAccessType(objectType, indexType) {
  return (0, _validateNode.default)({
    type: &quot;OptionalIndexedAccessType&quot;,
    objectType,
    indexType,
    optional: null
  });
}
function jsxAttribute(name, value = null) {
  return (0, _validateNode.default)({
    type: &quot;JSXAttribute&quot;,
    name,
    value
  });
}
function jsxClosingElement(name) {
  return (0, _validateNode.default)({
    type: &quot;JSXClosingElement&quot;,
    name
  });
}
function jsxElement(openingElement, closingElement = null, children, selfClosing = null) {
  return (0, _validateNode.default)({
    type: &quot;JSXElement&quot;,
    openingElement,
    closingElement,
    children,
    selfClosing
  });
}
function jsxEmptyExpression() {
  return {
    type: &quot;JSXEmptyExpression&quot;
  };
}
function jsxExpressionContainer(expression) {
  return (0, _validateNode.default)({
    type: &quot;JSXExpressionContainer&quot;,
    expression
  });
}
function jsxSpreadChild(expression) {
  return (0, _validateNode.default)({
    type: &quot;JSXSpreadChild&quot;,
    expression
  });
}
function jsxIdentifier(name) {
  return (0, _validateNode.default)({
    type: &quot;JSXIdentifier&quot;,
    name
  });
}
function jsxMemberExpression(object, property) {
  return (0, _validateNode.default)({
    type: &quot;JSXMemberExpression&quot;,
    object,
    property
  });
}
function jsxNamespacedName(namespace, name) {
  return (0, _validateNode.default)({
    type: &quot;JSXNamespacedName&quot;,
    namespace,
    name
  });
}
function jsxOpeningElement(name, attributes, selfClosing = false) {
  return (0, _validateNode.default)({
    type: &quot;JSXOpeningElement&quot;,
    name,
    attributes,
    selfClosing
  });
}
function jsxSpreadAttribute(argument) {
  return (0, _validateNode.default)({
    type: &quot;JSXSpreadAttribute&quot;,
    argument
  });
}
function jsxText(value) {
  return (0, _validateNode.default)({
    type: &quot;JSXText&quot;,
    value
  });
}
function jsxFragment(openingFragment, closingFragment, children) {
  return (0, _validateNode.default)({
    type: &quot;JSXFragment&quot;,
    openingFragment,
    closingFragment,
    children
  });
}
function jsxOpeningFragment() {
  return {
    type: &quot;JSXOpeningFragment&quot;
  };
}
function jsxClosingFragment() {
  return {
    type: &quot;JSXClosingFragment&quot;
  };
}
function noop() {
  return {
    type: &quot;Noop&quot;
  };
}
function placeholder(expectedNode, name) {
  return (0, _validateNode.default)({
    type: &quot;Placeholder&quot;,
    expectedNode,
    name
  });
}
function v8IntrinsicIdentifier(name) {
  return (0, _validateNode.default)({
    type: &quot;V8IntrinsicIdentifier&quot;,
    name
  });
}
function argumentPlaceholder() {
  return {
    type: &quot;ArgumentPlaceholder&quot;
  };
}
function bindExpression(object, callee) {
  return (0, _validateNode.default)({
    type: &quot;BindExpression&quot;,
    object,
    callee
  });
}
function importAttribute(key, value) {
  return (0, _validateNode.default)({
    type: &quot;ImportAttribute&quot;,
    key,
    value
  });
}
function decorator(expression) {
  return (0, _validateNode.default)({
    type: &quot;Decorator&quot;,
    expression
  });
}
function doExpression(body, async = false) {
  return (0, _validateNode.default)({
    type: &quot;DoExpression&quot;,
    body,
    async
  });
}
function exportDefaultSpecifier(exported) {
  return (0, _validateNode.default)({
    type: &quot;ExportDefaultSpecifier&quot;,
    exported
  });
}
function recordExpression(properties) {
  return (0, _validateNode.default)({
    type: &quot;RecordExpression&quot;,
    properties
  });
}
function tupleExpression(elements = []) {
  return (0, _validateNode.default)({
    type: &quot;TupleExpression&quot;,
    elements
  });
}
function decimalLiteral(value) {
  return (0, _validateNode.default)({
    type: &quot;DecimalLiteral&quot;,
    value
  });
}
function moduleExpression(body) {
  return (0, _validateNode.default)({
    type: &quot;ModuleExpression&quot;,
    body
  });
}
function topicReference() {
  return {
    type: &quot;TopicReference&quot;
  };
}
function pipelineTopicExpression(expression) {
  return (0, _validateNode.default)({
    type: &quot;PipelineTopicExpression&quot;,
    expression
  });
}
function pipelineBareFunction(callee) {
  return (0, _validateNode.default)({
    type: &quot;PipelineBareFunction&quot;,
    callee
  });
}
function pipelinePrimaryTopicReference() {
  return {
    type: &quot;PipelinePrimaryTopicReference&quot;
  };
}
function tsParameterProperty(parameter) {
  return (0, _validateNode.default)({
    type: &quot;TSParameterProperty&quot;,
    parameter
  });
}
function tsDeclareFunction(id = null, typeParameters = null, params, returnType = null) {
  return (0, _validateNode.default)({
    type: &quot;TSDeclareFunction&quot;,
    id,
    typeParameters,
    params,
    returnType
  });
}
function tsDeclareMethod(decorators = null, key, typeParameters = null, params, returnType = null) {
  return (0, _validateNode.default)({
    type: &quot;TSDeclareMethod&quot;,
    decorators,
    key,
    typeParameters,
    params,
    returnType
  });
}
function tsQualifiedName(left, right) {
  return (0, _validateNode.default)({
    type: &quot;TSQualifiedName&quot;,
    left,
    right
  });
}
function tsCallSignatureDeclaration(typeParameters = null, parameters, typeAnnotation = null) {
  return (0, _validateNode.default)({
    type: &quot;TSCallSignatureDeclaration&quot;,
    typeParameters,
    parameters,
    typeAnnotation
  });
}
function tsConstructSignatureDeclaration(typeParameters = null, parameters, typeAnnotation = null) {
  return (0, _validateNode.default)({
    type: &quot;TSConstructSignatureDeclaration&quot;,
    typeParameters,
    parameters,
    typeAnnotation
  });
}
function tsPropertySignature(key, typeAnnotation = null, initializer = null) {
  return (0, _validateNode.default)({
    type: &quot;TSPropertySignature&quot;,
    key,
    typeAnnotation,
    initializer,
    kind: null
  });
}
function tsMethodSignature(key, typeParameters = null, parameters, typeAnnotation = null) {
  return (0, _validateNode.default)({
    type: &quot;TSMethodSignature&quot;,
    key,
    typeParameters,
    parameters,
    typeAnnotation,
    kind: null
  });
}
function tsIndexSignature(parameters, typeAnnotation = null) {
  return (0, _validateNode.default)({
    type: &quot;TSIndexSignature&quot;,
    parameters,
    typeAnnotation
  });
}
function tsAnyKeyword() {
  return {
    type: &quot;TSAnyKeyword&quot;
  };
}
function tsBooleanKeyword() {
  return {
    type: &quot;TSBooleanKeyword&quot;
  };
}
function tsBigIntKeyword() {
  return {
    type: &quot;TSBigIntKeyword&quot;
  };
}
function tsIntrinsicKeyword() {
  return {
    type: &quot;TSIntrinsicKeyword&quot;
  };
}
function tsNeverKeyword() {
  return {
    type: &quot;TSNeverKeyword&quot;
  };
}
function tsNullKeyword() {
  return {
    type: &quot;TSNullKeyword&quot;
  };
}
function tsNumberKeyword() {
  return {
    type: &quot;TSNumberKeyword&quot;
  };
}
function tsObjectKeyword() {
  return {
    type: &quot;TSObjectKeyword&quot;
  };
}
function tsStringKeyword() {
  return {
    type: &quot;TSStringKeyword&quot;
  };
}
function tsSymbolKeyword() {
  return {
    type: &quot;TSSymbolKeyword&quot;
  };
}
function tsUndefinedKeyword() {
  return {
    type: &quot;TSUndefinedKeyword&quot;
  };
}
function tsUnknownKeyword() {
  return {
    type: &quot;TSUnknownKeyword&quot;
  };
}
function tsVoidKeyword() {
  return {
    type: &quot;TSVoidKeyword&quot;
  };
}
function tsThisType() {
  return {
    type: &quot;TSThisType&quot;
  };
}
function tsFunctionType(typeParameters = null, parameters, typeAnnotation = null) {
  return (0, _validateNode.default)({
    type: &quot;TSFunctionType&quot;,
    typeParameters,
    parameters,
    typeAnnotation
  });
}
function tsConstructorType(typeParameters = null, parameters, typeAnnotation = null) {
  return (0, _validateNode.default)({
    type: &quot;TSConstructorType&quot;,
    typeParameters,
    parameters,
    typeAnnotation
  });
}
function tsTypeReference(typeName, typeParameters = null) {
  return (0, _validateNode.default)({
    type: &quot;TSTypeReference&quot;,
    typeName,
    typeParameters
  });
}
function tsTypePredicate(parameterName, typeAnnotation = null, asserts = null) {
  return (0, _validateNode.default)({
    type: &quot;TSTypePredicate&quot;,
    parameterName,
    typeAnnotation,
    asserts
  });
}
function tsTypeQuery(exprName, typeParameters = null) {
  return (0, _validateNode.default)({
    type: &quot;TSTypeQuery&quot;,
    exprName,
    typeParameters
  });
}
function tsTypeLiteral(members) {
  return (0, _validateNode.default)({
    type: &quot;TSTypeLiteral&quot;,
    members
  });
}
function tsArrayType(elementType) {
  return (0, _validateNode.default)({
    type: &quot;TSArrayType&quot;,
    elementType
  });
}
function tsTupleType(elementTypes) {
  return (0, _validateNode.default)({
    type: &quot;TSTupleType&quot;,
    elementTypes
  });
}
function tsOptionalType(typeAnnotation) {
  return (0, _validateNode.default)({
    type: &quot;TSOptionalType&quot;,
    typeAnnotation
  });
}
function tsRestType(typeAnnotation) {
  return (0, _validateNode.default)({
    type: &quot;TSRestType&quot;,
    typeAnnotation
  });
}
function tsNamedTupleMember(label, elementType, optional = false) {
  return (0, _validateNode.default)({
    type: &quot;TSNamedTupleMember&quot;,
    label,
    elementType,
    optional
  });
}
function tsUnionType(types) {
  return (0, _validateNode.default)({
    type: &quot;TSUnionType&quot;,
    types
  });
}
function tsIntersectionType(types) {
  return (0, _validateNode.default)({
    type: &quot;TSIntersectionType&quot;,
    types
  });
}
function tsConditionalType(checkType, extendsType, trueType, falseType) {
  return (0, _validateNode.default)({
    type: &quot;TSConditionalType&quot;,
    checkType,
    extendsType,
    trueType,
    falseType
  });
}
function tsInferType(typeParameter) {
  return (0, _validateNode.default)({
    type: &quot;TSInferType&quot;,
    typeParameter
  });
}
function tsParenthesizedType(typeAnnotation) {
  return (0, _validateNode.default)({
    type: &quot;TSParenthesizedType&quot;,
    typeAnnotation
  });
}
function tsTypeOperator(typeAnnotation) {
  return (0, _validateNode.default)({
    type: &quot;TSTypeOperator&quot;,
    typeAnnotation,
    operator: null
  });
}
function tsIndexedAccessType(objectType, indexType) {
  return (0, _validateNode.default)({
    type: &quot;TSIndexedAccessType&quot;,
    objectType,
    indexType
  });
}
function tsMappedType(typeParameter, typeAnnotation = null, nameType = null) {
  return (0, _validateNode.default)({
    type: &quot;TSMappedType&quot;,
    typeParameter,
    typeAnnotation,
    nameType
  });
}
function tsLiteralType(literal) {
  return (0, _validateNode.default)({
    type: &quot;TSLiteralType&quot;,
    literal
  });
}
function tsExpressionWithTypeArguments(expression, typeParameters = null) {
  return (0, _validateNode.default)({
    type: &quot;TSExpressionWithTypeArguments&quot;,
    expression,
    typeParameters
  });
}
function tsInterfaceDeclaration(id, typeParameters = null, _extends = null, body) {
  return (0, _validateNode.default)({
    type: &quot;TSInterfaceDeclaration&quot;,
    id,
    typeParameters,
    extends: _extends,
    body
  });
}
function tsInterfaceBody(body) {
  return (0, _validateNode.default)({
    type: &quot;TSInterfaceBody&quot;,
    body
  });
}
function tsTypeAliasDeclaration(id, typeParameters = null, typeAnnotation) {
  return (0, _validateNode.default)({
    type: &quot;TSTypeAliasDeclaration&quot;,
    id,
    typeParameters,
    typeAnnotation
  });
}
function tsInstantiationExpression(expression, typeParameters = null) {
  return (0, _validateNode.default)({
    type: &quot;TSInstantiationExpression&quot;,
    expression,
    typeParameters
  });
}
function tsAsExpression(expression, typeAnnotation) {
  return (0, _validateNode.default)({
    type: &quot;TSAsExpression&quot;,
    expression,
    typeAnnotation
  });
}
function tsSatisfiesExpression(expression, typeAnnotation) {
  return (0, _validateNode.default)({
    type: &quot;TSSatisfiesExpression&quot;,
    expression,
    typeAnnotation
  });
}
function tsTypeAssertion(typeAnnotation, expression) {
  return (0, _validateNode.default)({
    type: &quot;TSTypeAssertion&quot;,
    typeAnnotation,
    expression
  });
}
function tsEnumDeclaration(id, members) {
  return (0, _validateNode.default)({
    type: &quot;TSEnumDeclaration&quot;,
    id,
    members
  });
}
function tsEnumMember(id, initializer = null) {
  return (0, _validateNode.default)({
    type: &quot;TSEnumMember&quot;,
    id,
    initializer
  });
}
function tsModuleDeclaration(id, body) {
  return (0, _validateNode.default)({
    type: &quot;TSModuleDeclaration&quot;,
    id,
    body
  });
}
function tsModuleBlock(body) {
  return (0, _validateNode.default)({
    type: &quot;TSModuleBlock&quot;,
    body
  });
}
function tsImportType(argument, qualifier = null, typeParameters = null) {
  return (0, _validateNode.default)({
    type: &quot;TSImportType&quot;,
    argument,
    qualifier,
    typeParameters
  });
}
function tsImportEqualsDeclaration(id, moduleReference) {
  return (0, _validateNode.default)({
    type: &quot;TSImportEqualsDeclaration&quot;,
    id,
    moduleReference,
    isExport: null
  });
}
function tsExternalModuleReference(expression) {
  return (0, _validateNode.default)({
    type: &quot;TSExternalModuleReference&quot;,
    expression
  });
}
function tsNonNullExpression(expression) {
  return (0, _validateNode.default)({
    type: &quot;TSNonNullExpression&quot;,
    expression
  });
}
function tsExportAssignment(expression) {
  return (0, _validateNode.default)({
    type: &quot;TSExportAssignment&quot;,
    expression
  });
}
function tsNamespaceExportDeclaration(id) {
  return (0, _validateNode.default)({
    type: &quot;TSNamespaceExportDeclaration&quot;,
    id
  });
}
function tsTypeAnnotation(typeAnnotation) {
  return (0, _validateNode.default)({
    type: &quot;TSTypeAnnotation&quot;,
    typeAnnotation
  });
}
function tsTypeParameterInstantiation(params) {
  return (0, _validateNode.default)({
    type: &quot;TSTypeParameterInstantiation&quot;,
    params
  });
}
function tsTypeParameterDeclaration(params) {
  return (0, _validateNode.default)({
    type: &quot;TSTypeParameterDeclaration&quot;,
    params
  });
}
function tsTypeParameter(constraint = null, _default = null, name) {
  return (0, _validateNode.default)({
    type: &quot;TSTypeParameter&quot;,
    constraint,
    default: _default,
    name
  });
}
function NumberLiteral(value) {
  (0, _deprecationWarning.default)(&quot;NumberLiteral&quot;, &quot;NumericLiteral&quot;, &quot;The node type &quot;);
  return numericLiteral(value);
}
function RegexLiteral(pattern, flags = &quot;&quot;) {
  (0, _deprecationWarning.default)(&quot;RegexLiteral&quot;, &quot;RegExpLiteral&quot;, &quot;The node type &quot;);
  return regExpLiteral(pattern, flags);
}
function RestProperty(argument) {
  (0, _deprecationWarning.default)(&quot;RestProperty&quot;, &quot;RestElement&quot;, &quot;The node type &quot;);
  return restElement(argument);
}
function SpreadProperty(argument) {
  (0, _deprecationWarning.default)(&quot;SpreadProperty&quot;, &quot;SpreadElement&quot;, &quot;The node type &quot;);
  return spreadElement(argument);
}

//# sourceMappingURL=index.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
