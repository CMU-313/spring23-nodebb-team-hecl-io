<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-unnecessary-condition.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-unnecessary-condition.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">71.14</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">496</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">49.62</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.65</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
var __createBinding = (this &amp;&amp; this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (&quot;get&quot; in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this &amp;&amp; this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, &quot;default&quot;, { enumerable: true, value: v });
}) : function(o, v) {
    o[&quot;default&quot;] = v;
});
var __importStar = (this &amp;&amp; this.__importStar) || function (mod) {
    if (mod &amp;&amp; mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== &quot;default&quot; &amp;&amp; Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
const utils_1 = require(&quot;@typescript-eslint/utils&quot;);
const tsutils_1 = require(&quot;tsutils&quot;);
const ts = __importStar(require(&quot;typescript&quot;));
const util_1 = require(&quot;../util&quot;);
// Truthiness utilities
// #region
const isTruthyLiteral = (type) =&gt; (0, tsutils_1.isBooleanLiteralType)(type, true) || ((0, tsutils_1.isLiteralType)(type) &amp;&amp; !!type.value);
const isPossiblyFalsy = (type) =&gt; (0, tsutils_1.unionTypeParts)(type)
    // PossiblyFalsy flag includes literal values, so exclude ones that
    // are definitely truthy
    .filter(t =&gt; !isTruthyLiteral(t))
    .some(type =&gt; (0, util_1.isTypeFlagSet)(type, ts.TypeFlags.PossiblyFalsy));
const isPossiblyTruthy = (type) =&gt; (0, tsutils_1.unionTypeParts)(type).some(type =&gt; !(0, tsutils_1.isFalsyType)(type));
// Nullish utilities
const nullishFlag = ts.TypeFlags.Undefined | ts.TypeFlags.Null;
const isNullishType = (type) =&gt; (0, util_1.isTypeFlagSet)(type, nullishFlag);
const isPossiblyNullish = (type) =&gt; (0, tsutils_1.unionTypeParts)(type).some(isNullishType);
const isAlwaysNullish = (type) =&gt; (0, tsutils_1.unionTypeParts)(type).every(isNullishType);
// isLiteralType only covers numbers and strings, this is a more exhaustive check.
const isLiteral = (type) =&gt; (0, tsutils_1.isBooleanLiteralType)(type, true) ||
    (0, tsutils_1.isBooleanLiteralType)(type, false) ||
    type.flags === ts.TypeFlags.Undefined ||
    type.flags === ts.TypeFlags.Null ||
    type.flags === ts.TypeFlags.Void ||
    (0, tsutils_1.isLiteralType)(type);
exports.default = (0, util_1.createRule)({
    name: &#039;no-unnecessary-condition&#039;,
    meta: {
        type: &#039;suggestion&#039;,
        docs: {
            description: &#039;Disallow conditionals where the type is always truthy or always falsy&#039;,
            recommended: &#039;strict&#039;,
            requiresTypeChecking: true,
        },
        schema: [
            {
                type: &#039;object&#039;,
                properties: {
                    allowConstantLoopConditions: {
                        description: &#039;Whether to ignore constant loop conditions, such as `while (true)`.&#039;,
                        type: &#039;boolean&#039;,
                    },
                    allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: {
                        description: &#039;Whether to not error when running with a tsconfig that has strictNullChecks turned.&#039;,
                        type: &#039;boolean&#039;,
                    },
                },
                additionalProperties: false,
            },
        ],
        fixable: &#039;code&#039;,
        messages: {
            alwaysTruthy: &#039;Unnecessary conditional, value is always truthy.&#039;,
            alwaysFalsy: &#039;Unnecessary conditional, value is always falsy.&#039;,
            alwaysTruthyFunc: &#039;This callback should return a conditional, but return is always truthy.&#039;,
            alwaysFalsyFunc: &#039;This callback should return a conditional, but return is always falsy.&#039;,
            neverNullish: &#039;Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.&#039;,
            alwaysNullish: &#039;Unnecessary conditional, left-hand side of `??` operator is always `null` or `undefined`.&#039;,
            literalBooleanExpression: &#039;Unnecessary conditional, both sides of the expression are literal values.&#039;,
            noOverlapBooleanExpression: &#039;Unnecessary conditional, the types have no overlap.&#039;,
            never: &#039;Unnecessary conditional, value is `never`.&#039;,
            neverOptionalChain: &#039;Unnecessary optional chain on a non-nullish value.&#039;,
            noStrictNullCheck: &#039;This rule requires the `strictNullChecks` compiler option to be turned on to function correctly.&#039;,
        },
    },
    defaultOptions: [
        {
            allowConstantLoopConditions: false,
            allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: false,
        },
    ],
    create(context, [{ allowConstantLoopConditions, allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing, },]) {
        const service = (0, util_1.getParserServices)(context);
        const checker = service.program.getTypeChecker();
        const sourceCode = context.getSourceCode();
        const compilerOptions = service.program.getCompilerOptions();
        const isStrictNullChecks = (0, tsutils_1.isStrictCompilerOptionEnabled)(compilerOptions, &#039;strictNullChecks&#039;);
        if (!isStrictNullChecks &amp;&amp;
            allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing !== true) {
            context.report({
                loc: {
                    start: { line: 0, column: 0 },
                    end: { line: 0, column: 0 },
                },
                messageId: &#039;noStrictNullCheck&#039;,
            });
        }
        function getNodeType(node) {
            const tsNode = service.esTreeNodeToTSNodeMap.get(node);
            return (0, util_1.getConstrainedTypeAtLocation)(checker, tsNode);
        }
        function nodeIsArrayType(node) {
            const nodeType = getNodeType(node);
            return checker.isArrayType(nodeType);
        }
        function nodeIsTupleType(node) {
            const nodeType = getNodeType(node);
            return checker.isTupleType(nodeType);
        }
        function isArrayIndexExpression(node) {
            return (
            // Is an index signature
            node.type === utils_1.AST_NODE_TYPES.MemberExpression &amp;&amp;
                node.computed &amp;&amp;
                // ...into an array type
                (nodeIsArrayType(node.object) ||
                    // ... or a tuple type
                    (nodeIsTupleType(node.object) &amp;&amp;
                        // Exception: literal index into a tuple - will have a sound type
                        node.property.type !== utils_1.AST_NODE_TYPES.Literal)));
        }
        /**
         * Checks if a conditional node is necessary:
         * if the type of the node is always true or always false, it&#039;s not necessary.
         */
        function checkNode(node, isUnaryNotArgument = false) {
            // Check if the node is Unary Negation expression and handle it
            if (node.type === utils_1.AST_NODE_TYPES.UnaryExpression &amp;&amp;
                node.operator === &#039;!&#039;) {
                return checkNode(node.argument, true);
            }
            // Since typescript array index signature types don&#039;t represent the
            //  possibility of out-of-bounds access, if we&#039;re indexing into an array
            //  just skip the check, to avoid false positives
            if (isArrayIndexExpression(node)) {
                return;
            }
            // When checking logical expressions, only check the right side
            //  as the left side has been checked by checkLogicalExpressionForUnnecessaryConditionals
            //
            // Unless the node is nullish coalescing, as it&#039;s common to use patterns like `nullBool ?? true` to to strict
            //  boolean checks if we inspect the right here, it&#039;ll usually be a constant condition on purpose.
            // In this case it&#039;s better to inspect the type of the expression as a whole.
            if (node.type === utils_1.AST_NODE_TYPES.LogicalExpression &amp;&amp;
                node.operator !== &#039;??&#039;) {
                return checkNode(node.right);
            }
            const type = getNodeType(node);
            // Conditional is always necessary if it involves:
            //    `any` or `unknown` or a naked type variable
            if ((0, tsutils_1.unionTypeParts)(type).some(part =&gt; (0, util_1.isTypeAnyType)(part) ||
                (0, util_1.isTypeUnknownType)(part) ||
                (0, util_1.isTypeFlagSet)(part, ts.TypeFlags.TypeVariable))) {
                return;
            }
            let messageId = null;
            if ((0, util_1.isTypeFlagSet)(type, ts.TypeFlags.Never)) {
                messageId = &#039;never&#039;;
            }
            else if (!isPossiblyTruthy(type)) {
                messageId = !isUnaryNotArgument ? &#039;alwaysFalsy&#039; : &#039;alwaysTruthy&#039;;
            }
            else if (!isPossiblyFalsy(type)) {
                messageId = !isUnaryNotArgument ? &#039;alwaysTruthy&#039; : &#039;alwaysFalsy&#039;;
            }
            if (messageId) {
                context.report({ node, messageId });
            }
        }
        function checkNodeForNullish(node) {
            const type = getNodeType(node);
            // Conditional is always necessary if it involves `any` or `unknown`
            if ((0, util_1.isTypeAnyType)(type) || (0, util_1.isTypeUnknownType)(type)) {
                return;
            }
            let messageId = null;
            if ((0, util_1.isTypeFlagSet)(type, ts.TypeFlags.Never)) {
                messageId = &#039;never&#039;;
            }
            else if (!isPossiblyNullish(type)) {
                // Since typescript array index signature types don&#039;t represent the
                //  possibility of out-of-bounds access, if we&#039;re indexing into an array
                //  just skip the check, to avoid false positives
                if (!isArrayIndexExpression(node) &amp;&amp;
                    !(node.type === utils_1.AST_NODE_TYPES.ChainExpression &amp;&amp;
                        node.expression.type !== utils_1.AST_NODE_TYPES.TSNonNullExpression &amp;&amp;
                        optionChainContainsOptionArrayIndex(node.expression))) {
                    messageId = &#039;neverNullish&#039;;
                }
            }
            else if (isAlwaysNullish(type)) {
                messageId = &#039;alwaysNullish&#039;;
            }
            if (messageId) {
                context.report({ node, messageId });
            }
        }
        /**
         * Checks that a binary expression is necessarily conditional, reports otherwise.
         * If both sides of the binary expression are literal values, it&#039;s not a necessary condition.
         *
         * NOTE: It&#039;s also unnecessary if the types that don&#039;t overlap at all
         *    but that case is handled by the Typescript compiler itself.
         *    Known exceptions:
         *      * https://github.com/microsoft/TypeScript/issues/32627
         *      * https://github.com/microsoft/TypeScript/issues/37160 (handled)
         */
        const BOOL_OPERATORS = new Set([
            &#039;&lt;&#039;,
            &#039;&gt;&#039;,
            &#039;&lt;=&#039;,
            &#039;&gt;=&#039;,
            &#039;==&#039;,
            &#039;===&#039;,
            &#039;!=&#039;,
            &#039;!==&#039;,
        ]);
        function checkIfBinaryExpressionIsNecessaryConditional(node) {
            if (!BOOL_OPERATORS.has(node.operator)) {
                return;
            }
            const leftType = getNodeType(node.left);
            const rightType = getNodeType(node.right);
            if (isLiteral(leftType) &amp;&amp; isLiteral(rightType)) {
                context.report({ node, messageId: &#039;literalBooleanExpression&#039; });
                return;
            }
            // Workaround for https://github.com/microsoft/TypeScript/issues/37160
            if (isStrictNullChecks) {
                const UNDEFINED = ts.TypeFlags.Undefined;
                const NULL = ts.TypeFlags.Null;
                const VOID = ts.TypeFlags.Void;
                const isComparable = (type, flag) =&gt; {
                    // Allow comparison to `any`, `unknown` or a naked type parameter.
                    flag |=
                        ts.TypeFlags.Any |
                            ts.TypeFlags.Unknown |
                            ts.TypeFlags.TypeParameter;
                    // Allow loose comparison to nullish values.
                    if (node.operator === &#039;==&#039; || node.operator === &#039;!=&#039;) {
                        flag |= NULL | UNDEFINED | VOID;
                    }
                    return (0, util_1.isTypeFlagSet)(type, flag);
                };
                if ((leftType.flags === UNDEFINED &amp;&amp;
                    !isComparable(rightType, UNDEFINED | VOID)) ||
                    (rightType.flags === UNDEFINED &amp;&amp;
                        !isComparable(leftType, UNDEFINED | VOID)) ||
                    (leftType.flags === NULL &amp;&amp; !isComparable(rightType, NULL)) ||
                    (rightType.flags === NULL &amp;&amp; !isComparable(leftType, NULL))) {
                    context.report({ node, messageId: &#039;noOverlapBooleanExpression&#039; });
                    return;
                }
            }
        }
        /**
         * Checks that a logical expression contains a boolean, reports otherwise.
         */
        function checkLogicalExpressionForUnnecessaryConditionals(node) {
            if (node.operator === &#039;??&#039;) {
                checkNodeForNullish(node.left);
                return;
            }
            // Only checks the left side, since the right side might not be &quot;conditional&quot; at all.
            // The right side will be checked if the LogicalExpression is used in a conditional context
            checkNode(node.left);
        }
        /**
         * Checks that a testable expression of a loop is necessarily conditional, reports otherwise.
         */
        function checkIfLoopIsNecessaryConditional(node) {
            if (node.test == null) {
                // e.g. `for(;;)`
                return;
            }
            /**
             * Allow:
             *   while (true) {}
             *   for (;true;) {}
             *   do {} while (true)
             */
            if (allowConstantLoopConditions &amp;&amp;
                (0, tsutils_1.isBooleanLiteralType)(getNodeType(node.test), true)) {
                return;
            }
            checkNode(node.test);
        }
        const ARRAY_PREDICATE_FUNCTIONS = new Set([
            &#039;filter&#039;,
            &#039;find&#039;,
            &#039;some&#039;,
            &#039;every&#039;,
        ]);
        function isArrayPredicateFunction(node) {
            const { callee } = node;
            return (
            // looks like `something.filter` or `something.find`
            callee.type === utils_1.AST_NODE_TYPES.MemberExpression &amp;&amp;
                callee.property.type === utils_1.AST_NODE_TYPES.Identifier &amp;&amp;
                ARRAY_PREDICATE_FUNCTIONS.has(callee.property.name) &amp;&amp;
                // and the left-hand side is an array, according to the types
                (nodeIsArrayType(callee.object) || nodeIsTupleType(callee.object)));
        }
        function checkCallExpression(node) {
            // If this is something like arr.filter(x =&gt; /*condition*/), check `condition`
            if (isArrayPredicateFunction(node) &amp;&amp; node.arguments.length) {
                const callback = node.arguments[0];
                // Inline defined functions
                if ((callback.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression ||
                    callback.type === utils_1.AST_NODE_TYPES.FunctionExpression) &amp;&amp;
                    callback.body) {
                    // Two special cases, where we can directly check the node that&#039;s returned:
                    // () =&gt; something
                    if (callback.body.type !== utils_1.AST_NODE_TYPES.BlockStatement) {
                        return checkNode(callback.body);
                    }
                    // () =&gt; { return something; }
                    const callbackBody = callback.body.body;
                    if (callbackBody.length === 1 &amp;&amp;
                        callbackBody[0].type === utils_1.AST_NODE_TYPES.ReturnStatement &amp;&amp;
                        callbackBody[0].argument) {
                        return checkNode(callbackBody[0].argument);
                    }
                    // Potential enhancement: could use code-path analysis to check
                    //   any function with a single return statement
                    // (Value to complexity ratio is dubious however)
                }
                // Otherwise just do type analysis on the function as a whole.
                const returnTypes = (0, tsutils_1.getCallSignaturesOfType)(getNodeType(callback)).map(sig =&gt; sig.getReturnType());
                /* istanbul ignore if */ if (returnTypes.length === 0) {
                    // Not a callable function
                    return;
                }
                // Predicate is always necessary if it involves `any` or `unknown`
                if (returnTypes.some(t =&gt; (0, util_1.isTypeAnyType)(t) || (0, util_1.isTypeUnknownType)(t))) {
                    return;
                }
                if (!returnTypes.some(isPossiblyFalsy)) {
                    return context.report({
                        node: callback,
                        messageId: &#039;alwaysTruthyFunc&#039;,
                    });
                }
                if (!returnTypes.some(isPossiblyTruthy)) {
                    return context.report({
                        node: callback,
                        messageId: &#039;alwaysFalsyFunc&#039;,
                    });
                }
            }
        }
        // Recursively searches an optional chain for an array index expression
        //  Has to search the entire chain, because an array index will &quot;infect&quot; the rest of the types
        //  Example:
        //  ```
        //  [{x: {y: &quot;z&quot;} }][n] // type is {x: {y: &quot;z&quot;}}
        //    ?.x // type is {y: &quot;z&quot;}
        //    ?.y // This access is considered &quot;unnecessary&quot; according to the types
        //  ```
        function optionChainContainsOptionArrayIndex(node) {
            const lhsNode = node.type === utils_1.AST_NODE_TYPES.CallExpression ? node.callee : node.object;
            if (node.optional &amp;&amp; isArrayIndexExpression(lhsNode)) {
                return true;
            }
            if (lhsNode.type === utils_1.AST_NODE_TYPES.MemberExpression ||
                lhsNode.type === utils_1.AST_NODE_TYPES.CallExpression) {
                return optionChainContainsOptionArrayIndex(lhsNode);
            }
            return false;
        }
        function isNullablePropertyType(objType, propertyType) {
            if (propertyType.isUnion()) {
                return propertyType.types.some(type =&gt; isNullablePropertyType(objType, type));
            }
            if (propertyType.isNumberLiteral() || propertyType.isStringLiteral()) {
                const propType = (0, util_1.getTypeOfPropertyOfName)(checker, objType, propertyType.value.toString());
                if (propType) {
                    return (0, util_1.isNullableType)(propType, { allowUndefined: true });
                }
            }
            const typeName = (0, util_1.getTypeName)(checker, propertyType);
            return !!((typeName === &#039;string&#039; &amp;&amp;
                checker.getIndexInfoOfType(objType, ts.IndexKind.String)) ||
                (typeName === &#039;number&#039; &amp;&amp;
                    checker.getIndexInfoOfType(objType, ts.IndexKind.Number)));
        }
        // Checks whether a member expression is nullable or not regardless of it&#039;s previous node.
        //  Example:
        //  ```
        //  // &#039;bar&#039; is nullable if &#039;foo&#039; is null.
        //  // but this function checks regardless of &#039;foo&#039; type, so returns &#039;true&#039;.
        //  declare const foo: { bar : { baz: string } } | null
        //  foo?.bar;
        //  ```
        function isNullableOriginFromPrev(node) {
            const prevType = getNodeType(node.object);
            const property = node.property;
            if (prevType.isUnion() &amp;&amp; (0, util_1.isIdentifier)(property)) {
                const isOwnNullable = prevType.types.some(type =&gt; {
                    if (node.computed) {
                        const propertyType = getNodeType(node.property);
                        return isNullablePropertyType(type, propertyType);
                    }
                    const propType = (0, util_1.getTypeOfPropertyOfName)(checker, type, property.name);
                    if (propType) {
                        return (0, util_1.isNullableType)(propType, { allowUndefined: true });
                    }
                    return !!checker.getIndexInfoOfType(type, ts.IndexKind.String);
                });
                return (!isOwnNullable &amp;&amp; (0, util_1.isNullableType)(prevType, { allowUndefined: true }));
            }
            return false;
        }
        function isOptionableExpression(node) {
            const type = getNodeType(node);
            const isOwnNullable = node.type === utils_1.AST_NODE_TYPES.MemberExpression
                ? !isNullableOriginFromPrev(node)
                : true;
            const possiblyVoid = (0, util_1.isTypeFlagSet)(type, ts.TypeFlags.Void);
            return ((0, util_1.isTypeFlagSet)(type, ts.TypeFlags.Any | ts.TypeFlags.Unknown) ||
                (isOwnNullable &amp;&amp;
                    ((0, util_1.isNullableType)(type, { allowUndefined: true }) || possiblyVoid)));
        }
        function checkOptionalChain(node, beforeOperator, fix) {
            // We only care if this step in the chain is optional. If just descend
            // from an optional chain, then that&#039;s fine.
            if (!node.optional) {
                return;
            }
            // Since typescript array index signature types don&#039;t represent the
            //  possibility of out-of-bounds access, if we&#039;re indexing into an array
            //  just skip the check, to avoid false positives
            if (optionChainContainsOptionArrayIndex(node)) {
                return;
            }
            const nodeToCheck = node.type === utils_1.AST_NODE_TYPES.CallExpression ? node.callee : node.object;
            if (isOptionableExpression(nodeToCheck)) {
                return;
            }
            const questionDotOperator = (0, util_1.nullThrows)(sourceCode.getTokenAfter(beforeOperator, token =&gt; token.type === utils_1.AST_TOKEN_TYPES.Punctuator &amp;&amp; token.value === &#039;?.&#039;), util_1.NullThrowsReasons.MissingToken(&#039;operator&#039;, node.type));
            context.report({
                node,
                loc: questionDotOperator.loc,
                messageId: &#039;neverOptionalChain&#039;,
                fix(fixer) {
                    return fixer.replaceText(questionDotOperator, fix);
                },
            });
        }
        function checkOptionalMemberExpression(node) {
            checkOptionalChain(node, node.object, node.computed ? &#039;&#039; : &#039;.&#039;);
        }
        function checkOptionalCallExpression(node) {
            checkOptionalChain(node, node.callee, &#039;&#039;);
        }
        function checkAssignmentExpression(node) {
            // Similar to checkLogicalExpressionForUnnecessaryConditionals, since
            // a ||= b is equivalent to a || (a = b)
            if ([&#039;||=&#039;, &#039;&amp;&amp;=&#039;].includes(node.operator)) {
                checkNode(node.left);
            }
            else if (node.operator === &#039;??=&#039;) {
                checkNodeForNullish(node.left);
            }
        }
        return {
            AssignmentExpression: checkAssignmentExpression,
            BinaryExpression: checkIfBinaryExpressionIsNecessaryConditional,
            CallExpression: checkCallExpression,
            ConditionalExpression: (node) =&gt; checkNode(node.test),
            DoWhileStatement: checkIfLoopIsNecessaryConditional,
            ForStatement: checkIfLoopIsNecessaryConditional,
            IfStatement: (node) =&gt; checkNode(node.test),
            LogicalExpression: checkLogicalExpressionForUnnecessaryConditionals,
            WhileStatement: checkIfLoopIsNecessaryConditional,
            &#039;MemberExpression[optional = true]&#039;: checkOptionalMemberExpression,
            &#039;CallExpression[optional = true]&#039;: checkOptionalCallExpression,
        };
    },
});
//# sourceMappingURL=no-unnecessary-condition.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
