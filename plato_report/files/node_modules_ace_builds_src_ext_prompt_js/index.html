<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/ace-builds/src/ext-prompt.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/ace-builds/src/ext-prompt.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">62.61</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">2538</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">129.93</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">48.31</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">define(&quot;ace/ext/menu_tools/get_editor_keyboard_shortcuts&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/keys&quot;], function(require, exports, module){/*jslint indent: 4, maxerr: 50, white: true, browser: true, vars: true*/
&quot;use strict&quot;;
var keys = require(&quot;../../lib/keys&quot;);
module.exports.getEditorKeybordShortcuts = function (editor) {
    var KEY_MODS = keys.KEY_MODS;
    var keybindings = [];
    var commandMap = {};
    editor.keyBinding.$handlers.forEach(function (handler) {
        var ckb = handler.commandKeyBinding;
        for (var i in ckb) {
            var key = i.replace(/(^|-)\w/g, function (x) { return x.toUpperCase(); });
            var commands = ckb[i];
            if (!Array.isArray(commands))
                commands = [commands];
            commands.forEach(function (command) {
                if (typeof command != &quot;string&quot;)
                    command = command.name;
                if (commandMap[command]) {
                    commandMap[command].key += &quot;|&quot; + key;
                }
                else {
                    commandMap[command] = { key: key, command: command };
                    keybindings.push(commandMap[command]);
                }
            });
        }
    });
    return keybindings;
};

});

define(&quot;ace/autocomplete/popup&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/virtual_renderer&quot;,&quot;ace/editor&quot;,&quot;ace/range&quot;,&quot;ace/lib/event&quot;,&quot;ace/lib/lang&quot;,&quot;ace/lib/dom&quot;], function(require, exports, module){&quot;use strict&quot;;
var Renderer = require(&quot;../virtual_renderer&quot;).VirtualRenderer;
var Editor = require(&quot;../editor&quot;).Editor;
var Range = require(&quot;../range&quot;).Range;
var event = require(&quot;../lib/event&quot;);
var lang = require(&quot;../lib/lang&quot;);
var dom = require(&quot;../lib/dom&quot;);
var getAriaId = function (index) {
    return &quot;suggest-aria-id:&quot;.concat(index);
};
var $singleLineEditor = function (el) {
    var renderer = new Renderer(el);
    renderer.$maxLines = 4;
    var editor = new Editor(renderer);
    editor.setHighlightActiveLine(false);
    editor.setShowPrintMargin(false);
    editor.renderer.setShowGutter(false);
    editor.renderer.setHighlightGutterLine(false);
    editor.$mouseHandler.$focusTimeout = 0;
    editor.$highlightTagPending = true;
    return editor;
};
var AcePopup = function (parentNode) {
    var el = dom.createElement(&quot;div&quot;);
    var popup = new $singleLineEditor(el);
    if (parentNode)
        parentNode.appendChild(el);
    el.style.display = &quot;none&quot;;
    popup.renderer.content.style.cursor = &quot;default&quot;;
    popup.renderer.setStyle(&quot;ace_autocomplete&quot;);
    popup.renderer.container.setAttribute(&quot;role&quot;, &quot;listbox&quot;);
    popup.renderer.container.setAttribute(&quot;aria-label&quot;, &quot;Autocomplete suggestions&quot;);
    popup.setOption(&quot;displayIndentGuides&quot;, false);
    popup.setOption(&quot;dragDelay&quot;, 150);
    var noop = function () { };
    popup.focus = noop;
    popup.$isFocused = true;
    popup.renderer.$cursorLayer.restartTimer = noop;
    popup.renderer.$cursorLayer.element.style.opacity = 0;
    popup.renderer.$maxLines = 8;
    popup.renderer.$keepTextAreaAtCursor = false;
    popup.setHighlightActiveLine(false);
    popup.session.highlight(&quot;&quot;);
    popup.session.$searchHighlight.clazz = &quot;ace_highlight-marker&quot;;
    popup.on(&quot;mousedown&quot;, function (e) {
        var pos = e.getDocumentPosition();
        popup.selection.moveToPosition(pos);
        selectionMarker.start.row = selectionMarker.end.row = pos.row;
        e.stop();
    });
    var lastMouseEvent;
    var hoverMarker = new Range(-1, 0, -1, Infinity);
    var selectionMarker = new Range(-1, 0, -1, Infinity);
    selectionMarker.id = popup.session.addMarker(selectionMarker, &quot;ace_active-line&quot;, &quot;fullLine&quot;);
    popup.setSelectOnHover = function (val) {
        if (!val) {
            hoverMarker.id = popup.session.addMarker(hoverMarker, &quot;ace_line-hover&quot;, &quot;fullLine&quot;);
        }
        else if (hoverMarker.id) {
            popup.session.removeMarker(hoverMarker.id);
            hoverMarker.id = null;
        }
    };
    popup.setSelectOnHover(false);
    popup.on(&quot;mousemove&quot;, function (e) {
        if (!lastMouseEvent) {
            lastMouseEvent = e;
            return;
        }
        if (lastMouseEvent.x == e.x &amp;&amp; lastMouseEvent.y == e.y) {
            return;
        }
        lastMouseEvent = e;
        lastMouseEvent.scrollTop = popup.renderer.scrollTop;
        var row = lastMouseEvent.getDocumentPosition().row;
        if (hoverMarker.start.row != row) {
            if (!hoverMarker.id)
                popup.setRow(row);
            setHoverMarker(row);
        }
    });
    popup.renderer.on(&quot;beforeRender&quot;, function () {
        if (lastMouseEvent &amp;&amp; hoverMarker.start.row != -1) {
            lastMouseEvent.$pos = null;
            var row = lastMouseEvent.getDocumentPosition().row;
            if (!hoverMarker.id)
                popup.setRow(row);
            setHoverMarker(row, true);
        }
    });
    popup.renderer.on(&quot;afterRender&quot;, function () {
        var row = popup.getRow();
        var t = popup.renderer.$textLayer;
        var selected = t.element.childNodes[row - t.config.firstRow];
        var el = document.activeElement; // Active element is textarea of main editor
        if (selected !== t.selectedNode &amp;&amp; t.selectedNode) {
            dom.removeCssClass(t.selectedNode, &quot;ace_selected&quot;);
            el.removeAttribute(&quot;aria-activedescendant&quot;);
            t.selectedNode.removeAttribute(&quot;id&quot;);
        }
        t.selectedNode = selected;
        if (selected) {
            dom.addCssClass(selected, &quot;ace_selected&quot;);
            var ariaId = getAriaId(row);
            selected.id = ariaId;
            popup.renderer.container.setAttribute(&quot;aria-activedescendant&quot;, ariaId);
            el.setAttribute(&quot;aria-activedescendant&quot;, ariaId);
            selected.setAttribute(&quot;aria-label&quot;, popup.getData(row).value);
        }
    });
    var hideHoverMarker = function () { setHoverMarker(-1); };
    var setHoverMarker = function (row, suppressRedraw) {
        if (row !== hoverMarker.start.row) {
            hoverMarker.start.row = hoverMarker.end.row = row;
            if (!suppressRedraw)
                popup.session._emit(&quot;changeBackMarker&quot;);
            popup._emit(&quot;changeHoverMarker&quot;);
        }
    };
    popup.getHoveredRow = function () {
        return hoverMarker.start.row;
    };
    event.addListener(popup.container, &quot;mouseout&quot;, hideHoverMarker);
    popup.on(&quot;hide&quot;, hideHoverMarker);
    popup.on(&quot;changeSelection&quot;, hideHoverMarker);
    popup.session.doc.getLength = function () {
        return popup.data.length;
    };
    popup.session.doc.getLine = function (i) {
        var data = popup.data[i];
        if (typeof data == &quot;string&quot;)
            return data;
        return (data &amp;&amp; data.value) || &quot;&quot;;
    };
    var bgTokenizer = popup.session.bgTokenizer;
    bgTokenizer.$tokenizeRow = function (row) {
        var data = popup.data[row];
        var tokens = [];
        if (!data)
            return tokens;
        if (typeof data == &quot;string&quot;)
            data = { value: data };
        var caption = data.caption || data.value || data.name;
        function addToken(value, className) {
            value &amp;&amp; tokens.push({
                type: (data.className || &quot;&quot;) + (className || &quot;&quot;),
                value: value
            });
        }
        var lower = caption.toLowerCase();
        var filterText = (popup.filterText || &quot;&quot;).toLowerCase();
        var lastIndex = 0;
        var lastI = 0;
        for (var i = 0; i &lt;= filterText.length; i++) {
            if (i != lastI &amp;&amp; (data.matchMask &amp; (1 &lt;&lt; i) || i == filterText.length)) {
                var sub = filterText.slice(lastI, i);
                lastI = i;
                var index = lower.indexOf(sub, lastIndex);
                if (index == -1)
                    continue;
                addToken(caption.slice(lastIndex, index), &quot;&quot;);
                lastIndex = index + sub.length;
                addToken(caption.slice(index, lastIndex), &quot;completion-highlight&quot;);
            }
        }
        addToken(caption.slice(lastIndex, caption.length), &quot;&quot;);
        if (data.meta)
            tokens.push({ type: &quot;completion-meta&quot;, value: data.meta });
        if (data.message)
            tokens.push({ type: &quot;completion-message&quot;, value: data.message });
        return tokens;
    };
    bgTokenizer.$updateOnChange = noop;
    bgTokenizer.start = noop;
    popup.session.$computeWidth = function () {
        return this.screenWidth = 0;
    };
    popup.isOpen = false;
    popup.isTopdown = false;
    popup.autoSelect = true;
    popup.filterText = &quot;&quot;;
    popup.data = [];
    popup.setData = function (list, filterText) {
        popup.filterText = filterText || &quot;&quot;;
        popup.setValue(lang.stringRepeat(&quot;\n&quot;, list.length), -1);
        popup.data = list || [];
        popup.setRow(0);
    };
    popup.getData = function (row) {
        return popup.data[row];
    };
    popup.getRow = function () {
        return selectionMarker.start.row;
    };
    popup.setRow = function (line) {
        line = Math.max(this.autoSelect ? 0 : -1, Math.min(this.data.length, line));
        if (selectionMarker.start.row != line) {
            popup.selection.clearSelection();
            selectionMarker.start.row = selectionMarker.end.row = line || 0;
            popup.session._emit(&quot;changeBackMarker&quot;);
            popup.moveCursorTo(line || 0, 0);
            if (popup.isOpen)
                popup._signal(&quot;select&quot;);
        }
    };
    popup.on(&quot;changeSelection&quot;, function () {
        if (popup.isOpen)
            popup.setRow(popup.selection.lead.row);
        popup.renderer.scrollCursorIntoView();
    });
    popup.hide = function () {
        this.container.style.display = &quot;none&quot;;
        this._signal(&quot;hide&quot;);
        popup.isOpen = false;
    };
    popup.show = function (pos, lineHeight, topdownOnly) {
        var el = this.container;
        var screenHeight = window.innerHeight;
        var screenWidth = window.innerWidth;
        var renderer = this.renderer;
        var maxH = renderer.$maxLines * lineHeight * 1.4;
        var top = pos.top + this.$borderSize;
        var allowTopdown = top &gt; screenHeight / 2 &amp;&amp; !topdownOnly;
        if (allowTopdown &amp;&amp; top + lineHeight + maxH &gt; screenHeight) {
            renderer.$maxPixelHeight = top - 2 * this.$borderSize;
            el.style.top = &quot;&quot;;
            el.style.bottom = screenHeight - top + &quot;px&quot;;
            popup.isTopdown = false;
        }
        else {
            top += lineHeight;
            renderer.$maxPixelHeight = screenHeight - top - 0.2 * lineHeight;
            el.style.top = top + &quot;px&quot;;
            el.style.bottom = &quot;&quot;;
            popup.isTopdown = true;
        }
        el.style.display = &quot;&quot;;
        var left = pos.left;
        if (left + el.offsetWidth &gt; screenWidth)
            left = screenWidth - el.offsetWidth;
        el.style.left = left + &quot;px&quot;;
        this._signal(&quot;show&quot;);
        lastMouseEvent = null;
        popup.isOpen = true;
    };
    popup.goTo = function (where) {
        var row = this.getRow();
        var max = this.session.getLength() - 1;
        switch (where) {
            case &quot;up&quot;:
                row = row &lt;= 0 ? max : row - 1;
                break;
            case &quot;down&quot;:
                row = row &gt;= max ? -1 : row + 1;
                break;
            case &quot;start&quot;:
                row = 0;
                break;
            case &quot;end&quot;:
                row = max;
                break;
        }
        this.setRow(row);
    };
    popup.getTextLeftOffset = function () {
        return this.$borderSize + this.renderer.$padding + this.$imageSize;
    };
    popup.$imageSize = 0;
    popup.$borderSize = 1;
    return popup;
};
dom.importCssString(&quot;\n.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {\n    background-color: #CAD6FA;\n    z-index: 1;\n}\n.ace_dark.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {\n    background-color: #3a674e;\n}\n.ace_editor.ace_autocomplete .ace_line-hover {\n    border: 1px solid #abbffe;\n    margin-top: -1px;\n    background: rgba(233,233,253,0.4);\n    position: absolute;\n    z-index: 2;\n}\n.ace_dark.ace_editor.ace_autocomplete .ace_line-hover {\n    border: 1px solid rgba(109, 150, 13, 0.8);\n    background: rgba(58, 103, 78, 0.62);\n}\n.ace_completion-meta {\n    opacity: 0.5;\n    margin: 0.9em;\n}\n.ace_completion-message {\n    color: blue;\n}\n.ace_editor.ace_autocomplete .ace_completion-highlight{\n    color: #2d69c7;\n}\n.ace_dark.ace_editor.ace_autocomplete .ace_completion-highlight{\n    color: #93ca12;\n}\n.ace_editor.ace_autocomplete {\n    width: 300px;\n    z-index: 200000;\n    border: 1px lightgray solid;\n    position: fixed;\n    box-shadow: 2px 3px 5px rgba(0,0,0,.2);\n    line-height: 1.4;\n    background: #fefefe;\n    color: #111;\n}\n.ace_dark.ace_editor.ace_autocomplete {\n    border: 1px #484747 solid;\n    box-shadow: 2px 3px 5px rgba(0, 0, 0, 0.51);\n    line-height: 1.4;\n    background: #25282c;\n    color: #c1c1c1;\n}&quot;, &quot;autocompletion.css&quot;, false);
exports.AcePopup = AcePopup;
exports.$singleLineEditor = $singleLineEditor;
exports.getAriaId = getAriaId;

});

define(&quot;ace/autocomplete/util&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;], function(require, exports, module){&quot;use strict&quot;;
exports.parForEach = function (array, fn, callback) {
    var completed = 0;
    var arLength = array.length;
    if (arLength === 0)
        callback();
    for (var i = 0; i &lt; arLength; i++) {
        fn(array[i], function (result, err) {
            completed++;
            if (completed === arLength)
                callback(result, err);
        });
    }
};
var ID_REGEX = /[a-zA-Z_0-9\$\-\u00A2-\u2000\u2070-\uFFFF]/;
exports.retrievePrecedingIdentifier = function (text, pos, regex) {
    regex = regex || ID_REGEX;
    var buf = [];
    for (var i = pos - 1; i &gt;= 0; i--) {
        if (regex.test(text[i]))
            buf.push(text[i]);
        else
            break;
    }
    return buf.reverse().join(&quot;&quot;);
};
exports.retrieveFollowingIdentifier = function (text, pos, regex) {
    regex = regex || ID_REGEX;
    var buf = [];
    for (var i = pos; i &lt; text.length; i++) {
        if (regex.test(text[i]))
            buf.push(text[i]);
        else
            break;
    }
    return buf;
};
exports.getCompletionPrefix = function (editor) {
    var pos = editor.getCursorPosition();
    var line = editor.session.getLine(pos.row);
    var prefix;
    editor.completers.forEach(function (completer) {
        if (completer.identifierRegexps) {
            completer.identifierRegexps.forEach(function (identifierRegex) {
                if (!prefix &amp;&amp; identifierRegex)
                    prefix = this.retrievePrecedingIdentifier(line, pos.column, identifierRegex);
            }.bind(this));
        }
    }.bind(this));
    return prefix || this.retrievePrecedingIdentifier(line, pos.column);
};

});

define(&quot;ace/snippets&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/dom&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/event_emitter&quot;,&quot;ace/lib/lang&quot;,&quot;ace/range&quot;,&quot;ace/range_list&quot;,&quot;ace/keyboard/hash_handler&quot;,&quot;ace/tokenizer&quot;,&quot;ace/clipboard&quot;,&quot;ace/editor&quot;], function(require, exports, module){&quot;use strict&quot;;
var dom = require(&quot;./lib/dom&quot;);
var oop = require(&quot;./lib/oop&quot;);
var EventEmitter = require(&quot;./lib/event_emitter&quot;).EventEmitter;
var lang = require(&quot;./lib/lang&quot;);
var Range = require(&quot;./range&quot;).Range;
var RangeList = require(&quot;./range_list&quot;).RangeList;
var HashHandler = require(&quot;./keyboard/hash_handler&quot;).HashHandler;
var Tokenizer = require(&quot;./tokenizer&quot;).Tokenizer;
var clipboard = require(&quot;./clipboard&quot;);
var VARIABLES = {
    CURRENT_WORD: function (editor) {
        return editor.session.getTextRange(editor.session.getWordRange());
    },
    SELECTION: function (editor, name, indentation) {
        var text = editor.session.getTextRange();
        if (indentation)
            return text.replace(/\n\r?([ \t]*\S)/g, &quot;\n&quot; + indentation + &quot;$1&quot;);
        return text;
    },
    CURRENT_LINE: function (editor) {
        return editor.session.getLine(editor.getCursorPosition().row);
    },
    PREV_LINE: function (editor) {
        return editor.session.getLine(editor.getCursorPosition().row - 1);
    },
    LINE_INDEX: function (editor) {
        return editor.getCursorPosition().row;
    },
    LINE_NUMBER: function (editor) {
        return editor.getCursorPosition().row + 1;
    },
    SOFT_TABS: function (editor) {
        return editor.session.getUseSoftTabs() ? &quot;YES&quot; : &quot;NO&quot;;
    },
    TAB_SIZE: function (editor) {
        return editor.session.getTabSize();
    },
    CLIPBOARD: function (editor) {
        return clipboard.getText &amp;&amp; clipboard.getText();
    },
    FILENAME: function (editor) {
        return /[^/\\]*$/.exec(this.FILEPATH(editor))[0];
    },
    FILENAME_BASE: function (editor) {
        return /[^/\\]*$/.exec(this.FILEPATH(editor))[0].replace(/\.[^.]*$/, &quot;&quot;);
    },
    DIRECTORY: function (editor) {
        return this.FILEPATH(editor).replace(/[^/\\]*$/, &quot;&quot;);
    },
    FILEPATH: function (editor) { return &quot;/not implemented.txt&quot;; },
    WORKSPACE_NAME: function () { return &quot;Unknown&quot;; },
    FULLNAME: function () { return &quot;Unknown&quot;; },
    BLOCK_COMMENT_START: function (editor) {
        var mode = editor.session.$mode || {};
        return mode.blockComment &amp;&amp; mode.blockComment.start || &quot;&quot;;
    },
    BLOCK_COMMENT_END: function (editor) {
        var mode = editor.session.$mode || {};
        return mode.blockComment &amp;&amp; mode.blockComment.end || &quot;&quot;;
    },
    LINE_COMMENT: function (editor) {
        var mode = editor.session.$mode || {};
        return mode.lineCommentStart || &quot;&quot;;
    },
    CURRENT_YEAR: date.bind(null, { year: &quot;numeric&quot; }),
    CURRENT_YEAR_SHORT: date.bind(null, { year: &quot;2-digit&quot; }),
    CURRENT_MONTH: date.bind(null, { month: &quot;numeric&quot; }),
    CURRENT_MONTH_NAME: date.bind(null, { month: &quot;long&quot; }),
    CURRENT_MONTH_NAME_SHORT: date.bind(null, { month: &quot;short&quot; }),
    CURRENT_DATE: date.bind(null, { day: &quot;2-digit&quot; }),
    CURRENT_DAY_NAME: date.bind(null, { weekday: &quot;long&quot; }),
    CURRENT_DAY_NAME_SHORT: date.bind(null, { weekday: &quot;short&quot; }),
    CURRENT_HOUR: date.bind(null, { hour: &quot;2-digit&quot;, hour12: false }),
    CURRENT_MINUTE: date.bind(null, { minute: &quot;2-digit&quot; }),
    CURRENT_SECOND: date.bind(null, { second: &quot;2-digit&quot; })
};
VARIABLES.SELECTED_TEXT = VARIABLES.SELECTION;
function date(dateFormat) {
    var str = new Date().toLocaleString(&quot;en-us&quot;, dateFormat);
    return str.length == 1 ? &quot;0&quot; + str : str;
}
var SnippetManager = function () {
    this.snippetMap = {};
    this.snippetNameMap = {};
};
(function () {
    oop.implement(this, EventEmitter);
    this.getTokenizer = function () {
        return SnippetManager.$tokenizer || this.createTokenizer();
    };
    this.createTokenizer = function () {
        function TabstopToken(str) {
            str = str.substr(1);
            if (/^\d+$/.test(str))
                return [{ tabstopId: parseInt(str, 10) }];
            return [{ text: str }];
        }
        function escape(ch) {
            return &quot;(?:[^\\\\&quot; + ch + &quot;]|\\\\.)&quot;;
        }
        var formatMatcher = {
            regex: &quot;/(&quot; + escape(&quot;/&quot;) + &quot;+)/&quot;,
            onMatch: function (val, state, stack) {
                var ts = stack[0];
                ts.fmtString = true;
                ts.guard = val.slice(1, -1);
                ts.flag = &quot;&quot;;
                return &quot;&quot;;
            },
            next: &quot;formatString&quot;
        };
        SnippetManager.$tokenizer = new Tokenizer({
            start: [
                { regex: /\\./, onMatch: function (val, state, stack) {
                        var ch = val[1];
                        if (ch == &quot;}&quot; &amp;&amp; stack.length) {
                            val = ch;
                        }
                        else if (&quot;`$\\&quot;.indexOf(ch) != -1) {
                            val = ch;
                        }
                        return [val];
                    } },
                { regex: /}/, onMatch: function (val, state, stack) {
                        return [stack.length ? stack.shift() : val];
                    } },
                { regex: /\$(?:\d+|\w+)/, onMatch: TabstopToken },
                { regex: /\$\{[\dA-Z_a-z]+/, onMatch: function (str, state, stack) {
                        var t = TabstopToken(str.substr(1));
                        stack.unshift(t[0]);
                        return t;
                    }, next: &quot;snippetVar&quot; },
                { regex: /\n/, token: &quot;newline&quot;, merge: false }
            ],
            snippetVar: [
                { regex: &quot;\\|&quot; + escape(&quot;\\|&quot;) + &quot;*\\|&quot;, onMatch: function (val, state, stack) {
                        var choices = val.slice(1, -1).replace(/\\[,|\\]|,/g, function (operator) {
                            return operator.length == 2 ? operator[1] : &quot;\x00&quot;;
                        }).split(&quot;\x00&quot;).map(function (value) {
                            return { value: value };
                        });
                        stack[0].choices = choices;
                        return [choices[0]];
                    }, next: &quot;start&quot; },
                formatMatcher,
                { regex: &quot;([^:}\\\\]|\\\\.)*:?&quot;, token: &quot;&quot;, next: &quot;start&quot; }
            ],
            formatString: [
                { regex: /:/, onMatch: function (val, state, stack) {
                        if (stack.length &amp;&amp; stack[0].expectElse) {
                            stack[0].expectElse = false;
                            stack[0].ifEnd = { elseEnd: stack[0] };
                            return [stack[0].ifEnd];
                        }
                        return &quot;:&quot;;
                    } },
                { regex: /\\./, onMatch: function (val, state, stack) {
                        var ch = val[1];
                        if (ch == &quot;}&quot; &amp;&amp; stack.length)
                            val = ch;
                        else if (&quot;`$\\&quot;.indexOf(ch) != -1)
                            val = ch;
                        else if (ch == &quot;n&quot;)
                            val = &quot;\n&quot;;
                        else if (ch == &quot;t&quot;)
                            val = &quot;\t&quot;;
                        else if (&quot;ulULE&quot;.indexOf(ch) != -1)
                            val = { changeCase: ch, local: ch &gt; &quot;a&quot; };
                        return [val];
                    } },
                { regex: &quot;/\\w*}&quot;, onMatch: function (val, state, stack) {
                        var next = stack.shift();
                        if (next)
                            next.flag = val.slice(1, -1);
                        this.next = next &amp;&amp; next.tabstopId ? &quot;start&quot; : &quot;&quot;;
                        return [next || val];
                    }, next: &quot;start&quot; },
                { regex: /\$(?:\d+|\w+)/, onMatch: function (val, state, stack) {
                        return [{ text: val.slice(1) }];
                    } },
                { regex: /\${\w+/, onMatch: function (val, state, stack) {
                        var token = { text: val.slice(2) };
                        stack.unshift(token);
                        return [token];
                    }, next: &quot;formatStringVar&quot; },
                { regex: /\n/, token: &quot;newline&quot;, merge: false },
                { regex: /}/, onMatch: function (val, state, stack) {
                        var next = stack.shift();
                        this.next = next &amp;&amp; next.tabstopId ? &quot;start&quot; : &quot;&quot;;
                        return [next || val];
                    }, next: &quot;start&quot; }
            ],
            formatStringVar: [
                { regex: /:\/\w+}/, onMatch: function (val, state, stack) {
                        var ts = stack[0];
                        ts.formatFunction = val.slice(2, -1);
                        return [stack.shift()];
                    }, next: &quot;formatString&quot; },
                formatMatcher,
                { regex: /:[\?\-+]?/, onMatch: function (val, state, stack) {
                        if (val[1] == &quot;+&quot;)
                            stack[0].ifEnd = stack[0];
                        if (val[1] == &quot;?&quot;)
                            stack[0].expectElse = true;
                    }, next: &quot;formatString&quot; },
                { regex: &quot;([^:}\\\\]|\\\\.)*:?&quot;, token: &quot;&quot;, next: &quot;formatString&quot; }
            ]
        });
        return SnippetManager.$tokenizer;
    };
    this.tokenizeTmSnippet = function (str, startState) {
        return this.getTokenizer().getLineTokens(str, startState).tokens.map(function (x) {
            return x.value || x;
        });
    };
    this.getVariableValue = function (editor, name, indentation) {
        if (/^\d+$/.test(name))
            return (this.variables.__ || {})[name] || &quot;&quot;;
        if (/^[A-Z]\d+$/.test(name))
            return (this.variables[name[0] + &quot;__&quot;] || {})[name.substr(1)] || &quot;&quot;;
        name = name.replace(/^TM_/, &quot;&quot;);
        if (!this.variables.hasOwnProperty(name))
            return &quot;&quot;;
        var value = this.variables[name];
        if (typeof value == &quot;function&quot;)
            value = this.variables[name](editor, name, indentation);
        return value == null ? &quot;&quot; : value;
    };
    this.variables = VARIABLES;
    this.tmStrFormat = function (str, ch, editor) {
        if (!ch.fmt)
            return str;
        var flag = ch.flag || &quot;&quot;;
        var re = ch.guard;
        re = new RegExp(re, flag.replace(/[^gim]/g, &quot;&quot;));
        var fmtTokens = typeof ch.fmt == &quot;string&quot; ? this.tokenizeTmSnippet(ch.fmt, &quot;formatString&quot;) : ch.fmt;
        var _self = this;
        var formatted = str.replace(re, function () {
            var oldArgs = _self.variables.__;
            _self.variables.__ = [].slice.call(arguments);
            var fmtParts = _self.resolveVariables(fmtTokens, editor);
            var gChangeCase = &quot;E&quot;;
            for (var i = 0; i &lt; fmtParts.length; i++) {
                var ch = fmtParts[i];
                if (typeof ch == &quot;object&quot;) {
                    fmtParts[i] = &quot;&quot;;
                    if (ch.changeCase &amp;&amp; ch.local) {
                        var next = fmtParts[i + 1];
                        if (next &amp;&amp; typeof next == &quot;string&quot;) {
                            if (ch.changeCase == &quot;u&quot;)
                                fmtParts[i] = next[0].toUpperCase();
                            else
                                fmtParts[i] = next[0].toLowerCase();
                            fmtParts[i + 1] = next.substr(1);
                        }
                    }
                    else if (ch.changeCase) {
                        gChangeCase = ch.changeCase;
                    }
                }
                else if (gChangeCase == &quot;U&quot;) {
                    fmtParts[i] = ch.toUpperCase();
                }
                else if (gChangeCase == &quot;L&quot;) {
                    fmtParts[i] = ch.toLowerCase();
                }
            }
            _self.variables.__ = oldArgs;
            return fmtParts.join(&quot;&quot;);
        });
        return formatted;
    };
    this.tmFormatFunction = function (str, ch, editor) {
        if (ch.formatFunction == &quot;upcase&quot;)
            return str.toUpperCase();
        if (ch.formatFunction == &quot;downcase&quot;)
            return str.toLowerCase();
        return str;
    };
    this.resolveVariables = function (snippet, editor) {
        var result = [];
        var indentation = &quot;&quot;;
        var afterNewLine = true;
        for (var i = 0; i &lt; snippet.length; i++) {
            var ch = snippet[i];
            if (typeof ch == &quot;string&quot;) {
                result.push(ch);
                if (ch == &quot;\n&quot;) {
                    afterNewLine = true;
                    indentation = &quot;&quot;;
                }
                else if (afterNewLine) {
                    indentation = /^\t*/.exec(ch)[0];
                    afterNewLine = /\S/.test(ch);
                }
                continue;
            }
            if (!ch)
                continue;
            afterNewLine = false;
            if (ch.fmtString) {
                var j = snippet.indexOf(ch, i + 1);
                if (j == -1)
                    j = snippet.length;
                ch.fmt = snippet.slice(i + 1, j);
                i = j;
            }
            if (ch.text) {
                var value = this.getVariableValue(editor, ch.text, indentation) + &quot;&quot;;
                if (ch.fmtString)
                    value = this.tmStrFormat(value, ch, editor);
                if (ch.formatFunction)
                    value = this.tmFormatFunction(value, ch, editor);
                if (value &amp;&amp; !ch.ifEnd) {
                    result.push(value);
                    gotoNext(ch);
                }
                else if (!value &amp;&amp; ch.ifEnd) {
                    gotoNext(ch.ifEnd);
                }
            }
            else if (ch.elseEnd) {
                gotoNext(ch.elseEnd);
            }
            else if (ch.tabstopId != null) {
                result.push(ch);
            }
            else if (ch.changeCase != null) {
                result.push(ch);
            }
        }
        function gotoNext(ch) {
            var i1 = snippet.indexOf(ch, i + 1);
            if (i1 != -1)
                i = i1;
        }
        return result;
    };
    this.insertSnippetForSelection = function (editor, snippetText) {
        var cursor = editor.getCursorPosition();
        var line = editor.session.getLine(cursor.row);
        var tabString = editor.session.getTabString();
        var indentString = line.match(/^\s*/)[0];
        if (cursor.column &lt; indentString.length)
            indentString = indentString.slice(0, cursor.column);
        snippetText = snippetText.replace(/\r/g, &quot;&quot;);
        var tokens = this.tokenizeTmSnippet(snippetText);
        tokens = this.resolveVariables(tokens, editor);
        tokens = tokens.map(function (x) {
            if (x == &quot;\n&quot;)
                return x + indentString;
            if (typeof x == &quot;string&quot;)
                return x.replace(/\t/g, tabString);
            return x;
        });
        var tabstops = [];
        tokens.forEach(function (p, i) {
            if (typeof p != &quot;object&quot;)
                return;
            var id = p.tabstopId;
            var ts = tabstops[id];
            if (!ts) {
                ts = tabstops[id] = [];
                ts.index = id;
                ts.value = &quot;&quot;;
                ts.parents = {};
            }
            if (ts.indexOf(p) !== -1)
                return;
            if (p.choices &amp;&amp; !ts.choices)
                ts.choices = p.choices;
            ts.push(p);
            var i1 = tokens.indexOf(p, i + 1);
            if (i1 === -1)
                return;
            var value = tokens.slice(i + 1, i1);
            var isNested = value.some(function (t) { return typeof t === &quot;object&quot;; });
            if (isNested &amp;&amp; !ts.value) {
                ts.value = value;
            }
            else if (value.length &amp;&amp; (!ts.value || typeof ts.value !== &quot;string&quot;)) {
                ts.value = value.join(&quot;&quot;);
            }
        });
        tabstops.forEach(function (ts) { ts.length = 0; });
        var expanding = {};
        function copyValue(val) {
            var copy = [];
            for (var i = 0; i &lt; val.length; i++) {
                var p = val[i];
                if (typeof p == &quot;object&quot;) {
                    if (expanding[p.tabstopId])
                        continue;
                    var j = val.lastIndexOf(p, i - 1);
                    p = copy[j] || { tabstopId: p.tabstopId };
                }
                copy[i] = p;
            }
            return copy;
        }
        for (var i = 0; i &lt; tokens.length; i++) {
            var p = tokens[i];
            if (typeof p != &quot;object&quot;)
                continue;
            var id = p.tabstopId;
            var ts = tabstops[id];
            var i1 = tokens.indexOf(p, i + 1);
            if (expanding[id]) {
                if (expanding[id] === p) {
                    delete expanding[id];
                    Object.keys(expanding).forEach(function (parentId) {
                        ts.parents[parentId] = true;
                    });
                }
                continue;
            }
            expanding[id] = p;
            var value = ts.value;
            if (typeof value !== &quot;string&quot;)
                value = copyValue(value);
            else if (p.fmt)
                value = this.tmStrFormat(value, p, editor);
            tokens.splice.apply(tokens, [i + 1, Math.max(0, i1 - i)].concat(value, p));
            if (ts.indexOf(p) === -1)
                ts.push(p);
        }
        var row = 0, column = 0;
        var text = &quot;&quot;;
        tokens.forEach(function (t) {
            if (typeof t === &quot;string&quot;) {
                var lines = t.split(&quot;\n&quot;);
                if (lines.length &gt; 1) {
                    column = lines[lines.length - 1].length;
                    row += lines.length - 1;
                }
                else
                    column += t.length;
                text += t;
            }
            else if (t) {
                if (!t.start)
                    t.start = { row: row, column: column };
                else
                    t.end = { row: row, column: column };
            }
        });
        var range = editor.getSelectionRange();
        var end = editor.session.replace(range, text);
        var tabstopManager = new TabstopManager(editor);
        var selectionId = editor.inVirtualSelectionMode &amp;&amp; editor.selection.index;
        tabstopManager.addTabstops(tabstops, range.start, end, selectionId);
    };
    this.insertSnippet = function (editor, snippetText) {
        var self = this;
        if (editor.inVirtualSelectionMode)
            return self.insertSnippetForSelection(editor, snippetText);
        editor.forEachSelection(function () {
            self.insertSnippetForSelection(editor, snippetText);
        }, null, { keepOrder: true });
        if (editor.tabstopManager)
            editor.tabstopManager.tabNext();
    };
    this.$getScope = function (editor) {
        var scope = editor.session.$mode.$id || &quot;&quot;;
        scope = scope.split(&quot;/&quot;).pop();
        if (scope === &quot;html&quot; || scope === &quot;php&quot;) {
            if (scope === &quot;php&quot; &amp;&amp; !editor.session.$mode.inlinePhp)
                scope = &quot;html&quot;;
            var c = editor.getCursorPosition();
            var state = editor.session.getState(c.row);
            if (typeof state === &quot;object&quot;) {
                state = state[0];
            }
            if (state.substring) {
                if (state.substring(0, 3) == &quot;js-&quot;)
                    scope = &quot;javascript&quot;;
                else if (state.substring(0, 4) == &quot;css-&quot;)
                    scope = &quot;css&quot;;
                else if (state.substring(0, 4) == &quot;php-&quot;)
                    scope = &quot;php&quot;;
            }
        }
        return scope;
    };
    this.getActiveScopes = function (editor) {
        var scope = this.$getScope(editor);
        var scopes = [scope];
        var snippetMap = this.snippetMap;
        if (snippetMap[scope] &amp;&amp; snippetMap[scope].includeScopes) {
            scopes.push.apply(scopes, snippetMap[scope].includeScopes);
        }
        scopes.push(&quot;_&quot;);
        return scopes;
    };
    this.expandWithTab = function (editor, options) {
        var self = this;
        var result = editor.forEachSelection(function () {
            return self.expandSnippetForSelection(editor, options);
        }, null, { keepOrder: true });
        if (result &amp;&amp; editor.tabstopManager)
            editor.tabstopManager.tabNext();
        return result;
    };
    this.expandSnippetForSelection = function (editor, options) {
        var cursor = editor.getCursorPosition();
        var line = editor.session.getLine(cursor.row);
        var before = line.substring(0, cursor.column);
        var after = line.substr(cursor.column);
        var snippetMap = this.snippetMap;
        var snippet;
        this.getActiveScopes(editor).some(function (scope) {
            var snippets = snippetMap[scope];
            if (snippets)
                snippet = this.findMatchingSnippet(snippets, before, after);
            return !!snippet;
        }, this);
        if (!snippet)
            return false;
        if (options &amp;&amp; options.dryRun)
            return true;
        editor.session.doc.removeInLine(cursor.row, cursor.column - snippet.replaceBefore.length, cursor.column + snippet.replaceAfter.length);
        this.variables.M__ = snippet.matchBefore;
        this.variables.T__ = snippet.matchAfter;
        this.insertSnippetForSelection(editor, snippet.content);
        this.variables.M__ = this.variables.T__ = null;
        return true;
    };
    this.findMatchingSnippet = function (snippetList, before, after) {
        for (var i = snippetList.length; i--;) {
            var s = snippetList[i];
            if (s.startRe &amp;&amp; !s.startRe.test(before))
                continue;
            if (s.endRe &amp;&amp; !s.endRe.test(after))
                continue;
            if (!s.startRe &amp;&amp; !s.endRe)
                continue;
            s.matchBefore = s.startRe ? s.startRe.exec(before) : [&quot;&quot;];
            s.matchAfter = s.endRe ? s.endRe.exec(after) : [&quot;&quot;];
            s.replaceBefore = s.triggerRe ? s.triggerRe.exec(before)[0] : &quot;&quot;;
            s.replaceAfter = s.endTriggerRe ? s.endTriggerRe.exec(after)[0] : &quot;&quot;;
            return s;
        }
    };
    this.snippetMap = {};
    this.snippetNameMap = {};
    this.register = function (snippets, scope) {
        var snippetMap = this.snippetMap;
        var snippetNameMap = this.snippetNameMap;
        var self = this;
        if (!snippets)
            snippets = [];
        function wrapRegexp(src) {
            if (src &amp;&amp; !/^\^?\(.*\)\$?$|^\\b$/.test(src))
                src = &quot;(?:&quot; + src + &quot;)&quot;;
            return src || &quot;&quot;;
        }
        function guardedRegexp(re, guard, opening) {
            re = wrapRegexp(re);
            guard = wrapRegexp(guard);
            if (opening) {
                re = guard + re;
                if (re &amp;&amp; re[re.length - 1] != &quot;$&quot;)
                    re = re + &quot;$&quot;;
            }
            else {
                re = re + guard;
                if (re &amp;&amp; re[0] != &quot;^&quot;)
                    re = &quot;^&quot; + re;
            }
            return new RegExp(re);
        }
        function addSnippet(s) {
            if (!s.scope)
                s.scope = scope || &quot;_&quot;;
            scope = s.scope;
            if (!snippetMap[scope]) {
                snippetMap[scope] = [];
                snippetNameMap[scope] = {};
            }
            var map = snippetNameMap[scope];
            if (s.name) {
                var old = map[s.name];
                if (old)
                    self.unregister(old);
                map[s.name] = s;
            }
            snippetMap[scope].push(s);
            if (s.prefix)
                s.tabTrigger = s.prefix;
            if (!s.content &amp;&amp; s.body)
                s.content = Array.isArray(s.body) ? s.body.join(&quot;\n&quot;) : s.body;
            if (s.tabTrigger &amp;&amp; !s.trigger) {
                if (!s.guard &amp;&amp; /^\w/.test(s.tabTrigger))
                    s.guard = &quot;\\b&quot;;
                s.trigger = lang.escapeRegExp(s.tabTrigger);
            }
            if (!s.trigger &amp;&amp; !s.guard &amp;&amp; !s.endTrigger &amp;&amp; !s.endGuard)
                return;
            s.startRe = guardedRegexp(s.trigger, s.guard, true);
            s.triggerRe = new RegExp(s.trigger);
            s.endRe = guardedRegexp(s.endTrigger, s.endGuard, true);
            s.endTriggerRe = new RegExp(s.endTrigger);
        }
        if (Array.isArray(snippets)) {
            snippets.forEach(addSnippet);
        }
        else {
            Object.keys(snippets).forEach(function (key) {
                addSnippet(snippets[key]);
            });
        }
        this._signal(&quot;registerSnippets&quot;, { scope: scope });
    };
    this.unregister = function (snippets, scope) {
        var snippetMap = this.snippetMap;
        var snippetNameMap = this.snippetNameMap;
        function removeSnippet(s) {
            var nameMap = snippetNameMap[s.scope || scope];
            if (nameMap &amp;&amp; nameMap[s.name]) {
                delete nameMap[s.name];
                var map = snippetMap[s.scope || scope];
                var i = map &amp;&amp; map.indexOf(s);
                if (i &gt;= 0)
                    map.splice(i, 1);
            }
        }
        if (snippets.content)
            removeSnippet(snippets);
        else if (Array.isArray(snippets))
            snippets.forEach(removeSnippet);
    };
    this.parseSnippetFile = function (str) {
        str = str.replace(/\r/g, &quot;&quot;);
        var list = [], snippet = {};
        var re = /^#.*|^({[\s\S]*})\s*$|^(\S+) (.*)$|^((?:\n*\t.*)+)/gm;
        var m;
        while (m = re.exec(str)) {
            if (m[1]) {
                try {
                    snippet = JSON.parse(m[1]);
                    list.push(snippet);
                }
                catch (e) { }
            }
            if (m[4]) {
                snippet.content = m[4].replace(/^\t/gm, &quot;&quot;);
                list.push(snippet);
                snippet = {};
            }
            else {
                var key = m[2], val = m[3];
                if (key == &quot;regex&quot;) {
                    var guardRe = /\/((?:[^\/\\]|\\.)*)|$/g;
                    snippet.guard = guardRe.exec(val)[1];
                    snippet.trigger = guardRe.exec(val)[1];
                    snippet.endTrigger = guardRe.exec(val)[1];
                    snippet.endGuard = guardRe.exec(val)[1];
                }
                else if (key == &quot;snippet&quot;) {
                    snippet.tabTrigger = val.match(/^\S*/)[0];
                    if (!snippet.name)
                        snippet.name = val;
                }
                else if (key) {
                    snippet[key] = val;
                }
            }
        }
        return list;
    };
    this.getSnippetByName = function (name, editor) {
        var snippetMap = this.snippetNameMap;
        var snippet;
        this.getActiveScopes(editor).some(function (scope) {
            var snippets = snippetMap[scope];
            if (snippets)
                snippet = snippets[name];
            return !!snippet;
        }, this);
        return snippet;
    };
}).call(SnippetManager.prototype);
var TabstopManager = function (editor) {
    if (editor.tabstopManager)
        return editor.tabstopManager;
    editor.tabstopManager = this;
    this.$onChange = this.onChange.bind(this);
    this.$onChangeSelection = lang.delayedCall(this.onChangeSelection.bind(this)).schedule;
    this.$onChangeSession = this.onChangeSession.bind(this);
    this.$onAfterExec = this.onAfterExec.bind(this);
    this.attach(editor);
};
(function () {
    this.attach = function (editor) {
        this.index = 0;
        this.ranges = [];
        this.tabstops = [];
        this.$openTabstops = null;
        this.selectedTabstop = null;
        this.editor = editor;
        this.editor.on(&quot;change&quot;, this.$onChange);
        this.editor.on(&quot;changeSelection&quot;, this.$onChangeSelection);
        this.editor.on(&quot;changeSession&quot;, this.$onChangeSession);
        this.editor.commands.on(&quot;afterExec&quot;, this.$onAfterExec);
        this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
    };
    this.detach = function () {
        this.tabstops.forEach(this.removeTabstopMarkers, this);
        this.ranges = null;
        this.tabstops = null;
        this.selectedTabstop = null;
        this.editor.removeListener(&quot;change&quot;, this.$onChange);
        this.editor.removeListener(&quot;changeSelection&quot;, this.$onChangeSelection);
        this.editor.removeListener(&quot;changeSession&quot;, this.$onChangeSession);
        this.editor.commands.removeListener(&quot;afterExec&quot;, this.$onAfterExec);
        this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler);
        this.editor.tabstopManager = null;
        this.editor = null;
    };
    this.onChange = function (delta) {
        var isRemove = delta.action[0] == &quot;r&quot;;
        var selectedTabstop = this.selectedTabstop || {};
        var parents = selectedTabstop.parents || {};
        var tabstops = (this.tabstops || []).slice();
        for (var i = 0; i &lt; tabstops.length; i++) {
            var ts = tabstops[i];
            var active = ts == selectedTabstop || parents[ts.index];
            ts.rangeList.$bias = active ? 0 : 1;
            if (delta.action == &quot;remove&quot; &amp;&amp; ts !== selectedTabstop) {
                var parentActive = ts.parents &amp;&amp; ts.parents[selectedTabstop.index];
                var startIndex = ts.rangeList.pointIndex(delta.start, parentActive);
                startIndex = startIndex &lt; 0 ? -startIndex - 1 : startIndex + 1;
                var endIndex = ts.rangeList.pointIndex(delta.end, parentActive);
                endIndex = endIndex &lt; 0 ? -endIndex - 1 : endIndex - 1;
                var toRemove = ts.rangeList.ranges.slice(startIndex, endIndex);
                for (var j = 0; j &lt; toRemove.length; j++)
                    this.removeRange(toRemove[j]);
            }
            ts.rangeList.$onChange(delta);
        }
        var session = this.editor.session;
        if (!this.$inChange &amp;&amp; isRemove &amp;&amp; session.getLength() == 1 &amp;&amp; !session.getValue())
            this.detach();
    };
    this.updateLinkedFields = function () {
        var ts = this.selectedTabstop;
        if (!ts || !ts.hasLinkedRanges || !ts.firstNonLinked)
            return;
        this.$inChange = true;
        var session = this.editor.session;
        var text = session.getTextRange(ts.firstNonLinked);
        for (var i = 0; i &lt; ts.length; i++) {
            var range = ts[i];
            if (!range.linked)
                continue;
            var original = range.original;
            var fmt = exports.snippetManager.tmStrFormat(text, original, this.editor);
            session.replace(range, fmt);
        }
        this.$inChange = false;
    };
    this.onAfterExec = function (e) {
        if (e.command &amp;&amp; !e.command.readOnly)
            this.updateLinkedFields();
    };
    this.onChangeSelection = function () {
        if (!this.editor)
            return;
        var lead = this.editor.selection.lead;
        var anchor = this.editor.selection.anchor;
        var isEmpty = this.editor.selection.isEmpty();
        for (var i = 0; i &lt; this.ranges.length; i++) {
            if (this.ranges[i].linked)
                continue;
            var containsLead = this.ranges[i].contains(lead.row, lead.column);
            var containsAnchor = isEmpty || this.ranges[i].contains(anchor.row, anchor.column);
            if (containsLead &amp;&amp; containsAnchor)
                return;
        }
        this.detach();
    };
    this.onChangeSession = function () {
        this.detach();
    };
    this.tabNext = function (dir) {
        var max = this.tabstops.length;
        var index = this.index + (dir || 1);
        index = Math.min(Math.max(index, 1), max);
        if (index == max)
            index = 0;
        this.selectTabstop(index);
        if (index === 0)
            this.detach();
    };
    this.selectTabstop = function (index) {
        this.$openTabstops = null;
        var ts = this.tabstops[this.index];
        if (ts)
            this.addTabstopMarkers(ts);
        this.index = index;
        ts = this.tabstops[this.index];
        if (!ts || !ts.length)
            return;
        this.selectedTabstop = ts;
        var range = ts.firstNonLinked || ts;
        if (ts.choices)
            range.cursor = range.start;
        if (!this.editor.inVirtualSelectionMode) {
            var sel = this.editor.multiSelect;
            sel.toSingleRange(range);
            for (var i = 0; i &lt; ts.length; i++) {
                if (ts.hasLinkedRanges &amp;&amp; ts[i].linked)
                    continue;
                sel.addRange(ts[i].clone(), true);
            }
        }
        else {
            this.editor.selection.fromOrientedRange(range);
        }
        this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
        if (this.selectedTabstop &amp;&amp; this.selectedTabstop.choices)
            this.editor.execCommand(&quot;startAutocomplete&quot;, { matches: this.selectedTabstop.choices });
    };
    this.addTabstops = function (tabstops, start, end) {
        var useLink = this.useLink || !this.editor.getOption(&quot;enableMultiselect&quot;);
        if (!this.$openTabstops)
            this.$openTabstops = [];
        if (!tabstops[0]) {
            var p = Range.fromPoints(end, end);
            moveRelative(p.start, start);
            moveRelative(p.end, start);
            tabstops[0] = [p];
            tabstops[0].index = 0;
        }
        var i = this.index;
        var arg = [i + 1, 0];
        var ranges = this.ranges;
        tabstops.forEach(function (ts, index) {
            var dest = this.$openTabstops[index] || ts;
            for (var i = 0; i &lt; ts.length; i++) {
                var p = ts[i];
                var range = Range.fromPoints(p.start, p.end || p.start);
                movePoint(range.start, start);
                movePoint(range.end, start);
                range.original = p;
                range.tabstop = dest;
                ranges.push(range);
                if (dest != ts)
                    dest.unshift(range);
                else
                    dest[i] = range;
                if (p.fmtString || (dest.firstNonLinked &amp;&amp; useLink)) {
                    range.linked = true;
                    dest.hasLinkedRanges = true;
                }
                else if (!dest.firstNonLinked)
                    dest.firstNonLinked = range;
            }
            if (!dest.firstNonLinked)
                dest.hasLinkedRanges = false;
            if (dest === ts) {
                arg.push(dest);
                this.$openTabstops[index] = dest;
            }
            this.addTabstopMarkers(dest);
            dest.rangeList = dest.rangeList || new RangeList();
            dest.rangeList.$bias = 0;
            dest.rangeList.addList(dest);
        }, this);
        if (arg.length &gt; 2) {
            if (this.tabstops.length)
                arg.push(arg.splice(2, 1)[0]);
            this.tabstops.splice.apply(this.tabstops, arg);
        }
    };
    this.addTabstopMarkers = function (ts) {
        var session = this.editor.session;
        ts.forEach(function (range) {
            if (!range.markerId)
                range.markerId = session.addMarker(range, &quot;ace_snippet-marker&quot;, &quot;text&quot;);
        });
    };
    this.removeTabstopMarkers = function (ts) {
        var session = this.editor.session;
        ts.forEach(function (range) {
            session.removeMarker(range.markerId);
            range.markerId = null;
        });
    };
    this.removeRange = function (range) {
        var i = range.tabstop.indexOf(range);
        if (i != -1)
            range.tabstop.splice(i, 1);
        i = this.ranges.indexOf(range);
        if (i != -1)
            this.ranges.splice(i, 1);
        i = range.tabstop.rangeList.ranges.indexOf(range);
        if (i != -1)
            range.tabstop.splice(i, 1);
        this.editor.session.removeMarker(range.markerId);
        if (!range.tabstop.length) {
            i = this.tabstops.indexOf(range.tabstop);
            if (i != -1)
                this.tabstops.splice(i, 1);
            if (!this.tabstops.length)
                this.detach();
        }
    };
    this.keyboardHandler = new HashHandler();
    this.keyboardHandler.bindKeys({
        &quot;Tab&quot;: function (editor) {
            if (exports.snippetManager &amp;&amp; exports.snippetManager.expandWithTab(editor))
                return;
            editor.tabstopManager.tabNext(1);
            editor.renderer.scrollCursorIntoView();
        },
        &quot;Shift-Tab&quot;: function (editor) {
            editor.tabstopManager.tabNext(-1);
            editor.renderer.scrollCursorIntoView();
        },
        &quot;Esc&quot;: function (editor) {
            editor.tabstopManager.detach();
        }
    });
}).call(TabstopManager.prototype);
var movePoint = function (point, diff) {
    if (point.row == 0)
        point.column += diff.column;
    point.row += diff.row;
};
var moveRelative = function (point, start) {
    if (point.row == start.row)
        point.column -= start.column;
    point.row -= start.row;
};
dom.importCssString(&quot;\n.ace_snippet-marker {\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n    background: rgba(194, 193, 208, 0.09);\n    border: 1px dotted rgba(211, 208, 235, 0.62);\n    position: absolute;\n}&quot;, &quot;snippets.css&quot;, false);
exports.snippetManager = new SnippetManager();
var Editor = require(&quot;./editor&quot;).Editor;
(function () {
    this.insertSnippet = function (content, options) {
        return exports.snippetManager.insertSnippet(this, content, options);
    };
    this.expandSnippet = function (options) {
        return exports.snippetManager.expandWithTab(this, options);
    };
}).call(Editor.prototype);

});

define(&quot;ace/autocomplete&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/keyboard/hash_handler&quot;,&quot;ace/autocomplete/popup&quot;,&quot;ace/autocomplete/popup&quot;,&quot;ace/autocomplete/util&quot;,&quot;ace/lib/lang&quot;,&quot;ace/lib/dom&quot;,&quot;ace/snippets&quot;,&quot;ace/config&quot;], function(require, exports, module){&quot;use strict&quot;;
var HashHandler = require(&quot;./keyboard/hash_handler&quot;).HashHandler;
var AcePopup = require(&quot;./autocomplete/popup&quot;).AcePopup;
var getAriaId = require(&quot;./autocomplete/popup&quot;).getAriaId;
var util = require(&quot;./autocomplete/util&quot;);
var lang = require(&quot;./lib/lang&quot;);
var dom = require(&quot;./lib/dom&quot;);
var snippetManager = require(&quot;./snippets&quot;).snippetManager;
var config = require(&quot;./config&quot;);
var Autocomplete = function () {
    this.autoInsert = false;
    this.autoSelect = true;
    this.exactMatch = false;
    this.gatherCompletionsId = 0;
    this.keyboardHandler = new HashHandler();
    this.keyboardHandler.bindKeys(this.commands);
    this.blurListener = this.blurListener.bind(this);
    this.changeListener = this.changeListener.bind(this);
    this.mousedownListener = this.mousedownListener.bind(this);
    this.mousewheelListener = this.mousewheelListener.bind(this);
    this.changeTimer = lang.delayedCall(function () {
        this.updateCompletions(true);
    }.bind(this));
    this.tooltipTimer = lang.delayedCall(this.updateDocTooltip.bind(this), 50);
};
(function () {
    this.$init = function () {
        this.popup = new AcePopup(document.body || document.documentElement);
        this.popup.on(&quot;click&quot;, function (e) {
            this.insertMatch();
            e.stop();
        }.bind(this));
        this.popup.focus = this.editor.focus.bind(this.editor);
        this.popup.on(&quot;show&quot;, this.tooltipTimer.bind(null, null));
        this.popup.on(&quot;select&quot;, this.tooltipTimer.bind(null, null));
        this.popup.on(&quot;changeHoverMarker&quot;, this.tooltipTimer.bind(null, null));
        return this.popup;
    };
    this.getPopup = function () {
        return this.popup || this.$init();
    };
    this.openPopup = function (editor, prefix, keepPopupPosition) {
        if (!this.popup)
            this.$init();
        this.popup.autoSelect = this.autoSelect;
        this.popup.setData(this.completions.filtered, this.completions.filterText);
        this.editor.textInput.setAriaOptions({ activeDescendant: getAriaId(this.popup.getRow()) });
        editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
        var renderer = editor.renderer;
        this.popup.setRow(this.autoSelect ? 0 : -1);
        if (!keepPopupPosition) {
            this.popup.setTheme(editor.getTheme());
            this.popup.setFontSize(editor.getFontSize());
            var lineHeight = renderer.layerConfig.lineHeight;
            var pos = renderer.$cursorLayer.getPixelPosition(this.base, true);
            pos.left -= this.popup.getTextLeftOffset();
            var rect = editor.container.getBoundingClientRect();
            pos.top += rect.top - renderer.layerConfig.offset;
            pos.left += rect.left - editor.renderer.scrollLeft;
            pos.left += renderer.gutterWidth;
            this.popup.show(pos, lineHeight);
        }
        else if (keepPopupPosition &amp;&amp; !prefix) {
            this.detach();
        }
        this.changeTimer.cancel();
    };
    this.detach = function () {
        this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler);
        this.editor.off(&quot;changeSelection&quot;, this.changeListener);
        this.editor.off(&quot;blur&quot;, this.blurListener);
        this.editor.off(&quot;mousedown&quot;, this.mousedownListener);
        this.editor.off(&quot;mousewheel&quot;, this.mousewheelListener);
        this.changeTimer.cancel();
        this.hideDocTooltip();
        this.gatherCompletionsId += 1;
        if (this.popup &amp;&amp; this.popup.isOpen)
            this.popup.hide();
        if (this.base)
            this.base.detach();
        this.activated = false;
        this.completions = this.base = null;
    };
    this.changeListener = function (e) {
        var cursor = this.editor.selection.lead;
        if (cursor.row != this.base.row || cursor.column &lt; this.base.column) {
            this.detach();
        }
        if (this.activated)
            this.changeTimer.schedule();
        else
            this.detach();
    };
    this.blurListener = function (e) {
        var el = document.activeElement;
        var text = this.editor.textInput.getElement();
        var fromTooltip = e.relatedTarget &amp;&amp; this.tooltipNode &amp;&amp; this.tooltipNode.contains(e.relatedTarget);
        var container = this.popup &amp;&amp; this.popup.container;
        if (el != text &amp;&amp; el.parentNode != container &amp;&amp; !fromTooltip
            &amp;&amp; el != this.tooltipNode &amp;&amp; e.relatedTarget != text) {
            this.detach();
        }
    };
    this.mousedownListener = function (e) {
        this.detach();
    };
    this.mousewheelListener = function (e) {
        this.detach();
    };
    this.goTo = function (where) {
        this.popup.goTo(where);
    };
    this.insertMatch = function (data, options) {
        if (!data)
            data = this.popup.getData(this.popup.getRow());
        if (!data)
            return false;
        var completions = this.completions;
        this.editor.startOperation({ command: { name: &quot;insertMatch&quot; } });
        if (data.completer &amp;&amp; data.completer.insertMatch) {
            data.completer.insertMatch(this.editor, data);
        }
        else {
            if (!completions)
                return false;
            if (completions.filterText) {
                var ranges = this.editor.selection.getAllRanges();
                for (var i = 0, range; range = ranges[i]; i++) {
                    range.start.column -= completions.filterText.length;
                    this.editor.session.remove(range);
                }
            }
            if (data.snippet)
                snippetManager.insertSnippet(this.editor, data.snippet);
            else
                this.editor.execCommand(&quot;insertstring&quot;, data.value || data);
        }
        if (this.completions == completions)
            this.detach();
        this.editor.endOperation();
    };
    this.commands = {
        &quot;Up&quot;: function (editor) { editor.completer.goTo(&quot;up&quot;); },
        &quot;Down&quot;: function (editor) { editor.completer.goTo(&quot;down&quot;); },
        &quot;Ctrl-Up|Ctrl-Home&quot;: function (editor) { editor.completer.goTo(&quot;start&quot;); },
        &quot;Ctrl-Down|Ctrl-End&quot;: function (editor) { editor.completer.goTo(&quot;end&quot;); },
        &quot;Esc&quot;: function (editor) { editor.completer.detach(); },
        &quot;Return&quot;: function (editor) { return editor.completer.insertMatch(); },
        &quot;Shift-Return&quot;: function (editor) { editor.completer.insertMatch(null, { deleteSuffix: true }); },
        &quot;Tab&quot;: function (editor) {
            var result = editor.completer.insertMatch();
            if (!result &amp;&amp; !editor.tabstopManager)
                editor.completer.goTo(&quot;down&quot;);
            else
                return result;
        },
        &quot;PageUp&quot;: function (editor) { editor.completer.popup.gotoPageUp(); },
        &quot;PageDown&quot;: function (editor) { editor.completer.popup.gotoPageDown(); }
    };
    this.gatherCompletions = function (editor, callback) {
        var session = editor.getSession();
        var pos = editor.getCursorPosition();
        var prefix = util.getCompletionPrefix(editor);
        this.base = session.doc.createAnchor(pos.row, pos.column - prefix.length);
        this.base.$insertRight = true;
        var matches = [];
        var total = editor.completers.length;
        editor.completers.forEach(function (completer, i) {
            completer.getCompletions(editor, session, pos, prefix, function (err, results) {
                if (!err &amp;&amp; results)
                    matches = matches.concat(results);
                callback(null, {
                    prefix: util.getCompletionPrefix(editor),
                    matches: matches,
                    finished: (--total === 0)
                });
            });
        });
        return true;
    };
    this.showPopup = function (editor, options) {
        if (this.editor)
            this.detach();
        this.activated = true;
        this.editor = editor;
        if (editor.completer != this) {
            if (editor.completer)
                editor.completer.detach();
            editor.completer = this;
        }
        editor.on(&quot;changeSelection&quot;, this.changeListener);
        editor.on(&quot;blur&quot;, this.blurListener);
        editor.on(&quot;mousedown&quot;, this.mousedownListener);
        editor.on(&quot;mousewheel&quot;, this.mousewheelListener);
        this.updateCompletions(false, options);
    };
    this.updateCompletions = function (keepPopupPosition, options) {
        if (keepPopupPosition &amp;&amp; this.base &amp;&amp; this.completions) {
            var pos = this.editor.getCursorPosition();
            var prefix = this.editor.session.getTextRange({ start: this.base, end: pos });
            if (prefix == this.completions.filterText)
                return;
            this.completions.setFilter(prefix);
            if (!this.completions.filtered.length)
                return this.detach();
            if (this.completions.filtered.length == 1
                &amp;&amp; this.completions.filtered[0].value == prefix
                &amp;&amp; !this.completions.filtered[0].snippet)
                return this.detach();
            this.openPopup(this.editor, prefix, keepPopupPosition);
            return;
        }
        if (options &amp;&amp; options.matches) {
            var pos = this.editor.getSelectionRange().start;
            this.base = this.editor.session.doc.createAnchor(pos.row, pos.column);
            this.base.$insertRight = true;
            this.completions = new FilteredList(options.matches);
            return this.openPopup(this.editor, &quot;&quot;, keepPopupPosition);
        }
        var _id = this.gatherCompletionsId;
        var detachIfFinished = function (results) {
            if (!results.finished)
                return;
            return this.detach();
        }.bind(this);
        var processResults = function (results) {
            var prefix = results.prefix;
            var matches = results.matches;
            this.completions = new FilteredList(matches);
            if (this.exactMatch)
                this.completions.exactMatch = true;
            this.completions.setFilter(prefix);
            var filtered = this.completions.filtered;
            if (!filtered.length)
                return detachIfFinished(results);
            if (filtered.length == 1 &amp;&amp; filtered[0].value == prefix &amp;&amp; !filtered[0].snippet)
                return detachIfFinished(results);
            if (this.autoInsert &amp;&amp; filtered.length == 1 &amp;&amp; results.finished)
                return this.insertMatch(filtered[0]);
            this.openPopup(this.editor, prefix, keepPopupPosition);
        }.bind(this);
        var isImmediate = true;
        var immediateResults = null;
        this.gatherCompletions(this.editor, function (err, results) {
            var prefix = results.prefix;
            var matches = results &amp;&amp; results.matches;
            if (!matches || !matches.length)
                return detachIfFinished(results);
            if (prefix.indexOf(results.prefix) !== 0 || _id != this.gatherCompletionsId)
                return;
            if (isImmediate) {
                immediateResults = results;
                return;
            }
            processResults(results);
        }.bind(this));
        isImmediate = false;
        if (immediateResults) {
            var results = immediateResults;
            immediateResults = null;
            processResults(results);
        }
    };
    this.cancelContextMenu = function () {
        this.editor.$mouseHandler.cancelContextMenu();
    };
    this.updateDocTooltip = function () {
        var popup = this.popup;
        var all = popup.data;
        var selected = all &amp;&amp; (all[popup.getHoveredRow()] || all[popup.getRow()]);
        var doc = null;
        if (!selected || !this.editor || !this.popup.isOpen)
            return this.hideDocTooltip();
        this.editor.completers.some(function (completer) {
            if (completer.getDocTooltip)
                doc = completer.getDocTooltip(selected);
            return doc;
        });
        if (!doc &amp;&amp; typeof selected != &quot;string&quot;)
            doc = selected;
        if (typeof doc == &quot;string&quot;)
            doc = { docText: doc };
        if (!doc || !(doc.docHTML || doc.docText))
            return this.hideDocTooltip();
        this.showDocTooltip(doc);
    };
    this.showDocTooltip = function (item) {
        if (!this.tooltipNode) {
            this.tooltipNode = dom.createElement(&quot;div&quot;);
            this.tooltipNode.className = &quot;ace_tooltip ace_doc-tooltip&quot;;
            this.tooltipNode.style.margin = 0;
            this.tooltipNode.style.pointerEvents = &quot;auto&quot;;
            this.tooltipNode.tabIndex = -1;
            this.tooltipNode.onblur = this.blurListener.bind(this);
            this.tooltipNode.onclick = this.onTooltipClick.bind(this);
        }
        var tooltipNode = this.tooltipNode;
        if (item.docHTML) {
            tooltipNode.innerHTML = item.docHTML;
        }
        else if (item.docText) {
            tooltipNode.textContent = item.docText;
        }
        if (!tooltipNode.parentNode)
            document.body.appendChild(tooltipNode);
        var popup = this.popup;
        var rect = popup.container.getBoundingClientRect();
        tooltipNode.style.top = popup.container.style.top;
        tooltipNode.style.bottom = popup.container.style.bottom;
        tooltipNode.style.display = &quot;block&quot;;
        if (window.innerWidth - rect.right &lt; 320) {
            if (rect.left &lt; 320) {
                if (popup.isTopdown) {
                    tooltipNode.style.top = rect.bottom + &quot;px&quot;;
                    tooltipNode.style.left = rect.left + &quot;px&quot;;
                    tooltipNode.style.right = &quot;&quot;;
                    tooltipNode.style.bottom = &quot;&quot;;
                }
                else {
                    tooltipNode.style.top = popup.container.offsetTop - tooltipNode.offsetHeight + &quot;px&quot;;
                    tooltipNode.style.left = rect.left + &quot;px&quot;;
                    tooltipNode.style.right = &quot;&quot;;
                    tooltipNode.style.bottom = &quot;&quot;;
                }
            }
            else {
                tooltipNode.style.right = window.innerWidth - rect.left + &quot;px&quot;;
                tooltipNode.style.left = &quot;&quot;;
            }
        }
        else {
            tooltipNode.style.left = (rect.right + 1) + &quot;px&quot;;
            tooltipNode.style.right = &quot;&quot;;
        }
    };
    this.hideDocTooltip = function () {
        this.tooltipTimer.cancel();
        if (!this.tooltipNode)
            return;
        var el = this.tooltipNode;
        if (!this.editor.isFocused() &amp;&amp; document.activeElement == el)
            this.editor.focus();
        this.tooltipNode = null;
        if (el.parentNode)
            el.parentNode.removeChild(el);
    };
    this.onTooltipClick = function (e) {
        var a = e.target;
        while (a &amp;&amp; a != this.tooltipNode) {
            if (a.nodeName == &quot;A&quot; &amp;&amp; a.href) {
                a.rel = &quot;noreferrer&quot;;
                a.target = &quot;_blank&quot;;
                break;
            }
            a = a.parentNode;
        }
    };
    this.destroy = function () {
        this.detach();
        if (this.popup) {
            this.popup.destroy();
            var el = this.popup.container;
            if (el &amp;&amp; el.parentNode)
                el.parentNode.removeChild(el);
        }
        if (this.editor &amp;&amp; this.editor.completer == this)
            this.editor.completer == null;
        this.popup = null;
    };
}).call(Autocomplete.prototype);
Autocomplete.for = function (editor) {
    if (editor.completer) {
        return editor.completer;
    }
    if (config.get(&quot;sharedPopups&quot;)) {
        if (!Autocomplete.$shared)
            Autocomplete.$sharedInstance = new Autocomplete();
        editor.completer = Autocomplete.$sharedInstance;
    }
    else {
        editor.completer = new Autocomplete();
        editor.once(&quot;destroy&quot;, function (e, editor) {
            editor.completer.destroy();
        });
    }
    return editor.completer;
};
Autocomplete.startCommand = {
    name: &quot;startAutocomplete&quot;,
    exec: function (editor, options) {
        var completer = Autocomplete.for(editor);
        completer.autoInsert = false;
        completer.autoSelect = true;
        completer.showPopup(editor, options);
        completer.cancelContextMenu();
    },
    bindKey: &quot;Ctrl-Space|Ctrl-Shift-Space|Alt-Space&quot;
};
var FilteredList = function (array, filterText) {
    this.all = array;
    this.filtered = array;
    this.filterText = filterText || &quot;&quot;;
    this.exactMatch = false;
};
(function () {
    this.setFilter = function (str) {
        if (str.length &gt; this.filterText &amp;&amp; str.lastIndexOf(this.filterText, 0) === 0)
            var matches = this.filtered;
        else
            var matches = this.all;
        this.filterText = str;
        matches = this.filterCompletions(matches, this.filterText);
        matches = matches.sort(function (a, b) {
            return b.exactMatch - a.exactMatch || b.$score - a.$score
                || (a.caption || a.value).localeCompare(b.caption || b.value);
        });
        var prev = null;
        matches = matches.filter(function (item) {
            var caption = item.snippet || item.caption || item.value;
            if (caption === prev)
                return false;
            prev = caption;
            return true;
        });
        this.filtered = matches;
    };
    this.filterCompletions = function (items, needle) {
        var results = [];
        var upper = needle.toUpperCase();
        var lower = needle.toLowerCase();
        loop: for (var i = 0, item; item = items[i]; i++) {
            var caption = item.caption || item.value || item.snippet;
            if (!caption)
                continue;
            var lastIndex = -1;
            var matchMask = 0;
            var penalty = 0;
            var index, distance;
            if (this.exactMatch) {
                if (needle !== caption.substr(0, needle.length))
                    continue loop;
            }
            else {
                var fullMatchIndex = caption.toLowerCase().indexOf(lower);
                if (fullMatchIndex &gt; -1) {
                    penalty = fullMatchIndex;
                }
                else {
                    for (var j = 0; j &lt; needle.length; j++) {
                        var i1 = caption.indexOf(lower[j], lastIndex + 1);
                        var i2 = caption.indexOf(upper[j], lastIndex + 1);
                        index = (i1 &gt;= 0) ? ((i2 &lt; 0 || i1 &lt; i2) ? i1 : i2) : i2;
                        if (index &lt; 0)
                            continue loop;
                        distance = index - lastIndex - 1;
                        if (distance &gt; 0) {
                            if (lastIndex === -1)
                                penalty += 10;
                            penalty += distance;
                            matchMask = matchMask | (1 &lt;&lt; j);
                        }
                        lastIndex = index;
                    }
                }
            }
            item.matchMask = matchMask;
            item.exactMatch = penalty ? 0 : 1;
            item.$score = (item.score || 0) - penalty;
            results.push(item);
        }
        return results;
    };
}).call(FilteredList.prototype);
exports.Autocomplete = Autocomplete;
exports.FilteredList = FilteredList;

});

define(&quot;ace/ext/menu_tools/settings_menu.css&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;], function(require, exports, module){module.exports = &quot;#ace_settingsmenu, #kbshortcutmenu {\n    background-color: #F7F7F7;\n    color: black;\n    box-shadow: -5px 4px 5px rgba(126, 126, 126, 0.55);\n    padding: 1em 0.5em 2em 1em;\n    overflow: auto;\n    position: absolute;\n    margin: 0;\n    bottom: 0;\n    right: 0;\n    top: 0;\n    z-index: 9991;\n    cursor: default;\n}\n\n.ace_dark #ace_settingsmenu, .ace_dark #kbshortcutmenu {\n    box-shadow: -20px 10px 25px rgba(126, 126, 126, 0.25);\n    background-color: rgba(255, 255, 255, 0.6);\n    color: black;\n}\n\n.ace_optionsMenuEntry:hover {\n    background-color: rgba(100, 100, 100, 0.1);\n    transition: all 0.3s\n}\n\n.ace_closeButton {\n    background: rgba(245, 146, 146, 0.5);\n    border: 1px solid #F48A8A;\n    border-radius: 50%;\n    padding: 7px;\n    position: absolute;\n    right: -8px;\n    top: -8px;\n    z-index: 100000;\n}\n.ace_closeButton{\n    background: rgba(245, 146, 146, 0.9);\n}\n.ace_optionsMenuKey {\n    color: darkslateblue;\n    font-weight: bold;\n}\n.ace_optionsMenuCommand {\n    color: darkcyan;\n    font-weight: normal;\n}\n.ace_optionsMenuEntry input, .ace_optionsMenuEntry button {\n    vertical-align: middle;\n}\n\n.ace_optionsMenuEntry button[ace_selected_button=true] {\n    background: #e7e7e7;\n    box-shadow: 1px 0px 2px 0px #adadad inset;\n    border-color: #adadad;\n}\n.ace_optionsMenuEntry button {\n    background: white;\n    border: 1px solid lightgray;\n    margin: 0px;\n}\n.ace_optionsMenuEntry button:hover{\n    background: #f0f0f0;\n}&quot;;

});

define(&quot;ace/ext/menu_tools/overlay_page&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/dom&quot;,&quot;ace/ext/menu_tools/settings_menu.css&quot;], function(require, exports, module){/*jslint indent: 4, maxerr: 50, white: true, browser: true, vars: true*/
&#039;use strict&#039;;
var dom = require(&quot;../../lib/dom&quot;);
var cssText = require(&quot;./settings_menu.css&quot;);
dom.importCssString(cssText, &quot;settings_menu.css&quot;, false);
module.exports.overlayPage = function overlayPage(editor, contentElement, callback) {
    var closer = document.createElement(&#039;div&#039;);
    var ignoreFocusOut = false;
    function documentEscListener(e) {
        if (e.keyCode === 27) {
            close();
        }
    }
    function close() {
        if (!closer)
            return;
        document.removeEventListener(&#039;keydown&#039;, documentEscListener);
        closer.parentNode.removeChild(closer);
        if (editor) {
            editor.focus();
        }
        closer = null;
        callback &amp;&amp; callback();
    }
    function setIgnoreFocusOut(ignore) {
        ignoreFocusOut = ignore;
        if (ignore) {
            closer.style.pointerEvents = &quot;none&quot;;
            contentElement.style.pointerEvents = &quot;auto&quot;;
        }
    }
    closer.style.cssText = &#039;margin: 0; padding: 0; &#039; +
        &#039;position: fixed; top:0; bottom:0; left:0; right:0;&#039; +
        &#039;z-index: 9990; &#039; +
        (editor ? &#039;background-color: rgba(0, 0, 0, 0.3);&#039; : &#039;&#039;);
    closer.addEventListener(&#039;click&#039;, function (e) {
        if (!ignoreFocusOut) {
            close();
        }
    });
    document.addEventListener(&#039;keydown&#039;, documentEscListener);
    contentElement.addEventListener(&#039;click&#039;, function (e) {
        e.stopPropagation();
    });
    closer.appendChild(contentElement);
    document.body.appendChild(closer);
    if (editor) {
        editor.blur();
    }
    return {
        close: close,
        setIgnoreFocusOut: setIgnoreFocusOut
    };
};

});

define(&quot;ace/ext/modelist&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;], function(require, exports, module){&quot;use strict&quot;;
var modes = [];
function getModeForPath(path) {
    var mode = modesByName.text;
    var fileName = path.split(/[\/\\]/).pop();
    for (var i = 0; i &lt; modes.length; i++) {
        if (modes[i].supportsFile(fileName)) {
            mode = modes[i];
            break;
        }
    }
    return mode;
}
var Mode = function (name, caption, extensions) {
    this.name = name;
    this.caption = caption;
    this.mode = &quot;ace/mode/&quot; + name;
    this.extensions = extensions;
    var re;
    if (/\^/.test(extensions)) {
        re = extensions.replace(/\|(\^)?/g, function (a, b) {
            return &quot;$|&quot; + (b ? &quot;^&quot; : &quot;^.*\\.&quot;);
        }) + &quot;$&quot;;
    }
    else {
        re = &quot;^.*\\.(&quot; + extensions + &quot;)$&quot;;
    }
    this.extRe = new RegExp(re, &quot;gi&quot;);
};
Mode.prototype.supportsFile = function (filename) {
    return filename.match(this.extRe);
};
var supportedModes = {
    ABAP: [&quot;abap&quot;],
    ABC: [&quot;abc&quot;],
    ActionScript: [&quot;as&quot;],
    ADA: [&quot;ada|adb&quot;],
    Alda: [&quot;alda&quot;],
    Apache_Conf: [&quot;^htaccess|^htgroups|^htpasswd|^conf|htaccess|htgroups|htpasswd&quot;],
    Apex: [&quot;apex|cls|trigger|tgr&quot;],
    AQL: [&quot;aql&quot;],
    AsciiDoc: [&quot;asciidoc|adoc&quot;],
    ASL: [&quot;dsl|asl|asl.json&quot;],
    Assembly_x86: [&quot;asm|a&quot;],
    AutoHotKey: [&quot;ahk&quot;],
    BatchFile: [&quot;bat|cmd&quot;],
    BibTeX: [&quot;bib&quot;],
    C_Cpp: [&quot;cpp|c|cc|cxx|h|hh|hpp|ino&quot;],
    C9Search: [&quot;c9search_results&quot;],
    Cirru: [&quot;cirru|cr&quot;],
    Clojure: [&quot;clj|cljs&quot;],
    Cobol: [&quot;CBL|COB&quot;],
    coffee: [&quot;coffee|cf|cson|^Cakefile&quot;],
    ColdFusion: [&quot;cfm&quot;],
    Crystal: [&quot;cr&quot;],
    CSharp: [&quot;cs&quot;],
    Csound_Document: [&quot;csd&quot;],
    Csound_Orchestra: [&quot;orc&quot;],
    Csound_Score: [&quot;sco&quot;],
    CSS: [&quot;css&quot;],
    Curly: [&quot;curly&quot;],
    D: [&quot;d|di&quot;],
    Dart: [&quot;dart&quot;],
    Diff: [&quot;diff|patch&quot;],
    Dockerfile: [&quot;^Dockerfile&quot;],
    Dot: [&quot;dot&quot;],
    Drools: [&quot;drl&quot;],
    Edifact: [&quot;edi&quot;],
    Eiffel: [&quot;e|ge&quot;],
    EJS: [&quot;ejs&quot;],
    Elixir: [&quot;ex|exs&quot;],
    Elm: [&quot;elm&quot;],
    Erlang: [&quot;erl|hrl&quot;],
    Forth: [&quot;frt|fs|ldr|fth|4th&quot;],
    Fortran: [&quot;f|f90&quot;],
    FSharp: [&quot;fsi|fs|ml|mli|fsx|fsscript&quot;],
    FSL: [&quot;fsl&quot;],
    FTL: [&quot;ftl&quot;],
    Gcode: [&quot;gcode&quot;],
    Gherkin: [&quot;feature&quot;],
    Gitignore: [&quot;^.gitignore&quot;],
    Glsl: [&quot;glsl|frag|vert&quot;],
    Gobstones: [&quot;gbs&quot;],
    golang: [&quot;go&quot;],
    GraphQLSchema: [&quot;gql&quot;],
    Groovy: [&quot;groovy&quot;],
    HAML: [&quot;haml&quot;],
    Handlebars: [&quot;hbs|handlebars|tpl|mustache&quot;],
    Haskell: [&quot;hs&quot;],
    Haskell_Cabal: [&quot;cabal&quot;],
    haXe: [&quot;hx&quot;],
    Hjson: [&quot;hjson&quot;],
    HTML: [&quot;html|htm|xhtml|vue|we|wpy&quot;],
    HTML_Elixir: [&quot;eex|html.eex&quot;],
    HTML_Ruby: [&quot;erb|rhtml|html.erb&quot;],
    INI: [&quot;ini|conf|cfg|prefs&quot;],
    Io: [&quot;io&quot;],
    Ion: [&quot;ion&quot;],
    Jack: [&quot;jack&quot;],
    Jade: [&quot;jade|pug&quot;],
    Java: [&quot;java&quot;],
    JavaScript: [&quot;js|jsm|jsx|cjs|mjs&quot;],
    JEXL: [&quot;jexl&quot;],
    JSON: [&quot;json&quot;],
    JSON5: [&quot;json5&quot;],
    JSONiq: [&quot;jq&quot;],
    JSP: [&quot;jsp&quot;],
    JSSM: [&quot;jssm|jssm_state&quot;],
    JSX: [&quot;jsx&quot;],
    Julia: [&quot;jl&quot;],
    Kotlin: [&quot;kt|kts&quot;],
    LaTeX: [&quot;tex|latex|ltx|bib&quot;],
    Latte: [&quot;latte&quot;],
    LESS: [&quot;less&quot;],
    Liquid: [&quot;liquid&quot;],
    Lisp: [&quot;lisp&quot;],
    LiveScript: [&quot;ls&quot;],
    Log: [&quot;log&quot;],
    LogiQL: [&quot;logic|lql&quot;],
    Logtalk: [&quot;lgt&quot;],
    LSL: [&quot;lsl&quot;],
    Lua: [&quot;lua&quot;],
    LuaPage: [&quot;lp&quot;],
    Lucene: [&quot;lucene&quot;],
    Makefile: [&quot;^Makefile|^GNUmakefile|^makefile|^OCamlMakefile|make&quot;],
    Markdown: [&quot;md|markdown&quot;],
    Mask: [&quot;mask&quot;],
    MATLAB: [&quot;matlab&quot;],
    Maze: [&quot;mz&quot;],
    MediaWiki: [&quot;wiki|mediawiki&quot;],
    MEL: [&quot;mel&quot;],
    MIPS: [&quot;s|asm&quot;],
    MIXAL: [&quot;mixal&quot;],
    MUSHCode: [&quot;mc|mush&quot;],
    MySQL: [&quot;mysql&quot;],
    Nginx: [&quot;nginx|conf&quot;],
    Nim: [&quot;nim&quot;],
    Nix: [&quot;nix&quot;],
    NSIS: [&quot;nsi|nsh&quot;],
    Nunjucks: [&quot;nunjucks|nunjs|nj|njk&quot;],
    ObjectiveC: [&quot;m|mm&quot;],
    OCaml: [&quot;ml|mli&quot;],
    PartiQL: [&quot;partiql|pql&quot;],
    Pascal: [&quot;pas|p&quot;],
    Perl: [&quot;pl|pm&quot;],
    pgSQL: [&quot;pgsql&quot;],
    PHP_Laravel_blade: [&quot;blade.php&quot;],
    PHP: [&quot;php|inc|phtml|shtml|php3|php4|php5|phps|phpt|aw|ctp|module&quot;],
    Pig: [&quot;pig&quot;],
    Powershell: [&quot;ps1&quot;],
    Praat: [&quot;praat|praatscript|psc|proc&quot;],
    Prisma: [&quot;prisma&quot;],
    Prolog: [&quot;plg|prolog&quot;],
    Properties: [&quot;properties&quot;],
    Protobuf: [&quot;proto&quot;],
    Puppet: [&quot;epp|pp&quot;],
    Python: [&quot;py&quot;],
    QML: [&quot;qml&quot;],
    R: [&quot;r&quot;],
    Raku: [&quot;raku|rakumod|rakutest|p6|pl6|pm6&quot;],
    Razor: [&quot;cshtml|asp&quot;],
    RDoc: [&quot;Rd&quot;],
    Red: [&quot;red|reds&quot;],
    RHTML: [&quot;Rhtml&quot;],
    Robot: [&quot;robot|resource&quot;],
    RST: [&quot;rst&quot;],
    Ruby: [&quot;rb|ru|gemspec|rake|^Guardfile|^Rakefile|^Gemfile&quot;],
    Rust: [&quot;rs&quot;],
    SaC: [&quot;sac&quot;],
    SASS: [&quot;sass&quot;],
    SCAD: [&quot;scad&quot;],
    Scala: [&quot;scala|sbt&quot;],
    Scheme: [&quot;scm|sm|rkt|oak|scheme&quot;],
    Scrypt: [&quot;scrypt&quot;],
    SCSS: [&quot;scss&quot;],
    SH: [&quot;sh|bash|^.bashrc&quot;],
    SJS: [&quot;sjs&quot;],
    Slim: [&quot;slim|skim&quot;],
    Smarty: [&quot;smarty|tpl&quot;],
    Smithy: [&quot;smithy&quot;],
    snippets: [&quot;snippets&quot;],
    Soy_Template: [&quot;soy&quot;],
    Space: [&quot;space&quot;],
    SPARQL: [&quot;rq&quot;],
    SQL: [&quot;sql&quot;],
    SQLServer: [&quot;sqlserver&quot;],
    Stylus: [&quot;styl|stylus&quot;],
    SVG: [&quot;svg&quot;],
    Swift: [&quot;swift&quot;],
    Tcl: [&quot;tcl&quot;],
    Terraform: [&quot;tf&quot;, &quot;tfvars&quot;, &quot;terragrunt&quot;],
    Tex: [&quot;tex&quot;],
    Text: [&quot;txt&quot;],
    Textile: [&quot;textile&quot;],
    Toml: [&quot;toml&quot;],
    TSX: [&quot;tsx&quot;],
    Turtle: [&quot;ttl&quot;],
    Twig: [&quot;twig|swig&quot;],
    Typescript: [&quot;ts|typescript|str&quot;],
    Vala: [&quot;vala&quot;],
    VBScript: [&quot;vbs|vb&quot;],
    Velocity: [&quot;vm&quot;],
    Verilog: [&quot;v|vh|sv|svh&quot;],
    VHDL: [&quot;vhd|vhdl&quot;],
    Visualforce: [&quot;vfp|component|page&quot;],
    Wollok: [&quot;wlk|wpgm|wtest&quot;],
    XML: [&quot;xml|rdf|rss|wsdl|xslt|atom|mathml|mml|xul|xbl|xaml&quot;],
    XQuery: [&quot;xq&quot;],
    YAML: [&quot;yaml|yml&quot;],
    Zeek: [&quot;zeek|bro&quot;],
    Django: [&quot;html&quot;]
};
var nameOverrides = {
    ObjectiveC: &quot;Objective-C&quot;,
    CSharp: &quot;C#&quot;,
    golang: &quot;Go&quot;,
    C_Cpp: &quot;C and C++&quot;,
    Csound_Document: &quot;Csound Document&quot;,
    Csound_Orchestra: &quot;Csound&quot;,
    Csound_Score: &quot;Csound Score&quot;,
    coffee: &quot;CoffeeScript&quot;,
    HTML_Ruby: &quot;HTML (Ruby)&quot;,
    HTML_Elixir: &quot;HTML (Elixir)&quot;,
    FTL: &quot;FreeMarker&quot;,
    PHP_Laravel_blade: &quot;PHP (Blade Template)&quot;,
    Perl6: &quot;Perl 6&quot;,
    AutoHotKey: &quot;AutoHotkey / AutoIt&quot;
};
var modesByName = {};
for (var name in supportedModes) {
    var data = supportedModes[name];
    var displayName = (nameOverrides[name] || name).replace(/_/g, &quot; &quot;);
    var filename = name.toLowerCase();
    var mode = new Mode(filename, displayName, data[0]);
    modesByName[filename] = mode;
    modes.push(mode);
}
module.exports = {
    getModeForPath: getModeForPath,
    modes: modes,
    modesByName: modesByName
};

});

define(&quot;ace/ext/prompt&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/range&quot;,&quot;ace/lib/dom&quot;,&quot;ace/ext/menu_tools/get_editor_keyboard_shortcuts&quot;,&quot;ace/autocomplete&quot;,&quot;ace/autocomplete/popup&quot;,&quot;ace/autocomplete/popup&quot;,&quot;ace/undomanager&quot;,&quot;ace/tokenizer&quot;,&quot;ace/ext/menu_tools/overlay_page&quot;,&quot;ace/ext/modelist&quot;], function(require, exports, module){/**
 * Prompt plugin is used for getting input from user.
 *
 * @param {Object} editor                   Ouside editor related to this prompt. Will be blurred when prompt is open.
 * @param {String} message                  Predefined value of prompt input box.
 * @param {Object} options                  Cusomizable options for this prompt.
 * @param {String} options.name             Prompt name.
 * @param {String} options.$type            Use prompt of specific type (gotoLine|commands|modes or default if empty).
 * @param {[start, end]} options.selection  Defines which part of the predefined value should be highlited.
 * @param {Boolean} options.hasDescription  Set to true if prompt has description below input box.
 * @param {String} options.prompt           Description below input box.
 * @param {String} options.placeholder      Placeholder for value.
 * @param {Object} options.$rules           Specific rules for input like password or regexp.
 * @param {Boolean} options.ignoreFocusOut  Set to true to keep the prompt open when focus moves to another part of the editor.
 * @param {Function} options.getCompletions Function for defining list of options for value.
 * @param {Function} options.getPrefix      Function for defining current value prefix.
 * @param {Function} options.onAccept       Function called when Enter is pressed.
 * @param {Function} options.onInput        Function called when input is added to prompt input box.
 * @param {Function} options.onCancel       Function called when Esc|Shift-Esc is pressed.
 * @param {Function} callback               Function called after done.
 * */
&quot;use strict&quot;;
var Range = require(&quot;../range&quot;).Range;
var dom = require(&quot;../lib/dom&quot;);
var shortcuts = require(&quot;../ext/menu_tools/get_editor_keyboard_shortcuts&quot;);
var FilteredList = require(&quot;../autocomplete&quot;).FilteredList;
var AcePopup = require(&#039;../autocomplete/popup&#039;).AcePopup;
var $singleLineEditor = require(&#039;../autocomplete/popup&#039;).$singleLineEditor;
var UndoManager = require(&quot;../undomanager&quot;).UndoManager;
var Tokenizer = require(&quot;../tokenizer&quot;).Tokenizer;
var overlayPage = require(&quot;./menu_tools/overlay_page&quot;).overlayPage;
var modelist = require(&quot;./modelist&quot;);
var openPrompt;
function prompt(editor, message, options, callback) {
    if (typeof message == &quot;object&quot;) {
        return prompt(editor, &quot;&quot;, message, options);
    }
    if (openPrompt) {
        var lastPrompt = openPrompt;
        editor = lastPrompt.editor;
        lastPrompt.close();
        if (lastPrompt.name &amp;&amp; lastPrompt.name == options.name)
            return;
    }
    if (options.$type)
        return prompt[options.$type](editor, callback);
    var cmdLine = $singleLineEditor();
    cmdLine.session.setUndoManager(new UndoManager());
    var el = dom.buildDom([&quot;div&quot;, { class: &quot;ace_prompt_container&quot; + (options.hasDescription ? &quot; input-box-with-description&quot; : &quot;&quot;) }]);
    var overlay = overlayPage(editor, el, done);
    el.appendChild(cmdLine.container);
    if (editor) {
        editor.cmdLine = cmdLine;
        cmdLine.setOption(&quot;fontSize&quot;, editor.getOption(&quot;fontSize&quot;));
    }
    if (message) {
        cmdLine.setValue(message, 1);
    }
    if (options.selection) {
        cmdLine.selection.setRange({
            start: cmdLine.session.doc.indexToPosition(options.selection[0]),
            end: cmdLine.session.doc.indexToPosition(options.selection[1])
        });
    }
    if (options.getCompletions) {
        var popup = new AcePopup();
        popup.renderer.setStyle(&quot;ace_autocomplete_inline&quot;);
        popup.container.style.display = &quot;block&quot;;
        popup.container.style.maxWidth = &quot;600px&quot;;
        popup.container.style.width = &quot;100%&quot;;
        popup.container.style.marginTop = &quot;3px&quot;;
        popup.renderer.setScrollMargin(2, 2, 0, 0);
        popup.autoSelect = false;
        popup.renderer.$maxLines = 15;
        popup.setRow(-1);
        popup.on(&quot;click&quot;, function (e) {
            var data = popup.getData(popup.getRow());
            if (!data.error) {
                cmdLine.setValue(data.value || data.name || data);
                accept();
                e.stop();
            }
        });
        el.appendChild(popup.container);
        updateCompletions();
    }
    if (options.$rules) {
        var tokenizer = new Tokenizer(options.$rules);
        cmdLine.session.bgTokenizer.setTokenizer(tokenizer);
    }
    if (options.placeholder) {
        cmdLine.setOption(&quot;placeholder&quot;, options.placeholder);
    }
    if (options.hasDescription) {
        var promptTextContainer = dom.buildDom([&quot;div&quot;, { class: &quot;ace_prompt_text_container&quot; }]);
        dom.buildDom(options.prompt || &quot;Press &#039;Enter&#039; to confirm or &#039;Escape&#039; to cancel&quot;, promptTextContainer);
        el.appendChild(promptTextContainer);
    }
    overlay.setIgnoreFocusOut(options.ignoreFocusOut);
    function accept() {
        var val;
        if (popup &amp;&amp; popup.getCursorPosition().row &gt; 0) {
            val = valueFromRecentList();
        }
        else {
            val = cmdLine.getValue();
        }
        var curData = popup ? popup.getData(popup.getRow()) : val;
        if (curData &amp;&amp; !curData.error) {
            done();
            options.onAccept &amp;&amp; options.onAccept({
                value: val,
                item: curData
            }, cmdLine);
        }
    }
    var keys = {
        &quot;Enter&quot;: accept,
        &quot;Esc|Shift-Esc&quot;: function () {
            options.onCancel &amp;&amp; options.onCancel(cmdLine.getValue(), cmdLine);
            done();
        }
    };
    if (popup) {
        Object.assign(keys, {
            &quot;Up&quot;: function (editor) { popup.goTo(&quot;up&quot;); valueFromRecentList(); },
            &quot;Down&quot;: function (editor) { popup.goTo(&quot;down&quot;); valueFromRecentList(); },
            &quot;Ctrl-Up|Ctrl-Home&quot;: function (editor) { popup.goTo(&quot;start&quot;); valueFromRecentList(); },
            &quot;Ctrl-Down|Ctrl-End&quot;: function (editor) { popup.goTo(&quot;end&quot;); valueFromRecentList(); },
            &quot;Tab&quot;: function (editor) {
                popup.goTo(&quot;down&quot;);
                valueFromRecentList();
            },
            &quot;PageUp&quot;: function (editor) { popup.gotoPageUp(); valueFromRecentList(); },
            &quot;PageDown&quot;: function (editor) { popup.gotoPageDown(); valueFromRecentList(); }
        });
    }
    cmdLine.commands.bindKeys(keys);
    function done() {
        overlay.close();
        callback &amp;&amp; callback();
        openPrompt = null;
    }
    cmdLine.on(&quot;input&quot;, function () {
        options.onInput &amp;&amp; options.onInput();
        updateCompletions();
    });
    function updateCompletions() {
        if (options.getCompletions) {
            var prefix;
            if (options.getPrefix) {
                prefix = options.getPrefix(cmdLine);
            }
            var completions = options.getCompletions(cmdLine);
            popup.setData(completions, prefix);
            popup.resize(true);
        }
    }
    function valueFromRecentList() {
        var current = popup.getData(popup.getRow());
        if (current &amp;&amp; !current.error)
            return current.value || current.caption || current;
    }
    cmdLine.resize(true);
    if (popup) {
        popup.resize(true);
    }
    cmdLine.focus();
    openPrompt = {
        close: done,
        name: options.name,
        editor: editor
    };
}
prompt.gotoLine = function (editor, callback) {
    function stringifySelection(selection) {
        if (!Array.isArray(selection))
            selection = [selection];
        return selection.map(function (r) {
            var cursor = r.isBackwards ? r.start : r.end;
            var anchor = r.isBackwards ? r.end : r.start;
            var row = anchor.row;
            var s = (row + 1) + &quot;:&quot; + anchor.column;
            if (anchor.row == cursor.row) {
                if (anchor.column != cursor.column)
                    s += &quot;&gt;&quot; + &quot;:&quot; + cursor.column;
            }
            else {
                s += &quot;&gt;&quot; + (cursor.row + 1) + &quot;:&quot; + cursor.column;
            }
            return s;
        }).reverse().join(&quot;, &quot;);
    }
    prompt(editor, &quot;:&quot; + stringifySelection(editor.selection.toJSON()), {
        name: &quot;gotoLine&quot;,
        selection: [1, Number.MAX_VALUE],
        onAccept: function (data) {
            var value = data.value;
            var _history = prompt.gotoLine._history;
            if (!_history)
                prompt.gotoLine._history = _history = [];
            if (_history.indexOf(value) != -1)
                _history.splice(_history.indexOf(value), 1);
            _history.unshift(value);
            if (_history.length &gt; 20)
                _history.length = 20;
            var pos = editor.getCursorPosition();
            var ranges = [];
            value.replace(/^:/, &quot;&quot;).split(/,/).map(function (str) {
                var parts = str.split(/([&lt;&gt;:+-]|c?\d+)|[^c\d&lt;&gt;:+-]+/).filter(Boolean);
                var i = 0;
                function readPosition() {
                    var c = parts[i++];
                    if (!c)
                        return;
                    if (c[0] == &quot;c&quot;) {
                        var index = parseInt(c.slice(1)) || 0;
                        return editor.session.doc.indexToPosition(index);
                    }
                    var row = pos.row;
                    var column = 0;
                    if (/\d/.test(c)) {
                        row = parseInt(c) - 1;
                        c = parts[i++];
                    }
                    if (c == &quot;:&quot;) {
                        c = parts[i++];
                        if (/\d/.test(c)) {
                            column = parseInt(c) || 0;
                        }
                    }
                    return { row: row, column: column };
                }
                pos = readPosition();
                var range = Range.fromPoints(pos, pos);
                if (parts[i] == &quot;&gt;&quot;) {
                    i++;
                    range.end = readPosition();
                }
                else if (parts[i] == &quot;&lt;&quot;) {
                    i++;
                    range.start = readPosition();
                }
                ranges.unshift(range);
            });
            editor.selection.fromJSON(ranges);
            var scrollTop = editor.renderer.scrollTop;
            editor.renderer.scrollSelectionIntoView(editor.selection.anchor, editor.selection.cursor, 0.5);
            editor.renderer.animateScrolling(scrollTop);
        },
        history: function () {
            var undoManager = editor.session.getUndoManager();
            if (!prompt.gotoLine._history)
                return [];
            return prompt.gotoLine._history;
        },
        getCompletions: function (cmdLine) {
            var value = cmdLine.getValue();
            var m = value.replace(/^:/, &quot;&quot;).split(&quot;:&quot;);
            var row = Math.min(parseInt(m[0]) || 1, editor.session.getLength()) - 1;
            var line = editor.session.getLine(row);
            var current = value + &quot;  &quot; + line;
            return [current].concat(this.history());
        },
        $rules: {
            start: [{
                    regex: /\d+/,
                    token: &quot;string&quot;
                }, {
                    regex: /[:,&gt;&lt;+\-c]/,
                    token: &quot;keyword&quot;
                }]
        }
    });
};
prompt.commands = function (editor, callback) {
    function normalizeName(name) {
        return (name || &quot;&quot;).replace(/^./, function (x) {
            return x.toUpperCase(x);
        }).replace(/[a-z][A-Z]/g, function (x) {
            return x[0] + &quot; &quot; + x[1].toLowerCase(x);
        });
    }
    function getEditorCommandsByName(excludeCommands) {
        var commandsByName = [];
        var commandMap = {};
        editor.keyBinding.$handlers.forEach(function (handler) {
            var platform = handler.platform;
            var cbn = handler.byName;
            for (var i in cbn) {
                var key = cbn[i].bindKey;
                if (typeof key !== &quot;string&quot;) {
                    key = key &amp;&amp; key[platform] || &quot;&quot;;
                }
                var commands = cbn[i];
                var description = commands.description || normalizeName(commands.name);
                if (!Array.isArray(commands))
                    commands = [commands];
                commands.forEach(function (command) {
                    if (typeof command != &quot;string&quot;)
                        command = command.name;
                    var needle = excludeCommands.find(function (el) {
                        return el === command;
                    });
                    if (!needle) {
                        if (commandMap[command]) {
                            commandMap[command].key += &quot;|&quot; + key;
                        }
                        else {
                            commandMap[command] = { key: key, command: command, description: description };
                            commandsByName.push(commandMap[command]);
                        }
                    }
                });
            }
        });
        return commandsByName;
    }
    var excludeCommandsList = [&quot;insertstring&quot;, &quot;inserttext&quot;, &quot;setIndentation&quot;, &quot;paste&quot;];
    var shortcutsArray = getEditorCommandsByName(excludeCommandsList);
    shortcutsArray = shortcutsArray.map(function (item) {
        return { value: item.description, meta: item.key, command: item.command };
    });
    prompt(editor, &quot;&quot;, {
        name: &quot;commands&quot;,
        selection: [0, Number.MAX_VALUE],
        maxHistoryCount: 5,
        onAccept: function (data) {
            if (data.item) {
                var commandName = data.item.command;
                this.addToHistory(data.item);
                editor.execCommand(commandName);
            }
        },
        addToHistory: function (item) {
            var history = this.history();
            history.unshift(item);
            delete item.message;
            for (var i = 1; i &lt; history.length; i++) {
                if (history[i][&quot;command&quot;] == item.command) {
                    history.splice(i, 1);
                    break;
                }
            }
            if (this.maxHistoryCount &gt; 0 &amp;&amp; history.length &gt; this.maxHistoryCount) {
                history.splice(history.length - 1, 1);
            }
            prompt.commands.history = history;
        },
        history: function () {
            return prompt.commands.history || [];
        },
        getPrefix: function (cmdLine) {
            var currentPos = cmdLine.getCursorPosition();
            var filterValue = cmdLine.getValue();
            return filterValue.substring(0, currentPos.column);
        },
        getCompletions: function (cmdLine) {
            function getFilteredCompletions(commands, prefix) {
                var resultCommands = JSON.parse(JSON.stringify(commands));
                var filtered = new FilteredList(resultCommands);
                return filtered.filterCompletions(resultCommands, prefix);
            }
            function getUniqueCommandList(commands, usedCommands) {
                if (!usedCommands || !usedCommands.length) {
                    return commands;
                }
                var excludeCommands = [];
                usedCommands.forEach(function (item) {
                    excludeCommands.push(item.command);
                });
                var resultCommands = [];
                commands.forEach(function (item) {
                    if (excludeCommands.indexOf(item.command) === -1) {
                        resultCommands.push(item);
                    }
                });
                return resultCommands;
            }
            var prefix = this.getPrefix(cmdLine);
            var recentlyUsedCommands = getFilteredCompletions(this.history(), prefix);
            var otherCommands = getUniqueCommandList(shortcutsArray, recentlyUsedCommands);
            otherCommands = getFilteredCompletions(otherCommands, prefix);
            if (recentlyUsedCommands.length &amp;&amp; otherCommands.length) {
                recentlyUsedCommands[0][&quot;message&quot;] = &quot; Recently used&quot;;
                otherCommands[0][&quot;message&quot;] = &quot; Other commands&quot;;
            }
            var completions = recentlyUsedCommands.concat(otherCommands);
            return completions.length &gt; 0 ? completions : [{
                    value: &quot;No matching commands&quot;,
                    error: 1
                }];
        }
    });
};
prompt.modes = function (editor, callback) {
    var modesArray = modelist.modes;
    modesArray = modesArray.map(function (item) {
        return { value: item.caption, mode: item.name };
    });
    prompt(editor, &quot;&quot;, {
        name: &quot;modes&quot;,
        selection: [0, Number.MAX_VALUE],
        onAccept: function (data) {
            if (data.item) {
                var modeName = &quot;ace/mode/&quot; + data.item.mode;
                editor.session.setMode(modeName);
            }
        },
        getPrefix: function (cmdLine) {
            var currentPos = cmdLine.getCursorPosition();
            var filterValue = cmdLine.getValue();
            return filterValue.substring(0, currentPos.column);
        },
        getCompletions: function (cmdLine) {
            function getFilteredCompletions(modes, prefix) {
                var resultCommands = JSON.parse(JSON.stringify(modes));
                var filtered = new FilteredList(resultCommands);
                return filtered.filterCompletions(resultCommands, prefix);
            }
            var prefix = this.getPrefix(cmdLine);
            var completions = getFilteredCompletions(modesArray, prefix);
            return completions.length &gt; 0 ? completions : [{
                    &quot;caption&quot;: &quot;No mode matching&quot;,
                    &quot;value&quot;: &quot;No mode matching&quot;,
                    &quot;error&quot;: 1
                }];
        }
    });
};
dom.importCssString(&quot;.ace_prompt_container {\n    max-width: 600px;\n    width: 100%;\n    margin: 20px auto;\n    padding: 3px;\n    background: white;\n    border-radius: 2px;\n    box-shadow: 0px 2px 3px 0px #555;\n}&quot;, &quot;promtp.css&quot;, false);
exports.prompt = prompt;

});                (function() {
                    window.require([&quot;ace/ext/prompt&quot;], function(m) {
                        if (typeof module == &quot;object&quot; &amp;&amp; typeof exports == &quot;object&quot; &amp;&amp; module) {
                            module.exports = m;
                        }
                    });
                })();</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
