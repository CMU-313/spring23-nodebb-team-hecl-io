<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@eslint/eslintrc/node_modules/ajv/dist/ajv.bundle.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@eslint/eslintrc/node_modules/ajv/dist/ajv.bundle.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">50.98</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">7189</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">269.07</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">126.93</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">(function(f){if(typeof exports===&quot;object&quot;&amp;&amp;typeof module!==&quot;undefined&quot;){module.exports=f()}else if(typeof define===&quot;function&quot;&amp;&amp;define.amd){define([],f)}else{var g;if(typeof window!==&quot;undefined&quot;){g=window}else if(typeof global!==&quot;undefined&quot;){g=global}else if(typeof self!==&quot;undefined&quot;){g=self}else{g=this}g.Ajv = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=&quot;function&quot;==typeof require&amp;&amp;require;if(!f&amp;&amp;c)return c(i,!0);if(u)return u(i,!0);var a=new Error(&quot;Cannot find module &#039;&quot;+i+&quot;&#039;&quot;);throw a.code=&quot;MODULE_NOT_FOUND&quot;,a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=&quot;function&quot;==typeof require&amp;&amp;require,i=0;i&lt;t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
&#039;use strict&#039;;


var Cache = module.exports = function Cache() {
  this._cache = {};
};


Cache.prototype.put = function Cache_put(key, value) {
  this._cache[key] = value;
};


Cache.prototype.get = function Cache_get(key) {
  return this._cache[key];
};


Cache.prototype.del = function Cache_del(key) {
  delete this._cache[key];
};


Cache.prototype.clear = function Cache_clear() {
  this._cache = {};
};

},{}],2:[function(require,module,exports){
&#039;use strict&#039;;

var MissingRefError = require(&#039;./error_classes&#039;).MissingRef;

module.exports = compileAsync;


/**
 * Creates validating function for passed schema with asynchronous loading of missing schemas.
 * `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.
 * @this  Ajv
 * @param {Object}   schema schema object
 * @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped
 * @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.
 * @return {Promise} promise that resolves with a validating function.
 */
function compileAsync(schema, meta, callback) {
  /* eslint no-shadow: 0 */
  /* global Promise */
  /* jshint validthis: true */
  var self = this;
  if (typeof this._opts.loadSchema != &#039;function&#039;)
    throw new Error(&#039;options.loadSchema should be a function&#039;);

  if (typeof meta == &#039;function&#039;) {
    callback = meta;
    meta = undefined;
  }

  var p = loadMetaSchemaOf(schema).then(function () {
    var schemaObj = self._addSchema(schema, undefined, meta);
    return schemaObj.validate || _compileAsync(schemaObj);
  });

  if (callback) {
    p.then(
      function(v) { callback(null, v); },
      callback
    );
  }

  return p;


  function loadMetaSchemaOf(sch) {
    var $schema = sch.$schema;
    return $schema &amp;&amp; !self.getSchema($schema)
            ? compileAsync.call(self, { $ref: $schema }, true)
            : Promise.resolve();
  }


  function _compileAsync(schemaObj) {
    try { return self._compile(schemaObj); }
    catch(e) {
      if (e instanceof MissingRefError) return loadMissingSchema(e);
      throw e;
    }


    function loadMissingSchema(e) {
      var ref = e.missingSchema;
      if (added(ref)) throw new Error(&#039;Schema &#039; + ref + &#039; is loaded but &#039; + e.missingRef + &#039; cannot be resolved&#039;);

      var schemaPromise = self._loadingSchemas[ref];
      if (!schemaPromise) {
        schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);
        schemaPromise.then(removePromise, removePromise);
      }

      return schemaPromise.then(function (sch) {
        if (!added(ref)) {
          return loadMetaSchemaOf(sch).then(function () {
            if (!added(ref)) self.addSchema(sch, ref, undefined, meta);
          });
        }
      }).then(function() {
        return _compileAsync(schemaObj);
      });

      function removePromise() {
        delete self._loadingSchemas[ref];
      }

      function added(ref) {
        return self._refs[ref] || self._schemas[ref];
      }
    }
  }
}

},{&quot;./error_classes&quot;:3}],3:[function(require,module,exports){
&#039;use strict&#039;;

var resolve = require(&#039;./resolve&#039;);

module.exports = {
  Validation: errorSubclass(ValidationError),
  MissingRef: errorSubclass(MissingRefError)
};


function ValidationError(errors) {
  this.message = &#039;validation failed&#039;;
  this.errors = errors;
  this.ajv = this.validation = true;
}


MissingRefError.message = function (baseId, ref) {
  return &#039;can\&#039;t resolve reference &#039; + ref + &#039; from id &#039; + baseId;
};


function MissingRefError(baseId, ref, message) {
  this.message = message || MissingRefError.message(baseId, ref);
  this.missingRef = resolve.url(baseId, ref);
  this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
}


function errorSubclass(Subclass) {
  Subclass.prototype = Object.create(Error.prototype);
  Subclass.prototype.constructor = Subclass;
  return Subclass;
}

},{&quot;./resolve&quot;:6}],4:[function(require,module,exports){
&#039;use strict&#039;;

var util = require(&#039;./util&#039;);

var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [0,31,28,31,30,31,30,31,31,30,31,30,31];
var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&amp;&#039;()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&amp;&#039;()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&amp;&#039;()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&amp;&#039;()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&amp;&#039;()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&amp;&#039;()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&amp;&#039;()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&amp;&#039;()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&amp;&#039;()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&amp;&#039;()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&amp;&#039;()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&amp;&#039;()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&amp;&#039;&quot;()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&amp;&#039;&quot;()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&amp;&#039;&quot;()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&amp;&#039;&quot;()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&amp;&#039;&quot;()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&amp;&#039;&quot;()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&amp;&#039;&quot;()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&amp;&#039;&quot;()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
// uri-template: https://tools.ietf.org/html/rfc6570
var URITEMPLATE = /^(?:(?:[^\x00-\x20&quot;&#039;&lt;&gt;%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&amp;=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
// For the source: https://gist.github.com/dperini/729294
// For test cases: https://mathiasbynens.be/demo/url-regex
// @todo Delete current URL in favour of the commented out URL rule when this issue is fixed https://github.com/eslint/eslint/issues/7983.
// var URL = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu;
var URL = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&amp;&#039;()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;


module.exports = formats;

function formats(mode) {
  mode = mode == &#039;full&#039; ? &#039;full&#039; : &#039;fast&#039;;
  return util.copy(formats[mode]);
}


formats.fast = {
  // date: http://tools.ietf.org/html/rfc3339#section-5.6
  date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
  time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
  &#039;date-time&#039;: /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
  uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
  &#039;uri-reference&#039;: /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
  &#039;uri-template&#039;: URITEMPLATE,
  url: URL,
  // email (sources from jsen validator):
  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for &#039;willful violation&#039;)
  email: /^[a-z0-9.!#$%&amp;&#039;*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
  hostname: HOSTNAME,
  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: regex,
  // uuid: http://tools.ietf.org/html/rfc4122
  uuid: UUID,
  // JSON-pointer: https://tools.ietf.org/html/rfc6901
  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
  &#039;json-pointer&#039;: JSON_POINTER,
  &#039;json-pointer-uri-fragment&#039;: JSON_POINTER_URI_FRAGMENT,
  // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
  &#039;relative-json-pointer&#039;: RELATIVE_JSON_POINTER
};


formats.full = {
  date: date,
  time: time,
  &#039;date-time&#039;: date_time,
  uri: uri,
  &#039;uri-reference&#039;: URIREF,
  &#039;uri-template&#039;: URITEMPLATE,
  url: URL,
  email: /^[a-z0-9!#$%&amp;&#039;*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;&#039;*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
  hostname: HOSTNAME,
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: regex,
  uuid: UUID,
  &#039;json-pointer&#039;: JSON_POINTER,
  &#039;json-pointer-uri-fragment&#039;: JSON_POINTER_URI_FRAGMENT,
  &#039;relative-json-pointer&#039;: RELATIVE_JSON_POINTER
};


function isLeapYear(year) {
  // https://tools.ietf.org/html/rfc3339#appendix-C
  return year % 4 === 0 &amp;&amp; (year % 100 !== 0 || year % 400 === 0);
}


function date(str) {
  // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
  var matches = str.match(DATE);
  if (!matches) return false;

  var year = +matches[1];
  var month = +matches[2];
  var day = +matches[3];

  return month &gt;= 1 &amp;&amp; month &lt;= 12 &amp;&amp; day &gt;= 1 &amp;&amp;
          day &lt;= (month == 2 &amp;&amp; isLeapYear(year) ? 29 : DAYS[month]);
}


function time(str, full) {
  var matches = str.match(TIME);
  if (!matches) return false;

  var hour = matches[1];
  var minute = matches[2];
  var second = matches[3];
  var timeZone = matches[5];
  return ((hour &lt;= 23 &amp;&amp; minute &lt;= 59 &amp;&amp; second &lt;= 59) ||
          (hour == 23 &amp;&amp; minute == 59 &amp;&amp; second == 60)) &amp;&amp;
         (!full || timeZone);
}


var DATE_TIME_SEPARATOR = /t|\s/i;
function date_time(str) {
  // http://tools.ietf.org/html/rfc3339#section-5.6
  var dateTime = str.split(DATE_TIME_SEPARATOR);
  return dateTime.length == 2 &amp;&amp; date(dateTime[0]) &amp;&amp; time(dateTime[1], true);
}


var NOT_URI_FRAGMENT = /\/|:/;
function uri(str) {
  // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required &quot;.&quot;
  return NOT_URI_FRAGMENT.test(str) &amp;&amp; URI.test(str);
}


var Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
  if (Z_ANCHOR.test(str)) return false;
  try {
    new RegExp(str);
    return true;
  } catch(e) {
    return false;
  }
}

},{&quot;./util&quot;:10}],5:[function(require,module,exports){
&#039;use strict&#039;;

var resolve = require(&#039;./resolve&#039;)
  , util = require(&#039;./util&#039;)
  , errorClasses = require(&#039;./error_classes&#039;)
  , stableStringify = require(&#039;fast-json-stable-stringify&#039;);

var validateGenerator = require(&#039;../dotjs/validate&#039;);

/**
 * Functions below are used inside compiled validations function
 */

var ucs2length = util.ucs2length;
var equal = require(&#039;fast-deep-equal&#039;);

// this error is thrown by async schemas to return validation errors via exception
var ValidationError = errorClasses.Validation;

module.exports = compile;


/**
 * Compiles schema to validation function
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Object} root object with information about the root schema for this schema
 * @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
 * @param  {String} baseId base ID for IDs in the schema
 * @return {Function} validation function
 */
function compile(schema, root, localRefs, baseId) {
  /* jshint validthis: true, evil: true */
  /* eslint no-shadow: 0 */
  var self = this
    , opts = this._opts
    , refVal = [ undefined ]
    , refs = {}
    , patterns = []
    , patternsHash = {}
    , defaults = []
    , defaultsHash = {}
    , customRules = [];

  root = root || { schema: schema, refVal: refVal, refs: refs };

  var c = checkCompiling.call(this, schema, root, baseId);
  var compilation = this._compilations[c.index];
  if (c.compiling) return (compilation.callValidate = callValidate);

  var formats = this._formats;
  var RULES = this.RULES;

  try {
    var v = localCompile(schema, root, localRefs, baseId);
    compilation.validate = v;
    var cv = compilation.callValidate;
    if (cv) {
      cv.schema = v.schema;
      cv.errors = null;
      cv.refs = v.refs;
      cv.refVal = v.refVal;
      cv.root = v.root;
      cv.$async = v.$async;
      if (opts.sourceCode) cv.source = v.source;
    }
    return v;
  } finally {
    endCompiling.call(this, schema, root, baseId);
  }

  /* @this   {*} - custom context, see passContext option */
  function callValidate() {
    /* jshint validthis: true */
    var validate = compilation.validate;
    var result = validate.apply(this, arguments);
    callValidate.errors = validate.errors;
    return result;
  }

  function localCompile(_schema, _root, localRefs, baseId) {
    var isRoot = !_root || (_root &amp;&amp; _root.schema == _schema);
    if (_root.schema != root.schema)
      return compile.call(self, _schema, _root, localRefs, baseId);

    var $async = _schema.$async === true;

    var sourceCode = validateGenerator({
      isTop: true,
      schema: _schema,
      isRoot: isRoot,
      baseId: baseId,
      root: _root,
      schemaPath: &#039;&#039;,
      errSchemaPath: &#039;#&#039;,
      errorPath: &#039;&quot;&quot;&#039;,
      MissingRefError: errorClasses.MissingRef,
      RULES: RULES,
      validate: validateGenerator,
      util: util,
      resolve: resolve,
      resolveRef: resolveRef,
      usePattern: usePattern,
      useDefault: useDefault,
      useCustomRule: useCustomRule,
      opts: opts,
      formats: formats,
      logger: self.logger,
      self: self
    });

    sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode)
                   + vars(defaults, defaultCode) + vars(customRules, customRuleCode)
                   + sourceCode;

    if (opts.processCode) sourceCode = opts.processCode(sourceCode, _schema);
    // console.log(&#039;\n\n\n *** \n&#039;, JSON.stringify(sourceCode));
    var validate;
    try {
      var makeValidate = new Function(
        &#039;self&#039;,
        &#039;RULES&#039;,
        &#039;formats&#039;,
        &#039;root&#039;,
        &#039;refVal&#039;,
        &#039;defaults&#039;,
        &#039;customRules&#039;,
        &#039;equal&#039;,
        &#039;ucs2length&#039;,
        &#039;ValidationError&#039;,
        sourceCode
      );

      validate = makeValidate(
        self,
        RULES,
        formats,
        root,
        refVal,
        defaults,
        customRules,
        equal,
        ucs2length,
        ValidationError
      );

      refVal[0] = validate;
    } catch(e) {
      self.logger.error(&#039;Error compiling schema, function code:&#039;, sourceCode);
      throw e;
    }

    validate.schema = _schema;
    validate.errors = null;
    validate.refs = refs;
    validate.refVal = refVal;
    validate.root = isRoot ? validate : _root;
    if ($async) validate.$async = true;
    if (opts.sourceCode === true) {
      validate.source = {
        code: sourceCode,
        patterns: patterns,
        defaults: defaults
      };
    }

    return validate;
  }

  function resolveRef(baseId, ref, isRoot) {
    ref = resolve.url(baseId, ref);
    var refIndex = refs[ref];
    var _refVal, refCode;
    if (refIndex !== undefined) {
      _refVal = refVal[refIndex];
      refCode = &#039;refVal[&#039; + refIndex + &#039;]&#039;;
      return resolvedRef(_refVal, refCode);
    }
    if (!isRoot &amp;&amp; root.refs) {
      var rootRefId = root.refs[ref];
      if (rootRefId !== undefined) {
        _refVal = root.refVal[rootRefId];
        refCode = addLocalRef(ref, _refVal);
        return resolvedRef(_refVal, refCode);
      }
    }

    refCode = addLocalRef(ref);
    var v = resolve.call(self, localCompile, root, ref);
    if (v === undefined) {
      var localSchema = localRefs &amp;&amp; localRefs[ref];
      if (localSchema) {
        v = resolve.inlineRef(localSchema, opts.inlineRefs)
            ? localSchema
            : compile.call(self, localSchema, root, localRefs, baseId);
      }
    }

    if (v === undefined) {
      removeLocalRef(ref);
    } else {
      replaceLocalRef(ref, v);
      return resolvedRef(v, refCode);
    }
  }

  function addLocalRef(ref, v) {
    var refId = refVal.length;
    refVal[refId] = v;
    refs[ref] = refId;
    return &#039;refVal&#039; + refId;
  }

  function removeLocalRef(ref) {
    delete refs[ref];
  }

  function replaceLocalRef(ref, v) {
    var refId = refs[ref];
    refVal[refId] = v;
  }

  function resolvedRef(refVal, code) {
    return typeof refVal == &#039;object&#039; || typeof refVal == &#039;boolean&#039;
            ? { code: code, schema: refVal, inline: true }
            : { code: code, $async: refVal &amp;&amp; !!refVal.$async };
  }

  function usePattern(regexStr) {
    var index = patternsHash[regexStr];
    if (index === undefined) {
      index = patternsHash[regexStr] = patterns.length;
      patterns[index] = regexStr;
    }
    return &#039;pattern&#039; + index;
  }

  function useDefault(value) {
    switch (typeof value) {
      case &#039;boolean&#039;:
      case &#039;number&#039;:
        return &#039;&#039; + value;
      case &#039;string&#039;:
        return util.toQuotedString(value);
      case &#039;object&#039;:
        if (value === null) return &#039;null&#039;;
        var valueStr = stableStringify(value);
        var index = defaultsHash[valueStr];
        if (index === undefined) {
          index = defaultsHash[valueStr] = defaults.length;
          defaults[index] = value;
        }
        return &#039;default&#039; + index;
    }
  }

  function useCustomRule(rule, schema, parentSchema, it) {
    if (self._opts.validateSchema !== false) {
      var deps = rule.definition.dependencies;
      if (deps &amp;&amp; !deps.every(function(keyword) {
        return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
      }))
        throw new Error(&#039;parent schema must have all required keywords: &#039; + deps.join(&#039;,&#039;));

      var validateSchema = rule.definition.validateSchema;
      if (validateSchema) {
        var valid = validateSchema(schema);
        if (!valid) {
          var message = &#039;keyword schema is invalid: &#039; + self.errorsText(validateSchema.errors);
          if (self._opts.validateSchema == &#039;log&#039;) self.logger.error(message);
          else throw new Error(message);
        }
      }
    }

    var compile = rule.definition.compile
      , inline = rule.definition.inline
      , macro = rule.definition.macro;

    var validate;
    if (compile) {
      validate = compile.call(self, schema, parentSchema, it);
    } else if (macro) {
      validate = macro.call(self, schema, parentSchema, it);
      if (opts.validateSchema !== false) self.validateSchema(validate, true);
    } else if (inline) {
      validate = inline.call(self, it, rule.keyword, schema, parentSchema);
    } else {
      validate = rule.definition.validate;
      if (!validate) return;
    }

    if (validate === undefined)
      throw new Error(&#039;custom keyword &quot;&#039; + rule.keyword + &#039;&quot;failed to compile&#039;);

    var index = customRules.length;
    customRules[index] = validate;

    return {
      code: &#039;customRule&#039; + index,
      validate: validate
    };
  }
}


/**
 * Checks if the schema is currently compiled
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Object} object with properties &quot;index&quot; (compilation index) and &quot;compiling&quot; (boolean)
 */
function checkCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var index = compIndex.call(this, schema, root, baseId);
  if (index &gt;= 0) return { index: index, compiling: true };
  index = this._compilations.length;
  this._compilations[index] = {
    schema: schema,
    root: root,
    baseId: baseId
  };
  return { index: index, compiling: false };
}


/**
 * Removes the schema from the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 */
function endCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var i = compIndex.call(this, schema, root, baseId);
  if (i &gt;= 0) this._compilations.splice(i, 1);
}


/**
 * Index of schema compilation in the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Integer} compilation index
 */
function compIndex(schema, root, baseId) {
  /* jshint validthis: true */
  for (var i=0; i&lt;this._compilations.length; i++) {
    var c = this._compilations[i];
    if (c.schema == schema &amp;&amp; c.root == root &amp;&amp; c.baseId == baseId) return i;
  }
  return -1;
}


function patternCode(i, patterns) {
  return &#039;var pattern&#039; + i + &#039; = new RegExp(&#039; + util.toQuotedString(patterns[i]) + &#039;);&#039;;
}


function defaultCode(i) {
  return &#039;var default&#039; + i + &#039; = defaults[&#039; + i + &#039;];&#039;;
}


function refValCode(i, refVal) {
  return refVal[i] === undefined ? &#039;&#039; : &#039;var refVal&#039; + i + &#039; = refVal[&#039; + i + &#039;];&#039;;
}


function customRuleCode(i) {
  return &#039;var customRule&#039; + i + &#039; = customRules[&#039; + i + &#039;];&#039;;
}


function vars(arr, statement) {
  if (!arr.length) return &#039;&#039;;
  var code = &#039;&#039;;
  for (var i=0; i&lt;arr.length; i++)
    code += statement(i, arr);
  return code;
}

},{&quot;../dotjs/validate&quot;:38,&quot;./error_classes&quot;:3,&quot;./resolve&quot;:6,&quot;./util&quot;:10,&quot;fast-deep-equal&quot;:42,&quot;fast-json-stable-stringify&quot;:43}],6:[function(require,module,exports){
&#039;use strict&#039;;

var URI = require(&#039;uri-js&#039;)
  , equal = require(&#039;fast-deep-equal&#039;)
  , util = require(&#039;./util&#039;)
  , SchemaObject = require(&#039;./schema_obj&#039;)
  , traverse = require(&#039;json-schema-traverse&#039;);

module.exports = resolve;

resolve.normalizeId = normalizeId;
resolve.fullPath = getFullPath;
resolve.url = resolveUrl;
resolve.ids = resolveIds;
resolve.inlineRef = inlineRef;
resolve.schema = resolveSchema;

/**
 * [resolve and compile the references ($ref)]
 * @this   Ajv
 * @param  {Function} compile reference to schema compilation funciton (localCompile)
 * @param  {Object} root object with information about the root schema for the current schema
 * @param  {String} ref reference to resolve
 * @return {Object|Function} schema object (if the schema can be inlined) or validation function
 */
function resolve(compile, root, ref) {
  /* jshint validthis: true */
  var refVal = this._refs[ref];
  if (typeof refVal == &#039;string&#039;) {
    if (this._refs[refVal]) refVal = this._refs[refVal];
    else return resolve.call(this, compile, root, refVal);
  }

  refVal = refVal || this._schemas[ref];
  if (refVal instanceof SchemaObject) {
    return inlineRef(refVal.schema, this._opts.inlineRefs)
            ? refVal.schema
            : refVal.validate || this._compile(refVal);
  }

  var res = resolveSchema.call(this, root, ref);
  var schema, v, baseId;
  if (res) {
    schema = res.schema;
    root = res.root;
    baseId = res.baseId;
  }

  if (schema instanceof SchemaObject) {
    v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
  } else if (schema !== undefined) {
    v = inlineRef(schema, this._opts.inlineRefs)
        ? schema
        : compile.call(this, schema, root, undefined, baseId);
  }

  return v;
}


/**
 * Resolve schema, its root and baseId
 * @this Ajv
 * @param  {Object} root root object with properties schema, refVal, refs
 * @param  {String} ref  reference to resolve
 * @return {Object} object with properties schema, root, baseId
 */
function resolveSchema(root, ref) {
  /* jshint validthis: true */
  var p = URI.parse(ref)
    , refPath = _getFullPath(p)
    , baseId = getFullPath(this._getId(root.schema));
  if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
    var id = normalizeId(refPath);
    var refVal = this._refs[id];
    if (typeof refVal == &#039;string&#039;) {
      return resolveRecursive.call(this, root, refVal, p);
    } else if (refVal instanceof SchemaObject) {
      if (!refVal.validate) this._compile(refVal);
      root = refVal;
    } else {
      refVal = this._schemas[id];
      if (refVal instanceof SchemaObject) {
        if (!refVal.validate) this._compile(refVal);
        if (id == normalizeId(ref))
          return { schema: refVal, root: root, baseId: baseId };
        root = refVal;
      } else {
        return;
      }
    }
    if (!root.schema) return;
    baseId = getFullPath(this._getId(root.schema));
  }
  return getJsonPointer.call(this, p, baseId, root.schema, root);
}


/* @this Ajv */
function resolveRecursive(root, ref, parsedRef) {
  /* jshint validthis: true */
  var res = resolveSchema.call(this, root, ref);
  if (res) {
    var schema = res.schema;
    var baseId = res.baseId;
    root = res.root;
    var id = this._getId(schema);
    if (id) baseId = resolveUrl(baseId, id);
    return getJsonPointer.call(this, parsedRef, baseId, schema, root);
  }
}


var PREVENT_SCOPE_CHANGE = util.toHash([&#039;properties&#039;, &#039;patternProperties&#039;, &#039;enum&#039;, &#039;dependencies&#039;, &#039;definitions&#039;]);
/* @this Ajv */
function getJsonPointer(parsedRef, baseId, schema, root) {
  /* jshint validthis: true */
  parsedRef.fragment = parsedRef.fragment || &#039;&#039;;
  if (parsedRef.fragment.slice(0,1) != &#039;/&#039;) return;
  var parts = parsedRef.fragment.split(&#039;/&#039;);

  for (var i = 1; i &lt; parts.length; i++) {
    var part = parts[i];
    if (part) {
      part = util.unescapeFragment(part);
      schema = schema[part];
      if (schema === undefined) break;
      var id;
      if (!PREVENT_SCOPE_CHANGE[part]) {
        id = this._getId(schema);
        if (id) baseId = resolveUrl(baseId, id);
        if (schema.$ref) {
          var $ref = resolveUrl(baseId, schema.$ref);
          var res = resolveSchema.call(this, root, $ref);
          if (res) {
            schema = res.schema;
            root = res.root;
            baseId = res.baseId;
          }
        }
      }
    }
  }
  if (schema !== undefined &amp;&amp; schema !== root.schema)
    return { schema: schema, root: root, baseId: baseId };
}


var SIMPLE_INLINED = util.toHash([
  &#039;type&#039;, &#039;format&#039;, &#039;pattern&#039;,
  &#039;maxLength&#039;, &#039;minLength&#039;,
  &#039;maxProperties&#039;, &#039;minProperties&#039;,
  &#039;maxItems&#039;, &#039;minItems&#039;,
  &#039;maximum&#039;, &#039;minimum&#039;,
  &#039;uniqueItems&#039;, &#039;multipleOf&#039;,
  &#039;required&#039;, &#039;enum&#039;
]);
function inlineRef(schema, limit) {
  if (limit === false) return false;
  if (limit === undefined || limit === true) return checkNoRef(schema);
  else if (limit) return countKeys(schema) &lt;= limit;
}


function checkNoRef(schema) {
  var item;
  if (Array.isArray(schema)) {
    for (var i=0; i&lt;schema.length; i++) {
      item = schema[i];
      if (typeof item == &#039;object&#039; &amp;&amp; !checkNoRef(item)) return false;
    }
  } else {
    for (var key in schema) {
      if (key == &#039;$ref&#039;) return false;
      item = schema[key];
      if (typeof item == &#039;object&#039; &amp;&amp; !checkNoRef(item)) return false;
    }
  }
  return true;
}


function countKeys(schema) {
  var count = 0, item;
  if (Array.isArray(schema)) {
    for (var i=0; i&lt;schema.length; i++) {
      item = schema[i];
      if (typeof item == &#039;object&#039;) count += countKeys(item);
      if (count == Infinity) return Infinity;
    }
  } else {
    for (var key in schema) {
      if (key == &#039;$ref&#039;) return Infinity;
      if (SIMPLE_INLINED[key]) {
        count++;
      } else {
        item = schema[key];
        if (typeof item == &#039;object&#039;) count += countKeys(item) + 1;
        if (count == Infinity) return Infinity;
      }
    }
  }
  return count;
}


function getFullPath(id, normalize) {
  if (normalize !== false) id = normalizeId(id);
  var p = URI.parse(id);
  return _getFullPath(p);
}


function _getFullPath(p) {
  return URI.serialize(p).split(&#039;#&#039;)[0] + &#039;#&#039;;
}


var TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id) {
  return id ? id.replace(TRAILING_SLASH_HASH, &#039;&#039;) : &#039;&#039;;
}


function resolveUrl(baseId, id) {
  id = normalizeId(id);
  return URI.resolve(baseId, id);
}


/* @this Ajv */
function resolveIds(schema) {
  var schemaId = normalizeId(this._getId(schema));
  var baseIds = {&#039;&#039;: schemaId};
  var fullPaths = {&#039;&#039;: getFullPath(schemaId, false)};
  var localRefs = {};
  var self = this;

  traverse(schema, {allKeys: true}, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (jsonPtr === &#039;&#039;) return;
    var id = self._getId(sch);
    var baseId = baseIds[parentJsonPtr];
    var fullPath = fullPaths[parentJsonPtr] + &#039;/&#039; + parentKeyword;
    if (keyIndex !== undefined)
      fullPath += &#039;/&#039; + (typeof keyIndex == &#039;number&#039; ? keyIndex : util.escapeFragment(keyIndex));

    if (typeof id == &#039;string&#039;) {
      id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);

      var refVal = self._refs[id];
      if (typeof refVal == &#039;string&#039;) refVal = self._refs[refVal];
      if (refVal &amp;&amp; refVal.schema) {
        if (!equal(sch, refVal.schema))
          throw new Error(&#039;id &quot;&#039; + id + &#039;&quot; resolves to more than one schema&#039;);
      } else if (id != normalizeId(fullPath)) {
        if (id[0] == &#039;#&#039;) {
          if (localRefs[id] &amp;&amp; !equal(sch, localRefs[id]))
            throw new Error(&#039;id &quot;&#039; + id + &#039;&quot; resolves to more than one schema&#039;);
          localRefs[id] = sch;
        } else {
          self._refs[id] = fullPath;
        }
      }
    }
    baseIds[jsonPtr] = baseId;
    fullPaths[jsonPtr] = fullPath;
  });

  return localRefs;
}

},{&quot;./schema_obj&quot;:8,&quot;./util&quot;:10,&quot;fast-deep-equal&quot;:42,&quot;json-schema-traverse&quot;:44,&quot;uri-js&quot;:45}],7:[function(require,module,exports){
&#039;use strict&#039;;

var ruleModules = require(&#039;../dotjs&#039;)
  , toHash = require(&#039;./util&#039;).toHash;

module.exports = function rules() {
  var RULES = [
    { type: &#039;number&#039;,
      rules: [ { &#039;maximum&#039;: [&#039;exclusiveMaximum&#039;] },
               { &#039;minimum&#039;: [&#039;exclusiveMinimum&#039;] }, &#039;multipleOf&#039;, &#039;format&#039;] },
    { type: &#039;string&#039;,
      rules: [ &#039;maxLength&#039;, &#039;minLength&#039;, &#039;pattern&#039;, &#039;format&#039; ] },
    { type: &#039;array&#039;,
      rules: [ &#039;maxItems&#039;, &#039;minItems&#039;, &#039;items&#039;, &#039;contains&#039;, &#039;uniqueItems&#039; ] },
    { type: &#039;object&#039;,
      rules: [ &#039;maxProperties&#039;, &#039;minProperties&#039;, &#039;required&#039;, &#039;dependencies&#039;, &#039;propertyNames&#039;,
               { &#039;properties&#039;: [&#039;additionalProperties&#039;, &#039;patternProperties&#039;] } ] },
    { rules: [ &#039;$ref&#039;, &#039;const&#039;, &#039;enum&#039;, &#039;not&#039;, &#039;anyOf&#039;, &#039;oneOf&#039;, &#039;allOf&#039;, &#039;if&#039; ] }
  ];

  var ALL = [ &#039;type&#039;, &#039;$comment&#039; ];
  var KEYWORDS = [
    &#039;$schema&#039;, &#039;$id&#039;, &#039;id&#039;, &#039;$data&#039;, &#039;$async&#039;, &#039;title&#039;,
    &#039;description&#039;, &#039;default&#039;, &#039;definitions&#039;,
    &#039;examples&#039;, &#039;readOnly&#039;, &#039;writeOnly&#039;,
    &#039;contentMediaType&#039;, &#039;contentEncoding&#039;,
    &#039;additionalItems&#039;, &#039;then&#039;, &#039;else&#039;
  ];
  var TYPES = [ &#039;number&#039;, &#039;integer&#039;, &#039;string&#039;, &#039;array&#039;, &#039;object&#039;, &#039;boolean&#039;, &#039;null&#039; ];
  RULES.all = toHash(ALL);
  RULES.types = toHash(TYPES);

  RULES.forEach(function (group) {
    group.rules = group.rules.map(function (keyword) {
      var implKeywords;
      if (typeof keyword == &#039;object&#039;) {
        var key = Object.keys(keyword)[0];
        implKeywords = keyword[key];
        keyword = key;
        implKeywords.forEach(function (k) {
          ALL.push(k);
          RULES.all[k] = true;
        });
      }
      ALL.push(keyword);
      var rule = RULES.all[keyword] = {
        keyword: keyword,
        code: ruleModules[keyword],
        implements: implKeywords
      };
      return rule;
    });

    RULES.all.$comment = {
      keyword: &#039;$comment&#039;,
      code: ruleModules.$comment
    };

    if (group.type) RULES.types[group.type] = group;
  });

  RULES.keywords = toHash(ALL.concat(KEYWORDS));
  RULES.custom = {};

  return RULES;
};

},{&quot;../dotjs&quot;:27,&quot;./util&quot;:10}],8:[function(require,module,exports){
&#039;use strict&#039;;

var util = require(&#039;./util&#039;);

module.exports = SchemaObject;

function SchemaObject(obj) {
  util.copy(obj, this);
}

},{&quot;./util&quot;:10}],9:[function(require,module,exports){
&#039;use strict&#039;;

// https://mathiasbynens.be/notes/javascript-encoding
// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
module.exports = function ucs2length(str) {
  var length = 0
    , len = str.length
    , pos = 0
    , value;
  while (pos &lt; len) {
    length++;
    value = str.charCodeAt(pos++);
    if (value &gt;= 0xD800 &amp;&amp; value &lt;= 0xDBFF &amp;&amp; pos &lt; len) {
      // high surrogate, and there is a next character
      value = str.charCodeAt(pos);
      if ((value &amp; 0xFC00) == 0xDC00) pos++; // low surrogate
    }
  }
  return length;
};

},{}],10:[function(require,module,exports){
&#039;use strict&#039;;


module.exports = {
  copy: copy,
  checkDataType: checkDataType,
  checkDataTypes: checkDataTypes,
  coerceToTypes: coerceToTypes,
  toHash: toHash,
  getProperty: getProperty,
  escapeQuotes: escapeQuotes,
  equal: require(&#039;fast-deep-equal&#039;),
  ucs2length: require(&#039;./ucs2length&#039;),
  varOccurences: varOccurences,
  varReplace: varReplace,
  schemaHasRules: schemaHasRules,
  schemaHasRulesExcept: schemaHasRulesExcept,
  schemaUnknownRules: schemaUnknownRules,
  toQuotedString: toQuotedString,
  getPathExpr: getPathExpr,
  getPath: getPath,
  getData: getData,
  unescapeFragment: unescapeFragment,
  unescapeJsonPointer: unescapeJsonPointer,
  escapeFragment: escapeFragment,
  escapeJsonPointer: escapeJsonPointer
};


function copy(o, to) {
  to = to || {};
  for (var key in o) to[key] = o[key];
  return to;
}


function checkDataType(dataType, data, strictNumbers, negate) {
  var EQUAL = negate ? &#039; !== &#039; : &#039; === &#039;
    , AND = negate ? &#039; || &#039; : &#039; &amp;&amp; &#039;
    , OK = negate ? &#039;!&#039; : &#039;&#039;
    , NOT = negate ? &#039;&#039; : &#039;!&#039;;
  switch (dataType) {
    case &#039;null&#039;: return data + EQUAL + &#039;null&#039;;
    case &#039;array&#039;: return OK + &#039;Array.isArray(&#039; + data + &#039;)&#039;;
    case &#039;object&#039;: return &#039;(&#039; + OK + data + AND +
                          &#039;typeof &#039; + data + EQUAL + &#039;&quot;object&quot;&#039; + AND +
                          NOT + &#039;Array.isArray(&#039; + data + &#039;))&#039;;
    case &#039;integer&#039;: return &#039;(typeof &#039; + data + EQUAL + &#039;&quot;number&quot;&#039; + AND +
                           NOT + &#039;(&#039; + data + &#039; % 1)&#039; +
                           AND + data + EQUAL + data +
                           (strictNumbers ? (AND + OK + &#039;isFinite(&#039; + data + &#039;)&#039;) : &#039;&#039;) + &#039;)&#039;;
    case &#039;number&#039;: return &#039;(typeof &#039; + data + EQUAL + &#039;&quot;&#039; + dataType + &#039;&quot;&#039; +
                          (strictNumbers ? (AND + OK + &#039;isFinite(&#039; + data + &#039;)&#039;) : &#039;&#039;) + &#039;)&#039;;
    default: return &#039;typeof &#039; + data + EQUAL + &#039;&quot;&#039; + dataType + &#039;&quot;&#039;;
  }
}


function checkDataTypes(dataTypes, data, strictNumbers) {
  switch (dataTypes.length) {
    case 1: return checkDataType(dataTypes[0], data, strictNumbers, true);
    default:
      var code = &#039;&#039;;
      var types = toHash(dataTypes);
      if (types.array &amp;&amp; types.object) {
        code = types.null ? &#039;(&#039;: &#039;(!&#039; + data + &#039; || &#039;;
        code += &#039;typeof &#039; + data + &#039; !== &quot;object&quot;)&#039;;
        delete types.null;
        delete types.array;
        delete types.object;
      }
      if (types.number) delete types.integer;
      for (var t in types)
        code += (code ? &#039; &amp;&amp; &#039; : &#039;&#039; ) + checkDataType(t, data, strictNumbers, true);

      return code;
  }
}


var COERCE_TO_TYPES = toHash([ &#039;string&#039;, &#039;number&#039;, &#039;integer&#039;, &#039;boolean&#039;, &#039;null&#039; ]);
function coerceToTypes(optionCoerceTypes, dataTypes) {
  if (Array.isArray(dataTypes)) {
    var types = [];
    for (var i=0; i&lt;dataTypes.length; i++) {
      var t = dataTypes[i];
      if (COERCE_TO_TYPES[t]) types[types.length] = t;
      else if (optionCoerceTypes === &#039;array&#039; &amp;&amp; t === &#039;array&#039;) types[types.length] = t;
    }
    if (types.length) return types;
  } else if (COERCE_TO_TYPES[dataTypes]) {
    return [dataTypes];
  } else if (optionCoerceTypes === &#039;array&#039; &amp;&amp; dataTypes === &#039;array&#039;) {
    return [&#039;array&#039;];
  }
}


function toHash(arr) {
  var hash = {};
  for (var i=0; i&lt;arr.length; i++) hash[arr[i]] = true;
  return hash;
}


var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
var SINGLE_QUOTE = /&#039;|\\/g;
function getProperty(key) {
  return typeof key == &#039;number&#039;
          ? &#039;[&#039; + key + &#039;]&#039;
          : IDENTIFIER.test(key)
            ? &#039;.&#039; + key
            : &quot;[&#039;&quot; + escapeQuotes(key) + &quot;&#039;]&quot;;
}


function escapeQuotes(str) {
  return str.replace(SINGLE_QUOTE, &#039;\\$&amp;&#039;)
            .replace(/\n/g, &#039;\\n&#039;)
            .replace(/\r/g, &#039;\\r&#039;)
            .replace(/\f/g, &#039;\\f&#039;)
            .replace(/\t/g, &#039;\\t&#039;);
}


function varOccurences(str, dataVar) {
  dataVar += &#039;[^0-9]&#039;;
  var matches = str.match(new RegExp(dataVar, &#039;g&#039;));
  return matches ? matches.length : 0;
}


function varReplace(str, dataVar, expr) {
  dataVar += &#039;([^0-9])&#039;;
  expr = expr.replace(/\$/g, &#039;$$$$&#039;);
  return str.replace(new RegExp(dataVar, &#039;g&#039;), expr + &#039;$1&#039;);
}


function schemaHasRules(schema, rules) {
  if (typeof schema == &#039;boolean&#039;) return !schema;
  for (var key in schema) if (rules[key]) return true;
}


function schemaHasRulesExcept(schema, rules, exceptKeyword) {
  if (typeof schema == &#039;boolean&#039;) return !schema &amp;&amp; exceptKeyword != &#039;not&#039;;
  for (var key in schema) if (key != exceptKeyword &amp;&amp; rules[key]) return true;
}


function schemaUnknownRules(schema, rules) {
  if (typeof schema == &#039;boolean&#039;) return;
  for (var key in schema) if (!rules[key]) return key;
}


function toQuotedString(str) {
  return &#039;\&#039;&#039; + escapeQuotes(str) + &#039;\&#039;&#039;;
}


function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
  var path = jsonPointers // false by default
              ? &#039;\&#039;/\&#039; + &#039; + expr + (isNumber ? &#039;&#039; : &#039;.replace(/~/g, \&#039;~0\&#039;).replace(/\\//g, \&#039;~1\&#039;)&#039;)
              : (isNumber ? &#039;\&#039;[\&#039; + &#039; + expr + &#039; + \&#039;]\&#039;&#039; : &#039;\&#039;[\\\&#039;\&#039; + &#039; + expr + &#039; + \&#039;\\\&#039;]\&#039;&#039;);
  return joinPaths(currentPath, path);
}


function getPath(currentPath, prop, jsonPointers) {
  var path = jsonPointers // false by default
              ? toQuotedString(&#039;/&#039; + escapeJsonPointer(prop))
              : toQuotedString(getProperty(prop));
  return joinPaths(currentPath, path);
}


var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, lvl, paths) {
  var up, jsonPointer, data, matches;
  if ($data === &#039;&#039;) return &#039;rootData&#039;;
  if ($data[0] == &#039;/&#039;) {
    if (!JSON_POINTER.test($data)) throw new Error(&#039;Invalid JSON-pointer: &#039; + $data);
    jsonPointer = $data;
    data = &#039;rootData&#039;;
  } else {
    matches = $data.match(RELATIVE_JSON_POINTER);
    if (!matches) throw new Error(&#039;Invalid JSON-pointer: &#039; + $data);
    up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer == &#039;#&#039;) {
      if (up &gt;= lvl) throw new Error(&#039;Cannot access property/index &#039; + up + &#039; levels up, current level is &#039; + lvl);
      return paths[lvl - up];
    }

    if (up &gt; lvl) throw new Error(&#039;Cannot access data &#039; + up + &#039; levels up, current level is &#039; + lvl);
    data = &#039;data&#039; + ((lvl - up) || &#039;&#039;);
    if (!jsonPointer) return data;
  }

  var expr = data;
  var segments = jsonPointer.split(&#039;/&#039;);
  for (var i=0; i&lt;segments.length; i++) {
    var segment = segments[i];
    if (segment) {
      data += getProperty(unescapeJsonPointer(segment));
      expr += &#039; &amp;&amp; &#039; + data;
    }
  }
  return expr;
}


function joinPaths (a, b) {
  if (a == &#039;&quot;&quot;&#039;) return b;
  return (a + &#039; + &#039; + b).replace(/([^\\])&#039; \+ &#039;/g, &#039;$1&#039;);
}


function unescapeFragment(str) {
  return unescapeJsonPointer(decodeURIComponent(str));
}


function escapeFragment(str) {
  return encodeURIComponent(escapeJsonPointer(str));
}


function escapeJsonPointer(str) {
  return str.replace(/~/g, &#039;~0&#039;).replace(/\//g, &#039;~1&#039;);
}


function unescapeJsonPointer(str) {
  return str.replace(/~1/g, &#039;/&#039;).replace(/~0/g, &#039;~&#039;);
}

},{&quot;./ucs2length&quot;:9,&quot;fast-deep-equal&quot;:42}],11:[function(require,module,exports){
&#039;use strict&#039;;

var KEYWORDS = [
  &#039;multipleOf&#039;,
  &#039;maximum&#039;,
  &#039;exclusiveMaximum&#039;,
  &#039;minimum&#039;,
  &#039;exclusiveMinimum&#039;,
  &#039;maxLength&#039;,
  &#039;minLength&#039;,
  &#039;pattern&#039;,
  &#039;additionalItems&#039;,
  &#039;maxItems&#039;,
  &#039;minItems&#039;,
  &#039;uniqueItems&#039;,
  &#039;maxProperties&#039;,
  &#039;minProperties&#039;,
  &#039;required&#039;,
  &#039;additionalProperties&#039;,
  &#039;enum&#039;,
  &#039;format&#039;,
  &#039;const&#039;
];

module.exports = function (metaSchema, keywordsJsonPointers) {
  for (var i=0; i&lt;keywordsJsonPointers.length; i++) {
    metaSchema = JSON.parse(JSON.stringify(metaSchema));
    var segments = keywordsJsonPointers[i].split(&#039;/&#039;);
    var keywords = metaSchema;
    var j;
    for (j=1; j&lt;segments.length; j++)
      keywords = keywords[segments[j]];

    for (j=0; j&lt;KEYWORDS.length; j++) {
      var key = KEYWORDS[j];
      var schema = keywords[key];
      if (schema) {
        keywords[key] = {
          anyOf: [
            schema,
            { $ref: &#039;https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#&#039; }
          ]
        };
      }
    }
  }

  return metaSchema;
};

},{}],12:[function(require,module,exports){
&#039;use strict&#039;;

var metaSchema = require(&#039;./refs/json-schema-draft-07.json&#039;);

module.exports = {
  $id: &#039;https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js&#039;,
  definitions: {
    simpleTypes: metaSchema.definitions.simpleTypes
  },
  type: &#039;object&#039;,
  dependencies: {
    schema: [&#039;validate&#039;],
    $data: [&#039;validate&#039;],
    statements: [&#039;inline&#039;],
    valid: {not: {required: [&#039;macro&#039;]}}
  },
  properties: {
    type: metaSchema.properties.type,
    schema: {type: &#039;boolean&#039;},
    statements: {type: &#039;boolean&#039;},
    dependencies: {
      type: &#039;array&#039;,
      items: {type: &#039;string&#039;}
    },
    metaSchema: {type: &#039;object&#039;},
    modifying: {type: &#039;boolean&#039;},
    valid: {type: &#039;boolean&#039;},
    $data: {type: &#039;boolean&#039;},
    async: {type: &#039;boolean&#039;},
    errors: {
      anyOf: [
        {type: &#039;boolean&#039;},
        {const: &#039;full&#039;}
      ]
    }
  }
};

},{&quot;./refs/json-schema-draft-07.json&quot;:41}],13:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate__limit(it, $keyword, $ruleType) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $isData = it.opts.$data &amp;&amp; $schema &amp;&amp; $schema.$data,
    $schemaValue;
  if ($isData) {
    out += &#039; var schema&#039; + ($lvl) + &#039; = &#039; + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + &#039;; &#039;;
    $schemaValue = &#039;schema&#039; + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $isMax = $keyword == &#039;maximum&#039;,
    $exclusiveKeyword = $isMax ? &#039;exclusiveMaximum&#039; : &#039;exclusiveMinimum&#039;,
    $schemaExcl = it.schema[$exclusiveKeyword],
    $isDataExcl = it.opts.$data &amp;&amp; $schemaExcl &amp;&amp; $schemaExcl.$data,
    $op = $isMax ? &#039;&lt;&#039; : &#039;&gt;&#039;,
    $notOp = $isMax ? &#039;&gt;&#039; : &#039;&lt;&#039;,
    $errorKeyword = undefined;
  if (!($isData || typeof $schema == &#039;number&#039; || $schema === undefined)) {
    throw new Error($keyword + &#039; must be number&#039;);
  }
  if (!($isDataExcl || $schemaExcl === undefined || typeof $schemaExcl == &#039;number&#039; || typeof $schemaExcl == &#039;boolean&#039;)) {
    throw new Error($exclusiveKeyword + &#039; must be number or boolean&#039;);
  }
  if ($isDataExcl) {
    var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
      $exclusive = &#039;exclusive&#039; + $lvl,
      $exclType = &#039;exclType&#039; + $lvl,
      $exclIsNumber = &#039;exclIsNumber&#039; + $lvl,
      $opExpr = &#039;op&#039; + $lvl,
      $opStr = &#039;\&#039; + &#039; + $opExpr + &#039; + \&#039;&#039;;
    out += &#039; var schemaExcl&#039; + ($lvl) + &#039; = &#039; + ($schemaValueExcl) + &#039;; &#039;;
    $schemaValueExcl = &#039;schemaExcl&#039; + $lvl;
    out += &#039; var &#039; + ($exclusive) + &#039;; var &#039; + ($exclType) + &#039; = typeof &#039; + ($schemaValueExcl) + &#039;; if (&#039; + ($exclType) + &#039; != \&#039;boolean\&#039; &amp;&amp; &#039; + ($exclType) + &#039; != \&#039;undefined\&#039; &amp;&amp; &#039; + ($exclType) + &#039; != \&#039;number\&#039;) { &#039;;
    var $errorKeyword = $exclusiveKeyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = &#039;&#039;; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;_exclusiveLimit&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: {} &#039;;
      if (it.opts.messages !== false) {
        out += &#039; , message: \&#039;&#039; + ($exclusiveKeyword) + &#039; should be boolean\&#039; &#039;;
      }
      if (it.opts.verbose) {
        out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
      }
      out += &#039; } &#039;;
    } else {
      out += &#039; {} &#039;;
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule &amp;&amp; $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
      } else {
        out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
      }
    } else {
      out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
    }
    out += &#039; } else if ( &#039;;
    if ($isData) {
      out += &#039; (&#039; + ($schemaValue) + &#039; !== undefined &amp;&amp; typeof &#039; + ($schemaValue) + &#039; != \&#039;number\&#039;) || &#039;;
    }
    out += &#039; &#039; + ($exclType) + &#039; == \&#039;number\&#039; ? ( (&#039; + ($exclusive) + &#039; = &#039; + ($schemaValue) + &#039; === undefined || &#039; + ($schemaValueExcl) + &#039; &#039; + ($op) + &#039;= &#039; + ($schemaValue) + &#039;) ? &#039; + ($data) + &#039; &#039; + ($notOp) + &#039;= &#039; + ($schemaValueExcl) + &#039; : &#039; + ($data) + &#039; &#039; + ($notOp) + &#039; &#039; + ($schemaValue) + &#039; ) : ( (&#039; + ($exclusive) + &#039; = &#039; + ($schemaValueExcl) + &#039; === true) ? &#039; + ($data) + &#039; &#039; + ($notOp) + &#039;= &#039; + ($schemaValue) + &#039; : &#039; + ($data) + &#039; &#039; + ($notOp) + &#039; &#039; + ($schemaValue) + &#039; ) || &#039; + ($data) + &#039; !== &#039; + ($data) + &#039;) { var op&#039; + ($lvl) + &#039; = &#039; + ($exclusive) + &#039; ? \&#039;&#039; + ($op) + &#039;\&#039; : \&#039;&#039; + ($op) + &#039;=\&#039;; &#039;;
    if ($schema === undefined) {
      $errorKeyword = $exclusiveKeyword;
      $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $exclusiveKeyword;
      $schemaValue = $schemaValueExcl;
      $isData = $isDataExcl;
    }
  } else {
    var $exclIsNumber = typeof $schemaExcl == &#039;number&#039;,
      $opStr = $op;
    if ($exclIsNumber &amp;&amp; $isData) {
      var $opExpr = &#039;\&#039;&#039; + $opStr + &#039;\&#039;&#039;;
      out += &#039; if ( &#039;;
      if ($isData) {
        out += &#039; (&#039; + ($schemaValue) + &#039; !== undefined &amp;&amp; typeof &#039; + ($schemaValue) + &#039; != \&#039;number\&#039;) || &#039;;
      }
      out += &#039; ( &#039; + ($schemaValue) + &#039; === undefined || &#039; + ($schemaExcl) + &#039; &#039; + ($op) + &#039;= &#039; + ($schemaValue) + &#039; ? &#039; + ($data) + &#039; &#039; + ($notOp) + &#039;= &#039; + ($schemaExcl) + &#039; : &#039; + ($data) + &#039; &#039; + ($notOp) + &#039; &#039; + ($schemaValue) + &#039; ) || &#039; + ($data) + &#039; !== &#039; + ($data) + &#039;) { &#039;;
    } else {
      if ($exclIsNumber &amp;&amp; $schema === undefined) {
        $exclusive = true;
        $errorKeyword = $exclusiveKeyword;
        $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $exclusiveKeyword;
        $schemaValue = $schemaExcl;
        $notOp += &#039;=&#039;;
      } else {
        if ($exclIsNumber) $schemaValue = Math[$isMax ? &#039;min&#039; : &#039;max&#039;]($schemaExcl, $schema);
        if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
          $exclusive = true;
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $exclusiveKeyword;
          $notOp += &#039;=&#039;;
        } else {
          $exclusive = false;
          $opStr += &#039;=&#039;;
        }
      }
      var $opExpr = &#039;\&#039;&#039; + $opStr + &#039;\&#039;&#039;;
      out += &#039; if ( &#039;;
      if ($isData) {
        out += &#039; (&#039; + ($schemaValue) + &#039; !== undefined &amp;&amp; typeof &#039; + ($schemaValue) + &#039; != \&#039;number\&#039;) || &#039;;
      }
      out += &#039; &#039; + ($data) + &#039; &#039; + ($notOp) + &#039; &#039; + ($schemaValue) + &#039; || &#039; + ($data) + &#039; !== &#039; + ($data) + &#039;) { &#039;;
    }
  }
  $errorKeyword = $errorKeyword || $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = &#039;&#039;; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;_limit&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: { comparison: &#039; + ($opExpr) + &#039;, limit: &#039; + ($schemaValue) + &#039;, exclusive: &#039; + ($exclusive) + &#039; } &#039;;
    if (it.opts.messages !== false) {
      out += &#039; , message: \&#039;should be &#039; + ($opStr) + &#039; &#039;;
      if ($isData) {
        out += &#039;\&#039; + &#039; + ($schemaValue);
      } else {
        out += &#039;&#039; + ($schemaValue) + &#039;\&#039;&#039;;
      }
    }
    if (it.opts.verbose) {
      out += &#039; , schema:  &#039;;
      if ($isData) {
        out += &#039;validate.schema&#039; + ($schemaPath);
      } else {
        out += &#039;&#039; + ($schema);
      }
      out += &#039;         , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
    }
    out += &#039; } &#039;;
  } else {
    out += &#039; {} &#039;;
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule &amp;&amp; $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
    } else {
      out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
    }
  } else {
    out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
  }
  out += &#039; } &#039;;
  if ($breakOnError) {
    out += &#039; else { &#039;;
  }
  return out;
}

},{}],14:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate__limitItems(it, $keyword, $ruleType) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $isData = it.opts.$data &amp;&amp; $schema &amp;&amp; $schema.$data,
    $schemaValue;
  if ($isData) {
    out += &#039; var schema&#039; + ($lvl) + &#039; = &#039; + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + &#039;; &#039;;
    $schemaValue = &#039;schema&#039; + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!($isData || typeof $schema == &#039;number&#039;)) {
    throw new Error($keyword + &#039; must be number&#039;);
  }
  var $op = $keyword == &#039;maxItems&#039; ? &#039;&gt;&#039; : &#039;&lt;&#039;;
  out += &#039;if ( &#039;;
  if ($isData) {
    out += &#039; (&#039; + ($schemaValue) + &#039; !== undefined &amp;&amp; typeof &#039; + ($schemaValue) + &#039; != \&#039;number\&#039;) || &#039;;
  }
  out += &#039; &#039; + ($data) + &#039;.length &#039; + ($op) + &#039; &#039; + ($schemaValue) + &#039;) { &#039;;
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = &#039;&#039;; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;_limitItems&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: { limit: &#039; + ($schemaValue) + &#039; } &#039;;
    if (it.opts.messages !== false) {
      out += &#039; , message: \&#039;should NOT have &#039;;
      if ($keyword == &#039;maxItems&#039;) {
        out += &#039;more&#039;;
      } else {
        out += &#039;fewer&#039;;
      }
      out += &#039; than &#039;;
      if ($isData) {
        out += &#039;\&#039; + &#039; + ($schemaValue) + &#039; + \&#039;&#039;;
      } else {
        out += &#039;&#039; + ($schema);
      }
      out += &#039; items\&#039; &#039;;
    }
    if (it.opts.verbose) {
      out += &#039; , schema:  &#039;;
      if ($isData) {
        out += &#039;validate.schema&#039; + ($schemaPath);
      } else {
        out += &#039;&#039; + ($schema);
      }
      out += &#039;         , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
    }
    out += &#039; } &#039;;
  } else {
    out += &#039; {} &#039;;
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule &amp;&amp; $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
    } else {
      out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
    }
  } else {
    out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
  }
  out += &#039;} &#039;;
  if ($breakOnError) {
    out += &#039; else { &#039;;
  }
  return out;
}

},{}],15:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate__limitLength(it, $keyword, $ruleType) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $isData = it.opts.$data &amp;&amp; $schema &amp;&amp; $schema.$data,
    $schemaValue;
  if ($isData) {
    out += &#039; var schema&#039; + ($lvl) + &#039; = &#039; + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + &#039;; &#039;;
    $schemaValue = &#039;schema&#039; + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!($isData || typeof $schema == &#039;number&#039;)) {
    throw new Error($keyword + &#039; must be number&#039;);
  }
  var $op = $keyword == &#039;maxLength&#039; ? &#039;&gt;&#039; : &#039;&lt;&#039;;
  out += &#039;if ( &#039;;
  if ($isData) {
    out += &#039; (&#039; + ($schemaValue) + &#039; !== undefined &amp;&amp; typeof &#039; + ($schemaValue) + &#039; != \&#039;number\&#039;) || &#039;;
  }
  if (it.opts.unicode === false) {
    out += &#039; &#039; + ($data) + &#039;.length &#039;;
  } else {
    out += &#039; ucs2length(&#039; + ($data) + &#039;) &#039;;
  }
  out += &#039; &#039; + ($op) + &#039; &#039; + ($schemaValue) + &#039;) { &#039;;
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = &#039;&#039;; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;_limitLength&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: { limit: &#039; + ($schemaValue) + &#039; } &#039;;
    if (it.opts.messages !== false) {
      out += &#039; , message: \&#039;should NOT be &#039;;
      if ($keyword == &#039;maxLength&#039;) {
        out += &#039;longer&#039;;
      } else {
        out += &#039;shorter&#039;;
      }
      out += &#039; than &#039;;
      if ($isData) {
        out += &#039;\&#039; + &#039; + ($schemaValue) + &#039; + \&#039;&#039;;
      } else {
        out += &#039;&#039; + ($schema);
      }
      out += &#039; characters\&#039; &#039;;
    }
    if (it.opts.verbose) {
      out += &#039; , schema:  &#039;;
      if ($isData) {
        out += &#039;validate.schema&#039; + ($schemaPath);
      } else {
        out += &#039;&#039; + ($schema);
      }
      out += &#039;         , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
    }
    out += &#039; } &#039;;
  } else {
    out += &#039; {} &#039;;
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule &amp;&amp; $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
    } else {
      out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
    }
  } else {
    out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
  }
  out += &#039;} &#039;;
  if ($breakOnError) {
    out += &#039; else { &#039;;
  }
  return out;
}

},{}],16:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate__limitProperties(it, $keyword, $ruleType) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $isData = it.opts.$data &amp;&amp; $schema &amp;&amp; $schema.$data,
    $schemaValue;
  if ($isData) {
    out += &#039; var schema&#039; + ($lvl) + &#039; = &#039; + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + &#039;; &#039;;
    $schemaValue = &#039;schema&#039; + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!($isData || typeof $schema == &#039;number&#039;)) {
    throw new Error($keyword + &#039; must be number&#039;);
  }
  var $op = $keyword == &#039;maxProperties&#039; ? &#039;&gt;&#039; : &#039;&lt;&#039;;
  out += &#039;if ( &#039;;
  if ($isData) {
    out += &#039; (&#039; + ($schemaValue) + &#039; !== undefined &amp;&amp; typeof &#039; + ($schemaValue) + &#039; != \&#039;number\&#039;) || &#039;;
  }
  out += &#039; Object.keys(&#039; + ($data) + &#039;).length &#039; + ($op) + &#039; &#039; + ($schemaValue) + &#039;) { &#039;;
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = &#039;&#039;; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;_limitProperties&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: { limit: &#039; + ($schemaValue) + &#039; } &#039;;
    if (it.opts.messages !== false) {
      out += &#039; , message: \&#039;should NOT have &#039;;
      if ($keyword == &#039;maxProperties&#039;) {
        out += &#039;more&#039;;
      } else {
        out += &#039;fewer&#039;;
      }
      out += &#039; than &#039;;
      if ($isData) {
        out += &#039;\&#039; + &#039; + ($schemaValue) + &#039; + \&#039;&#039;;
      } else {
        out += &#039;&#039; + ($schema);
      }
      out += &#039; properties\&#039; &#039;;
    }
    if (it.opts.verbose) {
      out += &#039; , schema:  &#039;;
      if ($isData) {
        out += &#039;validate.schema&#039; + ($schemaPath);
      } else {
        out += &#039;&#039; + ($schema);
      }
      out += &#039;         , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
    }
    out += &#039; } &#039;;
  } else {
    out += &#039; {} &#039;;
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule &amp;&amp; $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
    } else {
      out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
    }
  } else {
    out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
  }
  out += &#039;} &#039;;
  if ($breakOnError) {
    out += &#039; else { &#039;;
  }
  return out;
}

},{}],17:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_allOf(it, $keyword, $ruleType) {
  var out = &#039; &#039;;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $it = it.util.copy(it);
  var $closingBraces = &#039;&#039;;
  $it.level++;
  var $nextValid = &#039;valid&#039; + $it.level;
  var $currentBaseId = $it.baseId,
    $allSchemasEmpty = true;
  var arr1 = $schema;
  if (arr1) {
    var $sch, $i = -1,
      l1 = arr1.length - 1;
    while ($i &lt; l1) {
      $sch = arr1[$i += 1];
      if ((it.opts.strictKeywords ? (typeof $sch == &#039;object&#039; &amp;&amp; Object.keys($sch).length &gt; 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
        $allSchemasEmpty = false;
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + &#039;[&#039; + $i + &#039;]&#039;;
        $it.errSchemaPath = $errSchemaPath + &#039;/&#039; + $i;
        out += &#039;  &#039; + (it.validate($it)) + &#039; &#039;;
        $it.baseId = $currentBaseId;
        if ($breakOnError) {
          out += &#039; if (&#039; + ($nextValid) + &#039;) { &#039;;
          $closingBraces += &#039;}&#039;;
        }
      }
    }
  }
  if ($breakOnError) {
    if ($allSchemasEmpty) {
      out += &#039; if (true) { &#039;;
    } else {
      out += &#039; &#039; + ($closingBraces.slice(0, -1)) + &#039; &#039;;
    }
  }
  return out;
}

},{}],18:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_anyOf(it, $keyword, $ruleType) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $valid = &#039;valid&#039; + $lvl;
  var $errs = &#039;errs__&#039; + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = &#039;&#039;;
  $it.level++;
  var $nextValid = &#039;valid&#039; + $it.level;
  var $noEmptySchema = $schema.every(function($sch) {
    return (it.opts.strictKeywords ? (typeof $sch == &#039;object&#039; &amp;&amp; Object.keys($sch).length &gt; 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all));
  });
  if ($noEmptySchema) {
    var $currentBaseId = $it.baseId;
    out += &#039; var &#039; + ($errs) + &#039; = errors; var &#039; + ($valid) + &#039; = false;  &#039;;
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1,
        l1 = arr1.length - 1;
      while ($i &lt; l1) {
        $sch = arr1[$i += 1];
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + &#039;[&#039; + $i + &#039;]&#039;;
        $it.errSchemaPath = $errSchemaPath + &#039;/&#039; + $i;
        out += &#039;  &#039; + (it.validate($it)) + &#039; &#039;;
        $it.baseId = $currentBaseId;
        out += &#039; &#039; + ($valid) + &#039; = &#039; + ($valid) + &#039; || &#039; + ($nextValid) + &#039;; if (!&#039; + ($valid) + &#039;) { &#039;;
        $closingBraces += &#039;}&#039;;
      }
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += &#039; &#039; + ($closingBraces) + &#039; if (!&#039; + ($valid) + &#039;) {   var err =   &#039;; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += &#039; { keyword: \&#039;&#039; + (&#039;anyOf&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: {} &#039;;
      if (it.opts.messages !== false) {
        out += &#039; , message: \&#039;should match some schema in anyOf\&#039; &#039;;
      }
      if (it.opts.verbose) {
        out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
      }
      out += &#039; } &#039;;
    } else {
      out += &#039; {} &#039;;
    }
    out += &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
    if (!it.compositeRule &amp;&amp; $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += &#039; throw new ValidationError(vErrors); &#039;;
      } else {
        out += &#039; validate.errors = vErrors; return false; &#039;;
      }
    }
    out += &#039; } else {  errors = &#039; + ($errs) + &#039;; if (vErrors !== null) { if (&#039; + ($errs) + &#039;) vErrors.length = &#039; + ($errs) + &#039;; else vErrors = null; } &#039;;
    if (it.opts.allErrors) {
      out += &#039; } &#039;;
    }
  } else {
    if ($breakOnError) {
      out += &#039; if (true) { &#039;;
    }
  }
  return out;
}

},{}],19:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_comment(it, $keyword, $ruleType) {
  var out = &#039; &#039;;
  var $schema = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $comment = it.util.toQuotedString($schema);
  if (it.opts.$comment === true) {
    out += &#039; console.log(&#039; + ($comment) + &#039;);&#039;;
  } else if (typeof it.opts.$comment == &#039;function&#039;) {
    out += &#039; self._opts.$comment(&#039; + ($comment) + &#039;, &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039;, validate.root.schema);&#039;;
  }
  return out;
}

},{}],20:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_const(it, $keyword, $ruleType) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $valid = &#039;valid&#039; + $lvl;
  var $isData = it.opts.$data &amp;&amp; $schema &amp;&amp; $schema.$data,
    $schemaValue;
  if ($isData) {
    out += &#039; var schema&#039; + ($lvl) + &#039; = &#039; + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + &#039;; &#039;;
    $schemaValue = &#039;schema&#039; + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!$isData) {
    out += &#039; var schema&#039; + ($lvl) + &#039; = validate.schema&#039; + ($schemaPath) + &#039;;&#039;;
  }
  out += &#039;var &#039; + ($valid) + &#039; = equal(&#039; + ($data) + &#039;, schema&#039; + ($lvl) + &#039;); if (!&#039; + ($valid) + &#039;) {   &#039;;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = &#039;&#039;; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += &#039; { keyword: \&#039;&#039; + (&#039;const&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: { allowedValue: schema&#039; + ($lvl) + &#039; } &#039;;
    if (it.opts.messages !== false) {
      out += &#039; , message: \&#039;should be equal to constant\&#039; &#039;;
    }
    if (it.opts.verbose) {
      out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
    }
    out += &#039; } &#039;;
  } else {
    out += &#039; {} &#039;;
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule &amp;&amp; $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
    } else {
      out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
    }
  } else {
    out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
  }
  out += &#039; }&#039;;
  if ($breakOnError) {
    out += &#039; else { &#039;;
  }
  return out;
}

},{}],21:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_contains(it, $keyword, $ruleType) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $valid = &#039;valid&#039; + $lvl;
  var $errs = &#039;errs__&#039; + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = &#039;&#039;;
  $it.level++;
  var $nextValid = &#039;valid&#039; + $it.level;
  var $idx = &#039;i&#039; + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = &#039;data&#039; + $dataNxt,
    $currentBaseId = it.baseId,
    $nonEmptySchema = (it.opts.strictKeywords ? (typeof $schema == &#039;object&#039; &amp;&amp; Object.keys($schema).length &gt; 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all));
  out += &#039;var &#039; + ($errs) + &#039; = errors;var &#039; + ($valid) + &#039;;&#039;;
  if ($nonEmptySchema) {
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += &#039; var &#039; + ($nextValid) + &#039; = false; for (var &#039; + ($idx) + &#039; = 0; &#039; + ($idx) + &#039; &lt; &#039; + ($data) + &#039;.length; &#039; + ($idx) + &#039;++) { &#039;;
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + &#039;[&#039; + $idx + &#039;]&#039;;
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) &lt; 2) {
      out += &#039; &#039; + (it.util.varReplace($code, $nextData, $passData)) + &#039; &#039;;
    } else {
      out += &#039; var &#039; + ($nextData) + &#039; = &#039; + ($passData) + &#039;; &#039; + ($code) + &#039; &#039;;
    }
    out += &#039; if (&#039; + ($nextValid) + &#039;) break; }  &#039;;
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += &#039; &#039; + ($closingBraces) + &#039; if (!&#039; + ($nextValid) + &#039;) {&#039;;
  } else {
    out += &#039; if (&#039; + ($data) + &#039;.length == 0) {&#039;;
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = &#039;&#039;; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += &#039; { keyword: \&#039;&#039; + (&#039;contains&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: {} &#039;;
    if (it.opts.messages !== false) {
      out += &#039; , message: \&#039;should contain a valid item\&#039; &#039;;
    }
    if (it.opts.verbose) {
      out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
    }
    out += &#039; } &#039;;
  } else {
    out += &#039; {} &#039;;
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule &amp;&amp; $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
    } else {
      out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
    }
  } else {
    out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
  }
  out += &#039; } else { &#039;;
  if ($nonEmptySchema) {
    out += &#039;  errors = &#039; + ($errs) + &#039;; if (vErrors !== null) { if (&#039; + ($errs) + &#039;) vErrors.length = &#039; + ($errs) + &#039;; else vErrors = null; } &#039;;
  }
  if (it.opts.allErrors) {
    out += &#039; } &#039;;
  }
  return out;
}

},{}],22:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_custom(it, $keyword, $ruleType) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $valid = &#039;valid&#039; + $lvl;
  var $errs = &#039;errs__&#039; + $lvl;
  var $isData = it.opts.$data &amp;&amp; $schema &amp;&amp; $schema.$data,
    $schemaValue;
  if ($isData) {
    out += &#039; var schema&#039; + ($lvl) + &#039; = &#039; + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + &#039;; &#039;;
    $schemaValue = &#039;schema&#039; + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $rule = this,
    $definition = &#039;definition&#039; + $lvl,
    $rDef = $rule.definition,
    $closingBraces = &#039;&#039;;
  var $compile, $inline, $macro, $ruleValidate, $validateCode;
  if ($isData &amp;&amp; $rDef.$data) {
    $validateCode = &#039;keywordValidate&#039; + $lvl;
    var $validateSchema = $rDef.validateSchema;
    out += &#039; var &#039; + ($definition) + &#039; = RULES.custom[\&#039;&#039; + ($keyword) + &#039;\&#039;].definition; var &#039; + ($validateCode) + &#039; = &#039; + ($definition) + &#039;.validate;&#039;;
  } else {
    $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
    if (!$ruleValidate) return;
    $schemaValue = &#039;validate.schema&#039; + $schemaPath;
    $validateCode = $ruleValidate.code;
    $compile = $rDef.compile;
    $inline = $rDef.inline;
    $macro = $rDef.macro;
  }
  var $ruleErrs = $validateCode + &#039;.errors&#039;,
    $i = &#039;i&#039; + $lvl,
    $ruleErr = &#039;ruleErr&#039; + $lvl,
    $asyncKeyword = $rDef.async;
  if ($asyncKeyword &amp;&amp; !it.async) throw new Error(&#039;async keyword in sync schema&#039;);
  if (!($inline || $macro)) {
    out += &#039;&#039; + ($ruleErrs) + &#039; = null;&#039;;
  }
  out += &#039;var &#039; + ($errs) + &#039; = errors;var &#039; + ($valid) + &#039;;&#039;;
  if ($isData &amp;&amp; $rDef.$data) {
    $closingBraces += &#039;}&#039;;
    out += &#039; if (&#039; + ($schemaValue) + &#039; === undefined) { &#039; + ($valid) + &#039; = true; } else { &#039;;
    if ($validateSchema) {
      $closingBraces += &#039;}&#039;;
      out += &#039; &#039; + ($valid) + &#039; = &#039; + ($definition) + &#039;.validateSchema(&#039; + ($schemaValue) + &#039;); if (&#039; + ($valid) + &#039;) { &#039;;
    }
  }
  if ($inline) {
    if ($rDef.statements) {
      out += &#039; &#039; + ($ruleValidate.validate) + &#039; &#039;;
    } else {
      out += &#039; &#039; + ($valid) + &#039; = &#039; + ($ruleValidate.validate) + &#039;; &#039;;
    }
  } else if ($macro) {
    var $it = it.util.copy(it);
    var $closingBraces = &#039;&#039;;
    $it.level++;
    var $nextValid = &#039;valid&#039; + $it.level;
    $it.schema = $ruleValidate.validate;
    $it.schemaPath = &#039;&#039;;
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += &#039; &#039; + ($code);
  } else {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = &#039;&#039;;
    out += &#039;  &#039; + ($validateCode) + &#039;.call( &#039;;
    if (it.opts.passContext) {
      out += &#039;this&#039;;
    } else {
      out += &#039;self&#039;;
    }
    if ($compile || $rDef.schema === false) {
      out += &#039; , &#039; + ($data) + &#039; &#039;;
    } else {
      out += &#039; , &#039; + ($schemaValue) + &#039; , &#039; + ($data) + &#039; , validate.schema&#039; + (it.schemaPath) + &#039; &#039;;
    }
    out += &#039; , (dataPath || \&#039;\&#039;)&#039;;
    if (it.errorPath != &#039;&quot;&quot;&#039;) {
      out += &#039; + &#039; + (it.errorPath);
    }
    var $parentData = $dataLvl ? &#039;data&#039; + (($dataLvl - 1) || &#039;&#039;) : &#039;parentData&#039;,
      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : &#039;parentDataProperty&#039;;
    out += &#039; , &#039; + ($parentData) + &#039; , &#039; + ($parentDataProperty) + &#039; , rootData )  &#039;;
    var def_callRuleValidate = out;
    out = $$outStack.pop();
    if ($rDef.errors === false) {
      out += &#039; &#039; + ($valid) + &#039; = &#039;;
      if ($asyncKeyword) {
        out += &#039;await &#039;;
      }
      out += &#039;&#039; + (def_callRuleValidate) + &#039;; &#039;;
    } else {
      if ($asyncKeyword) {
        $ruleErrs = &#039;customErrors&#039; + $lvl;
        out += &#039; var &#039; + ($ruleErrs) + &#039; = null; try { &#039; + ($valid) + &#039; = await &#039; + (def_callRuleValidate) + &#039;; } catch (e) { &#039; + ($valid) + &#039; = false; if (e instanceof ValidationError) &#039; + ($ruleErrs) + &#039; = e.errors; else throw e; } &#039;;
      } else {
        out += &#039; &#039; + ($ruleErrs) + &#039; = null; &#039; + ($valid) + &#039; = &#039; + (def_callRuleValidate) + &#039;; &#039;;
      }
    }
  }
  if ($rDef.modifying) {
    out += &#039; if (&#039; + ($parentData) + &#039;) &#039; + ($data) + &#039; = &#039; + ($parentData) + &#039;[&#039; + ($parentDataProperty) + &#039;];&#039;;
  }
  out += &#039;&#039; + ($closingBraces);
  if ($rDef.valid) {
    if ($breakOnError) {
      out += &#039; if (true) { &#039;;
    }
  } else {
    out += &#039; if ( &#039;;
    if ($rDef.valid === undefined) {
      out += &#039; !&#039;;
      if ($macro) {
        out += &#039;&#039; + ($nextValid);
      } else {
        out += &#039;&#039; + ($valid);
      }
    } else {
      out += &#039; &#039; + (!$rDef.valid) + &#039; &#039;;
    }
    out += &#039;) { &#039;;
    $errorKeyword = $rule.keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = &#039;&#039;;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = &#039;&#039;; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;custom&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: { keyword: \&#039;&#039; + ($rule.keyword) + &#039;\&#039; } &#039;;
      if (it.opts.messages !== false) {
        out += &#039; , message: \&#039;should pass &quot;&#039; + ($rule.keyword) + &#039;&quot; keyword validation\&#039; &#039;;
      }
      if (it.opts.verbose) {
        out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
      }
      out += &#039; } &#039;;
    } else {
      out += &#039; {} &#039;;
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule &amp;&amp; $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
      } else {
        out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
      }
    } else {
      out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
    }
    var def_customError = out;
    out = $$outStack.pop();
    if ($inline) {
      if ($rDef.errors) {
        if ($rDef.errors != &#039;full&#039;) {
          out += &#039;  for (var &#039; + ($i) + &#039;=&#039; + ($errs) + &#039;; &#039; + ($i) + &#039;&lt;errors; &#039; + ($i) + &#039;++) { var &#039; + ($ruleErr) + &#039; = vErrors[&#039; + ($i) + &#039;]; if (&#039; + ($ruleErr) + &#039;.dataPath === undefined) &#039; + ($ruleErr) + &#039;.dataPath = (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039;; if (&#039; + ($ruleErr) + &#039;.schemaPath === undefined) { &#039; + ($ruleErr) + &#039;.schemaPath = &quot;&#039; + ($errSchemaPath) + &#039;&quot;; } &#039;;
          if (it.opts.verbose) {
            out += &#039; &#039; + ($ruleErr) + &#039;.schema = &#039; + ($schemaValue) + &#039;; &#039; + ($ruleErr) + &#039;.data = &#039; + ($data) + &#039;; &#039;;
          }
          out += &#039; } &#039;;
        }
      } else {
        if ($rDef.errors === false) {
          out += &#039; &#039; + (def_customError) + &#039; &#039;;
        } else {
          out += &#039; if (&#039; + ($errs) + &#039; == errors) { &#039; + (def_customError) + &#039; } else {  for (var &#039; + ($i) + &#039;=&#039; + ($errs) + &#039;; &#039; + ($i) + &#039;&lt;errors; &#039; + ($i) + &#039;++) { var &#039; + ($ruleErr) + &#039; = vErrors[&#039; + ($i) + &#039;]; if (&#039; + ($ruleErr) + &#039;.dataPath === undefined) &#039; + ($ruleErr) + &#039;.dataPath = (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039;; if (&#039; + ($ruleErr) + &#039;.schemaPath === undefined) { &#039; + ($ruleErr) + &#039;.schemaPath = &quot;&#039; + ($errSchemaPath) + &#039;&quot;; } &#039;;
          if (it.opts.verbose) {
            out += &#039; &#039; + ($ruleErr) + &#039;.schema = &#039; + ($schemaValue) + &#039;; &#039; + ($ruleErr) + &#039;.data = &#039; + ($data) + &#039;; &#039;;
          }
          out += &#039; } } &#039;;
        }
      }
    } else if ($macro) {
      out += &#039;   var err =   &#039;; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;custom&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: { keyword: \&#039;&#039; + ($rule.keyword) + &#039;\&#039; } &#039;;
        if (it.opts.messages !== false) {
          out += &#039; , message: \&#039;should pass &quot;&#039; + ($rule.keyword) + &#039;&quot; keyword validation\&#039; &#039;;
        }
        if (it.opts.verbose) {
          out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
        }
        out += &#039; } &#039;;
      } else {
        out += &#039; {} &#039;;
      }
      out += &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
      if (!it.compositeRule &amp;&amp; $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += &#039; throw new ValidationError(vErrors); &#039;;
        } else {
          out += &#039; validate.errors = vErrors; return false; &#039;;
        }
      }
    } else {
      if ($rDef.errors === false) {
        out += &#039; &#039; + (def_customError) + &#039; &#039;;
      } else {
        out += &#039; if (Array.isArray(&#039; + ($ruleErrs) + &#039;)) { if (vErrors === null) vErrors = &#039; + ($ruleErrs) + &#039;; else vErrors = vErrors.concat(&#039; + ($ruleErrs) + &#039;); errors = vErrors.length;  for (var &#039; + ($i) + &#039;=&#039; + ($errs) + &#039;; &#039; + ($i) + &#039;&lt;errors; &#039; + ($i) + &#039;++) { var &#039; + ($ruleErr) + &#039; = vErrors[&#039; + ($i) + &#039;]; if (&#039; + ($ruleErr) + &#039;.dataPath === undefined) &#039; + ($ruleErr) + &#039;.dataPath = (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039;;  &#039; + ($ruleErr) + &#039;.schemaPath = &quot;&#039; + ($errSchemaPath) + &#039;&quot;;  &#039;;
        if (it.opts.verbose) {
          out += &#039; &#039; + ($ruleErr) + &#039;.schema = &#039; + ($schemaValue) + &#039;; &#039; + ($ruleErr) + &#039;.data = &#039; + ($data) + &#039;; &#039;;
        }
        out += &#039; } } else { &#039; + (def_customError) + &#039; } &#039;;
      }
    }
    out += &#039; } &#039;;
    if ($breakOnError) {
      out += &#039; else { &#039;;
    }
  }
  return out;
}

},{}],23:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_dependencies(it, $keyword, $ruleType) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $errs = &#039;errs__&#039; + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = &#039;&#039;;
  $it.level++;
  var $nextValid = &#039;valid&#039; + $it.level;
  var $schemaDeps = {},
    $propertyDeps = {},
    $ownProperties = it.opts.ownProperties;
  for ($property in $schema) {
    if ($property == &#039;__proto__&#039;) continue;
    var $sch = $schema[$property];
    var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
    $deps[$property] = $sch;
  }
  out += &#039;var &#039; + ($errs) + &#039; = errors;&#039;;
  var $currentErrorPath = it.errorPath;
  out += &#039;var missing&#039; + ($lvl) + &#039;;&#039;;
  for (var $property in $propertyDeps) {
    $deps = $propertyDeps[$property];
    if ($deps.length) {
      out += &#039; if ( &#039; + ($data) + (it.util.getProperty($property)) + &#039; !== undefined &#039;;
      if ($ownProperties) {
        out += &#039; &amp;&amp; Object.prototype.hasOwnProperty.call(&#039; + ($data) + &#039;, \&#039;&#039; + (it.util.escapeQuotes($property)) + &#039;\&#039;) &#039;;
      }
      if ($breakOnError) {
        out += &#039; &amp;&amp; ( &#039;;
        var arr1 = $deps;
        if (arr1) {
          var $propertyKey, $i = -1,
            l1 = arr1.length - 1;
          while ($i &lt; l1) {
            $propertyKey = arr1[$i += 1];
            if ($i) {
              out += &#039; || &#039;;
            }
            var $prop = it.util.getProperty($propertyKey),
              $useData = $data + $prop;
            out += &#039; ( ( &#039; + ($useData) + &#039; === undefined &#039;;
            if ($ownProperties) {
              out += &#039; || ! Object.prototype.hasOwnProperty.call(&#039; + ($data) + &#039;, \&#039;&#039; + (it.util.escapeQuotes($propertyKey)) + &#039;\&#039;) &#039;;
            }
            out += &#039;) &amp;&amp; (missing&#039; + ($lvl) + &#039; = &#039; + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + &#039;) ) &#039;;
          }
        }
        out += &#039;)) {  &#039;;
        var $propertyPath = &#039;missing&#039; + $lvl,
          $missingProperty = &#039;\&#039; + &#039; + $propertyPath + &#039; + \&#039;&#039;;
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + &#039; + &#039; + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = &#039;&#039;; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += &#039; { keyword: \&#039;&#039; + (&#039;dependencies&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: { property: \&#039;&#039; + (it.util.escapeQuotes($property)) + &#039;\&#039;, missingProperty: \&#039;&#039; + ($missingProperty) + &#039;\&#039;, depsCount: &#039; + ($deps.length) + &#039;, deps: \&#039;&#039; + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(&quot;, &quot;))) + &#039;\&#039; } &#039;;
          if (it.opts.messages !== false) {
            out += &#039; , message: \&#039;should have &#039;;
            if ($deps.length == 1) {
              out += &#039;property &#039; + (it.util.escapeQuotes($deps[0]));
            } else {
              out += &#039;properties &#039; + (it.util.escapeQuotes($deps.join(&quot;, &quot;)));
            }
            out += &#039; when property &#039; + (it.util.escapeQuotes($property)) + &#039; is present\&#039; &#039;;
          }
          if (it.opts.verbose) {
            out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
          }
          out += &#039; } &#039;;
        } else {
          out += &#039; {} &#039;;
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule &amp;&amp; $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
          } else {
            out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
          }
        } else {
          out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
        }
      } else {
        out += &#039; ) { &#039;;
        var arr2 = $deps;
        if (arr2) {
          var $propertyKey, i2 = -1,
            l2 = arr2.length - 1;
          while (i2 &lt; l2) {
            $propertyKey = arr2[i2 += 1];
            var $prop = it.util.getProperty($propertyKey),
              $missingProperty = it.util.escapeQuotes($propertyKey),
              $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }
            out += &#039; if ( &#039; + ($useData) + &#039; === undefined &#039;;
            if ($ownProperties) {
              out += &#039; || ! Object.prototype.hasOwnProperty.call(&#039; + ($data) + &#039;, \&#039;&#039; + (it.util.escapeQuotes($propertyKey)) + &#039;\&#039;) &#039;;
            }
            out += &#039;) {  var err =   &#039;; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += &#039; { keyword: \&#039;&#039; + (&#039;dependencies&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: { property: \&#039;&#039; + (it.util.escapeQuotes($property)) + &#039;\&#039;, missingProperty: \&#039;&#039; + ($missingProperty) + &#039;\&#039;, depsCount: &#039; + ($deps.length) + &#039;, deps: \&#039;&#039; + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(&quot;, &quot;))) + &#039;\&#039; } &#039;;
              if (it.opts.messages !== false) {
                out += &#039; , message: \&#039;should have &#039;;
                if ($deps.length == 1) {
                  out += &#039;property &#039; + (it.util.escapeQuotes($deps[0]));
                } else {
                  out += &#039;properties &#039; + (it.util.escapeQuotes($deps.join(&quot;, &quot;)));
                }
                out += &#039; when property &#039; + (it.util.escapeQuotes($property)) + &#039; is present\&#039; &#039;;
              }
              if (it.opts.verbose) {
                out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
              }
              out += &#039; } &#039;;
            } else {
              out += &#039; {} &#039;;
            }
            out += &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } &#039;;
          }
        }
      }
      out += &#039; }   &#039;;
      if ($breakOnError) {
        $closingBraces += &#039;}&#039;;
        out += &#039; else { &#039;;
      }
    }
  }
  it.errorPath = $currentErrorPath;
  var $currentBaseId = $it.baseId;
  for (var $property in $schemaDeps) {
    var $sch = $schemaDeps[$property];
    if ((it.opts.strictKeywords ? (typeof $sch == &#039;object&#039; &amp;&amp; Object.keys($sch).length &gt; 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
      out += &#039; &#039; + ($nextValid) + &#039; = true; if ( &#039; + ($data) + (it.util.getProperty($property)) + &#039; !== undefined &#039;;
      if ($ownProperties) {
        out += &#039; &amp;&amp; Object.prototype.hasOwnProperty.call(&#039; + ($data) + &#039;, \&#039;&#039; + (it.util.escapeQuotes($property)) + &#039;\&#039;) &#039;;
      }
      out += &#039;) { &#039;;
      $it.schema = $sch;
      $it.schemaPath = $schemaPath + it.util.getProperty($property);
      $it.errSchemaPath = $errSchemaPath + &#039;/&#039; + it.util.escapeFragment($property);
      out += &#039;  &#039; + (it.validate($it)) + &#039; &#039;;
      $it.baseId = $currentBaseId;
      out += &#039; }  &#039;;
      if ($breakOnError) {
        out += &#039; if (&#039; + ($nextValid) + &#039;) { &#039;;
        $closingBraces += &#039;}&#039;;
      }
    }
  }
  if ($breakOnError) {
    out += &#039;   &#039; + ($closingBraces) + &#039; if (&#039; + ($errs) + &#039; == errors) {&#039;;
  }
  return out;
}

},{}],24:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_enum(it, $keyword, $ruleType) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $valid = &#039;valid&#039; + $lvl;
  var $isData = it.opts.$data &amp;&amp; $schema &amp;&amp; $schema.$data,
    $schemaValue;
  if ($isData) {
    out += &#039; var schema&#039; + ($lvl) + &#039; = &#039; + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + &#039;; &#039;;
    $schemaValue = &#039;schema&#039; + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $i = &#039;i&#039; + $lvl,
    $vSchema = &#039;schema&#039; + $lvl;
  if (!$isData) {
    out += &#039; var &#039; + ($vSchema) + &#039; = validate.schema&#039; + ($schemaPath) + &#039;;&#039;;
  }
  out += &#039;var &#039; + ($valid) + &#039;;&#039;;
  if ($isData) {
    out += &#039; if (schema&#039; + ($lvl) + &#039; === undefined) &#039; + ($valid) + &#039; = true; else if (!Array.isArray(schema&#039; + ($lvl) + &#039;)) &#039; + ($valid) + &#039; = false; else {&#039;;
  }
  out += &#039;&#039; + ($valid) + &#039; = false;for (var &#039; + ($i) + &#039;=0; &#039; + ($i) + &#039;&lt;&#039; + ($vSchema) + &#039;.length; &#039; + ($i) + &#039;++) if (equal(&#039; + ($data) + &#039;, &#039; + ($vSchema) + &#039;[&#039; + ($i) + &#039;])) { &#039; + ($valid) + &#039; = true; break; }&#039;;
  if ($isData) {
    out += &#039;  }  &#039;;
  }
  out += &#039; if (!&#039; + ($valid) + &#039;) {   &#039;;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = &#039;&#039;; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += &#039; { keyword: \&#039;&#039; + (&#039;enum&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: { allowedValues: schema&#039; + ($lvl) + &#039; } &#039;;
    if (it.opts.messages !== false) {
      out += &#039; , message: \&#039;should be equal to one of the allowed values\&#039; &#039;;
    }
    if (it.opts.verbose) {
      out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
    }
    out += &#039; } &#039;;
  } else {
    out += &#039; {} &#039;;
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule &amp;&amp; $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
    } else {
      out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
    }
  } else {
    out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
  }
  out += &#039; }&#039;;
  if ($breakOnError) {
    out += &#039; else { &#039;;
  }
  return out;
}

},{}],25:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_format(it, $keyword, $ruleType) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  if (it.opts.format === false) {
    if ($breakOnError) {
      out += &#039; if (true) { &#039;;
    }
    return out;
  }
  var $isData = it.opts.$data &amp;&amp; $schema &amp;&amp; $schema.$data,
    $schemaValue;
  if ($isData) {
    out += &#039; var schema&#039; + ($lvl) + &#039; = &#039; + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + &#039;; &#039;;
    $schemaValue = &#039;schema&#039; + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $unknownFormats = it.opts.unknownFormats,
    $allowUnknown = Array.isArray($unknownFormats);
  if ($isData) {
    var $format = &#039;format&#039; + $lvl,
      $isObject = &#039;isObject&#039; + $lvl,
      $formatType = &#039;formatType&#039; + $lvl;
    out += &#039; var &#039; + ($format) + &#039; = formats[&#039; + ($schemaValue) + &#039;]; var &#039; + ($isObject) + &#039; = typeof &#039; + ($format) + &#039; == \&#039;object\&#039; &amp;&amp; !(&#039; + ($format) + &#039; instanceof RegExp) &amp;&amp; &#039; + ($format) + &#039;.validate; var &#039; + ($formatType) + &#039; = &#039; + ($isObject) + &#039; &amp;&amp; &#039; + ($format) + &#039;.type || \&#039;string\&#039;; if (&#039; + ($isObject) + &#039;) { &#039;;
    if (it.async) {
      out += &#039; var async&#039; + ($lvl) + &#039; = &#039; + ($format) + &#039;.async; &#039;;
    }
    out += &#039; &#039; + ($format) + &#039; = &#039; + ($format) + &#039;.validate; } if (  &#039;;
    if ($isData) {
      out += &#039; (&#039; + ($schemaValue) + &#039; !== undefined &amp;&amp; typeof &#039; + ($schemaValue) + &#039; != \&#039;string\&#039;) || &#039;;
    }
    out += &#039; (&#039;;
    if ($unknownFormats != &#039;ignore&#039;) {
      out += &#039; (&#039; + ($schemaValue) + &#039; &amp;&amp; !&#039; + ($format) + &#039; &#039;;
      if ($allowUnknown) {
        out += &#039; &amp;&amp; self._opts.unknownFormats.indexOf(&#039; + ($schemaValue) + &#039;) == -1 &#039;;
      }
      out += &#039;) || &#039;;
    }
    out += &#039; (&#039; + ($format) + &#039; &amp;&amp; &#039; + ($formatType) + &#039; == \&#039;&#039; + ($ruleType) + &#039;\&#039; &amp;&amp; !(typeof &#039; + ($format) + &#039; == \&#039;function\&#039; ? &#039;;
    if (it.async) {
      out += &#039; (async&#039; + ($lvl) + &#039; ? await &#039; + ($format) + &#039;(&#039; + ($data) + &#039;) : &#039; + ($format) + &#039;(&#039; + ($data) + &#039;)) &#039;;
    } else {
      out += &#039; &#039; + ($format) + &#039;(&#039; + ($data) + &#039;) &#039;;
    }
    out += &#039; : &#039; + ($format) + &#039;.test(&#039; + ($data) + &#039;))))) {&#039;;
  } else {
    var $format = it.formats[$schema];
    if (!$format) {
      if ($unknownFormats == &#039;ignore&#039;) {
        it.logger.warn(&#039;unknown format &quot;&#039; + $schema + &#039;&quot; ignored in schema at path &quot;&#039; + it.errSchemaPath + &#039;&quot;&#039;);
        if ($breakOnError) {
          out += &#039; if (true) { &#039;;
        }
        return out;
      } else if ($allowUnknown &amp;&amp; $unknownFormats.indexOf($schema) &gt;= 0) {
        if ($breakOnError) {
          out += &#039; if (true) { &#039;;
        }
        return out;
      } else {
        throw new Error(&#039;unknown format &quot;&#039; + $schema + &#039;&quot; is used in schema at path &quot;&#039; + it.errSchemaPath + &#039;&quot;&#039;);
      }
    }
    var $isObject = typeof $format == &#039;object&#039; &amp;&amp; !($format instanceof RegExp) &amp;&amp; $format.validate;
    var $formatType = $isObject &amp;&amp; $format.type || &#039;string&#039;;
    if ($isObject) {
      var $async = $format.async === true;
      $format = $format.validate;
    }
    if ($formatType != $ruleType) {
      if ($breakOnError) {
        out += &#039; if (true) { &#039;;
      }
      return out;
    }
    if ($async) {
      if (!it.async) throw new Error(&#039;async format in sync schema&#039;);
      var $formatRef = &#039;formats&#039; + it.util.getProperty($schema) + &#039;.validate&#039;;
      out += &#039; if (!(await &#039; + ($formatRef) + &#039;(&#039; + ($data) + &#039;))) { &#039;;
    } else {
      out += &#039; if (! &#039;;
      var $formatRef = &#039;formats&#039; + it.util.getProperty($schema);
      if ($isObject) $formatRef += &#039;.validate&#039;;
      if (typeof $format == &#039;function&#039;) {
        out += &#039; &#039; + ($formatRef) + &#039;(&#039; + ($data) + &#039;) &#039;;
      } else {
        out += &#039; &#039; + ($formatRef) + &#039;.test(&#039; + ($data) + &#039;) &#039;;
      }
      out += &#039;) { &#039;;
    }
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = &#039;&#039;; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += &#039; { keyword: \&#039;&#039; + (&#039;format&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: { format:  &#039;;
    if ($isData) {
      out += &#039;&#039; + ($schemaValue);
    } else {
      out += &#039;&#039; + (it.util.toQuotedString($schema));
    }
    out += &#039;  } &#039;;
    if (it.opts.messages !== false) {
      out += &#039; , message: \&#039;should match format &quot;&#039;;
      if ($isData) {
        out += &#039;\&#039; + &#039; + ($schemaValue) + &#039; + \&#039;&#039;;
      } else {
        out += &#039;&#039; + (it.util.escapeQuotes($schema));
      }
      out += &#039;&quot;\&#039; &#039;;
    }
    if (it.opts.verbose) {
      out += &#039; , schema:  &#039;;
      if ($isData) {
        out += &#039;validate.schema&#039; + ($schemaPath);
      } else {
        out += &#039;&#039; + (it.util.toQuotedString($schema));
      }
      out += &#039;         , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
    }
    out += &#039; } &#039;;
  } else {
    out += &#039; {} &#039;;
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule &amp;&amp; $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
    } else {
      out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
    }
  } else {
    out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
  }
  out += &#039; } &#039;;
  if ($breakOnError) {
    out += &#039; else { &#039;;
  }
  return out;
}

},{}],26:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_if(it, $keyword, $ruleType) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $valid = &#039;valid&#039; + $lvl;
  var $errs = &#039;errs__&#039; + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = &#039;valid&#039; + $it.level;
  var $thenSch = it.schema[&#039;then&#039;],
    $elseSch = it.schema[&#039;else&#039;],
    $thenPresent = $thenSch !== undefined &amp;&amp; (it.opts.strictKeywords ? (typeof $thenSch == &#039;object&#039; &amp;&amp; Object.keys($thenSch).length &gt; 0) || $thenSch === false : it.util.schemaHasRules($thenSch, it.RULES.all)),
    $elsePresent = $elseSch !== undefined &amp;&amp; (it.opts.strictKeywords ? (typeof $elseSch == &#039;object&#039; &amp;&amp; Object.keys($elseSch).length &gt; 0) || $elseSch === false : it.util.schemaHasRules($elseSch, it.RULES.all)),
    $currentBaseId = $it.baseId;
  if ($thenPresent || $elsePresent) {
    var $ifClause;
    $it.createErrors = false;
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += &#039; var &#039; + ($errs) + &#039; = errors; var &#039; + ($valid) + &#039; = true;  &#039;;
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    out += &#039;  &#039; + (it.validate($it)) + &#039; &#039;;
    $it.baseId = $currentBaseId;
    $it.createErrors = true;
    out += &#039;  errors = &#039; + ($errs) + &#039;; if (vErrors !== null) { if (&#039; + ($errs) + &#039;) vErrors.length = &#039; + ($errs) + &#039;; else vErrors = null; }  &#039;;
    it.compositeRule = $it.compositeRule = $wasComposite;
    if ($thenPresent) {
      out += &#039; if (&#039; + ($nextValid) + &#039;) {  &#039;;
      $it.schema = it.schema[&#039;then&#039;];
      $it.schemaPath = it.schemaPath + &#039;.then&#039;;
      $it.errSchemaPath = it.errSchemaPath + &#039;/then&#039;;
      out += &#039;  &#039; + (it.validate($it)) + &#039; &#039;;
      $it.baseId = $currentBaseId;
      out += &#039; &#039; + ($valid) + &#039; = &#039; + ($nextValid) + &#039;; &#039;;
      if ($thenPresent &amp;&amp; $elsePresent) {
        $ifClause = &#039;ifClause&#039; + $lvl;
        out += &#039; var &#039; + ($ifClause) + &#039; = \&#039;then\&#039;; &#039;;
      } else {
        $ifClause = &#039;\&#039;then\&#039;&#039;;
      }
      out += &#039; } &#039;;
      if ($elsePresent) {
        out += &#039; else { &#039;;
      }
    } else {
      out += &#039; if (!&#039; + ($nextValid) + &#039;) { &#039;;
    }
    if ($elsePresent) {
      $it.schema = it.schema[&#039;else&#039;];
      $it.schemaPath = it.schemaPath + &#039;.else&#039;;
      $it.errSchemaPath = it.errSchemaPath + &#039;/else&#039;;
      out += &#039;  &#039; + (it.validate($it)) + &#039; &#039;;
      $it.baseId = $currentBaseId;
      out += &#039; &#039; + ($valid) + &#039; = &#039; + ($nextValid) + &#039;; &#039;;
      if ($thenPresent &amp;&amp; $elsePresent) {
        $ifClause = &#039;ifClause&#039; + $lvl;
        out += &#039; var &#039; + ($ifClause) + &#039; = \&#039;else\&#039;; &#039;;
      } else {
        $ifClause = &#039;\&#039;else\&#039;&#039;;
      }
      out += &#039; } &#039;;
    }
    out += &#039; if (!&#039; + ($valid) + &#039;) {   var err =   &#039;; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += &#039; { keyword: \&#039;&#039; + (&#039;if&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: { failingKeyword: &#039; + ($ifClause) + &#039; } &#039;;
      if (it.opts.messages !== false) {
        out += &#039; , message: \&#039;should match &quot;\&#039; + &#039; + ($ifClause) + &#039; + \&#039;&quot; schema\&#039; &#039;;
      }
      if (it.opts.verbose) {
        out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
      }
      out += &#039; } &#039;;
    } else {
      out += &#039; {} &#039;;
    }
    out += &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
    if (!it.compositeRule &amp;&amp; $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += &#039; throw new ValidationError(vErrors); &#039;;
      } else {
        out += &#039; validate.errors = vErrors; return false; &#039;;
      }
    }
    out += &#039; }   &#039;;
    if ($breakOnError) {
      out += &#039; else { &#039;;
    }
  } else {
    if ($breakOnError) {
      out += &#039; if (true) { &#039;;
    }
  }
  return out;
}

},{}],27:[function(require,module,exports){
&#039;use strict&#039;;

//all requires must be explicit because browserify won&#039;t work with dynamic requires
module.exports = {
  &#039;$ref&#039;: require(&#039;./ref&#039;),
  allOf: require(&#039;./allOf&#039;),
  anyOf: require(&#039;./anyOf&#039;),
  &#039;$comment&#039;: require(&#039;./comment&#039;),
  const: require(&#039;./const&#039;),
  contains: require(&#039;./contains&#039;),
  dependencies: require(&#039;./dependencies&#039;),
  &#039;enum&#039;: require(&#039;./enum&#039;),
  format: require(&#039;./format&#039;),
  &#039;if&#039;: require(&#039;./if&#039;),
  items: require(&#039;./items&#039;),
  maximum: require(&#039;./_limit&#039;),
  minimum: require(&#039;./_limit&#039;),
  maxItems: require(&#039;./_limitItems&#039;),
  minItems: require(&#039;./_limitItems&#039;),
  maxLength: require(&#039;./_limitLength&#039;),
  minLength: require(&#039;./_limitLength&#039;),
  maxProperties: require(&#039;./_limitProperties&#039;),
  minProperties: require(&#039;./_limitProperties&#039;),
  multipleOf: require(&#039;./multipleOf&#039;),
  not: require(&#039;./not&#039;),
  oneOf: require(&#039;./oneOf&#039;),
  pattern: require(&#039;./pattern&#039;),
  properties: require(&#039;./properties&#039;),
  propertyNames: require(&#039;./propertyNames&#039;),
  required: require(&#039;./required&#039;),
  uniqueItems: require(&#039;./uniqueItems&#039;),
  validate: require(&#039;./validate&#039;)
};

},{&quot;./_limit&quot;:13,&quot;./_limitItems&quot;:14,&quot;./_limitLength&quot;:15,&quot;./_limitProperties&quot;:16,&quot;./allOf&quot;:17,&quot;./anyOf&quot;:18,&quot;./comment&quot;:19,&quot;./const&quot;:20,&quot;./contains&quot;:21,&quot;./dependencies&quot;:23,&quot;./enum&quot;:24,&quot;./format&quot;:25,&quot;./if&quot;:26,&quot;./items&quot;:28,&quot;./multipleOf&quot;:29,&quot;./not&quot;:30,&quot;./oneOf&quot;:31,&quot;./pattern&quot;:32,&quot;./properties&quot;:33,&quot;./propertyNames&quot;:34,&quot;./ref&quot;:35,&quot;./required&quot;:36,&quot;./uniqueItems&quot;:37,&quot;./validate&quot;:38}],28:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_items(it, $keyword, $ruleType) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $valid = &#039;valid&#039; + $lvl;
  var $errs = &#039;errs__&#039; + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = &#039;&#039;;
  $it.level++;
  var $nextValid = &#039;valid&#039; + $it.level;
  var $idx = &#039;i&#039; + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = &#039;data&#039; + $dataNxt,
    $currentBaseId = it.baseId;
  out += &#039;var &#039; + ($errs) + &#039; = errors;var &#039; + ($valid) + &#039;;&#039;;
  if (Array.isArray($schema)) {
    var $additionalItems = it.schema.additionalItems;
    if ($additionalItems === false) {
      out += &#039; &#039; + ($valid) + &#039; = &#039; + ($data) + &#039;.length &lt;= &#039; + ($schema.length) + &#039;; &#039;;
      var $currErrSchemaPath = $errSchemaPath;
      $errSchemaPath = it.errSchemaPath + &#039;/additionalItems&#039;;
      out += &#039;  if (!&#039; + ($valid) + &#039;) {   &#039;;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = &#039;&#039;; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += &#039; { keyword: \&#039;&#039; + (&#039;additionalItems&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: { limit: &#039; + ($schema.length) + &#039; } &#039;;
        if (it.opts.messages !== false) {
          out += &#039; , message: \&#039;should NOT have more than &#039; + ($schema.length) + &#039; items\&#039; &#039;;
        }
        if (it.opts.verbose) {
          out += &#039; , schema: false , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
        }
        out += &#039; } &#039;;
      } else {
        out += &#039; {} &#039;;
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule &amp;&amp; $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
        } else {
          out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
        }
      } else {
        out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
      }
      out += &#039; } &#039;;
      $errSchemaPath = $currErrSchemaPath;
      if ($breakOnError) {
        $closingBraces += &#039;}&#039;;
        out += &#039; else { &#039;;
      }
    }
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1,
        l1 = arr1.length - 1;
      while ($i &lt; l1) {
        $sch = arr1[$i += 1];
        if ((it.opts.strictKeywords ? (typeof $sch == &#039;object&#039; &amp;&amp; Object.keys($sch).length &gt; 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
          out += &#039; &#039; + ($nextValid) + &#039; = true; if (&#039; + ($data) + &#039;.length &gt; &#039; + ($i) + &#039;) { &#039;;
          var $passData = $data + &#039;[&#039; + $i + &#039;]&#039;;
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + &#039;[&#039; + $i + &#039;]&#039;;
          $it.errSchemaPath = $errSchemaPath + &#039;/&#039; + $i;
          $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
          $it.dataPathArr[$dataNxt] = $i;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) &lt; 2) {
            out += &#039; &#039; + (it.util.varReplace($code, $nextData, $passData)) + &#039; &#039;;
          } else {
            out += &#039; var &#039; + ($nextData) + &#039; = &#039; + ($passData) + &#039;; &#039; + ($code) + &#039; &#039;;
          }
          out += &#039; }  &#039;;
          if ($breakOnError) {
            out += &#039; if (&#039; + ($nextValid) + &#039;) { &#039;;
            $closingBraces += &#039;}&#039;;
          }
        }
      }
    }
    if (typeof $additionalItems == &#039;object&#039; &amp;&amp; (it.opts.strictKeywords ? (typeof $additionalItems == &#039;object&#039; &amp;&amp; Object.keys($additionalItems).length &gt; 0) || $additionalItems === false : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
      $it.schema = $additionalItems;
      $it.schemaPath = it.schemaPath + &#039;.additionalItems&#039;;
      $it.errSchemaPath = it.errSchemaPath + &#039;/additionalItems&#039;;
      out += &#039; &#039; + ($nextValid) + &#039; = true; if (&#039; + ($data) + &#039;.length &gt; &#039; + ($schema.length) + &#039;) {  for (var &#039; + ($idx) + &#039; = &#039; + ($schema.length) + &#039;; &#039; + ($idx) + &#039; &lt; &#039; + ($data) + &#039;.length; &#039; + ($idx) + &#039;++) { &#039;;
      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
      var $passData = $data + &#039;[&#039; + $idx + &#039;]&#039;;
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) &lt; 2) {
        out += &#039; &#039; + (it.util.varReplace($code, $nextData, $passData)) + &#039; &#039;;
      } else {
        out += &#039; var &#039; + ($nextData) + &#039; = &#039; + ($passData) + &#039;; &#039; + ($code) + &#039; &#039;;
      }
      if ($breakOnError) {
        out += &#039; if (!&#039; + ($nextValid) + &#039;) break; &#039;;
      }
      out += &#039; } }  &#039;;
      if ($breakOnError) {
        out += &#039; if (&#039; + ($nextValid) + &#039;) { &#039;;
        $closingBraces += &#039;}&#039;;
      }
    }
  } else if ((it.opts.strictKeywords ? (typeof $schema == &#039;object&#039; &amp;&amp; Object.keys($schema).length &gt; 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all))) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += &#039;  for (var &#039; + ($idx) + &#039; = &#039; + (0) + &#039;; &#039; + ($idx) + &#039; &lt; &#039; + ($data) + &#039;.length; &#039; + ($idx) + &#039;++) { &#039;;
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + &#039;[&#039; + $idx + &#039;]&#039;;
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) &lt; 2) {
      out += &#039; &#039; + (it.util.varReplace($code, $nextData, $passData)) + &#039; &#039;;
    } else {
      out += &#039; var &#039; + ($nextData) + &#039; = &#039; + ($passData) + &#039;; &#039; + ($code) + &#039; &#039;;
    }
    if ($breakOnError) {
      out += &#039; if (!&#039; + ($nextValid) + &#039;) break; &#039;;
    }
    out += &#039; }&#039;;
  }
  if ($breakOnError) {
    out += &#039; &#039; + ($closingBraces) + &#039; if (&#039; + ($errs) + &#039; == errors) {&#039;;
  }
  return out;
}

},{}],29:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_multipleOf(it, $keyword, $ruleType) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $isData = it.opts.$data &amp;&amp; $schema &amp;&amp; $schema.$data,
    $schemaValue;
  if ($isData) {
    out += &#039; var schema&#039; + ($lvl) + &#039; = &#039; + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + &#039;; &#039;;
    $schemaValue = &#039;schema&#039; + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!($isData || typeof $schema == &#039;number&#039;)) {
    throw new Error($keyword + &#039; must be number&#039;);
  }
  out += &#039;var division&#039; + ($lvl) + &#039;;if (&#039;;
  if ($isData) {
    out += &#039; &#039; + ($schemaValue) + &#039; !== undefined &amp;&amp; ( typeof &#039; + ($schemaValue) + &#039; != \&#039;number\&#039; || &#039;;
  }
  out += &#039; (division&#039; + ($lvl) + &#039; = &#039; + ($data) + &#039; / &#039; + ($schemaValue) + &#039;, &#039;;
  if (it.opts.multipleOfPrecision) {
    out += &#039; Math.abs(Math.round(division&#039; + ($lvl) + &#039;) - division&#039; + ($lvl) + &#039;) &gt; 1e-&#039; + (it.opts.multipleOfPrecision) + &#039; &#039;;
  } else {
    out += &#039; division&#039; + ($lvl) + &#039; !== parseInt(division&#039; + ($lvl) + &#039;) &#039;;
  }
  out += &#039; ) &#039;;
  if ($isData) {
    out += &#039;  )  &#039;;
  }
  out += &#039; ) {   &#039;;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = &#039;&#039;; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += &#039; { keyword: \&#039;&#039; + (&#039;multipleOf&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: { multipleOf: &#039; + ($schemaValue) + &#039; } &#039;;
    if (it.opts.messages !== false) {
      out += &#039; , message: \&#039;should be multiple of &#039;;
      if ($isData) {
        out += &#039;\&#039; + &#039; + ($schemaValue);
      } else {
        out += &#039;&#039; + ($schemaValue) + &#039;\&#039;&#039;;
      }
    }
    if (it.opts.verbose) {
      out += &#039; , schema:  &#039;;
      if ($isData) {
        out += &#039;validate.schema&#039; + ($schemaPath);
      } else {
        out += &#039;&#039; + ($schema);
      }
      out += &#039;         , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
    }
    out += &#039; } &#039;;
  } else {
    out += &#039; {} &#039;;
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule &amp;&amp; $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
    } else {
      out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
    }
  } else {
    out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
  }
  out += &#039;} &#039;;
  if ($breakOnError) {
    out += &#039; else { &#039;;
  }
  return out;
}

},{}],30:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_not(it, $keyword, $ruleType) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $errs = &#039;errs__&#039; + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = &#039;valid&#039; + $it.level;
  if ((it.opts.strictKeywords ? (typeof $schema == &#039;object&#039; &amp;&amp; Object.keys($schema).length &gt; 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all))) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += &#039; var &#039; + ($errs) + &#039; = errors;  &#039;;
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.createErrors = false;
    var $allErrorsOption;
    if ($it.opts.allErrors) {
      $allErrorsOption = $it.opts.allErrors;
      $it.opts.allErrors = false;
    }
    out += &#039; &#039; + (it.validate($it)) + &#039; &#039;;
    $it.createErrors = true;
    if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += &#039; if (&#039; + ($nextValid) + &#039;) {   &#039;;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = &#039;&#039;; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += &#039; { keyword: \&#039;&#039; + (&#039;not&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: {} &#039;;
      if (it.opts.messages !== false) {
        out += &#039; , message: \&#039;should NOT be valid\&#039; &#039;;
      }
      if (it.opts.verbose) {
        out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
      }
      out += &#039; } &#039;;
    } else {
      out += &#039; {} &#039;;
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule &amp;&amp; $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
      } else {
        out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
      }
    } else {
      out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
    }
    out += &#039; } else {  errors = &#039; + ($errs) + &#039;; if (vErrors !== null) { if (&#039; + ($errs) + &#039;) vErrors.length = &#039; + ($errs) + &#039;; else vErrors = null; } &#039;;
    if (it.opts.allErrors) {
      out += &#039; } &#039;;
    }
  } else {
    out += &#039;  var err =   &#039;; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += &#039; { keyword: \&#039;&#039; + (&#039;not&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: {} &#039;;
      if (it.opts.messages !== false) {
        out += &#039; , message: \&#039;should NOT be valid\&#039; &#039;;
      }
      if (it.opts.verbose) {
        out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
      }
      out += &#039; } &#039;;
    } else {
      out += &#039; {} &#039;;
    }
    out += &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
    if ($breakOnError) {
      out += &#039; if (false) { &#039;;
    }
  }
  return out;
}

},{}],31:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_oneOf(it, $keyword, $ruleType) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $valid = &#039;valid&#039; + $lvl;
  var $errs = &#039;errs__&#039; + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = &#039;&#039;;
  $it.level++;
  var $nextValid = &#039;valid&#039; + $it.level;
  var $currentBaseId = $it.baseId,
    $prevValid = &#039;prevValid&#039; + $lvl,
    $passingSchemas = &#039;passingSchemas&#039; + $lvl;
  out += &#039;var &#039; + ($errs) + &#039; = errors , &#039; + ($prevValid) + &#039; = false , &#039; + ($valid) + &#039; = false , &#039; + ($passingSchemas) + &#039; = null; &#039;;
  var $wasComposite = it.compositeRule;
  it.compositeRule = $it.compositeRule = true;
  var arr1 = $schema;
  if (arr1) {
    var $sch, $i = -1,
      l1 = arr1.length - 1;
    while ($i &lt; l1) {
      $sch = arr1[$i += 1];
      if ((it.opts.strictKeywords ? (typeof $sch == &#039;object&#039; &amp;&amp; Object.keys($sch).length &gt; 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + &#039;[&#039; + $i + &#039;]&#039;;
        $it.errSchemaPath = $errSchemaPath + &#039;/&#039; + $i;
        out += &#039;  &#039; + (it.validate($it)) + &#039; &#039;;
        $it.baseId = $currentBaseId;
      } else {
        out += &#039; var &#039; + ($nextValid) + &#039; = true; &#039;;
      }
      if ($i) {
        out += &#039; if (&#039; + ($nextValid) + &#039; &amp;&amp; &#039; + ($prevValid) + &#039;) { &#039; + ($valid) + &#039; = false; &#039; + ($passingSchemas) + &#039; = [&#039; + ($passingSchemas) + &#039;, &#039; + ($i) + &#039;]; } else { &#039;;
        $closingBraces += &#039;}&#039;;
      }
      out += &#039; if (&#039; + ($nextValid) + &#039;) { &#039; + ($valid) + &#039; = &#039; + ($prevValid) + &#039; = true; &#039; + ($passingSchemas) + &#039; = &#039; + ($i) + &#039;; }&#039;;
    }
  }
  it.compositeRule = $it.compositeRule = $wasComposite;
  out += &#039;&#039; + ($closingBraces) + &#039;if (!&#039; + ($valid) + &#039;) {   var err =   &#039;; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += &#039; { keyword: \&#039;&#039; + (&#039;oneOf&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: { passingSchemas: &#039; + ($passingSchemas) + &#039; } &#039;;
    if (it.opts.messages !== false) {
      out += &#039; , message: \&#039;should match exactly one schema in oneOf\&#039; &#039;;
    }
    if (it.opts.verbose) {
      out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
    }
    out += &#039; } &#039;;
  } else {
    out += &#039; {} &#039;;
  }
  out += &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
  if (!it.compositeRule &amp;&amp; $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += &#039; throw new ValidationError(vErrors); &#039;;
    } else {
      out += &#039; validate.errors = vErrors; return false; &#039;;
    }
  }
  out += &#039;} else {  errors = &#039; + ($errs) + &#039;; if (vErrors !== null) { if (&#039; + ($errs) + &#039;) vErrors.length = &#039; + ($errs) + &#039;; else vErrors = null; }&#039;;
  if (it.opts.allErrors) {
    out += &#039; } &#039;;
  }
  return out;
}

},{}],32:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_pattern(it, $keyword, $ruleType) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $isData = it.opts.$data &amp;&amp; $schema &amp;&amp; $schema.$data,
    $schemaValue;
  if ($isData) {
    out += &#039; var schema&#039; + ($lvl) + &#039; = &#039; + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + &#039;; &#039;;
    $schemaValue = &#039;schema&#039; + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $regexp = $isData ? &#039;(new RegExp(&#039; + $schemaValue + &#039;))&#039; : it.usePattern($schema);
  out += &#039;if ( &#039;;
  if ($isData) {
    out += &#039; (&#039; + ($schemaValue) + &#039; !== undefined &amp;&amp; typeof &#039; + ($schemaValue) + &#039; != \&#039;string\&#039;) || &#039;;
  }
  out += &#039; !&#039; + ($regexp) + &#039;.test(&#039; + ($data) + &#039;) ) {   &#039;;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = &#039;&#039;; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += &#039; { keyword: \&#039;&#039; + (&#039;pattern&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: { pattern:  &#039;;
    if ($isData) {
      out += &#039;&#039; + ($schemaValue);
    } else {
      out += &#039;&#039; + (it.util.toQuotedString($schema));
    }
    out += &#039;  } &#039;;
    if (it.opts.messages !== false) {
      out += &#039; , message: \&#039;should match pattern &quot;&#039;;
      if ($isData) {
        out += &#039;\&#039; + &#039; + ($schemaValue) + &#039; + \&#039;&#039;;
      } else {
        out += &#039;&#039; + (it.util.escapeQuotes($schema));
      }
      out += &#039;&quot;\&#039; &#039;;
    }
    if (it.opts.verbose) {
      out += &#039; , schema:  &#039;;
      if ($isData) {
        out += &#039;validate.schema&#039; + ($schemaPath);
      } else {
        out += &#039;&#039; + (it.util.toQuotedString($schema));
      }
      out += &#039;         , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
    }
    out += &#039; } &#039;;
  } else {
    out += &#039; {} &#039;;
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule &amp;&amp; $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
    } else {
      out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
    }
  } else {
    out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
  }
  out += &#039;} &#039;;
  if ($breakOnError) {
    out += &#039; else { &#039;;
  }
  return out;
}

},{}],33:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_properties(it, $keyword, $ruleType) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $errs = &#039;errs__&#039; + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = &#039;&#039;;
  $it.level++;
  var $nextValid = &#039;valid&#039; + $it.level;
  var $key = &#039;key&#039; + $lvl,
    $idx = &#039;idx&#039; + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = &#039;data&#039; + $dataNxt,
    $dataProperties = &#039;dataProperties&#039; + $lvl;
  var $schemaKeys = Object.keys($schema || {}).filter(notProto),
    $pProperties = it.schema.patternProperties || {},
    $pPropertyKeys = Object.keys($pProperties).filter(notProto),
    $aProperties = it.schema.additionalProperties,
    $someProperties = $schemaKeys.length || $pPropertyKeys.length,
    $noAdditional = $aProperties === false,
    $additionalIsSchema = typeof $aProperties == &#039;object&#039; &amp;&amp; Object.keys($aProperties).length,
    $removeAdditional = it.opts.removeAdditional,
    $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,
    $ownProperties = it.opts.ownProperties,
    $currentBaseId = it.baseId;
  var $required = it.schema.required;
  if ($required &amp;&amp; !(it.opts.$data &amp;&amp; $required.$data) &amp;&amp; $required.length &lt; it.opts.loopRequired) {
    var $requiredHash = it.util.toHash($required);
  }

  function notProto(p) {
    return p !== &#039;__proto__&#039;;
  }
  out += &#039;var &#039; + ($errs) + &#039; = errors;var &#039; + ($nextValid) + &#039; = true;&#039;;
  if ($ownProperties) {
    out += &#039; var &#039; + ($dataProperties) + &#039; = undefined;&#039;;
  }
  if ($checkAdditional) {
    if ($ownProperties) {
      out += &#039; &#039; + ($dataProperties) + &#039; = &#039; + ($dataProperties) + &#039; || Object.keys(&#039; + ($data) + &#039;); for (var &#039; + ($idx) + &#039;=0; &#039; + ($idx) + &#039;&lt;&#039; + ($dataProperties) + &#039;.length; &#039; + ($idx) + &#039;++) { var &#039; + ($key) + &#039; = &#039; + ($dataProperties) + &#039;[&#039; + ($idx) + &#039;]; &#039;;
    } else {
      out += &#039; for (var &#039; + ($key) + &#039; in &#039; + ($data) + &#039;) { &#039;;
    }
    if ($someProperties) {
      out += &#039; var isAdditional&#039; + ($lvl) + &#039; = !(false &#039;;
      if ($schemaKeys.length) {
        if ($schemaKeys.length &gt; 8) {
          out += &#039; || validate.schema&#039; + ($schemaPath) + &#039;.hasOwnProperty(&#039; + ($key) + &#039;) &#039;;
        } else {
          var arr1 = $schemaKeys;
          if (arr1) {
            var $propertyKey, i1 = -1,
              l1 = arr1.length - 1;
            while (i1 &lt; l1) {
              $propertyKey = arr1[i1 += 1];
              out += &#039; || &#039; + ($key) + &#039; == &#039; + (it.util.toQuotedString($propertyKey)) + &#039; &#039;;
            }
          }
        }
      }
      if ($pPropertyKeys.length) {
        var arr2 = $pPropertyKeys;
        if (arr2) {
          var $pProperty, $i = -1,
            l2 = arr2.length - 1;
          while ($i &lt; l2) {
            $pProperty = arr2[$i += 1];
            out += &#039; || &#039; + (it.usePattern($pProperty)) + &#039;.test(&#039; + ($key) + &#039;) &#039;;
          }
        }
      }
      out += &#039; ); if (isAdditional&#039; + ($lvl) + &#039;) { &#039;;
    }
    if ($removeAdditional == &#039;all&#039;) {
      out += &#039; delete &#039; + ($data) + &#039;[&#039; + ($key) + &#039;]; &#039;;
    } else {
      var $currentErrorPath = it.errorPath;
      var $additionalProperty = &#039;\&#039; + &#039; + $key + &#039; + \&#039;&#039;;
      if (it.opts._errorDataPathProperty) {
        it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
      }
      if ($noAdditional) {
        if ($removeAdditional) {
          out += &#039; delete &#039; + ($data) + &#039;[&#039; + ($key) + &#039;]; &#039;;
        } else {
          out += &#039; &#039; + ($nextValid) + &#039; = false; &#039;;
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + &#039;/additionalProperties&#039;;
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = &#039;&#039;; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += &#039; { keyword: \&#039;&#039; + (&#039;additionalProperties&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: { additionalProperty: \&#039;&#039; + ($additionalProperty) + &#039;\&#039; } &#039;;
            if (it.opts.messages !== false) {
              out += &#039; , message: \&#039;&#039;;
              if (it.opts._errorDataPathProperty) {
                out += &#039;is an invalid additional property&#039;;
              } else {
                out += &#039;should NOT have additional properties&#039;;
              }
              out += &#039;\&#039; &#039;;
            }
            if (it.opts.verbose) {
              out += &#039; , schema: false , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
            }
            out += &#039; } &#039;;
          } else {
            out += &#039; {} &#039;;
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule &amp;&amp; $breakOnError) {
            /* istanbul ignore if */
            if (it.async) {
              out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
            } else {
              out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
            }
          } else {
            out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
          }
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) {
            out += &#039; break; &#039;;
          }
        }
      } else if ($additionalIsSchema) {
        if ($removeAdditional == &#039;failing&#039;) {
          out += &#039; var &#039; + ($errs) + &#039; = errors;  &#039;;
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + &#039;.additionalProperties&#039;;
          $it.errSchemaPath = it.errSchemaPath + &#039;/additionalProperties&#039;;
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + &#039;[&#039; + $key + &#039;]&#039;;
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) &lt; 2) {
            out += &#039; &#039; + (it.util.varReplace($code, $nextData, $passData)) + &#039; &#039;;
          } else {
            out += &#039; var &#039; + ($nextData) + &#039; = &#039; + ($passData) + &#039;; &#039; + ($code) + &#039; &#039;;
          }
          out += &#039; if (!&#039; + ($nextValid) + &#039;) { errors = &#039; + ($errs) + &#039;; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete &#039; + ($data) + &#039;[&#039; + ($key) + &#039;]; }  &#039;;
          it.compositeRule = $it.compositeRule = $wasComposite;
        } else {
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + &#039;.additionalProperties&#039;;
          $it.errSchemaPath = it.errSchemaPath + &#039;/additionalProperties&#039;;
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + &#039;[&#039; + $key + &#039;]&#039;;
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) &lt; 2) {
            out += &#039; &#039; + (it.util.varReplace($code, $nextData, $passData)) + &#039; &#039;;
          } else {
            out += &#039; var &#039; + ($nextData) + &#039; = &#039; + ($passData) + &#039;; &#039; + ($code) + &#039; &#039;;
          }
          if ($breakOnError) {
            out += &#039; if (!&#039; + ($nextValid) + &#039;) break; &#039;;
          }
        }
      }
      it.errorPath = $currentErrorPath;
    }
    if ($someProperties) {
      out += &#039; } &#039;;
    }
    out += &#039; }  &#039;;
    if ($breakOnError) {
      out += &#039; if (&#039; + ($nextValid) + &#039;) { &#039;;
      $closingBraces += &#039;}&#039;;
    }
  }
  var $useDefaults = it.opts.useDefaults &amp;&amp; !it.compositeRule;
  if ($schemaKeys.length) {
    var arr3 = $schemaKeys;
    if (arr3) {
      var $propertyKey, i3 = -1,
        l3 = arr3.length - 1;
      while (i3 &lt; l3) {
        $propertyKey = arr3[i3 += 1];
        var $sch = $schema[$propertyKey];
        if ((it.opts.strictKeywords ? (typeof $sch == &#039;object&#039; &amp;&amp; Object.keys($sch).length &gt; 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
          var $prop = it.util.getProperty($propertyKey),
            $passData = $data + $prop,
            $hasDefault = $useDefaults &amp;&amp; $sch.default !== undefined;
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + $prop;
          $it.errSchemaPath = $errSchemaPath + &#039;/&#039; + it.util.escapeFragment($propertyKey);
          $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
          $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) &lt; 2) {
            $code = it.util.varReplace($code, $nextData, $passData);
            var $useData = $passData;
          } else {
            var $useData = $nextData;
            out += &#039; var &#039; + ($nextData) + &#039; = &#039; + ($passData) + &#039;; &#039;;
          }
          if ($hasDefault) {
            out += &#039; &#039; + ($code) + &#039; &#039;;
          } else {
            if ($requiredHash &amp;&amp; $requiredHash[$propertyKey]) {
              out += &#039; if ( &#039; + ($useData) + &#039; === undefined &#039;;
              if ($ownProperties) {
                out += &#039; || ! Object.prototype.hasOwnProperty.call(&#039; + ($data) + &#039;, \&#039;&#039; + (it.util.escapeQuotes($propertyKey)) + &#039;\&#039;) &#039;;
              }
              out += &#039;) { &#039; + ($nextValid) + &#039; = false; &#039;;
              var $currentErrorPath = it.errorPath,
                $currErrSchemaPath = $errSchemaPath,
                $missingProperty = it.util.escapeQuotes($propertyKey);
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
              }
              $errSchemaPath = it.errSchemaPath + &#039;/required&#039;;
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = &#039;&#039;; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += &#039; { keyword: \&#039;&#039; + (&#039;required&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: { missingProperty: \&#039;&#039; + ($missingProperty) + &#039;\&#039; } &#039;;
                if (it.opts.messages !== false) {
                  out += &#039; , message: \&#039;&#039;;
                  if (it.opts._errorDataPathProperty) {
                    out += &#039;is a required property&#039;;
                  } else {
                    out += &#039;should have required property \\\&#039;&#039; + ($missingProperty) + &#039;\\\&#039;&#039;;
                  }
                  out += &#039;\&#039; &#039;;
                }
                if (it.opts.verbose) {
                  out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
                }
                out += &#039; } &#039;;
              } else {
                out += &#039; {} &#039;;
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule &amp;&amp; $breakOnError) {
                /* istanbul ignore if */
                if (it.async) {
                  out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
                } else {
                  out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
                }
              } else {
                out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
              }
              $errSchemaPath = $currErrSchemaPath;
              it.errorPath = $currentErrorPath;
              out += &#039; } else { &#039;;
            } else {
              if ($breakOnError) {
                out += &#039; if ( &#039; + ($useData) + &#039; === undefined &#039;;
                if ($ownProperties) {
                  out += &#039; || ! Object.prototype.hasOwnProperty.call(&#039; + ($data) + &#039;, \&#039;&#039; + (it.util.escapeQuotes($propertyKey)) + &#039;\&#039;) &#039;;
                }
                out += &#039;) { &#039; + ($nextValid) + &#039; = true; } else { &#039;;
              } else {
                out += &#039; if (&#039; + ($useData) + &#039; !== undefined &#039;;
                if ($ownProperties) {
                  out += &#039; &amp;&amp;   Object.prototype.hasOwnProperty.call(&#039; + ($data) + &#039;, \&#039;&#039; + (it.util.escapeQuotes($propertyKey)) + &#039;\&#039;) &#039;;
                }
                out += &#039; ) { &#039;;
              }
            }
            out += &#039; &#039; + ($code) + &#039; } &#039;;
          }
        }
        if ($breakOnError) {
          out += &#039; if (&#039; + ($nextValid) + &#039;) { &#039;;
          $closingBraces += &#039;}&#039;;
        }
      }
    }
  }
  if ($pPropertyKeys.length) {
    var arr4 = $pPropertyKeys;
    if (arr4) {
      var $pProperty, i4 = -1,
        l4 = arr4.length - 1;
      while (i4 &lt; l4) {
        $pProperty = arr4[i4 += 1];
        var $sch = $pProperties[$pProperty];
        if ((it.opts.strictKeywords ? (typeof $sch == &#039;object&#039; &amp;&amp; Object.keys($sch).length &gt; 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
          $it.schema = $sch;
          $it.schemaPath = it.schemaPath + &#039;.patternProperties&#039; + it.util.getProperty($pProperty);
          $it.errSchemaPath = it.errSchemaPath + &#039;/patternProperties/&#039; + it.util.escapeFragment($pProperty);
          if ($ownProperties) {
            out += &#039; &#039; + ($dataProperties) + &#039; = &#039; + ($dataProperties) + &#039; || Object.keys(&#039; + ($data) + &#039;); for (var &#039; + ($idx) + &#039;=0; &#039; + ($idx) + &#039;&lt;&#039; + ($dataProperties) + &#039;.length; &#039; + ($idx) + &#039;++) { var &#039; + ($key) + &#039; = &#039; + ($dataProperties) + &#039;[&#039; + ($idx) + &#039;]; &#039;;
          } else {
            out += &#039; for (var &#039; + ($key) + &#039; in &#039; + ($data) + &#039;) { &#039;;
          }
          out += &#039; if (&#039; + (it.usePattern($pProperty)) + &#039;.test(&#039; + ($key) + &#039;)) { &#039;;
          $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + &#039;[&#039; + $key + &#039;]&#039;;
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) &lt; 2) {
            out += &#039; &#039; + (it.util.varReplace($code, $nextData, $passData)) + &#039; &#039;;
          } else {
            out += &#039; var &#039; + ($nextData) + &#039; = &#039; + ($passData) + &#039;; &#039; + ($code) + &#039; &#039;;
          }
          if ($breakOnError) {
            out += &#039; if (!&#039; + ($nextValid) + &#039;) break; &#039;;
          }
          out += &#039; } &#039;;
          if ($breakOnError) {
            out += &#039; else &#039; + ($nextValid) + &#039; = true; &#039;;
          }
          out += &#039; }  &#039;;
          if ($breakOnError) {
            out += &#039; if (&#039; + ($nextValid) + &#039;) { &#039;;
            $closingBraces += &#039;}&#039;;
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += &#039; &#039; + ($closingBraces) + &#039; if (&#039; + ($errs) + &#039; == errors) {&#039;;
  }
  return out;
}

},{}],34:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_propertyNames(it, $keyword, $ruleType) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $errs = &#039;errs__&#039; + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = &#039;&#039;;
  $it.level++;
  var $nextValid = &#039;valid&#039; + $it.level;
  out += &#039;var &#039; + ($errs) + &#039; = errors;&#039;;
  if ((it.opts.strictKeywords ? (typeof $schema == &#039;object&#039; &amp;&amp; Object.keys($schema).length &gt; 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all))) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    var $key = &#039;key&#039; + $lvl,
      $idx = &#039;idx&#039; + $lvl,
      $i = &#039;i&#039; + $lvl,
      $invalidName = &#039;\&#039; + &#039; + $key + &#039; + \&#039;&#039;,
      $dataNxt = $it.dataLevel = it.dataLevel + 1,
      $nextData = &#039;data&#039; + $dataNxt,
      $dataProperties = &#039;dataProperties&#039; + $lvl,
      $ownProperties = it.opts.ownProperties,
      $currentBaseId = it.baseId;
    if ($ownProperties) {
      out += &#039; var &#039; + ($dataProperties) + &#039; = undefined; &#039;;
    }
    if ($ownProperties) {
      out += &#039; &#039; + ($dataProperties) + &#039; = &#039; + ($dataProperties) + &#039; || Object.keys(&#039; + ($data) + &#039;); for (var &#039; + ($idx) + &#039;=0; &#039; + ($idx) + &#039;&lt;&#039; + ($dataProperties) + &#039;.length; &#039; + ($idx) + &#039;++) { var &#039; + ($key) + &#039; = &#039; + ($dataProperties) + &#039;[&#039; + ($idx) + &#039;]; &#039;;
    } else {
      out += &#039; for (var &#039; + ($key) + &#039; in &#039; + ($data) + &#039;) { &#039;;
    }
    out += &#039; var startErrs&#039; + ($lvl) + &#039; = errors; &#039;;
    var $passData = $key;
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) &lt; 2) {
      out += &#039; &#039; + (it.util.varReplace($code, $nextData, $passData)) + &#039; &#039;;
    } else {
      out += &#039; var &#039; + ($nextData) + &#039; = &#039; + ($passData) + &#039;; &#039; + ($code) + &#039; &#039;;
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += &#039; if (!&#039; + ($nextValid) + &#039;) { for (var &#039; + ($i) + &#039;=startErrs&#039; + ($lvl) + &#039;; &#039; + ($i) + &#039;&lt;errors; &#039; + ($i) + &#039;++) { vErrors[&#039; + ($i) + &#039;].propertyName = &#039; + ($key) + &#039;; }   var err =   &#039;; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += &#039; { keyword: \&#039;&#039; + (&#039;propertyNames&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: { propertyName: \&#039;&#039; + ($invalidName) + &#039;\&#039; } &#039;;
      if (it.opts.messages !== false) {
        out += &#039; , message: \&#039;property name \\\&#039;&#039; + ($invalidName) + &#039;\\\&#039; is invalid\&#039; &#039;;
      }
      if (it.opts.verbose) {
        out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
      }
      out += &#039; } &#039;;
    } else {
      out += &#039; {} &#039;;
    }
    out += &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
    if (!it.compositeRule &amp;&amp; $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += &#039; throw new ValidationError(vErrors); &#039;;
      } else {
        out += &#039; validate.errors = vErrors; return false; &#039;;
      }
    }
    if ($breakOnError) {
      out += &#039; break; &#039;;
    }
    out += &#039; } }&#039;;
  }
  if ($breakOnError) {
    out += &#039; &#039; + ($closingBraces) + &#039; if (&#039; + ($errs) + &#039; == errors) {&#039;;
  }
  return out;
}

},{}],35:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_ref(it, $keyword, $ruleType) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $valid = &#039;valid&#039; + $lvl;
  var $async, $refCode;
  if ($schema == &#039;#&#039; || $schema == &#039;#/&#039;) {
    if (it.isRoot) {
      $async = it.async;
      $refCode = &#039;validate&#039;;
    } else {
      $async = it.root.schema.$async === true;
      $refCode = &#039;root.refVal[0]&#039;;
    }
  } else {
    var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
    if ($refVal === undefined) {
      var $message = it.MissingRefError.message(it.baseId, $schema);
      if (it.opts.missingRefs == &#039;fail&#039;) {
        it.logger.error($message);
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = &#039;&#039;; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += &#039; { keyword: \&#039;&#039; + (&#039;$ref&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: { ref: \&#039;&#039; + (it.util.escapeQuotes($schema)) + &#039;\&#039; } &#039;;
          if (it.opts.messages !== false) {
            out += &#039; , message: \&#039;can\\\&#039;t resolve reference &#039; + (it.util.escapeQuotes($schema)) + &#039;\&#039; &#039;;
          }
          if (it.opts.verbose) {
            out += &#039; , schema: &#039; + (it.util.toQuotedString($schema)) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
          }
          out += &#039; } &#039;;
        } else {
          out += &#039; {} &#039;;
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule &amp;&amp; $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
          } else {
            out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
          }
        } else {
          out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
        }
        if ($breakOnError) {
          out += &#039; if (false) { &#039;;
        }
      } else if (it.opts.missingRefs == &#039;ignore&#039;) {
        it.logger.warn($message);
        if ($breakOnError) {
          out += &#039; if (true) { &#039;;
        }
      } else {
        throw new it.MissingRefError(it.baseId, $schema, $message);
      }
    } else if ($refVal.inline) {
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = &#039;valid&#039; + $it.level;
      $it.schema = $refVal.schema;
      $it.schemaPath = &#039;&#039;;
      $it.errSchemaPath = $schema;
      var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
      out += &#039; &#039; + ($code) + &#039; &#039;;
      if ($breakOnError) {
        out += &#039; if (&#039; + ($nextValid) + &#039;) { &#039;;
      }
    } else {
      $async = $refVal.$async === true || (it.async &amp;&amp; $refVal.$async !== false);
      $refCode = $refVal.code;
    }
  }
  if ($refCode) {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = &#039;&#039;;
    if (it.opts.passContext) {
      out += &#039; &#039; + ($refCode) + &#039;.call(this, &#039;;
    } else {
      out += &#039; &#039; + ($refCode) + &#039;( &#039;;
    }
    out += &#039; &#039; + ($data) + &#039;, (dataPath || \&#039;\&#039;)&#039;;
    if (it.errorPath != &#039;&quot;&quot;&#039;) {
      out += &#039; + &#039; + (it.errorPath);
    }
    var $parentData = $dataLvl ? &#039;data&#039; + (($dataLvl - 1) || &#039;&#039;) : &#039;parentData&#039;,
      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : &#039;parentDataProperty&#039;;
    out += &#039; , &#039; + ($parentData) + &#039; , &#039; + ($parentDataProperty) + &#039;, rootData)  &#039;;
    var __callValidate = out;
    out = $$outStack.pop();
    if ($async) {
      if (!it.async) throw new Error(&#039;async schema referenced by sync schema&#039;);
      if ($breakOnError) {
        out += &#039; var &#039; + ($valid) + &#039;; &#039;;
      }
      out += &#039; try { await &#039; + (__callValidate) + &#039;; &#039;;
      if ($breakOnError) {
        out += &#039; &#039; + ($valid) + &#039; = true; &#039;;
      }
      out += &#039; } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; &#039;;
      if ($breakOnError) {
        out += &#039; &#039; + ($valid) + &#039; = false; &#039;;
      }
      out += &#039; } &#039;;
      if ($breakOnError) {
        out += &#039; if (&#039; + ($valid) + &#039;) { &#039;;
      }
    } else {
      out += &#039; if (!&#039; + (__callValidate) + &#039;) { if (vErrors === null) vErrors = &#039; + ($refCode) + &#039;.errors; else vErrors = vErrors.concat(&#039; + ($refCode) + &#039;.errors); errors = vErrors.length; } &#039;;
      if ($breakOnError) {
        out += &#039; else { &#039;;
      }
    }
  }
  return out;
}

},{}],36:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_required(it, $keyword, $ruleType) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $valid = &#039;valid&#039; + $lvl;
  var $isData = it.opts.$data &amp;&amp; $schema &amp;&amp; $schema.$data,
    $schemaValue;
  if ($isData) {
    out += &#039; var schema&#039; + ($lvl) + &#039; = &#039; + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + &#039;; &#039;;
    $schemaValue = &#039;schema&#039; + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $vSchema = &#039;schema&#039; + $lvl;
  if (!$isData) {
    if ($schema.length &lt; it.opts.loopRequired &amp;&amp; it.schema.properties &amp;&amp; Object.keys(it.schema.properties).length) {
      var $required = [];
      var arr1 = $schema;
      if (arr1) {
        var $property, i1 = -1,
          l1 = arr1.length - 1;
        while (i1 &lt; l1) {
          $property = arr1[i1 += 1];
          var $propertySch = it.schema.properties[$property];
          if (!($propertySch &amp;&amp; (it.opts.strictKeywords ? (typeof $propertySch == &#039;object&#039; &amp;&amp; Object.keys($propertySch).length &gt; 0) || $propertySch === false : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
            $required[$required.length] = $property;
          }
        }
      }
    } else {
      var $required = $schema;
    }
  }
  if ($isData || $required.length) {
    var $currentErrorPath = it.errorPath,
      $loopRequired = $isData || $required.length &gt;= it.opts.loopRequired,
      $ownProperties = it.opts.ownProperties;
    if ($breakOnError) {
      out += &#039; var missing&#039; + ($lvl) + &#039;; &#039;;
      if ($loopRequired) {
        if (!$isData) {
          out += &#039; var &#039; + ($vSchema) + &#039; = validate.schema&#039; + ($schemaPath) + &#039;; &#039;;
        }
        var $i = &#039;i&#039; + $lvl,
          $propertyPath = &#039;schema&#039; + $lvl + &#039;[&#039; + $i + &#039;]&#039;,
          $missingProperty = &#039;\&#039; + &#039; + $propertyPath + &#039; + \&#039;&#039;;
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        out += &#039; var &#039; + ($valid) + &#039; = true; &#039;;
        if ($isData) {
          out += &#039; if (schema&#039; + ($lvl) + &#039; === undefined) &#039; + ($valid) + &#039; = true; else if (!Array.isArray(schema&#039; + ($lvl) + &#039;)) &#039; + ($valid) + &#039; = false; else {&#039;;
        }
        out += &#039; for (var &#039; + ($i) + &#039; = 0; &#039; + ($i) + &#039; &lt; &#039; + ($vSchema) + &#039;.length; &#039; + ($i) + &#039;++) { &#039; + ($valid) + &#039; = &#039; + ($data) + &#039;[&#039; + ($vSchema) + &#039;[&#039; + ($i) + &#039;]] !== undefined &#039;;
        if ($ownProperties) {
          out += &#039; &amp;&amp;   Object.prototype.hasOwnProperty.call(&#039; + ($data) + &#039;, &#039; + ($vSchema) + &#039;[&#039; + ($i) + &#039;]) &#039;;
        }
        out += &#039;; if (!&#039; + ($valid) + &#039;) break; } &#039;;
        if ($isData) {
          out += &#039;  }  &#039;;
        }
        out += &#039;  if (!&#039; + ($valid) + &#039;) {   &#039;;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = &#039;&#039;; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += &#039; { keyword: \&#039;&#039; + (&#039;required&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: { missingProperty: \&#039;&#039; + ($missingProperty) + &#039;\&#039; } &#039;;
          if (it.opts.messages !== false) {
            out += &#039; , message: \&#039;&#039;;
            if (it.opts._errorDataPathProperty) {
              out += &#039;is a required property&#039;;
            } else {
              out += &#039;should have required property \\\&#039;&#039; + ($missingProperty) + &#039;\\\&#039;&#039;;
            }
            out += &#039;\&#039; &#039;;
          }
          if (it.opts.verbose) {
            out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
          }
          out += &#039; } &#039;;
        } else {
          out += &#039; {} &#039;;
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule &amp;&amp; $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
          } else {
            out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
          }
        } else {
          out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
        }
        out += &#039; } else { &#039;;
      } else {
        out += &#039; if ( &#039;;
        var arr2 = $required;
        if (arr2) {
          var $propertyKey, $i = -1,
            l2 = arr2.length - 1;
          while ($i &lt; l2) {
            $propertyKey = arr2[$i += 1];
            if ($i) {
              out += &#039; || &#039;;
            }
            var $prop = it.util.getProperty($propertyKey),
              $useData = $data + $prop;
            out += &#039; ( ( &#039; + ($useData) + &#039; === undefined &#039;;
            if ($ownProperties) {
              out += &#039; || ! Object.prototype.hasOwnProperty.call(&#039; + ($data) + &#039;, \&#039;&#039; + (it.util.escapeQuotes($propertyKey)) + &#039;\&#039;) &#039;;
            }
            out += &#039;) &amp;&amp; (missing&#039; + ($lvl) + &#039; = &#039; + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + &#039;) ) &#039;;
          }
        }
        out += &#039;) {  &#039;;
        var $propertyPath = &#039;missing&#039; + $lvl,
          $missingProperty = &#039;\&#039; + &#039; + $propertyPath + &#039; + \&#039;&#039;;
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + &#039; + &#039; + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = &#039;&#039;; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += &#039; { keyword: \&#039;&#039; + (&#039;required&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: { missingProperty: \&#039;&#039; + ($missingProperty) + &#039;\&#039; } &#039;;
          if (it.opts.messages !== false) {
            out += &#039; , message: \&#039;&#039;;
            if (it.opts._errorDataPathProperty) {
              out += &#039;is a required property&#039;;
            } else {
              out += &#039;should have required property \\\&#039;&#039; + ($missingProperty) + &#039;\\\&#039;&#039;;
            }
            out += &#039;\&#039; &#039;;
          }
          if (it.opts.verbose) {
            out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
          }
          out += &#039; } &#039;;
        } else {
          out += &#039; {} &#039;;
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule &amp;&amp; $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
          } else {
            out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
          }
        } else {
          out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
        }
        out += &#039; } else { &#039;;
      }
    } else {
      if ($loopRequired) {
        if (!$isData) {
          out += &#039; var &#039; + ($vSchema) + &#039; = validate.schema&#039; + ($schemaPath) + &#039;; &#039;;
        }
        var $i = &#039;i&#039; + $lvl,
          $propertyPath = &#039;schema&#039; + $lvl + &#039;[&#039; + $i + &#039;]&#039;,
          $missingProperty = &#039;\&#039; + &#039; + $propertyPath + &#039; + \&#039;&#039;;
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        if ($isData) {
          out += &#039; if (&#039; + ($vSchema) + &#039; &amp;&amp; !Array.isArray(&#039; + ($vSchema) + &#039;)) {  var err =   &#039;; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += &#039; { keyword: \&#039;&#039; + (&#039;required&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: { missingProperty: \&#039;&#039; + ($missingProperty) + &#039;\&#039; } &#039;;
            if (it.opts.messages !== false) {
              out += &#039; , message: \&#039;&#039;;
              if (it.opts._errorDataPathProperty) {
                out += &#039;is a required property&#039;;
              } else {
                out += &#039;should have required property \\\&#039;&#039; + ($missingProperty) + &#039;\\\&#039;&#039;;
              }
              out += &#039;\&#039; &#039;;
            }
            if (it.opts.verbose) {
              out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
            }
            out += &#039; } &#039;;
          } else {
            out += &#039; {} &#039;;
          }
          out += &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (&#039; + ($vSchema) + &#039; !== undefined) { &#039;;
        }
        out += &#039; for (var &#039; + ($i) + &#039; = 0; &#039; + ($i) + &#039; &lt; &#039; + ($vSchema) + &#039;.length; &#039; + ($i) + &#039;++) { if (&#039; + ($data) + &#039;[&#039; + ($vSchema) + &#039;[&#039; + ($i) + &#039;]] === undefined &#039;;
        if ($ownProperties) {
          out += &#039; || ! Object.prototype.hasOwnProperty.call(&#039; + ($data) + &#039;, &#039; + ($vSchema) + &#039;[&#039; + ($i) + &#039;]) &#039;;
        }
        out += &#039;) {  var err =   &#039;; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += &#039; { keyword: \&#039;&#039; + (&#039;required&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: { missingProperty: \&#039;&#039; + ($missingProperty) + &#039;\&#039; } &#039;;
          if (it.opts.messages !== false) {
            out += &#039; , message: \&#039;&#039;;
            if (it.opts._errorDataPathProperty) {
              out += &#039;is a required property&#039;;
            } else {
              out += &#039;should have required property \\\&#039;&#039; + ($missingProperty) + &#039;\\\&#039;&#039;;
            }
            out += &#039;\&#039; &#039;;
          }
          if (it.opts.verbose) {
            out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
          }
          out += &#039; } &#039;;
        } else {
          out += &#039; {} &#039;;
        }
        out += &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } &#039;;
        if ($isData) {
          out += &#039;  }  &#039;;
        }
      } else {
        var arr3 = $required;
        if (arr3) {
          var $propertyKey, i3 = -1,
            l3 = arr3.length - 1;
          while (i3 &lt; l3) {
            $propertyKey = arr3[i3 += 1];
            var $prop = it.util.getProperty($propertyKey),
              $missingProperty = it.util.escapeQuotes($propertyKey),
              $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }
            out += &#039; if ( &#039; + ($useData) + &#039; === undefined &#039;;
            if ($ownProperties) {
              out += &#039; || ! Object.prototype.hasOwnProperty.call(&#039; + ($data) + &#039;, \&#039;&#039; + (it.util.escapeQuotes($propertyKey)) + &#039;\&#039;) &#039;;
            }
            out += &#039;) {  var err =   &#039;; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += &#039; { keyword: \&#039;&#039; + (&#039;required&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: { missingProperty: \&#039;&#039; + ($missingProperty) + &#039;\&#039; } &#039;;
              if (it.opts.messages !== false) {
                out += &#039; , message: \&#039;&#039;;
                if (it.opts._errorDataPathProperty) {
                  out += &#039;is a required property&#039;;
                } else {
                  out += &#039;should have required property \\\&#039;&#039; + ($missingProperty) + &#039;\\\&#039;&#039;;
                }
                out += &#039;\&#039; &#039;;
              }
              if (it.opts.verbose) {
                out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
              }
              out += &#039; } &#039;;
            } else {
              out += &#039; {} &#039;;
            }
            out += &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } &#039;;
          }
        }
      }
    }
    it.errorPath = $currentErrorPath;
  } else if ($breakOnError) {
    out += &#039; if (true) {&#039;;
  }
  return out;
}

},{}],37:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
  var out = &#039; &#039;;
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
  var $valid = &#039;valid&#039; + $lvl;
  var $isData = it.opts.$data &amp;&amp; $schema &amp;&amp; $schema.$data,
    $schemaValue;
  if ($isData) {
    out += &#039; var schema&#039; + ($lvl) + &#039; = &#039; + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + &#039;; &#039;;
    $schemaValue = &#039;schema&#039; + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (($schema || $isData) &amp;&amp; it.opts.uniqueItems !== false) {
    if ($isData) {
      out += &#039; var &#039; + ($valid) + &#039;; if (&#039; + ($schemaValue) + &#039; === false || &#039; + ($schemaValue) + &#039; === undefined) &#039; + ($valid) + &#039; = true; else if (typeof &#039; + ($schemaValue) + &#039; != \&#039;boolean\&#039;) &#039; + ($valid) + &#039; = false; else { &#039;;
    }
    out += &#039; var i = &#039; + ($data) + &#039;.length , &#039; + ($valid) + &#039; = true , j; if (i &gt; 1) { &#039;;
    var $itemType = it.schema.items &amp;&amp; it.schema.items.type,
      $typeIsArray = Array.isArray($itemType);
    if (!$itemType || $itemType == &#039;object&#039; || $itemType == &#039;array&#039; || ($typeIsArray &amp;&amp; ($itemType.indexOf(&#039;object&#039;) &gt;= 0 || $itemType.indexOf(&#039;array&#039;) &gt;= 0))) {
      out += &#039; outer: for (;i--;) { for (j = i; j--;) { if (equal(&#039; + ($data) + &#039;[i], &#039; + ($data) + &#039;[j])) { &#039; + ($valid) + &#039; = false; break outer; } } } &#039;;
    } else {
      out += &#039; var itemIndices = {}, item; for (;i--;) { var item = &#039; + ($data) + &#039;[i]; &#039;;
      var $method = &#039;checkDataType&#039; + ($typeIsArray ? &#039;s&#039; : &#039;&#039;);
      out += &#039; if (&#039; + (it.util[$method]($itemType, &#039;item&#039;, it.opts.strictNumbers, true)) + &#039;) continue; &#039;;
      if ($typeIsArray) {
        out += &#039; if (typeof item == \&#039;string\&#039;) item = \&#039;&quot;\&#039; + item; &#039;;
      }
      out += &#039; if (typeof itemIndices[item] == \&#039;number\&#039;) { &#039; + ($valid) + &#039; = false; j = itemIndices[item]; break; } itemIndices[item] = i; } &#039;;
    }
    out += &#039; } &#039;;
    if ($isData) {
      out += &#039;  }  &#039;;
    }
    out += &#039; if (!&#039; + ($valid) + &#039;) {   &#039;;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = &#039;&#039;; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += &#039; { keyword: \&#039;&#039; + (&#039;uniqueItems&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: { i: i, j: j } &#039;;
      if (it.opts.messages !== false) {
        out += &#039; , message: \&#039;should NOT have duplicate items (items ## \&#039; + j + \&#039; and \&#039; + i + \&#039; are identical)\&#039; &#039;;
      }
      if (it.opts.verbose) {
        out += &#039; , schema:  &#039;;
        if ($isData) {
          out += &#039;validate.schema&#039; + ($schemaPath);
        } else {
          out += &#039;&#039; + ($schema);
        }
        out += &#039;         , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
      }
      out += &#039; } &#039;;
    } else {
      out += &#039; {} &#039;;
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule &amp;&amp; $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
      } else {
        out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
      }
    } else {
      out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
    }
    out += &#039; } &#039;;
    if ($breakOnError) {
      out += &#039; else { &#039;;
    }
  } else {
    if ($breakOnError) {
      out += &#039; if (true) { &#039;;
    }
  }
  return out;
}

},{}],38:[function(require,module,exports){
&#039;use strict&#039;;
module.exports = function generate_validate(it, $keyword, $ruleType) {
  var out = &#039;&#039;;
  var $async = it.schema.$async === true,
    $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, &#039;$ref&#039;),
    $id = it.self._getId(it.schema);
  if (it.opts.strictKeywords) {
    var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
    if ($unknownKwd) {
      var $keywordsMsg = &#039;unknown keyword: &#039; + $unknownKwd;
      if (it.opts.strictKeywords === &#039;log&#039;) it.logger.warn($keywordsMsg);
      else throw new Error($keywordsMsg);
    }
  }
  if (it.isTop) {
    out += &#039; var validate = &#039;;
    if ($async) {
      it.async = true;
      out += &#039;async &#039;;
    }
    out += &#039;function(data, dataPath, parentData, parentDataProperty, rootData) { \&#039;use strict\&#039;; &#039;;
    if ($id &amp;&amp; (it.opts.sourceCode || it.opts.processCode)) {
      out += &#039; &#039; + (&#039;/\*# sourceURL=&#039; + $id + &#039; */&#039;) + &#039; &#039;;
    }
  }
  if (typeof it.schema == &#039;boolean&#039; || !($refKeywords || it.schema.$ref)) {
    var $keyword = &#039;false schema&#039;;
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + &#039;/&#039; + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
    var $valid = &#039;valid&#039; + $lvl;
    if (it.schema === false) {
      if (it.isTop) {
        $breakOnError = true;
      } else {
        out += &#039; var &#039; + ($valid) + &#039; = false; &#039;;
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = &#039;&#039;; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;false schema&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: {} &#039;;
        if (it.opts.messages !== false) {
          out += &#039; , message: \&#039;boolean schema is false\&#039; &#039;;
        }
        if (it.opts.verbose) {
          out += &#039; , schema: false , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
        }
        out += &#039; } &#039;;
      } else {
        out += &#039; {} &#039;;
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule &amp;&amp; $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
        } else {
          out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
        }
      } else {
        out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
      }
    } else {
      if (it.isTop) {
        if ($async) {
          out += &#039; return data; &#039;;
        } else {
          out += &#039; validate.errors = null; return true; &#039;;
        }
      } else {
        out += &#039; var &#039; + ($valid) + &#039; = true; &#039;;
      }
    }
    if (it.isTop) {
      out += &#039; }; return validate; &#039;;
    }
    return out;
  }
  if (it.isTop) {
    var $top = it.isTop,
      $lvl = it.level = 0,
      $dataLvl = it.dataLevel = 0,
      $data = &#039;data&#039;;
    it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
    it.baseId = it.baseId || it.rootId;
    delete it.isTop;
    it.dataPathArr = [&quot;&quot;];
    if (it.schema.default !== undefined &amp;&amp; it.opts.useDefaults &amp;&amp; it.opts.strictDefaults) {
      var $defaultMsg = &#039;default is ignored in the schema root&#039;;
      if (it.opts.strictDefaults === &#039;log&#039;) it.logger.warn($defaultMsg);
      else throw new Error($defaultMsg);
    }
    out += &#039; var vErrors = null; &#039;;
    out += &#039; var errors = 0;     &#039;;
    out += &#039; if (rootData === undefined) rootData = data; &#039;;
  } else {
    var $lvl = it.level,
      $dataLvl = it.dataLevel,
      $data = &#039;data&#039; + ($dataLvl || &#039;&#039;);
    if ($id) it.baseId = it.resolve.url(it.baseId, $id);
    if ($async &amp;&amp; !it.async) throw new Error(&#039;async schema in sync schema&#039;);
    out += &#039; var errs_&#039; + ($lvl) + &#039; = errors;&#039;;
  }
  var $valid = &#039;valid&#039; + $lvl,
    $breakOnError = !it.opts.allErrors,
    $closingBraces1 = &#039;&#039;,
    $closingBraces2 = &#039;&#039;;
  var $errorKeyword;
  var $typeSchema = it.schema.type,
    $typeIsArray = Array.isArray($typeSchema);
  if ($typeSchema &amp;&amp; it.opts.nullable &amp;&amp; it.schema.nullable === true) {
    if ($typeIsArray) {
      if ($typeSchema.indexOf(&#039;null&#039;) == -1) $typeSchema = $typeSchema.concat(&#039;null&#039;);
    } else if ($typeSchema != &#039;null&#039;) {
      $typeSchema = [$typeSchema, &#039;null&#039;];
      $typeIsArray = true;
    }
  }
  if ($typeIsArray &amp;&amp; $typeSchema.length == 1) {
    $typeSchema = $typeSchema[0];
    $typeIsArray = false;
  }
  if (it.schema.$ref &amp;&amp; $refKeywords) {
    if (it.opts.extendRefs == &#039;fail&#039;) {
      throw new Error(&#039;$ref: validation keywords used in schema at path &quot;&#039; + it.errSchemaPath + &#039;&quot; (see option extendRefs)&#039;);
    } else if (it.opts.extendRefs !== true) {
      $refKeywords = false;
      it.logger.warn(&#039;$ref: keywords ignored in schema at path &quot;&#039; + it.errSchemaPath + &#039;&quot;&#039;);
    }
  }
  if (it.schema.$comment &amp;&amp; it.opts.$comment) {
    out += &#039; &#039; + (it.RULES.all.$comment.code(it, &#039;$comment&#039;));
  }
  if ($typeSchema) {
    if (it.opts.coerceTypes) {
      var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
    }
    var $rulesGroup = it.RULES.types[$typeSchema];
    if ($coerceToTypes || $typeIsArray || $rulesGroup === true || ($rulesGroup &amp;&amp; !$shouldUseGroup($rulesGroup))) {
      var $schemaPath = it.schemaPath + &#039;.type&#039;,
        $errSchemaPath = it.errSchemaPath + &#039;/type&#039;;
      var $schemaPath = it.schemaPath + &#039;.type&#039;,
        $errSchemaPath = it.errSchemaPath + &#039;/type&#039;,
        $method = $typeIsArray ? &#039;checkDataTypes&#039; : &#039;checkDataType&#039;;
      out += &#039; if (&#039; + (it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true)) + &#039;) { &#039;;
      if ($coerceToTypes) {
        var $dataType = &#039;dataType&#039; + $lvl,
          $coerced = &#039;coerced&#039; + $lvl;
        out += &#039; var &#039; + ($dataType) + &#039; = typeof &#039; + ($data) + &#039;; var &#039; + ($coerced) + &#039; = undefined; &#039;;
        if (it.opts.coerceTypes == &#039;array&#039;) {
          out += &#039; if (&#039; + ($dataType) + &#039; == \&#039;object\&#039; &amp;&amp; Array.isArray(&#039; + ($data) + &#039;) &amp;&amp; &#039; + ($data) + &#039;.length == 1) { &#039; + ($data) + &#039; = &#039; + ($data) + &#039;[0]; &#039; + ($dataType) + &#039; = typeof &#039; + ($data) + &#039;; if (&#039; + (it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers)) + &#039;) &#039; + ($coerced) + &#039; = &#039; + ($data) + &#039;; } &#039;;
        }
        out += &#039; if (&#039; + ($coerced) + &#039; !== undefined) ; &#039;;
        var arr1 = $coerceToTypes;
        if (arr1) {
          var $type, $i = -1,
            l1 = arr1.length - 1;
          while ($i &lt; l1) {
            $type = arr1[$i += 1];
            if ($type == &#039;string&#039;) {
              out += &#039; else if (&#039; + ($dataType) + &#039; == \&#039;number\&#039; || &#039; + ($dataType) + &#039; == \&#039;boolean\&#039;) &#039; + ($coerced) + &#039; = \&#039;\&#039; + &#039; + ($data) + &#039;; else if (&#039; + ($data) + &#039; === null) &#039; + ($coerced) + &#039; = \&#039;\&#039;; &#039;;
            } else if ($type == &#039;number&#039; || $type == &#039;integer&#039;) {
              out += &#039; else if (&#039; + ($dataType) + &#039; == \&#039;boolean\&#039; || &#039; + ($data) + &#039; === null || (&#039; + ($dataType) + &#039; == \&#039;string\&#039; &amp;&amp; &#039; + ($data) + &#039; &amp;&amp; &#039; + ($data) + &#039; == +&#039; + ($data) + &#039; &#039;;
              if ($type == &#039;integer&#039;) {
                out += &#039; &amp;&amp; !(&#039; + ($data) + &#039; % 1)&#039;;
              }
              out += &#039;)) &#039; + ($coerced) + &#039; = +&#039; + ($data) + &#039;; &#039;;
            } else if ($type == &#039;boolean&#039;) {
              out += &#039; else if (&#039; + ($data) + &#039; === \&#039;false\&#039; || &#039; + ($data) + &#039; === 0 || &#039; + ($data) + &#039; === null) &#039; + ($coerced) + &#039; = false; else if (&#039; + ($data) + &#039; === \&#039;true\&#039; || &#039; + ($data) + &#039; === 1) &#039; + ($coerced) + &#039; = true; &#039;;
            } else if ($type == &#039;null&#039;) {
              out += &#039; else if (&#039; + ($data) + &#039; === \&#039;\&#039; || &#039; + ($data) + &#039; === 0 || &#039; + ($data) + &#039; === false) &#039; + ($coerced) + &#039; = null; &#039;;
            } else if (it.opts.coerceTypes == &#039;array&#039; &amp;&amp; $type == &#039;array&#039;) {
              out += &#039; else if (&#039; + ($dataType) + &#039; == \&#039;string\&#039; || &#039; + ($dataType) + &#039; == \&#039;number\&#039; || &#039; + ($dataType) + &#039; == \&#039;boolean\&#039; || &#039; + ($data) + &#039; == null) &#039; + ($coerced) + &#039; = [&#039; + ($data) + &#039;]; &#039;;
            }
          }
        }
        out += &#039; else {   &#039;;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = &#039;&#039;; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;type&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: { type: \&#039;&#039;;
          if ($typeIsArray) {
            out += &#039;&#039; + ($typeSchema.join(&quot;,&quot;));
          } else {
            out += &#039;&#039; + ($typeSchema);
          }
          out += &#039;\&#039; } &#039;;
          if (it.opts.messages !== false) {
            out += &#039; , message: \&#039;should be &#039;;
            if ($typeIsArray) {
              out += &#039;&#039; + ($typeSchema.join(&quot;,&quot;));
            } else {
              out += &#039;&#039; + ($typeSchema);
            }
            out += &#039;\&#039; &#039;;
          }
          if (it.opts.verbose) {
            out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
          }
          out += &#039; } &#039;;
        } else {
          out += &#039; {} &#039;;
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule &amp;&amp; $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
          } else {
            out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
          }
        } else {
          out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
        }
        out += &#039; } if (&#039; + ($coerced) + &#039; !== undefined) {  &#039;;
        var $parentData = $dataLvl ? &#039;data&#039; + (($dataLvl - 1) || &#039;&#039;) : &#039;parentData&#039;,
          $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : &#039;parentDataProperty&#039;;
        out += &#039; &#039; + ($data) + &#039; = &#039; + ($coerced) + &#039;; &#039;;
        if (!$dataLvl) {
          out += &#039;if (&#039; + ($parentData) + &#039; !== undefined)&#039;;
        }
        out += &#039; &#039; + ($parentData) + &#039;[&#039; + ($parentDataProperty) + &#039;] = &#039; + ($coerced) + &#039;; } &#039;;
      } else {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = &#039;&#039;; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;type&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: { type: \&#039;&#039;;
          if ($typeIsArray) {
            out += &#039;&#039; + ($typeSchema.join(&quot;,&quot;));
          } else {
            out += &#039;&#039; + ($typeSchema);
          }
          out += &#039;\&#039; } &#039;;
          if (it.opts.messages !== false) {
            out += &#039; , message: \&#039;should be &#039;;
            if ($typeIsArray) {
              out += &#039;&#039; + ($typeSchema.join(&quot;,&quot;));
            } else {
              out += &#039;&#039; + ($typeSchema);
            }
            out += &#039;\&#039; &#039;;
          }
          if (it.opts.verbose) {
            out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
          }
          out += &#039; } &#039;;
        } else {
          out += &#039; {} &#039;;
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule &amp;&amp; $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
          } else {
            out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
          }
        } else {
          out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
        }
      }
      out += &#039; } &#039;;
    }
  }
  if (it.schema.$ref &amp;&amp; !$refKeywords) {
    out += &#039; &#039; + (it.RULES.all.$ref.code(it, &#039;$ref&#039;)) + &#039; &#039;;
    if ($breakOnError) {
      out += &#039; } if (errors === &#039;;
      if ($top) {
        out += &#039;0&#039;;
      } else {
        out += &#039;errs_&#039; + ($lvl);
      }
      out += &#039;) { &#039;;
      $closingBraces2 += &#039;}&#039;;
    }
  } else {
    var arr2 = it.RULES;
    if (arr2) {
      var $rulesGroup, i2 = -1,
        l2 = arr2.length - 1;
      while (i2 &lt; l2) {
        $rulesGroup = arr2[i2 += 1];
        if ($shouldUseGroup($rulesGroup)) {
          if ($rulesGroup.type) {
            out += &#039; if (&#039; + (it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers)) + &#039;) { &#039;;
          }
          if (it.opts.useDefaults) {
            if ($rulesGroup.type == &#039;object&#039; &amp;&amp; it.schema.properties) {
              var $schema = it.schema.properties,
                $schemaKeys = Object.keys($schema);
              var arr3 = $schemaKeys;
              if (arr3) {
                var $propertyKey, i3 = -1,
                  l3 = arr3.length - 1;
                while (i3 &lt; l3) {
                  $propertyKey = arr3[i3 += 1];
                  var $sch = $schema[$propertyKey];
                  if ($sch.default !== undefined) {
                    var $passData = $data + it.util.getProperty($propertyKey);
                    if (it.compositeRule) {
                      if (it.opts.strictDefaults) {
                        var $defaultMsg = &#039;default is ignored for: &#039; + $passData;
                        if (it.opts.strictDefaults === &#039;log&#039;) it.logger.warn($defaultMsg);
                        else throw new Error($defaultMsg);
                      }
                    } else {
                      out += &#039; if (&#039; + ($passData) + &#039; === undefined &#039;;
                      if (it.opts.useDefaults == &#039;empty&#039;) {
                        out += &#039; || &#039; + ($passData) + &#039; === null || &#039; + ($passData) + &#039; === \&#039;\&#039; &#039;;
                      }
                      out += &#039; ) &#039; + ($passData) + &#039; = &#039;;
                      if (it.opts.useDefaults == &#039;shared&#039;) {
                        out += &#039; &#039; + (it.useDefault($sch.default)) + &#039; &#039;;
                      } else {
                        out += &#039; &#039; + (JSON.stringify($sch.default)) + &#039; &#039;;
                      }
                      out += &#039;; &#039;;
                    }
                  }
                }
              }
            } else if ($rulesGroup.type == &#039;array&#039; &amp;&amp; Array.isArray(it.schema.items)) {
              var arr4 = it.schema.items;
              if (arr4) {
                var $sch, $i = -1,
                  l4 = arr4.length - 1;
                while ($i &lt; l4) {
                  $sch = arr4[$i += 1];
                  if ($sch.default !== undefined) {
                    var $passData = $data + &#039;[&#039; + $i + &#039;]&#039;;
                    if (it.compositeRule) {
                      if (it.opts.strictDefaults) {
                        var $defaultMsg = &#039;default is ignored for: &#039; + $passData;
                        if (it.opts.strictDefaults === &#039;log&#039;) it.logger.warn($defaultMsg);
                        else throw new Error($defaultMsg);
                      }
                    } else {
                      out += &#039; if (&#039; + ($passData) + &#039; === undefined &#039;;
                      if (it.opts.useDefaults == &#039;empty&#039;) {
                        out += &#039; || &#039; + ($passData) + &#039; === null || &#039; + ($passData) + &#039; === \&#039;\&#039; &#039;;
                      }
                      out += &#039; ) &#039; + ($passData) + &#039; = &#039;;
                      if (it.opts.useDefaults == &#039;shared&#039;) {
                        out += &#039; &#039; + (it.useDefault($sch.default)) + &#039; &#039;;
                      } else {
                        out += &#039; &#039; + (JSON.stringify($sch.default)) + &#039; &#039;;
                      }
                      out += &#039;; &#039;;
                    }
                  }
                }
              }
            }
          }
          var arr5 = $rulesGroup.rules;
          if (arr5) {
            var $rule, i5 = -1,
              l5 = arr5.length - 1;
            while (i5 &lt; l5) {
              $rule = arr5[i5 += 1];
              if ($shouldUseRule($rule)) {
                var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                if ($code) {
                  out += &#039; &#039; + ($code) + &#039; &#039;;
                  if ($breakOnError) {
                    $closingBraces1 += &#039;}&#039;;
                  }
                }
              }
            }
          }
          if ($breakOnError) {
            out += &#039; &#039; + ($closingBraces1) + &#039; &#039;;
            $closingBraces1 = &#039;&#039;;
          }
          if ($rulesGroup.type) {
            out += &#039; } &#039;;
            if ($typeSchema &amp;&amp; $typeSchema === $rulesGroup.type &amp;&amp; !$coerceToTypes) {
              out += &#039; else { &#039;;
              var $schemaPath = it.schemaPath + &#039;.type&#039;,
                $errSchemaPath = it.errSchemaPath + &#039;/type&#039;;
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = &#039;&#039;; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += &#039; { keyword: \&#039;&#039; + ($errorKeyword || &#039;type&#039;) + &#039;\&#039; , dataPath: (dataPath || \&#039;\&#039;) + &#039; + (it.errorPath) + &#039; , schemaPath: &#039; + (it.util.toQuotedString($errSchemaPath)) + &#039; , params: { type: \&#039;&#039;;
                if ($typeIsArray) {
                  out += &#039;&#039; + ($typeSchema.join(&quot;,&quot;));
                } else {
                  out += &#039;&#039; + ($typeSchema);
                }
                out += &#039;\&#039; } &#039;;
                if (it.opts.messages !== false) {
                  out += &#039; , message: \&#039;should be &#039;;
                  if ($typeIsArray) {
                    out += &#039;&#039; + ($typeSchema.join(&quot;,&quot;));
                  } else {
                    out += &#039;&#039; + ($typeSchema);
                  }
                  out += &#039;\&#039; &#039;;
                }
                if (it.opts.verbose) {
                  out += &#039; , schema: validate.schema&#039; + ($schemaPath) + &#039; , parentSchema: validate.schema&#039; + (it.schemaPath) + &#039; , data: &#039; + ($data) + &#039; &#039;;
                }
                out += &#039; } &#039;;
              } else {
                out += &#039; {} &#039;;
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule &amp;&amp; $breakOnError) {
                /* istanbul ignore if */
                if (it.async) {
                  out += &#039; throw new ValidationError([&#039; + (__err) + &#039;]); &#039;;
                } else {
                  out += &#039; validate.errors = [&#039; + (__err) + &#039;]; return false; &#039;;
                }
              } else {
                out += &#039; var err = &#039; + (__err) + &#039;;  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; &#039;;
              }
              out += &#039; } &#039;;
            }
          }
          if ($breakOnError) {
            out += &#039; if (errors === &#039;;
            if ($top) {
              out += &#039;0&#039;;
            } else {
              out += &#039;errs_&#039; + ($lvl);
            }
            out += &#039;) { &#039;;
            $closingBraces2 += &#039;}&#039;;
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += &#039; &#039; + ($closingBraces2) + &#039; &#039;;
  }
  if ($top) {
    if ($async) {
      out += &#039; if (errors === 0) return data;           &#039;;
      out += &#039; else throw new ValidationError(vErrors); &#039;;
    } else {
      out += &#039; validate.errors = vErrors; &#039;;
      out += &#039; return errors === 0;       &#039;;
    }
    out += &#039; }; return validate;&#039;;
  } else {
    out += &#039; var &#039; + ($valid) + &#039; = errors === errs_&#039; + ($lvl) + &#039;;&#039;;
  }

  function $shouldUseGroup($rulesGroup) {
    var rules = $rulesGroup.rules;
    for (var i = 0; i &lt; rules.length; i++)
      if ($shouldUseRule(rules[i])) return true;
  }

  function $shouldUseRule($rule) {
    return it.schema[$rule.keyword] !== undefined || ($rule.implements &amp;&amp; $ruleImplementsSomeKeyword($rule));
  }

  function $ruleImplementsSomeKeyword($rule) {
    var impl = $rule.implements;
    for (var i = 0; i &lt; impl.length; i++)
      if (it.schema[impl[i]] !== undefined) return true;
  }
  return out;
}

},{}],39:[function(require,module,exports){
&#039;use strict&#039;;

var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
var customRuleCode = require(&#039;./dotjs/custom&#039;);
var definitionSchema = require(&#039;./definition_schema&#039;);

module.exports = {
  add: addKeyword,
  get: getKeyword,
  remove: removeKeyword,
  validate: validateKeyword
};


/**
 * Define custom keyword
 * @this  Ajv
 * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).
 * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.
 * @return {Ajv} this for method chaining
 */
function addKeyword(keyword, definition) {
  /* jshint validthis: true */
  /* eslint no-shadow: 0 */
  var RULES = this.RULES;
  if (RULES.keywords[keyword])
    throw new Error(&#039;Keyword &#039; + keyword + &#039; is already defined&#039;);

  if (!IDENTIFIER.test(keyword))
    throw new Error(&#039;Keyword &#039; + keyword + &#039; is not a valid identifier&#039;);

  if (definition) {
    this.validateKeyword(definition, true);

    var dataType = definition.type;
    if (Array.isArray(dataType)) {
      for (var i=0; i&lt;dataType.length; i++)
        _addRule(keyword, dataType[i], definition);
    } else {
      _addRule(keyword, dataType, definition);
    }

    var metaSchema = definition.metaSchema;
    if (metaSchema) {
      if (definition.$data &amp;&amp; this._opts.$data) {
        metaSchema = {
          anyOf: [
            metaSchema,
            { &#039;$ref&#039;: &#039;https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#&#039; }
          ]
        };
      }
      definition.validateSchema = this.compile(metaSchema, true);
    }
  }

  RULES.keywords[keyword] = RULES.all[keyword] = true;


  function _addRule(keyword, dataType, definition) {
    var ruleGroup;
    for (var i=0; i&lt;RULES.length; i++) {
      var rg = RULES[i];
      if (rg.type == dataType) {
        ruleGroup = rg;
        break;
      }
    }

    if (!ruleGroup) {
      ruleGroup = { type: dataType, rules: [] };
      RULES.push(ruleGroup);
    }

    var rule = {
      keyword: keyword,
      definition: definition,
      custom: true,
      code: customRuleCode,
      implements: definition.implements
    };
    ruleGroup.rules.push(rule);
    RULES.custom[keyword] = rule;
  }

  return this;
}


/**
 * Get keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.
 */
function getKeyword(keyword) {
  /* jshint validthis: true */
  var rule = this.RULES.custom[keyword];
  return rule ? rule.definition : this.RULES.keywords[keyword] || false;
}


/**
 * Remove keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Ajv} this for method chaining
 */
function removeKeyword(keyword) {
  /* jshint validthis: true */
  var RULES = this.RULES;
  delete RULES.keywords[keyword];
  delete RULES.all[keyword];
  delete RULES.custom[keyword];
  for (var i=0; i&lt;RULES.length; i++) {
    var rules = RULES[i].rules;
    for (var j=0; j&lt;rules.length; j++) {
      if (rules[j].keyword == keyword) {
        rules.splice(j, 1);
        break;
      }
    }
  }
  return this;
}


/**
 * Validate keyword definition
 * @this  Ajv
 * @param {Object} definition keyword definition object.
 * @param {Boolean} throwError true to throw exception if definition is invalid
 * @return {boolean} validation result
 */
function validateKeyword(definition, throwError) {
  validateKeyword.errors = null;
  var v = this._validateKeyword = this._validateKeyword
                                  || this.compile(definitionSchema, true);

  if (v(definition)) return true;
  validateKeyword.errors = v.errors;
  if (throwError)
    throw new Error(&#039;custom keyword definition is invalid: &#039;  + this.errorsText(v.errors));
  else
    return false;
}

},{&quot;./definition_schema&quot;:12,&quot;./dotjs/custom&quot;:22}],40:[function(require,module,exports){
module.exports={
    &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
    &quot;$id&quot;: &quot;https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#&quot;,
    &quot;description&quot;: &quot;Meta-schema for $data reference (JSON Schema extension proposal)&quot;,
    &quot;type&quot;: &quot;object&quot;,
    &quot;required&quot;: [ &quot;$data&quot; ],
    &quot;properties&quot;: {
        &quot;$data&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;anyOf&quot;: [
                { &quot;format&quot;: &quot;relative-json-pointer&quot; }, 
                { &quot;format&quot;: &quot;json-pointer&quot; }
            ]
        }
    },
    &quot;additionalProperties&quot;: false
}

},{}],41:[function(require,module,exports){
module.exports={
    &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
    &quot;$id&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
    &quot;title&quot;: &quot;Core schema meta-schema&quot;,
    &quot;definitions&quot;: {
        &quot;schemaArray&quot;: {
            &quot;type&quot;: &quot;array&quot;,
            &quot;minItems&quot;: 1,
            &quot;items&quot;: { &quot;$ref&quot;: &quot;#&quot; }
        },
        &quot;nonNegativeInteger&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;minimum&quot;: 0
        },
        &quot;nonNegativeIntegerDefault0&quot;: {
            &quot;allOf&quot;: [
                { &quot;$ref&quot;: &quot;#/definitions/nonNegativeInteger&quot; },
                { &quot;default&quot;: 0 }
            ]
        },
        &quot;simpleTypes&quot;: {
            &quot;enum&quot;: [
                &quot;array&quot;,
                &quot;boolean&quot;,
                &quot;integer&quot;,
                &quot;null&quot;,
                &quot;number&quot;,
                &quot;object&quot;,
                &quot;string&quot;
            ]
        },
        &quot;stringArray&quot;: {
            &quot;type&quot;: &quot;array&quot;,
            &quot;items&quot;: { &quot;type&quot;: &quot;string&quot; },
            &quot;uniqueItems&quot;: true,
            &quot;default&quot;: []
        }
    },
    &quot;type&quot;: [&quot;object&quot;, &quot;boolean&quot;],
    &quot;properties&quot;: {
        &quot;$id&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;format&quot;: &quot;uri-reference&quot;
        },
        &quot;$schema&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;format&quot;: &quot;uri&quot;
        },
        &quot;$ref&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;format&quot;: &quot;uri-reference&quot;
        },
        &quot;$comment&quot;: {
            &quot;type&quot;: &quot;string&quot;
        },
        &quot;title&quot;: {
            &quot;type&quot;: &quot;string&quot;
        },
        &quot;description&quot;: {
            &quot;type&quot;: &quot;string&quot;
        },
        &quot;default&quot;: true,
        &quot;readOnly&quot;: {
            &quot;type&quot;: &quot;boolean&quot;,
            &quot;default&quot;: false
        },
        &quot;examples&quot;: {
            &quot;type&quot;: &quot;array&quot;,
            &quot;items&quot;: true
        },
        &quot;multipleOf&quot;: {
            &quot;type&quot;: &quot;number&quot;,
            &quot;exclusiveMinimum&quot;: 0
        },
        &quot;maximum&quot;: {
            &quot;type&quot;: &quot;number&quot;
        },
        &quot;exclusiveMaximum&quot;: {
            &quot;type&quot;: &quot;number&quot;
        },
        &quot;minimum&quot;: {
            &quot;type&quot;: &quot;number&quot;
        },
        &quot;exclusiveMinimum&quot;: {
            &quot;type&quot;: &quot;number&quot;
        },
        &quot;maxLength&quot;: { &quot;$ref&quot;: &quot;#/definitions/nonNegativeInteger&quot; },
        &quot;minLength&quot;: { &quot;$ref&quot;: &quot;#/definitions/nonNegativeIntegerDefault0&quot; },
        &quot;pattern&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;format&quot;: &quot;regex&quot;
        },
        &quot;additionalItems&quot;: { &quot;$ref&quot;: &quot;#&quot; },
        &quot;items&quot;: {
            &quot;anyOf&quot;: [
                { &quot;$ref&quot;: &quot;#&quot; },
                { &quot;$ref&quot;: &quot;#/definitions/schemaArray&quot; }
            ],
            &quot;default&quot;: true
        },
        &quot;maxItems&quot;: { &quot;$ref&quot;: &quot;#/definitions/nonNegativeInteger&quot; },
        &quot;minItems&quot;: { &quot;$ref&quot;: &quot;#/definitions/nonNegativeIntegerDefault0&quot; },
        &quot;uniqueItems&quot;: {
            &quot;type&quot;: &quot;boolean&quot;,
            &quot;default&quot;: false
        },
        &quot;contains&quot;: { &quot;$ref&quot;: &quot;#&quot; },
        &quot;maxProperties&quot;: { &quot;$ref&quot;: &quot;#/definitions/nonNegativeInteger&quot; },
        &quot;minProperties&quot;: { &quot;$ref&quot;: &quot;#/definitions/nonNegativeIntegerDefault0&quot; },
        &quot;required&quot;: { &quot;$ref&quot;: &quot;#/definitions/stringArray&quot; },
        &quot;additionalProperties&quot;: { &quot;$ref&quot;: &quot;#&quot; },
        &quot;definitions&quot;: {
            &quot;type&quot;: &quot;object&quot;,
            &quot;additionalProperties&quot;: { &quot;$ref&quot;: &quot;#&quot; },
            &quot;default&quot;: {}
        },
        &quot;properties&quot;: {
            &quot;type&quot;: &quot;object&quot;,
            &quot;additionalProperties&quot;: { &quot;$ref&quot;: &quot;#&quot; },
            &quot;default&quot;: {}
        },
        &quot;patternProperties&quot;: {
            &quot;type&quot;: &quot;object&quot;,
            &quot;additionalProperties&quot;: { &quot;$ref&quot;: &quot;#&quot; },
            &quot;propertyNames&quot;: { &quot;format&quot;: &quot;regex&quot; },
            &quot;default&quot;: {}
        },
        &quot;dependencies&quot;: {
            &quot;type&quot;: &quot;object&quot;,
            &quot;additionalProperties&quot;: {
                &quot;anyOf&quot;: [
                    { &quot;$ref&quot;: &quot;#&quot; },
                    { &quot;$ref&quot;: &quot;#/definitions/stringArray&quot; }
                ]
            }
        },
        &quot;propertyNames&quot;: { &quot;$ref&quot;: &quot;#&quot; },
        &quot;const&quot;: true,
        &quot;enum&quot;: {
            &quot;type&quot;: &quot;array&quot;,
            &quot;items&quot;: true,
            &quot;minItems&quot;: 1,
            &quot;uniqueItems&quot;: true
        },
        &quot;type&quot;: {
            &quot;anyOf&quot;: [
                { &quot;$ref&quot;: &quot;#/definitions/simpleTypes&quot; },
                {
                    &quot;type&quot;: &quot;array&quot;,
                    &quot;items&quot;: { &quot;$ref&quot;: &quot;#/definitions/simpleTypes&quot; },
                    &quot;minItems&quot;: 1,
                    &quot;uniqueItems&quot;: true
                }
            ]
        },
        &quot;format&quot;: { &quot;type&quot;: &quot;string&quot; },
        &quot;contentMediaType&quot;: { &quot;type&quot;: &quot;string&quot; },
        &quot;contentEncoding&quot;: { &quot;type&quot;: &quot;string&quot; },
        &quot;if&quot;: {&quot;$ref&quot;: &quot;#&quot;},
        &quot;then&quot;: {&quot;$ref&quot;: &quot;#&quot;},
        &quot;else&quot;: {&quot;$ref&quot;: &quot;#&quot;},
        &quot;allOf&quot;: { &quot;$ref&quot;: &quot;#/definitions/schemaArray&quot; },
        &quot;anyOf&quot;: { &quot;$ref&quot;: &quot;#/definitions/schemaArray&quot; },
        &quot;oneOf&quot;: { &quot;$ref&quot;: &quot;#/definitions/schemaArray&quot; },
        &quot;not&quot;: { &quot;$ref&quot;: &quot;#&quot; }
    },
    &quot;default&quot;: true
}

},{}],42:[function(require,module,exports){
&#039;use strict&#039;;

// do not edit .js files directly - edit src/index.jst



module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a &amp;&amp; b &amp;&amp; typeof a == &#039;object&#039; &amp;&amp; typeof b == &#039;object&#039;) {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source &amp;&amp; a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a &amp;&amp; b!==b;
};

},{}],43:[function(require,module,exports){
&#039;use strict&#039;;

module.exports = function (data, opts) {
    if (!opts) opts = {};
    if (typeof opts === &#039;function&#039;) opts = { cmp: opts };
    var cycles = (typeof opts.cycles === &#039;boolean&#039;) ? opts.cycles : false;

    var cmp = opts.cmp &amp;&amp; (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (node) {
        if (node &amp;&amp; node.toJSON &amp;&amp; typeof node.toJSON === &#039;function&#039;) {
            node = node.toJSON();
        }

        if (node === undefined) return;
        if (typeof node == &#039;number&#039;) return isFinite(node) ? &#039;&#039; + node : &#039;null&#039;;
        if (typeof node !== &#039;object&#039;) return JSON.stringify(node);

        var i, out;
        if (Array.isArray(node)) {
            out = &#039;[&#039;;
            for (i = 0; i &lt; node.length; i++) {
                if (i) out += &#039;,&#039;;
                out += stringify(node[i]) || &#039;null&#039;;
            }
            return out + &#039;]&#039;;
        }

        if (node === null) return &#039;null&#039;;

        if (seen.indexOf(node) !== -1) {
            if (cycles) return JSON.stringify(&#039;__cycle__&#039;);
            throw new TypeError(&#039;Converting circular structure to JSON&#039;);
        }

        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp &amp;&amp; cmp(node));
        out = &#039;&#039;;
        for (i = 0; i &lt; keys.length; i++) {
            var key = keys[i];
            var value = stringify(node[key]);

            if (!value) continue;
            if (out) out += &#039;,&#039;;
            out += JSON.stringify(key) + &#039;:&#039; + value;
        }
        seen.splice(seenIndex, 1);
        return &#039;{&#039; + out + &#039;}&#039;;
    })(data);
};

},{}],44:[function(require,module,exports){
&#039;use strict&#039;;

var traverse = module.exports = function (schema, opts, cb) {
  // Legacy support for v0.3.1 and earlier.
  if (typeof opts == &#039;function&#039;) {
    cb = opts;
    opts = {};
  }

  cb = opts.cb || cb;
  var pre = (typeof cb == &#039;function&#039;) ? cb : cb.pre || function() {};
  var post = cb.post || function() {};

  _traverse(opts, pre, post, schema, &#039;&#039;, schema);
};


traverse.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true
};

traverse.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};

traverse.propsKeywords = {
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};

traverse.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};


function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema &amp;&amp; typeof schema == &#039;object&#039; &amp;&amp; !Array.isArray(schema)) {
    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema) {
      var sch = schema[key];
      if (Array.isArray(sch)) {
        if (key in traverse.arrayKeywords) {
          for (var i=0; i&lt;sch.length; i++)
            _traverse(opts, pre, post, sch[i], jsonPtr + &#039;/&#039; + key + &#039;/&#039; + i, rootSchema, jsonPtr, key, schema, i);
        }
      } else if (key in traverse.propsKeywords) {
        if (sch &amp;&amp; typeof sch == &#039;object&#039;) {
          for (var prop in sch)
            _traverse(opts, pre, post, sch[prop], jsonPtr + &#039;/&#039; + key + &#039;/&#039; + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
        }
      } else if (key in traverse.keywords || (opts.allKeys &amp;&amp; !(key in traverse.skipKeywords))) {
        _traverse(opts, pre, post, sch, jsonPtr + &#039;/&#039; + key, rootSchema, jsonPtr, key, schema);
      }
    }
    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}


function escapeJsonPtr(str) {
  return str.replace(/~/g, &#039;~0&#039;).replace(/\//g, &#039;~1&#039;);
}

},{}],45:[function(require,module,exports){
/** @license URI.js v4.4.0 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function (global, factory) {
	typeof exports === &#039;object&#039; &amp;&amp; typeof module !== &#039;undefined&#039; ? factory(exports) :
	typeof define === &#039;function&#039; &amp;&amp; define.amd ? define([&#039;exports&#039;], factory) :
	(factory((global.URI = global.URI || {})));
}(this, (function (exports) { &#039;use strict&#039;;

function merge() {
    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key &lt; _len; _key++) {
        sets[_key] = arguments[_key];
    }

    if (sets.length &gt; 1) {
        sets[0] = sets[0].slice(0, -1);
        var xl = sets.length - 1;
        for (var x = 1; x &lt; xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
        }
        sets[xl] = sets[xl].slice(1);
        return sets.join(&#039;&#039;);
    } else {
        return sets[0];
    }
}
function subexp(str) {
    return &quot;(?:&quot; + str + &quot;)&quot;;
}
function typeOf(o) {
    return o === undefined ? &quot;undefined&quot; : o === null ? &quot;null&quot; : Object.prototype.toString.call(o).split(&quot; &quot;).pop().split(&quot;]&quot;).shift().toLowerCase();
}
function toUpperCase(str) {
    return str.toUpperCase();
}
function toArray(obj) {
    return obj !== undefined &amp;&amp; obj !== null ? obj instanceof Array ? obj : typeof obj.length !== &quot;number&quot; || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
}
function assign(target, source) {
    var obj = target;
    if (source) {
        for (var key in source) {
            obj[key] = source[key];
        }
    }
    return obj;
}

function buildExps(isIRI) {
    var ALPHA$$ = &quot;[A-Za-z]&quot;,
        CR$ = &quot;[\\x0D]&quot;,
        DIGIT$$ = &quot;[0-9]&quot;,
        DQUOTE$$ = &quot;[\\x22]&quot;,
        HEXDIG$$ = merge(DIGIT$$, &quot;[A-Fa-f]&quot;),
        //case-insensitive
    LF$$ = &quot;[\\x0A]&quot;,
        SP$$ = &quot;[\\x20]&quot;,
        PCT_ENCODED$ = subexp(subexp(&quot;%[EFef]&quot; + HEXDIG$$ + &quot;%&quot; + HEXDIG$$ + HEXDIG$$ + &quot;%&quot; + HEXDIG$$ + HEXDIG$$) + &quot;|&quot; + subexp(&quot;%[89A-Fa-f]&quot; + HEXDIG$$ + &quot;%&quot; + HEXDIG$$ + HEXDIG$$) + &quot;|&quot; + subexp(&quot;%&quot; + HEXDIG$$ + HEXDIG$$)),
        //expanded
    GEN_DELIMS$$ = &quot;[\\:\\/\\?\\#\\[\\]\\@]&quot;,
        SUB_DELIMS$$ = &quot;[\\!\\$\\&amp;\\&#039;\\(\\)\\*\\+\\,\\;\\=]&quot;,
        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
        UCSCHAR$$ = isIRI ? &quot;[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]&quot; : &quot;[]&quot;,
        //subset, excludes bidi control characters
    IPRIVATE$$ = isIRI ? &quot;[\\uE000-\\uF8FF]&quot; : &quot;[]&quot;,
        //subset
    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, &quot;[\\-\\.\\_\\~]&quot;, UCSCHAR$$),
        SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, &quot;[\\+\\-\\.]&quot;) + &quot;*&quot;),
        USERINFO$ = subexp(subexp(PCT_ENCODED$ + &quot;|&quot; + merge(UNRESERVED$$, SUB_DELIMS$$, &quot;[\\:]&quot;)) + &quot;*&quot;),
        DEC_OCTET$ = subexp(subexp(&quot;25[0-5]&quot;) + &quot;|&quot; + subexp(&quot;2[0-4]&quot; + DIGIT$$) + &quot;|&quot; + subexp(&quot;1&quot; + DIGIT$$ + DIGIT$$) + &quot;|&quot; + subexp(&quot;[1-9]&quot; + DIGIT$$) + &quot;|&quot; + DIGIT$$),
        DEC_OCTET_RELAXED$ = subexp(subexp(&quot;25[0-5]&quot;) + &quot;|&quot; + subexp(&quot;2[0-4]&quot; + DIGIT$$) + &quot;|&quot; + subexp(&quot;1&quot; + DIGIT$$ + DIGIT$$) + &quot;|&quot; + subexp(&quot;0?[1-9]&quot; + DIGIT$$) + &quot;|0?0?&quot; + DIGIT$$),
        //relaxed parsing rules
    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + &quot;\\.&quot; + DEC_OCTET_RELAXED$ + &quot;\\.&quot; + DEC_OCTET_RELAXED$ + &quot;\\.&quot; + DEC_OCTET_RELAXED$),
        H16$ = subexp(HEXDIG$$ + &quot;{1,4}&quot;),
        LS32$ = subexp(subexp(H16$ + &quot;\\:&quot; + H16$) + &quot;|&quot; + IPV4ADDRESS$),
        IPV6ADDRESS1$ = subexp(subexp(H16$ + &quot;\\:&quot;) + &quot;{6}&quot; + LS32$),
        //                           6( h16 &quot;:&quot; ) ls32
    IPV6ADDRESS2$ = subexp(&quot;\\:\\:&quot; + subexp(H16$ + &quot;\\:&quot;) + &quot;{5}&quot; + LS32$),
        //                      &quot;::&quot; 5( h16 &quot;:&quot; ) ls32
    IPV6ADDRESS3$ = subexp(subexp(H16$) + &quot;?\\:\\:&quot; + subexp(H16$ + &quot;\\:&quot;) + &quot;{4}&quot; + LS32$),
        //[               h16 ] &quot;::&quot; 4( h16 &quot;:&quot; ) ls32
    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + &quot;\\:&quot;) + &quot;{0,1}&quot; + H16$) + &quot;?\\:\\:&quot; + subexp(H16$ + &quot;\\:&quot;) + &quot;{3}&quot; + LS32$),
        //[ *1( h16 &quot;:&quot; ) h16 ] &quot;::&quot; 3( h16 &quot;:&quot; ) ls32
    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + &quot;\\:&quot;) + &quot;{0,2}&quot; + H16$) + &quot;?\\:\\:&quot; + subexp(H16$ + &quot;\\:&quot;) + &quot;{2}&quot; + LS32$),
        //[ *2( h16 &quot;:&quot; ) h16 ] &quot;::&quot; 2( h16 &quot;:&quot; ) ls32
    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + &quot;\\:&quot;) + &quot;{0,3}&quot; + H16$) + &quot;?\\:\\:&quot; + H16$ + &quot;\\:&quot; + LS32$),
        //[ *3( h16 &quot;:&quot; ) h16 ] &quot;::&quot;    h16 &quot;:&quot;   ls32
    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + &quot;\\:&quot;) + &quot;{0,4}&quot; + H16$) + &quot;?\\:\\:&quot; + LS32$),
        //[ *4( h16 &quot;:&quot; ) h16 ] &quot;::&quot;              ls32
    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + &quot;\\:&quot;) + &quot;{0,5}&quot; + H16$) + &quot;?\\:\\:&quot; + H16$),
        //[ *5( h16 &quot;:&quot; ) h16 ] &quot;::&quot;              h16
    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + &quot;\\:&quot;) + &quot;{0,6}&quot; + H16$) + &quot;?\\:\\:&quot;),
        //[ *6( h16 &quot;:&quot; ) h16 ] &quot;::&quot;
    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(&quot;|&quot;)),
        ZONEID$ = subexp(subexp(UNRESERVED$$ + &quot;|&quot; + PCT_ENCODED$) + &quot;+&quot;),
        //RFC 6874
    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + &quot;\\%25&quot; + ZONEID$),
        //RFC 6874
    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(&quot;\\%25|\\%(?!&quot; + HEXDIG$$ + &quot;{2})&quot;) + ZONEID$),
        //RFC 6874, with relaxed parsing rules
    IPVFUTURE$ = subexp(&quot;[vV]&quot; + HEXDIG$$ + &quot;+\\.&quot; + merge(UNRESERVED$$, SUB_DELIMS$$, &quot;[\\:]&quot;) + &quot;+&quot;),
        IP_LITERAL$ = subexp(&quot;\\[&quot; + subexp(IPV6ADDRZ_RELAXED$ + &quot;|&quot; + IPV6ADDRESS$ + &quot;|&quot; + IPVFUTURE$) + &quot;\\]&quot;),
        //RFC 6874
    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + &quot;|&quot; + merge(UNRESERVED$$, SUB_DELIMS$$)) + &quot;*&quot;),
        HOST$ = subexp(IP_LITERAL$ + &quot;|&quot; + IPV4ADDRESS$ + &quot;(?!&quot; + REG_NAME$ + &quot;)&quot; + &quot;|&quot; + REG_NAME$),
        PORT$ = subexp(DIGIT$$ + &quot;*&quot;),
        AUTHORITY$ = subexp(subexp(USERINFO$ + &quot;@&quot;) + &quot;?&quot; + HOST$ + subexp(&quot;\\:&quot; + PORT$) + &quot;?&quot;),
        PCHAR$ = subexp(PCT_ENCODED$ + &quot;|&quot; + merge(UNRESERVED$$, SUB_DELIMS$$, &quot;[\\:\\@]&quot;)),
        SEGMENT$ = subexp(PCHAR$ + &quot;*&quot;),
        SEGMENT_NZ$ = subexp(PCHAR$ + &quot;+&quot;),
        SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + &quot;|&quot; + merge(UNRESERVED$$, SUB_DELIMS$$, &quot;[\\@]&quot;)) + &quot;+&quot;),
        PATH_ABEMPTY$ = subexp(subexp(&quot;\\/&quot; + SEGMENT$) + &quot;*&quot;),
        PATH_ABSOLUTE$ = subexp(&quot;\\/&quot; + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + &quot;?&quot;),
        //simplified
    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),
        //simplified
    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),
        //simplified
    PATH_EMPTY$ = &quot;(?!&quot; + PCHAR$ + &quot;)&quot;,
        PATH$ = subexp(PATH_ABEMPTY$ + &quot;|&quot; + PATH_ABSOLUTE$ + &quot;|&quot; + PATH_NOSCHEME$ + &quot;|&quot; + PATH_ROOTLESS$ + &quot;|&quot; + PATH_EMPTY$),
        QUERY$ = subexp(subexp(PCHAR$ + &quot;|&quot; + merge(&quot;[\\/\\?]&quot;, IPRIVATE$$)) + &quot;*&quot;),
        FRAGMENT$ = subexp(subexp(PCHAR$ + &quot;|[\\/\\?]&quot;) + &quot;*&quot;),
        HIER_PART$ = subexp(subexp(&quot;\\/\\/&quot; + AUTHORITY$ + PATH_ABEMPTY$) + &quot;|&quot; + PATH_ABSOLUTE$ + &quot;|&quot; + PATH_ROOTLESS$ + &quot;|&quot; + PATH_EMPTY$),
        URI$ = subexp(SCHEME$ + &quot;\\:&quot; + HIER_PART$ + subexp(&quot;\\?&quot; + QUERY$) + &quot;?&quot; + subexp(&quot;\\#&quot; + FRAGMENT$) + &quot;?&quot;),
        RELATIVE_PART$ = subexp(subexp(&quot;\\/\\/&quot; + AUTHORITY$ + PATH_ABEMPTY$) + &quot;|&quot; + PATH_ABSOLUTE$ + &quot;|&quot; + PATH_NOSCHEME$ + &quot;|&quot; + PATH_EMPTY$),
        RELATIVE$ = subexp(RELATIVE_PART$ + subexp(&quot;\\?&quot; + QUERY$) + &quot;?&quot; + subexp(&quot;\\#&quot; + FRAGMENT$) + &quot;?&quot;),
        URI_REFERENCE$ = subexp(URI$ + &quot;|&quot; + RELATIVE$),
        ABSOLUTE_URI$ = subexp(SCHEME$ + &quot;\\:&quot; + HIER_PART$ + subexp(&quot;\\?&quot; + QUERY$) + &quot;?&quot;),
        GENERIC_REF$ = &quot;^(&quot; + SCHEME$ + &quot;)\\:&quot; + subexp(subexp(&quot;\\/\\/(&quot; + subexp(&quot;(&quot; + USERINFO$ + &quot;)@&quot;) + &quot;?(&quot; + HOST$ + &quot;)&quot; + subexp(&quot;\\:(&quot; + PORT$ + &quot;)&quot;) + &quot;?)&quot;) + &quot;?(&quot; + PATH_ABEMPTY$ + &quot;|&quot; + PATH_ABSOLUTE$ + &quot;|&quot; + PATH_ROOTLESS$ + &quot;|&quot; + PATH_EMPTY$ + &quot;)&quot;) + subexp(&quot;\\?(&quot; + QUERY$ + &quot;)&quot;) + &quot;?&quot; + subexp(&quot;\\#(&quot; + FRAGMENT$ + &quot;)&quot;) + &quot;?$&quot;,
        RELATIVE_REF$ = &quot;^(){0}&quot; + subexp(subexp(&quot;\\/\\/(&quot; + subexp(&quot;(&quot; + USERINFO$ + &quot;)@&quot;) + &quot;?(&quot; + HOST$ + &quot;)&quot; + subexp(&quot;\\:(&quot; + PORT$ + &quot;)&quot;) + &quot;?)&quot;) + &quot;?(&quot; + PATH_ABEMPTY$ + &quot;|&quot; + PATH_ABSOLUTE$ + &quot;|&quot; + PATH_NOSCHEME$ + &quot;|&quot; + PATH_EMPTY$ + &quot;)&quot;) + subexp(&quot;\\?(&quot; + QUERY$ + &quot;)&quot;) + &quot;?&quot; + subexp(&quot;\\#(&quot; + FRAGMENT$ + &quot;)&quot;) + &quot;?$&quot;,
        ABSOLUTE_REF$ = &quot;^(&quot; + SCHEME$ + &quot;)\\:&quot; + subexp(subexp(&quot;\\/\\/(&quot; + subexp(&quot;(&quot; + USERINFO$ + &quot;)@&quot;) + &quot;?(&quot; + HOST$ + &quot;)&quot; + subexp(&quot;\\:(&quot; + PORT$ + &quot;)&quot;) + &quot;?)&quot;) + &quot;?(&quot; + PATH_ABEMPTY$ + &quot;|&quot; + PATH_ABSOLUTE$ + &quot;|&quot; + PATH_ROOTLESS$ + &quot;|&quot; + PATH_EMPTY$ + &quot;)&quot;) + subexp(&quot;\\?(&quot; + QUERY$ + &quot;)&quot;) + &quot;?$&quot;,
        SAMEDOC_REF$ = &quot;^&quot; + subexp(&quot;\\#(&quot; + FRAGMENT$ + &quot;)&quot;) + &quot;?$&quot;,
        AUTHORITY_REF$ = &quot;^&quot; + subexp(&quot;(&quot; + USERINFO$ + &quot;)@&quot;) + &quot;?(&quot; + HOST$ + &quot;)&quot; + subexp(&quot;\\:(&quot; + PORT$ + &quot;)&quot;) + &quot;?$&quot;;
    return {
        NOT_SCHEME: new RegExp(merge(&quot;[^]&quot;, ALPHA$$, DIGIT$$, &quot;[\\+\\-\\.]&quot;), &quot;g&quot;),
        NOT_USERINFO: new RegExp(merge(&quot;[^\\%\\:]&quot;, UNRESERVED$$, SUB_DELIMS$$), &quot;g&quot;),
        NOT_HOST: new RegExp(merge(&quot;[^\\%\\[\\]\\:]&quot;, UNRESERVED$$, SUB_DELIMS$$), &quot;g&quot;),
        NOT_PATH: new RegExp(merge(&quot;[^\\%\\/\\:\\@]&quot;, UNRESERVED$$, SUB_DELIMS$$), &quot;g&quot;),
        NOT_PATH_NOSCHEME: new RegExp(merge(&quot;[^\\%\\/\\@]&quot;, UNRESERVED$$, SUB_DELIMS$$), &quot;g&quot;),
        NOT_QUERY: new RegExp(merge(&quot;[^\\%]&quot;, UNRESERVED$$, SUB_DELIMS$$, &quot;[\\:\\@\\/\\?]&quot;, IPRIVATE$$), &quot;g&quot;),
        NOT_FRAGMENT: new RegExp(merge(&quot;[^\\%]&quot;, UNRESERVED$$, SUB_DELIMS$$, &quot;[\\:\\@\\/\\?]&quot;), &quot;g&quot;),
        ESCAPE: new RegExp(merge(&quot;[^]&quot;, UNRESERVED$$, SUB_DELIMS$$), &quot;g&quot;),
        UNRESERVED: new RegExp(UNRESERVED$$, &quot;g&quot;),
        OTHER_CHARS: new RegExp(merge(&quot;[^\\%]&quot;, UNRESERVED$$, RESERVED$$), &quot;g&quot;),
        PCT_ENCODED: new RegExp(PCT_ENCODED$, &quot;g&quot;),
        IPV4ADDRESS: new RegExp(&quot;^(&quot; + IPV4ADDRESS$ + &quot;)$&quot;),
        IPV6ADDRESS: new RegExp(&quot;^\\[?(&quot; + IPV6ADDRESS$ + &quot;)&quot; + subexp(subexp(&quot;\\%25|\\%(?!&quot; + HEXDIG$$ + &quot;{2})&quot;) + &quot;(&quot; + ZONEID$ + &quot;)&quot;) + &quot;?\\]?$&quot;) //RFC 6874, with relaxed parsing rules
    };
}
var URI_PROTOCOL = buildExps(false);

var IRI_PROTOCOL = buildExps(true);

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i &amp;&amp; _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n &amp;&amp; _i[&quot;return&quot;]) _i[&quot;return&quot;]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError(&quot;Invalid attempt to destructure non-iterable instance&quot;);
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i &lt; arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/** Highest positive signed 32-bit float value */

var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

/** Bootstring parameters */
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80
var delimiter = &#039;-&#039;; // &#039;\x2D&#039;

/** Regular expressions */
var regexPunycode = /^xn--/;
var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

/** Error messages */
var errors = {
	&#039;overflow&#039;: &#039;Overflow: input needs wider integers to process&#039;,
	&#039;not-basic&#039;: &#039;Illegal input &gt;= 0x80 (not a basic code point)&#039;,
	&#039;invalid-input&#039;: &#039;Invalid input&#039;
};

/** Convenience shortcuts */
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;

/*--------------------------------------------------------------------------*/

/**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */
function error$1(type) {
	throw new RangeError(errors[type]);
}

/**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */
function map(array, fn) {
	var result = [];
	var length = array.length;
	while (length--) {
		result[length] = fn(array[length]);
	}
	return result;
}

/**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {Array} A new string of characters returned by the callback
 * function.
 */
function mapDomain(string, fn) {
	var parts = string.split(&#039;@&#039;);
	var result = &#039;&#039;;
	if (parts.length &gt; 1) {
		// In email addresses, only the domain name should be punycoded. Leave
		// the local part (i.e. everything up to `@`) intact.
		result = parts[0] + &#039;@&#039;;
		string = parts[1];
	}
	// Avoid `split(regex)` for IE8 compatibility. See #17.
	string = string.replace(regexSeparators, &#039;\x2E&#039;);
	var labels = string.split(&#039;.&#039;);
	var encoded = map(labels, fn).join(&#039;.&#039;);
	return result + encoded;
}

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see &lt;https://mathiasbynens.be/notes/javascript-encoding&gt;
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
function ucs2decode(string) {
	var output = [];
	var counter = 0;
	var length = string.length;
	while (counter &lt; length) {
		var value = string.charCodeAt(counter++);
		if (value &gt;= 0xD800 &amp;&amp; value &lt;= 0xDBFF &amp;&amp; counter &lt; length) {
			// It&#039;s a high surrogate, and there is a next character.
			var extra = string.charCodeAt(counter++);
			if ((extra &amp; 0xFC00) == 0xDC00) {
				// Low surrogate.
				output.push(((value &amp; 0x3FF) &lt;&lt; 10) + (extra &amp; 0x3FF) + 0x10000);
			} else {
				// It&#039;s an unmatched surrogate; only append this code unit, in case the
				// next code unit is the high surrogate of a surrogate pair.
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

/**
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */
var ucs2encode = function ucs2encode(array) {
	return String.fromCodePoint.apply(String, toConsumableArray(array));
};

/**
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
 */
var basicToDigit = function basicToDigit(codePoint) {
	if (codePoint - 0x30 &lt; 0x0A) {
		return codePoint - 0x16;
	}
	if (codePoint - 0x41 &lt; 0x1A) {
		return codePoint - 0x41;
	}
	if (codePoint - 0x61 &lt; 0x1A) {
		return codePoint - 0x61;
	}
	return base;
};

/**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */
var digitToBasic = function digitToBasic(digit, flag) {
	//  0..25 map to ASCII a..z or A..Z
	// 26..35 map to ASCII 0..9
	return digit + 22 + 75 * (digit &lt; 26) - ((flag != 0) &lt;&lt; 5);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */
var adapt = function adapt(delta, numPoints, firstTime) {
	var k = 0;
	delta = firstTime ? floor(delta / damp) : delta &gt;&gt; 1;
	delta += floor(delta / numPoints);
	for (; /* no initialization */delta &gt; baseMinusTMin * tMax &gt;&gt; 1; k += base) {
		delta = floor(delta / baseMinusTMin);
	}
	return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */
var decode = function decode(input) {
	// Don&#039;t use UCS-2.
	var output = [];
	var inputLength = input.length;
	var i = 0;
	var n = initialN;
	var bias = initialBias;

	// Handle the basic code points: let `basic` be the number of input code
	// points before the last delimiter, or `0` if there is none, then copy
	// the first basic code points to the output.

	var basic = input.lastIndexOf(delimiter);
	if (basic &lt; 0) {
		basic = 0;
	}

	for (var j = 0; j &lt; basic; ++j) {
		// if it&#039;s not a basic code point
		if (input.charCodeAt(j) &gt;= 0x80) {
			error$1(&#039;not-basic&#039;);
		}
		output.push(input.charCodeAt(j));
	}

	// Main decoding loop: start just after the last delimiter if any basic code
	// points were copied; start at the beginning otherwise.

	for (var index = basic &gt; 0 ? basic + 1 : 0; index &lt; inputLength;) /* no final expression */{

		// `index` is the index of the next character to be consumed.
		// Decode a generalized variable-length integer into `delta`,
		// which gets added to `i`. The overflow checking is easier
		// if we increase `i` as we go, then subtract off its starting
		// value at the end to obtain `delta`.
		var oldi = i;
		for (var w = 1, k = base;; /* no condition */k += base) {

			if (index &gt;= inputLength) {
				error$1(&#039;invalid-input&#039;);
			}

			var digit = basicToDigit(input.charCodeAt(index++));

			if (digit &gt;= base || digit &gt; floor((maxInt - i) / w)) {
				error$1(&#039;overflow&#039;);
			}

			i += digit * w;
			var t = k &lt;= bias ? tMin : k &gt;= bias + tMax ? tMax : k - bias;

			if (digit &lt; t) {
				break;
			}

			var baseMinusT = base - t;
			if (w &gt; floor(maxInt / baseMinusT)) {
				error$1(&#039;overflow&#039;);
			}

			w *= baseMinusT;
		}

		var out = output.length + 1;
		bias = adapt(i - oldi, out, oldi == 0);

		// `i` was supposed to wrap around from `out` to `0`,
		// incrementing `n` each time, so we&#039;ll fix that now:
		if (floor(i / out) &gt; maxInt - n) {
			error$1(&#039;overflow&#039;);
		}

		n += floor(i / out);
		i %= out;

		// Insert `n` at position `i` of the output.
		output.splice(i++, 0, n);
	}

	return String.fromCodePoint.apply(String, output);
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
var encode = function encode(input) {
	var output = [];

	// Convert the input in UCS-2 to an array of Unicode code points.
	input = ucs2decode(input);

	// Cache the length.
	var inputLength = input.length;

	// Initialize the state.
	var n = initialN;
	var delta = 0;
	var bias = initialBias;

	// Handle the basic code points.
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var _currentValue2 = _step.value;

			if (_currentValue2 &lt; 0x80) {
				output.push(stringFromCharCode(_currentValue2));
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion &amp;&amp; _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	var basicLength = output.length;
	var handledCPCount = basicLength;

	// `handledCPCount` is the number of code points that have been handled;
	// `basicLength` is the number of basic code points.

	// Finish the basic string with a delimiter unless it&#039;s empty.
	if (basicLength) {
		output.push(delimiter);
	}

	// Main encoding loop:
	while (handledCPCount &lt; inputLength) {

		// All non-basic code points &lt; n have been handled already. Find the next
		// larger one:
		var m = maxInt;
		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;

		try {
			for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				var currentValue = _step2.value;

				if (currentValue &gt;= n &amp;&amp; currentValue &lt; m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder&#039;s &lt;n,i&gt; state to &lt;m,0&gt;,
			// but guard against overflow.
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 &amp;&amp; _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}

		var handledCPCountPlusOne = handledCPCount + 1;
		if (m - n &gt; floor((maxInt - delta) / handledCPCountPlusOne)) {
			error$1(&#039;overflow&#039;);
		}

		delta += (m - n) * handledCPCountPlusOne;
		n = m;

		var _iteratorNormalCompletion3 = true;
		var _didIteratorError3 = false;
		var _iteratorError3 = undefined;

		try {
			for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
				var _currentValue = _step3.value;

				if (_currentValue &lt; n &amp;&amp; ++delta &gt; maxInt) {
					error$1(&#039;overflow&#039;);
				}
				if (_currentValue == n) {
					// Represent delta as a generalized variable-length integer.
					var q = delta;
					for (var k = base;; /* no condition */k += base) {
						var t = k &lt;= bias ? tMin : k &gt;= bias + tMax ? tMax : k - bias;
						if (q &lt; t) {
							break;
						}
						var qMinusT = q - t;
						var baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}
		} catch (err) {
			_didIteratorError3 = true;
			_iteratorError3 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion3 &amp;&amp; _iterator3.return) {
					_iterator3.return();
				}
			} finally {
				if (_didIteratorError3) {
					throw _iteratorError3;
				}
			}
		}

		++delta;
		++n;
	}
	return output.join(&#039;&#039;);
};

/**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn&#039;t matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */
var toUnicode = function toUnicode(input) {
	return mapDomain(input, function (string) {
		return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
	});
};

/**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn&#039;t matter if you call it with a domain that&#039;s already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
var toASCII = function toASCII(input) {
	return mapDomain(input, function (string) {
		return regexNonASCII.test(string) ? &#039;xn--&#039; + encode(string) : string;
	});
};

/*--------------------------------------------------------------------------*/

/** Define the public API */
var punycode = {
	/**
  * A string representing the current Punycode.js version number.
  * @memberOf punycode
  * @type String
  */
	&#039;version&#039;: &#039;2.1.0&#039;,
	/**
  * An object of methods to convert from JavaScript&#039;s internal character
  * representation (UCS-2) to Unicode code points, and back.
  * @see &lt;https://mathiasbynens.be/notes/javascript-encoding&gt;
  * @memberOf punycode
  * @type Object
  */
	&#039;ucs2&#039;: {
		&#039;decode&#039;: ucs2decode,
		&#039;encode&#039;: ucs2encode
	},
	&#039;decode&#039;: decode,
	&#039;encode&#039;: encode,
	&#039;toASCII&#039;: toASCII,
	&#039;toUnicode&#039;: toUnicode
};

/**
 * URI.js
 *
 * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
 * @author &lt;a href=&quot;mailto:gary.court@gmail.com&quot;&gt;Gary Court&lt;/a&gt;
 * @see http://github.com/garycourt/uri-js
 */
/**
 * Copyright 2011 Gary Court. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
 *       of conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS&#039;&#039; AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are those of the
 * authors and should not be interpreted as representing official policies, either expressed
 * or implied, of Gary Court.
 */
var SCHEMES = {};
function pctEncChar(chr) {
    var c = chr.charCodeAt(0);
    var e = void 0;
    if (c &lt; 16) e = &quot;%0&quot; + c.toString(16).toUpperCase();else if (c &lt; 128) e = &quot;%&quot; + c.toString(16).toUpperCase();else if (c &lt; 2048) e = &quot;%&quot; + (c &gt;&gt; 6 | 192).toString(16).toUpperCase() + &quot;%&quot; + (c &amp; 63 | 128).toString(16).toUpperCase();else e = &quot;%&quot; + (c &gt;&gt; 12 | 224).toString(16).toUpperCase() + &quot;%&quot; + (c &gt;&gt; 6 &amp; 63 | 128).toString(16).toUpperCase() + &quot;%&quot; + (c &amp; 63 | 128).toString(16).toUpperCase();
    return e;
}
function pctDecChars(str) {
    var newStr = &quot;&quot;;
    var i = 0;
    var il = str.length;
    while (i &lt; il) {
        var c = parseInt(str.substr(i + 1, 2), 16);
        if (c &lt; 128) {
            newStr += String.fromCharCode(c);
            i += 3;
        } else if (c &gt;= 194 &amp;&amp; c &lt; 224) {
            if (il - i &gt;= 6) {
                var c2 = parseInt(str.substr(i + 4, 2), 16);
                newStr += String.fromCharCode((c &amp; 31) &lt;&lt; 6 | c2 &amp; 63);
            } else {
                newStr += str.substr(i, 6);
            }
            i += 6;
        } else if (c &gt;= 224) {
            if (il - i &gt;= 9) {
                var _c = parseInt(str.substr(i + 4, 2), 16);
                var c3 = parseInt(str.substr(i + 7, 2), 16);
                newStr += String.fromCharCode((c &amp; 15) &lt;&lt; 12 | (_c &amp; 63) &lt;&lt; 6 | c3 &amp; 63);
            } else {
                newStr += str.substr(i, 9);
            }
            i += 9;
        } else {
            newStr += str.substr(i, 3);
            i += 3;
        }
    }
    return newStr;
}
function _normalizeComponentEncoding(components, protocol) {
    function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
    }
    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, &quot;&quot;);
    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    return components;
}

function _stripLeadingZeros(str) {
    return str.replace(/^0*(.*)/, &quot;$1&quot;) || &quot;0&quot;;
}
function _normalizeIPv4(host, protocol) {
    var matches = host.match(protocol.IPV4ADDRESS) || [];

    var _matches = slicedToArray(matches, 2),
        address = _matches[1];

    if (address) {
        return address.split(&quot;.&quot;).map(_stripLeadingZeros).join(&quot;.&quot;);
    } else {
        return host;
    }
}
function _normalizeIPv6(host, protocol) {
    var matches = host.match(protocol.IPV6ADDRESS) || [];

    var _matches2 = slicedToArray(matches, 3),
        address = _matches2[1],
        zone = _matches2[2];

    if (address) {
        var _address$toLowerCase$ = address.toLowerCase().split(&#039;::&#039;).reverse(),
            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
            last = _address$toLowerCase$2[0],
            first = _address$toLowerCase$2[1];

        var firstFields = first ? first.split(&quot;:&quot;).map(_stripLeadingZeros) : [];
        var lastFields = last.split(&quot;:&quot;).map(_stripLeadingZeros);
        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
        var lastFieldsStart = lastFields.length - fieldCount;
        var fields = Array(fieldCount);
        for (var x = 0; x &lt; fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || &#039;&#039;;
        }
        if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
        }
        var allZeroFields = fields.reduce(function (acc, field, index) {
            if (!field || field === &quot;0&quot;) {
                var lastLongest = acc[acc.length - 1];
                if (lastLongest &amp;&amp; lastLongest.index + lastLongest.length === index) {
                    lastLongest.length++;
                } else {
                    acc.push({ index: index, length: 1 });
                }
            }
            return acc;
        }, []);
        var longestZeroFields = allZeroFields.sort(function (a, b) {
            return b.length - a.length;
        })[0];
        var newHost = void 0;
        if (longestZeroFields &amp;&amp; longestZeroFields.length &gt; 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(&quot;:&quot;) + &quot;::&quot; + newLast.join(&quot;:&quot;);
        } else {
            newHost = fields.join(&quot;:&quot;);
        }
        if (zone) {
            newHost += &quot;%&quot; + zone;
        }
        return newHost;
    } else {
        return host;
    }
}
var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
var NO_MATCH_IS_UNDEFINED = &quot;&quot;.match(/(){0}/)[1] === undefined;
function parse(uriString) {
    var options = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : {};

    var components = {};
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    if (options.reference === &quot;suffix&quot;) uriString = (options.scheme ? options.scheme + &quot;:&quot; : &quot;&quot;) + &quot;//&quot; + uriString;
    var matches = uriString.match(URI_PARSE);
    if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
            //store each component
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || &quot;&quot;;
            components.query = matches[7];
            components.fragment = matches[8];
            //fix port number
            if (isNaN(components.port)) {
                components.port = matches[5];
            }
        } else {
            //IE FIX for improper RegExp matching
            //store each component
            components.scheme = matches[1] || undefined;
            components.userinfo = uriString.indexOf(&quot;@&quot;) !== -1 ? matches[3] : undefined;
            components.host = uriString.indexOf(&quot;//&quot;) !== -1 ? matches[4] : undefined;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || &quot;&quot;;
            components.query = uriString.indexOf(&quot;?&quot;) !== -1 ? matches[7] : undefined;
            components.fragment = uriString.indexOf(&quot;#&quot;) !== -1 ? matches[8] : undefined;
            //fix port number
            if (isNaN(components.port)) {
                components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
            }
        }
        if (components.host) {
            //normalize IP hosts
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
        }
        //determine reference type
        if (components.scheme === undefined &amp;&amp; components.userinfo === undefined &amp;&amp; components.host === undefined &amp;&amp; components.port === undefined &amp;&amp; !components.path &amp;&amp; components.query === undefined) {
            components.reference = &quot;same-document&quot;;
        } else if (components.scheme === undefined) {
            components.reference = &quot;relative&quot;;
        } else if (components.fragment === undefined) {
            components.reference = &quot;absolute&quot;;
        } else {
            components.reference = &quot;uri&quot;;
        }
        //check for reference errors
        if (options.reference &amp;&amp; options.reference !== &quot;suffix&quot; &amp;&amp; options.reference !== components.reference) {
            components.error = components.error || &quot;URI is not a &quot; + options.reference + &quot; reference.&quot;;
        }
        //find scheme handler
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || &quot;&quot;).toLowerCase()];
        //check if scheme can&#039;t handle IRIs
        if (!options.unicodeSupport &amp;&amp; (!schemeHandler || !schemeHandler.unicodeSupport)) {
            //if host component is a domain name
            if (components.host &amp;&amp; (options.domainHost || schemeHandler &amp;&amp; schemeHandler.domainHost)) {
                //convert Unicode IDN -&gt; ASCII IDN
                try {
                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                } catch (e) {
                    components.error = components.error || &quot;Host&#039;s domain name can not be converted to ASCII via punycode: &quot; + e;
                }
            }
            //convert IRI -&gt; URI
            _normalizeComponentEncoding(components, URI_PROTOCOL);
        } else {
            //normalize encodings
            _normalizeComponentEncoding(components, protocol);
        }
        //perform scheme specific parsing
        if (schemeHandler &amp;&amp; schemeHandler.parse) {
            schemeHandler.parse(components, options);
        }
    } else {
        components.error = components.error || &quot;URI can not be parsed.&quot;;
    }
    return components;
}

function _recomposeAuthority(components, options) {
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    if (components.userinfo !== undefined) {
        uriTokens.push(components.userinfo);
        uriTokens.push(&quot;@&quot;);
    }
    if (components.host !== undefined) {
        //normalize IP hosts, add brackets and escape zone separator for IPv6
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
            return &quot;[&quot; + $1 + ($2 ? &quot;%25&quot; + $2 : &quot;&quot;) + &quot;]&quot;;
        }));
    }
    if (typeof components.port === &quot;number&quot; || typeof components.port === &quot;string&quot;) {
        uriTokens.push(&quot;:&quot;);
        uriTokens.push(String(components.port));
    }
    return uriTokens.length ? uriTokens.join(&quot;&quot;) : undefined;
}

var RDS1 = /^\.\.?\//;
var RDS2 = /^\/\.(\/|$)/;
var RDS3 = /^\/\.\.(\/|$)/;
var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
function removeDotSegments(input) {
    var output = [];
    while (input.length) {
        if (input.match(RDS1)) {
            input = input.replace(RDS1, &quot;&quot;);
        } else if (input.match(RDS2)) {
            input = input.replace(RDS2, &quot;/&quot;);
        } else if (input.match(RDS3)) {
            input = input.replace(RDS3, &quot;/&quot;);
            output.pop();
        } else if (input === &quot;.&quot; || input === &quot;..&quot;) {
            input = &quot;&quot;;
        } else {
            var im = input.match(RDS5);
            if (im) {
                var s = im[0];
                input = input.slice(s.length);
                output.push(s);
            } else {
                throw new Error(&quot;Unexpected dot segment condition&quot;);
            }
        }
    }
    return output.join(&quot;&quot;);
}

function serialize(components) {
    var options = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : {};

    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    //find scheme handler
    var schemeHandler = SCHEMES[(options.scheme || components.scheme || &quot;&quot;).toLowerCase()];
    //perform scheme specific serialization
    if (schemeHandler &amp;&amp; schemeHandler.serialize) schemeHandler.serialize(components, options);
    if (components.host) {
        //if host component is an IPv6 address
        if (protocol.IPV6ADDRESS.test(components.host)) {}
        //TODO: normalize IPv6 address as per RFC 5952

        //if host component is a domain name
        else if (options.domainHost || schemeHandler &amp;&amp; schemeHandler.domainHost) {
                //convert IDN via punycode
                try {
                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
                } catch (e) {
                    components.error = components.error || &quot;Host&#039;s domain name can not be converted to &quot; + (!options.iri ? &quot;ASCII&quot; : &quot;Unicode&quot;) + &quot; via punycode: &quot; + e;
                }
            }
    }
    //normalize encoding
    _normalizeComponentEncoding(components, protocol);
    if (options.reference !== &quot;suffix&quot; &amp;&amp; components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(&quot;:&quot;);
    }
    var authority = _recomposeAuthority(components, options);
    if (authority !== undefined) {
        if (options.reference !== &quot;suffix&quot;) {
            uriTokens.push(&quot;//&quot;);
        }
        uriTokens.push(authority);
        if (components.path &amp;&amp; components.path.charAt(0) !== &quot;/&quot;) {
            uriTokens.push(&quot;/&quot;);
        }
    }
    if (components.path !== undefined) {
        var s = components.path;
        if (!options.absolutePath &amp;&amp; (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
        }
        if (authority === undefined) {
            s = s.replace(/^\/\//, &quot;/%2F&quot;); //don&#039;t allow the path to start with &quot;//&quot;
        }
        uriTokens.push(s);
    }
    if (components.query !== undefined) {
        uriTokens.push(&quot;?&quot;);
        uriTokens.push(components.query);
    }
    if (components.fragment !== undefined) {
        uriTokens.push(&quot;#&quot;);
        uriTokens.push(components.fragment);
    }
    return uriTokens.join(&quot;&quot;); //merge tokens into a string
}

function resolveComponents(base, relative) {
    var options = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : {};
    var skipNormalization = arguments[3];

    var target = {};
    if (!skipNormalization) {
        base = parse(serialize(base, options), options); //normalize base components
        relative = parse(serialize(relative, options), options); //normalize relative components
    }
    options = options || {};
    if (!options.tolerant &amp;&amp; relative.scheme) {
        target.scheme = relative.scheme;
        //target.authority = relative.authority;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || &quot;&quot;);
        target.query = relative.query;
    } else {
        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
            //target.authority = relative.authority;
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || &quot;&quot;);
            target.query = relative.query;
        } else {
            if (!relative.path) {
                target.path = base.path;
                if (relative.query !== undefined) {
                    target.query = relative.query;
                } else {
                    target.query = base.query;
                }
            } else {
                if (relative.path.charAt(0) === &quot;/&quot;) {
                    target.path = removeDotSegments(relative.path);
                } else {
                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) &amp;&amp; !base.path) {
                        target.path = &quot;/&quot; + relative.path;
                    } else if (!base.path) {
                        target.path = relative.path;
                    } else {
                        target.path = base.path.slice(0, base.path.lastIndexOf(&quot;/&quot;) + 1) + relative.path;
                    }
                    target.path = removeDotSegments(target.path);
                }
                target.query = relative.query;
            }
            //target.authority = base.authority;
            target.userinfo = base.userinfo;
            target.host = base.host;
            target.port = base.port;
        }
        target.scheme = base.scheme;
    }
    target.fragment = relative.fragment;
    return target;
}

function resolve(baseURI, relativeURI, options) {
    var schemelessOptions = assign({ scheme: &#039;null&#039; }, options);
    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
}

function normalize(uri, options) {
    if (typeof uri === &quot;string&quot;) {
        uri = serialize(parse(uri, options), options);
    } else if (typeOf(uri) === &quot;object&quot;) {
        uri = parse(serialize(uri, options), options);
    }
    return uri;
}

function equal(uriA, uriB, options) {
    if (typeof uriA === &quot;string&quot;) {
        uriA = serialize(parse(uriA, options), options);
    } else if (typeOf(uriA) === &quot;object&quot;) {
        uriA = serialize(uriA, options);
    }
    if (typeof uriB === &quot;string&quot;) {
        uriB = serialize(parse(uriB, options), options);
    } else if (typeOf(uriB) === &quot;object&quot;) {
        uriB = serialize(uriB, options);
    }
    return uriA === uriB;
}

function escapeComponent(str, options) {
    return str &amp;&amp; str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
}

function unescapeComponent(str, options) {
    return str &amp;&amp; str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
}

var handler = {
    scheme: &quot;http&quot;,
    domainHost: true,
    parse: function parse(components, options) {
        //report missing host
        if (!components.host) {
            components.error = components.error || &quot;HTTP URIs must have a host.&quot;;
        }
        return components;
    },
    serialize: function serialize(components, options) {
        var secure = String(components.scheme).toLowerCase() === &quot;https&quot;;
        //normalize the default port
        if (components.port === (secure ? 443 : 80) || components.port === &quot;&quot;) {
            components.port = undefined;
        }
        //normalize the empty path
        if (!components.path) {
            components.path = &quot;/&quot;;
        }
        //NOTE: We do not parse query strings for HTTP URIs
        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
        //and not the HTTP spec.
        return components;
    }
};

var handler$1 = {
    scheme: &quot;https&quot;,
    domainHost: handler.domainHost,
    parse: handler.parse,
    serialize: handler.serialize
};

function isSecure(wsComponents) {
    return typeof wsComponents.secure === &#039;boolean&#039; ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === &quot;wss&quot;;
}
//RFC 6455
var handler$2 = {
    scheme: &quot;ws&quot;,
    domainHost: true,
    parse: function parse(components, options) {
        var wsComponents = components;
        //indicate if the secure flag is set
        wsComponents.secure = isSecure(wsComponents);
        //construct resouce name
        wsComponents.resourceName = (wsComponents.path || &#039;/&#039;) + (wsComponents.query ? &#039;?&#039; + wsComponents.query : &#039;&#039;);
        wsComponents.path = undefined;
        wsComponents.query = undefined;
        return wsComponents;
    },
    serialize: function serialize(wsComponents, options) {
        //normalize the default port
        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === &quot;&quot;) {
            wsComponents.port = undefined;
        }
        //ensure scheme matches secure flag
        if (typeof wsComponents.secure === &#039;boolean&#039;) {
            wsComponents.scheme = wsComponents.secure ? &#039;wss&#039; : &#039;ws&#039;;
            wsComponents.secure = undefined;
        }
        //reconstruct path from resource name
        if (wsComponents.resourceName) {
            var _wsComponents$resourc = wsComponents.resourceName.split(&#039;?&#039;),
                _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),
                path = _wsComponents$resourc2[0],
                query = _wsComponents$resourc2[1];

            wsComponents.path = path &amp;&amp; path !== &#039;/&#039; ? path : undefined;
            wsComponents.query = query;
            wsComponents.resourceName = undefined;
        }
        //forbid fragment component
        wsComponents.fragment = undefined;
        return wsComponents;
    }
};

var handler$3 = {
    scheme: &quot;wss&quot;,
    domainHost: handler$2.domainHost,
    parse: handler$2.parse,
    serialize: handler$2.serialize
};

var O = {};
var isIRI = true;
//RFC 3986
var UNRESERVED$$ = &quot;[A-Za-z0-9\\-\\.\\_\\~&quot; + (isIRI ? &quot;\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF&quot; : &quot;&quot;) + &quot;]&quot;;
var HEXDIG$$ = &quot;[0-9A-Fa-f]&quot;; //case-insensitive
var PCT_ENCODED$ = subexp(subexp(&quot;%[EFef]&quot; + HEXDIG$$ + &quot;%&quot; + HEXDIG$$ + HEXDIG$$ + &quot;%&quot; + HEXDIG$$ + HEXDIG$$) + &quot;|&quot; + subexp(&quot;%[89A-Fa-f]&quot; + HEXDIG$$ + &quot;%&quot; + HEXDIG$$ + HEXDIG$$) + &quot;|&quot; + subexp(&quot;%&quot; + HEXDIG$$ + HEXDIG$$)); //expanded
//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] &amp; ; =
//const ATEXT$$ = &quot;[A-Za-z0-9\\!\\#\\$\\%\\&amp;\\&#039;\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]&quot;;
//const WSP$$ = &quot;[\\x20\\x09]&quot;;
//const OBS_QTEXT$$ = &quot;[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]&quot;;  //(%d1-8 / %d11-12 / %d14-31 / %d127)
//const QTEXT$$ = merge(&quot;[\\x21\\x23-\\x5B\\x5D-\\x7E]&quot;, OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
//const VCHAR$$ = &quot;[\\x21-\\x7E]&quot;;
//const WSP$$ = &quot;[\\x20\\x09]&quot;;
//const OBS_QP$ = subexp(&quot;\\\\&quot; + merge(&quot;[\\x00\\x0D\\x0A]&quot;, OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
//const FWS$ = subexp(subexp(WSP$$ + &quot;*&quot; + &quot;\\x0D\\x0A&quot;) + &quot;?&quot; + WSP$$ + &quot;+&quot;);
//const QUOTED_PAIR$ = subexp(subexp(&quot;\\\\&quot; + subexp(VCHAR$$ + &quot;|&quot; + WSP$$)) + &quot;|&quot; + OBS_QP$);
//const QUOTED_STRING$ = subexp(&#039;\\&quot;&#039; + subexp(FWS$ + &quot;?&quot; + QCONTENT$) + &quot;*&quot; + FWS$ + &quot;?&quot; + &#039;\\&quot;&#039;);
var ATEXT$$ = &quot;[A-Za-z0-9\\!\\$\\%\\&#039;\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]&quot;;
var QTEXT$$ = &quot;[\\!\\$\\%\\&#039;\\(\\)\\*\\+\\,\\-\\.0-9\\&lt;\\&gt;A-Z\\x5E-\\x7E]&quot;;
var VCHAR$$ = merge(QTEXT$$, &quot;[\\\&quot;\\\\]&quot;);
var SOME_DELIMS$$ = &quot;[\\!\\$\\&#039;\\(\\)\\*\\+\\,\\;\\:\\@]&quot;;
var UNRESERVED = new RegExp(UNRESERVED$$, &quot;g&quot;);
var PCT_ENCODED = new RegExp(PCT_ENCODED$, &quot;g&quot;);
var NOT_LOCAL_PART = new RegExp(merge(&quot;[^]&quot;, ATEXT$$, &quot;[\\.]&quot;, &#039;[\\&quot;]&#039;, VCHAR$$), &quot;g&quot;);
var NOT_HFNAME = new RegExp(merge(&quot;[^]&quot;, UNRESERVED$$, SOME_DELIMS$$), &quot;g&quot;);
var NOT_HFVALUE = NOT_HFNAME;
function decodeUnreserved(str) {
    var decStr = pctDecChars(str);
    return !decStr.match(UNRESERVED) ? str : decStr;
}
var handler$4 = {
    scheme: &quot;mailto&quot;,
    parse: function parse$$1(components, options) {
        var mailtoComponents = components;
        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(&quot;,&quot;) : [];
        mailtoComponents.path = undefined;
        if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split(&quot;&amp;&quot;);
            for (var x = 0, xl = hfields.length; x &lt; xl; ++x) {
                var hfield = hfields[x].split(&quot;=&quot;);
                switch (hfield[0]) {
                    case &quot;to&quot;:
                        var toAddrs = hfield[1].split(&quot;,&quot;);
                        for (var _x = 0, _xl = toAddrs.length; _x &lt; _xl; ++_x) {
                            to.push(toAddrs[_x]);
                        }
                        break;
                    case &quot;subject&quot;:
                        mailtoComponents.subject = unescapeComponent(hfield[1], options);
                        break;
                    case &quot;body&quot;:
                        mailtoComponents.body = unescapeComponent(hfield[1], options);
                        break;
                    default:
                        unknownHeaders = true;
                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                        break;
                }
            }
            if (unknownHeaders) mailtoComponents.headers = headers;
        }
        mailtoComponents.query = undefined;
        for (var _x2 = 0, _xl2 = to.length; _x2 &lt; _xl2; ++_x2) {
            var addr = to[_x2].split(&quot;@&quot;);
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
                //convert Unicode IDN -&gt; ASCII IDN
                try {
                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
                } catch (e) {
                    mailtoComponents.error = mailtoComponents.error || &quot;Email address&#039;s domain name can not be converted to ASCII via punycode: &quot; + e;
                }
            } else {
                addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join(&quot;@&quot;);
        }
        return mailtoComponents;
    },
    serialize: function serialize$$1(mailtoComponents, options) {
        var components = mailtoComponents;
        var to = toArray(mailtoComponents.to);
        if (to) {
            for (var x = 0, xl = to.length; x &lt; xl; ++x) {
                var toAddr = String(to[x]);
                var atIdx = toAddr.lastIndexOf(&quot;@&quot;);
                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
                var domain = toAddr.slice(atIdx + 1);
                //convert IDN via punycode
                try {
                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
                } catch (e) {
                    components.error = components.error || &quot;Email address&#039;s domain name can not be converted to &quot; + (!options.iri ? &quot;ASCII&quot; : &quot;Unicode&quot;) + &quot; via punycode: &quot; + e;
                }
                to[x] = localPart + &quot;@&quot; + domain;
            }
            components.path = to.join(&quot;,&quot;);
        }
        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
        if (mailtoComponents.subject) headers[&quot;subject&quot;] = mailtoComponents.subject;
        if (mailtoComponents.body) headers[&quot;body&quot;] = mailtoComponents.body;
        var fields = [];
        for (var name in headers) {
            if (headers[name] !== O[name]) {
                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + &quot;=&quot; + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
        }
        if (fields.length) {
            components.query = fields.join(&quot;&amp;&quot;);
        }
        return components;
    }
};

var URN_PARSE = /^([^\:]+)\:(.*)/;
//RFC 2141
var handler$5 = {
    scheme: &quot;urn&quot;,
    parse: function parse$$1(components, options) {
        var matches = components.path &amp;&amp; components.path.match(URN_PARSE);
        var urnComponents = components;
        if (matches) {
            var scheme = options.scheme || urnComponents.scheme || &quot;urn&quot;;
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + &quot;:&quot; + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = undefined;
            if (schemeHandler) {
                urnComponents = schemeHandler.parse(urnComponents, options);
            }
        } else {
            urnComponents.error = urnComponents.error || &quot;URN can not be parsed.&quot;;
        }
        return urnComponents;
    },
    serialize: function serialize$$1(urnComponents, options) {
        var scheme = options.scheme || urnComponents.scheme || &quot;urn&quot;;
        var nid = urnComponents.nid;
        var urnScheme = scheme + &quot;:&quot; + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        var uriComponents = urnComponents;
        var nss = urnComponents.nss;
        uriComponents.path = (nid || options.nid) + &quot;:&quot; + nss;
        return uriComponents;
    }
};

var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
//RFC 4122
var handler$6 = {
    scheme: &quot;urn:uuid&quot;,
    parse: function parse(urnComponents, options) {
        var uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = undefined;
        if (!options.tolerant &amp;&amp; (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || &quot;UUID is not valid.&quot;;
        }
        return uuidComponents;
    },
    serialize: function serialize(uuidComponents, options) {
        var urnComponents = uuidComponents;
        //normalize UUID
        urnComponents.nss = (uuidComponents.uuid || &quot;&quot;).toLowerCase();
        return urnComponents;
    }
};

SCHEMES[handler.scheme] = handler;
SCHEMES[handler$1.scheme] = handler$1;
SCHEMES[handler$2.scheme] = handler$2;
SCHEMES[handler$3.scheme] = handler$3;
SCHEMES[handler$4.scheme] = handler$4;
SCHEMES[handler$5.scheme] = handler$5;
SCHEMES[handler$6.scheme] = handler$6;

exports.SCHEMES = SCHEMES;
exports.pctEncChar = pctEncChar;
exports.pctDecChars = pctDecChars;
exports.parse = parse;
exports.removeDotSegments = removeDotSegments;
exports.serialize = serialize;
exports.resolveComponents = resolveComponents;
exports.resolve = resolve;
exports.normalize = normalize;
exports.equal = equal;
exports.escapeComponent = escapeComponent;
exports.unescapeComponent = unescapeComponent;

Object.defineProperty(exports, &#039;__esModule&#039;, { value: true });

})));


},{}],&quot;ajv&quot;:[function(require,module,exports){
&#039;use strict&#039;;

var compileSchema = require(&#039;./compile&#039;)
  , resolve = require(&#039;./compile/resolve&#039;)
  , Cache = require(&#039;./cache&#039;)
  , SchemaObject = require(&#039;./compile/schema_obj&#039;)
  , stableStringify = require(&#039;fast-json-stable-stringify&#039;)
  , formats = require(&#039;./compile/formats&#039;)
  , rules = require(&#039;./compile/rules&#039;)
  , $dataMetaSchema = require(&#039;./data&#039;)
  , util = require(&#039;./compile/util&#039;);

module.exports = Ajv;

Ajv.prototype.validate = validate;
Ajv.prototype.compile = compile;
Ajv.prototype.addSchema = addSchema;
Ajv.prototype.addMetaSchema = addMetaSchema;
Ajv.prototype.validateSchema = validateSchema;
Ajv.prototype.getSchema = getSchema;
Ajv.prototype.removeSchema = removeSchema;
Ajv.prototype.addFormat = addFormat;
Ajv.prototype.errorsText = errorsText;

Ajv.prototype._addSchema = _addSchema;
Ajv.prototype._compile = _compile;

Ajv.prototype.compileAsync = require(&#039;./compile/async&#039;);
var customKeyword = require(&#039;./keyword&#039;);
Ajv.prototype.addKeyword = customKeyword.add;
Ajv.prototype.getKeyword = customKeyword.get;
Ajv.prototype.removeKeyword = customKeyword.remove;
Ajv.prototype.validateKeyword = customKeyword.validate;

var errorClasses = require(&#039;./compile/error_classes&#039;);
Ajv.ValidationError = errorClasses.Validation;
Ajv.MissingRefError = errorClasses.MissingRef;
Ajv.$dataMetaSchema = $dataMetaSchema;

var META_SCHEMA_ID = &#039;http://json-schema.org/draft-07/schema&#039;;

var META_IGNORE_OPTIONS = [ &#039;removeAdditional&#039;, &#039;useDefaults&#039;, &#039;coerceTypes&#039;, &#039;strictDefaults&#039; ];
var META_SUPPORT_DATA = [&#039;/properties&#039;];

/**
 * Creates validator instance.
 * Usage: `Ajv(opts)`
 * @param {Object} opts optional options
 * @return {Object} ajv instance
 */
function Ajv(opts) {
  if (!(this instanceof Ajv)) return new Ajv(opts);
  opts = this._opts = util.copy(opts) || {};
  setLogger(this);
  this._schemas = {};
  this._refs = {};
  this._fragments = {};
  this._formats = formats(opts.format);

  this._cache = opts.cache || new Cache;
  this._loadingSchemas = {};
  this._compilations = [];
  this.RULES = rules();
  this._getId = chooseGetId(opts);

  opts.loopRequired = opts.loopRequired || Infinity;
  if (opts.errorDataPath == &#039;property&#039;) opts._errorDataPathProperty = true;
  if (opts.serialize === undefined) opts.serialize = stableStringify;
  this._metaOpts = getMetaSchemaOptions(this);

  if (opts.formats) addInitialFormats(this);
  if (opts.keywords) addInitialKeywords(this);
  addDefaultMetaSchema(this);
  if (typeof opts.meta == &#039;object&#039;) this.addMetaSchema(opts.meta);
  if (opts.nullable) this.addKeyword(&#039;nullable&#039;, {metaSchema: {type: &#039;boolean&#039;}});
  addInitialSchemas(this);
}



/**
 * Validate data using schema
 * Schema will be compiled and cached (using serialized JSON as key. [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize.
 * @this   Ajv
 * @param  {String|Object} schemaKeyRef key, ref or schema object
 * @param  {Any} data to be validated
 * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).
 */
function validate(schemaKeyRef, data) {
  var v;
  if (typeof schemaKeyRef == &#039;string&#039;) {
    v = this.getSchema(schemaKeyRef);
    if (!v) throw new Error(&#039;no schema with key or ref &quot;&#039; + schemaKeyRef + &#039;&quot;&#039;);
  } else {
    var schemaObj = this._addSchema(schemaKeyRef);
    v = schemaObj.validate || this._compile(schemaObj);
  }

  var valid = v(data);
  if (v.$async !== true) this.errors = v.errors;
  return valid;
}


/**
 * Create validating function for passed schema.
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.
 * @return {Function} validating function
 */
function compile(schema, _meta) {
  var schemaObj = this._addSchema(schema, undefined, _meta);
  return schemaObj.validate || this._compile(schemaObj);
}


/**
 * Adds schema to the instance.
 * @this   Ajv
 * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.
 * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
 * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.
 * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
 * @return {Ajv} this for method chaining
 */
function addSchema(schema, key, _skipValidation, _meta) {
  if (Array.isArray(schema)){
    for (var i=0; i&lt;schema.length; i++) this.addSchema(schema[i], undefined, _skipValidation, _meta);
    return this;
  }
  var id = this._getId(schema);
  if (id !== undefined &amp;&amp; typeof id != &#039;string&#039;)
    throw new Error(&#039;schema id must be string&#039;);
  key = resolve.normalizeId(key || id);
  checkUnique(this, key);
  this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
  return this;
}


/**
 * Add schema that will be used to validate other schemas
 * options in META_IGNORE_OPTIONS are alway set to false
 * @this   Ajv
 * @param {Object} schema schema object
 * @param {String} key optional schema key
 * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema
 * @return {Ajv} this for method chaining
 */
function addMetaSchema(schema, key, skipValidation) {
  this.addSchema(schema, key, skipValidation, true);
  return this;
}


/**
 * Validate schema
 * @this   Ajv
 * @param {Object} schema schema to validate
 * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid
 * @return {Boolean} true if schema is valid
 */
function validateSchema(schema, throwOrLogError) {
  var $schema = schema.$schema;
  if ($schema !== undefined &amp;&amp; typeof $schema != &#039;string&#039;)
    throw new Error(&#039;$schema must be a string&#039;);
  $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
  if (!$schema) {
    this.logger.warn(&#039;meta-schema not available&#039;);
    this.errors = null;
    return true;
  }
  var valid = this.validate($schema, schema);
  if (!valid &amp;&amp; throwOrLogError) {
    var message = &#039;schema is invalid: &#039; + this.errorsText();
    if (this._opts.validateSchema == &#039;log&#039;) this.logger.error(message);
    else throw new Error(message);
  }
  return valid;
}


function defaultMeta(self) {
  var meta = self._opts.meta;
  self._opts.defaultMeta = typeof meta == &#039;object&#039;
                            ? self._getId(meta) || meta
                            : self.getSchema(META_SCHEMA_ID)
                              ? META_SCHEMA_ID
                              : undefined;
  return self._opts.defaultMeta;
}


/**
 * Get compiled schema from the instance by `key` or `ref`.
 * @this   Ajv
 * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).
 * @return {Function} schema validating function (with property `schema`).
 */
function getSchema(keyRef) {
  var schemaObj = _getSchemaObj(this, keyRef);
  switch (typeof schemaObj) {
    case &#039;object&#039;: return schemaObj.validate || this._compile(schemaObj);
    case &#039;string&#039;: return this.getSchema(schemaObj);
    case &#039;undefined&#039;: return _getSchemaFragment(this, keyRef);
  }
}


function _getSchemaFragment(self, ref) {
  var res = resolve.schema.call(self, { schema: {} }, ref);
  if (res) {
    var schema = res.schema
      , root = res.root
      , baseId = res.baseId;
    var v = compileSchema.call(self, schema, root, undefined, baseId);
    self._fragments[ref] = new SchemaObject({
      ref: ref,
      fragment: true,
      schema: schema,
      root: root,
      baseId: baseId,
      validate: v
    });
    return v;
  }
}


function _getSchemaObj(self, keyRef) {
  keyRef = resolve.normalizeId(keyRef);
  return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
}


/**
 * Remove cached schema(s).
 * If no parameter is passed all schemas but meta-schemas are removed.
 * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
 * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
 * @this   Ajv
 * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object
 * @return {Ajv} this for method chaining
 */
function removeSchema(schemaKeyRef) {
  if (schemaKeyRef instanceof RegExp) {
    _removeAllSchemas(this, this._schemas, schemaKeyRef);
    _removeAllSchemas(this, this._refs, schemaKeyRef);
    return this;
  }
  switch (typeof schemaKeyRef) {
    case &#039;undefined&#039;:
      _removeAllSchemas(this, this._schemas);
      _removeAllSchemas(this, this._refs);
      this._cache.clear();
      return this;
    case &#039;string&#039;:
      var schemaObj = _getSchemaObj(this, schemaKeyRef);
      if (schemaObj) this._cache.del(schemaObj.cacheKey);
      delete this._schemas[schemaKeyRef];
      delete this._refs[schemaKeyRef];
      return this;
    case &#039;object&#039;:
      var serialize = this._opts.serialize;
      var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
      this._cache.del(cacheKey);
      var id = this._getId(schemaKeyRef);
      if (id) {
        id = resolve.normalizeId(id);
        delete this._schemas[id];
        delete this._refs[id];
      }
  }
  return this;
}


function _removeAllSchemas(self, schemas, regex) {
  for (var keyRef in schemas) {
    var schemaObj = schemas[keyRef];
    if (!schemaObj.meta &amp;&amp; (!regex || regex.test(keyRef))) {
      self._cache.del(schemaObj.cacheKey);
      delete schemas[keyRef];
    }
  }
}


/* @this   Ajv */
function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
  if (typeof schema != &#039;object&#039; &amp;&amp; typeof schema != &#039;boolean&#039;)
    throw new Error(&#039;schema should be object or boolean&#039;);
  var serialize = this._opts.serialize;
  var cacheKey = serialize ? serialize(schema) : schema;
  var cached = this._cache.get(cacheKey);
  if (cached) return cached;

  shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;

  var id = resolve.normalizeId(this._getId(schema));
  if (id &amp;&amp; shouldAddSchema) checkUnique(this, id);

  var willValidate = this._opts.validateSchema !== false &amp;&amp; !skipValidation;
  var recursiveMeta;
  if (willValidate &amp;&amp; !(recursiveMeta = id &amp;&amp; id == resolve.normalizeId(schema.$schema)))
    this.validateSchema(schema, true);

  var localRefs = resolve.ids.call(this, schema);

  var schemaObj = new SchemaObject({
    id: id,
    schema: schema,
    localRefs: localRefs,
    cacheKey: cacheKey,
    meta: meta
  });

  if (id[0] != &#039;#&#039; &amp;&amp; shouldAddSchema) this._refs[id] = schemaObj;
  this._cache.put(cacheKey, schemaObj);

  if (willValidate &amp;&amp; recursiveMeta) this.validateSchema(schema, true);

  return schemaObj;
}


/* @this   Ajv */
function _compile(schemaObj, root) {
  if (schemaObj.compiling) {
    schemaObj.validate = callValidate;
    callValidate.schema = schemaObj.schema;
    callValidate.errors = null;
    callValidate.root = root ? root : callValidate;
    if (schemaObj.schema.$async === true)
      callValidate.$async = true;
    return callValidate;
  }
  schemaObj.compiling = true;

  var currentOpts;
  if (schemaObj.meta) {
    currentOpts = this._opts;
    this._opts = this._metaOpts;
  }

  var v;
  try { v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs); }
  catch(e) {
    delete schemaObj.validate;
    throw e;
  }
  finally {
    schemaObj.compiling = false;
    if (schemaObj.meta) this._opts = currentOpts;
  }

  schemaObj.validate = v;
  schemaObj.refs = v.refs;
  schemaObj.refVal = v.refVal;
  schemaObj.root = v.root;
  return v;


  /* @this   {*} - custom context, see passContext option */
  function callValidate() {
    /* jshint validthis: true */
    var _validate = schemaObj.validate;
    var result = _validate.apply(this, arguments);
    callValidate.errors = _validate.errors;
    return result;
  }
}


function chooseGetId(opts) {
  switch (opts.schemaId) {
    case &#039;auto&#039;: return _get$IdOrId;
    case &#039;id&#039;: return _getId;
    default: return _get$Id;
  }
}

/* @this   Ajv */
function _getId(schema) {
  if (schema.$id) this.logger.warn(&#039;schema $id ignored&#039;, schema.$id);
  return schema.id;
}

/* @this   Ajv */
function _get$Id(schema) {
  if (schema.id) this.logger.warn(&#039;schema id ignored&#039;, schema.id);
  return schema.$id;
}


function _get$IdOrId(schema) {
  if (schema.$id &amp;&amp; schema.id &amp;&amp; schema.$id != schema.id)
    throw new Error(&#039;schema $id is different from id&#039;);
  return schema.$id || schema.id;
}


/**
 * Convert array of error message objects to string
 * @this   Ajv
 * @param  {Array&lt;Object&gt;} errors optional array of validation errors, if not passed errors from the instance are used.
 * @param  {Object} options optional options with properties `separator` and `dataVar`.
 * @return {String} human readable string with all errors descriptions
 */
function errorsText(errors, options) {
  errors = errors || this.errors;
  if (!errors) return &#039;No errors&#039;;
  options = options || {};
  var separator = options.separator === undefined ? &#039;, &#039; : options.separator;
  var dataVar = options.dataVar === undefined ? &#039;data&#039; : options.dataVar;

  var text = &#039;&#039;;
  for (var i=0; i&lt;errors.length; i++) {
    var e = errors[i];
    if (e) text += dataVar + e.dataPath + &#039; &#039; + e.message + separator;
  }
  return text.slice(0, -separator.length);
}


/**
 * Add custom format
 * @this   Ajv
 * @param {String} name format name
 * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
 * @return {Ajv} this for method chaining
 */
function addFormat(name, format) {
  if (typeof format == &#039;string&#039;) format = new RegExp(format);
  this._formats[name] = format;
  return this;
}


function addDefaultMetaSchema(self) {
  var $dataSchema;
  if (self._opts.$data) {
    $dataSchema = require(&#039;./refs/data.json&#039;);
    self.addMetaSchema($dataSchema, $dataSchema.$id, true);
  }
  if (self._opts.meta === false) return;
  var metaSchema = require(&#039;./refs/json-schema-draft-07.json&#039;);
  if (self._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
  self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
  self._refs[&#039;http://json-schema.org/schema&#039;] = META_SCHEMA_ID;
}


function addInitialSchemas(self) {
  var optsSchemas = self._opts.schemas;
  if (!optsSchemas) return;
  if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);
  else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);
}


function addInitialFormats(self) {
  for (var name in self._opts.formats) {
    var format = self._opts.formats[name];
    self.addFormat(name, format);
  }
}


function addInitialKeywords(self) {
  for (var name in self._opts.keywords) {
    var keyword = self._opts.keywords[name];
    self.addKeyword(name, keyword);
  }
}


function checkUnique(self, id) {
  if (self._schemas[id] || self._refs[id])
    throw new Error(&#039;schema with key or id &quot;&#039; + id + &#039;&quot; already exists&#039;);
}


function getMetaSchemaOptions(self) {
  var metaOpts = util.copy(self._opts);
  for (var i=0; i&lt;META_IGNORE_OPTIONS.length; i++)
    delete metaOpts[META_IGNORE_OPTIONS[i]];
  return metaOpts;
}


function setLogger(self) {
  var logger = self._opts.logger;
  if (logger === false) {
    self.logger = {log: noop, warn: noop, error: noop};
  } else {
    if (logger === undefined) logger = console;
    if (!(typeof logger == &#039;object&#039; &amp;&amp; logger.log &amp;&amp; logger.warn &amp;&amp; logger.error))
      throw new Error(&#039;logger must implement log, warn and error methods&#039;);
    self.logger = logger;
  }
}


function noop() {}

},{&quot;./cache&quot;:1,&quot;./compile&quot;:5,&quot;./compile/async&quot;:2,&quot;./compile/error_classes&quot;:3,&quot;./compile/formats&quot;:4,&quot;./compile/resolve&quot;:6,&quot;./compile/rules&quot;:7,&quot;./compile/schema_obj&quot;:8,&quot;./compile/util&quot;:10,&quot;./data&quot;:11,&quot;./keyword&quot;:39,&quot;./refs/data.json&quot;:40,&quot;./refs/json-schema-draft-07.json&quot;:41,&quot;fast-json-stable-stringify&quot;:43}]},{},[])(&quot;ajv&quot;)
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
