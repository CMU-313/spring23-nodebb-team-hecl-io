<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@webassemblyjs/ast/scripts/generateNodeUtils.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@webassemblyjs/ast/scripts/generateNodeUtils.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">82.87</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">219</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">26.46</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">1.54</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">const definitions = require(&quot;../src/definitions&quot;);
const flatMap = require(&quot;array.prototype.flatmap&quot;);
const {
  typeSignature,
  iterateProps,
  mapProps,
  filterProps,
  unique
} = require(&quot;./util&quot;);

const stdout = process.stdout;

const jsTypes = [&quot;string&quot;, &quot;number&quot;, &quot;boolean&quot;];

const quote = value =&gt; `&quot;${value}&quot;`;

function params(fields) {
  const optionalDefault = field =&gt; (field.default ? ` = ${field.default}` : &quot;&quot;);
  return mapProps(fields)
    .map(field =&gt; `${typeSignature(field)}${optionalDefault(field)}`)
    .join(&quot;,&quot;);
}

function assertParamType({ assertNodeType, array, name, type }) {
  if (array) {
    // TODO - assert contents of array?
    return `assert(typeof ${name} === &quot;object&quot; &amp;&amp; typeof ${name}.length !== &quot;undefined&quot;)\n`;
  } else {
    if (jsTypes.includes(type)) {
      return `assert(
          typeof ${name} === &quot;${type}&quot;,
          &quot;Argument ${name} must be of type ${type}, given: &quot; + typeof ${name}
      )`;
    }

    if (assertNodeType === true) {
      return `assert(
        ${name}.type === &quot;${type}&quot;,
        &quot;Argument ${name} must be of type ${type}, given: &quot; + ${name}.type
      )`;
    }

    return &quot;&quot;;
  }
}

function assertParam(meta) {
  const paramAssertion = assertParamType(meta);

  if (paramAssertion === &quot;&quot;) {
    return &quot;&quot;;
  }

  if (meta.maybe || meta.optional) {
    return `
      if (${meta.name} !== null &amp;&amp; ${meta.name} !== undefined) {
        ${paramAssertion};
      }
    `;
  } else {
    return paramAssertion;
  }
}

function assertParams(fields) {
  return mapProps(fields)
    .map(assertParam)
    .join(&quot;\n&quot;);
}

function buildObject(typeDef) {
  const optionalField = meta =&gt; {
    if (meta.array) {
      // omit optional array properties if the constructor function was supplied
      // with an empty array
      return `
        if (typeof ${meta.name} !== &quot;undefined&quot; &amp;&amp; ${meta.name}.length &gt; 0) {
          node.${meta.name} = ${meta.name};
        }
      `;
    } else if (meta.type === &quot;Object&quot;) {
      // omit optional object properties if they have no keys
      return `
        if (typeof ${meta.name} !== &quot;undefined&quot; &amp;&amp; Object.keys(${
        meta.name
      }).length !== 0) {
          node.${meta.name} = ${meta.name};
        }
      `;
    } else if (meta.type === &quot;boolean&quot;) {
      // omit optional boolean properties if they are not true
      return `
        if (${meta.name} === true) {
          node.${meta.name} = true;
        }
      `;
    } else {
      return `
        if (typeof ${meta.name} !== &quot;undefined&quot;) {
          node.${meta.name} = ${meta.name};
        }
      `;
    }
  };

  const fields = mapProps(typeDef.fields)
    .filter(f =&gt; !f.optional &amp;&amp; !f.constant)
    .map(f =&gt; f.name);

  const constants = mapProps(typeDef.fields)
    .filter(f =&gt; f.constant)
    .map(f =&gt; `${f.name}: &quot;${f.value}&quot;`);

  return `
    const node: ${typeDef.flowTypeName || typeDef.name} = {
      type: &quot;${typeDef.name}&quot;,
      ${constants.concat(fields).join(&quot;,&quot;)}
    }

    ${mapProps(typeDef.fields)
      .filter(f =&gt; f.optional)
      .map(optionalField)
      .join(&quot;&quot;)}
  `;
}

function lowerCamelCase(name) {
  return name.substring(0, 1).toLowerCase() + name.substring(1);
}

function generate() {
  stdout.write(`
    // @flow

    // THIS FILE IS AUTOGENERATED
    // see scripts/generateNodeUtils.js

    import { assert } from &quot;mamacro&quot;;

    function isTypeOf(t: string) {
      return (n: Node) =&gt; n.type === t;
    }

    function assertTypeOf(t: string) {
      return (n: Node) =&gt; assert(n.type === t);
    }
  `);

  // Node builders
  iterateProps(definitions, typeDefinition =&gt; {
    stdout.write(`
      export function ${lowerCamelCase(typeDefinition.name)} (
        ${params(filterProps(typeDefinition.fields, f =&gt; !f.constant))}
      ): ${typeDefinition.name} {

        ${assertParams(filterProps(typeDefinition.fields, f =&gt; !f.constant))}
        ${buildObject(typeDefinition)} 

        return node;
      }
    `);
  });

  // Node testers
  iterateProps(definitions, typeDefinition =&gt; {
    stdout.write(`
      export const is${typeDefinition.name} =
        isTypeOf(&quot;${typeDefinition.name}&quot;);
    `);
  });

  // Node union type testers
  const unionTypes = unique(
    flatMap(mapProps(definitions).filter(d =&gt; d.unionType), d =&gt; d.unionType)
  );
  unionTypes.forEach(unionType =&gt; {
    stdout.write(
      `
      export const is${unionType} = (node: Node) =&gt; ` +
        mapProps(definitions)
          .filter(d =&gt; d.unionType &amp;&amp; d.unionType.includes(unionType))
          .map(d =&gt; `is${d.name}(node) `)
          .join(&quot;||&quot;) +
        &quot;;\n\n&quot;
    );
  });

  // Node assertion
  iterateProps(definitions, typeDefinition =&gt; {
    stdout.write(`
      export const assert${typeDefinition.name} =
        assertTypeOf(&quot;${typeDefinition.name}&quot;);
    `);
  });

  // a map from node type to its set of union types
  stdout.write(
    `
    export const unionTypesMap = {` +
      mapProps(definitions)
        .filter(d =&gt; d.unionType)
        .map(t =&gt; `&quot;${t.name}&quot;: [${t.unionType.map(quote).join(&quot;,&quot;)}]\n`) +
      `};
      `
  );

  // an array of all node and union types
  stdout.write(
    `
    export const nodeAndUnionTypes = [` +
      mapProps(definitions)
        .map(t =&gt; `&quot;${t.name}&quot;`)
        .concat(unionTypes.map(quote))
        .join(&quot;,&quot;) +
      `];`
  );
}

generate();</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
