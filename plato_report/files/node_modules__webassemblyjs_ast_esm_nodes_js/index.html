<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@webassemblyjs/ast/esm/nodes.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@webassemblyjs/ast/esm/nodes.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">64.91</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">925</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">56.46</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">12.29</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">function _typeof(obj) { if (typeof Symbol === &quot;function&quot; &amp;&amp; typeof Symbol.iterator === &quot;symbol&quot;) { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj &amp;&amp; typeof Symbol === &quot;function&quot; &amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? &quot;symbol&quot; : typeof obj; }; } return _typeof(obj); }

// THIS FILE IS AUTOGENERATED
// see scripts/generateNodeUtils.js
function isTypeOf(t) {
  return function (n) {
    return n.type === t;
  };
}

function assertTypeOf(t) {
  return function (n) {
    return function () {
      if (!(n.type === t)) {
        throw new Error(&#039;n.type === t&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
      }
    }();
  };
}

export function module(id, fields, metadata) {
  if (id !== null &amp;&amp; id !== undefined) {
    if (!(typeof id === &quot;string&quot;)) {
      throw new Error(&#039;typeof id === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument id must be of type string, given: &quot; + _typeof(id) || &quot;unknown&quot;));
    }
  }

  if (!(_typeof(fields) === &quot;object&quot; &amp;&amp; typeof fields.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof fields === &quot;object&quot; &amp;&amp; typeof fields.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;Module&quot;,
    id: id,
    fields: fields
  };

  if (typeof metadata !== &quot;undefined&quot;) {
    node.metadata = metadata;
  }

  return node;
}
export function moduleMetadata(sections, functionNames, localNames, producers) {
  if (!(_typeof(sections) === &quot;object&quot; &amp;&amp; typeof sections.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof sections === &quot;object&quot; &amp;&amp; typeof sections.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  if (functionNames !== null &amp;&amp; functionNames !== undefined) {
    if (!(_typeof(functionNames) === &quot;object&quot; &amp;&amp; typeof functionNames.length !== &quot;undefined&quot;)) {
      throw new Error(&#039;typeof functionNames === &quot;object&quot; &amp;&amp; typeof functionNames.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
    }
  }

  if (localNames !== null &amp;&amp; localNames !== undefined) {
    if (!(_typeof(localNames) === &quot;object&quot; &amp;&amp; typeof localNames.length !== &quot;undefined&quot;)) {
      throw new Error(&#039;typeof localNames === &quot;object&quot; &amp;&amp; typeof localNames.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
    }
  }

  if (producers !== null &amp;&amp; producers !== undefined) {
    if (!(_typeof(producers) === &quot;object&quot; &amp;&amp; typeof producers.length !== &quot;undefined&quot;)) {
      throw new Error(&#039;typeof producers === &quot;object&quot; &amp;&amp; typeof producers.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
    }
  }

  var node = {
    type: &quot;ModuleMetadata&quot;,
    sections: sections
  };

  if (typeof functionNames !== &quot;undefined&quot; &amp;&amp; functionNames.length &gt; 0) {
    node.functionNames = functionNames;
  }

  if (typeof localNames !== &quot;undefined&quot; &amp;&amp; localNames.length &gt; 0) {
    node.localNames = localNames;
  }

  if (typeof producers !== &quot;undefined&quot; &amp;&amp; producers.length &gt; 0) {
    node.producers = producers;
  }

  return node;
}
export function moduleNameMetadata(value) {
  if (!(typeof value === &quot;string&quot;)) {
    throw new Error(&#039;typeof value === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument value must be of type string, given: &quot; + _typeof(value) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;ModuleNameMetadata&quot;,
    value: value
  };
  return node;
}
export function functionNameMetadata(value, index) {
  if (!(typeof value === &quot;string&quot;)) {
    throw new Error(&#039;typeof value === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument value must be of type string, given: &quot; + _typeof(value) || &quot;unknown&quot;));
  }

  if (!(typeof index === &quot;number&quot;)) {
    throw new Error(&#039;typeof index === &quot;number&quot;&#039; + &quot; error: &quot; + (&quot;Argument index must be of type number, given: &quot; + _typeof(index) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;FunctionNameMetadata&quot;,
    value: value,
    index: index
  };
  return node;
}
export function localNameMetadata(value, localIndex, functionIndex) {
  if (!(typeof value === &quot;string&quot;)) {
    throw new Error(&#039;typeof value === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument value must be of type string, given: &quot; + _typeof(value) || &quot;unknown&quot;));
  }

  if (!(typeof localIndex === &quot;number&quot;)) {
    throw new Error(&#039;typeof localIndex === &quot;number&quot;&#039; + &quot; error: &quot; + (&quot;Argument localIndex must be of type number, given: &quot; + _typeof(localIndex) || &quot;unknown&quot;));
  }

  if (!(typeof functionIndex === &quot;number&quot;)) {
    throw new Error(&#039;typeof functionIndex === &quot;number&quot;&#039; + &quot; error: &quot; + (&quot;Argument functionIndex must be of type number, given: &quot; + _typeof(functionIndex) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;LocalNameMetadata&quot;,
    value: value,
    localIndex: localIndex,
    functionIndex: functionIndex
  };
  return node;
}
export function binaryModule(id, blob) {
  if (id !== null &amp;&amp; id !== undefined) {
    if (!(typeof id === &quot;string&quot;)) {
      throw new Error(&#039;typeof id === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument id must be of type string, given: &quot; + _typeof(id) || &quot;unknown&quot;));
    }
  }

  if (!(_typeof(blob) === &quot;object&quot; &amp;&amp; typeof blob.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof blob === &quot;object&quot; &amp;&amp; typeof blob.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;BinaryModule&quot;,
    id: id,
    blob: blob
  };
  return node;
}
export function quoteModule(id, string) {
  if (id !== null &amp;&amp; id !== undefined) {
    if (!(typeof id === &quot;string&quot;)) {
      throw new Error(&#039;typeof id === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument id must be of type string, given: &quot; + _typeof(id) || &quot;unknown&quot;));
    }
  }

  if (!(_typeof(string) === &quot;object&quot; &amp;&amp; typeof string.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof string === &quot;object&quot; &amp;&amp; typeof string.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;QuoteModule&quot;,
    id: id,
    string: string
  };
  return node;
}
export function sectionMetadata(section, startOffset, size, vectorOfSize) {
  if (!(typeof startOffset === &quot;number&quot;)) {
    throw new Error(&#039;typeof startOffset === &quot;number&quot;&#039; + &quot; error: &quot; + (&quot;Argument startOffset must be of type number, given: &quot; + _typeof(startOffset) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;SectionMetadata&quot;,
    section: section,
    startOffset: startOffset,
    size: size,
    vectorOfSize: vectorOfSize
  };
  return node;
}
export function producersSectionMetadata(producers) {
  if (!(_typeof(producers) === &quot;object&quot; &amp;&amp; typeof producers.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof producers === &quot;object&quot; &amp;&amp; typeof producers.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;ProducersSectionMetadata&quot;,
    producers: producers
  };
  return node;
}
export function producerMetadata(language, processedBy, sdk) {
  if (!(_typeof(language) === &quot;object&quot; &amp;&amp; typeof language.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof language === &quot;object&quot; &amp;&amp; typeof language.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  if (!(_typeof(processedBy) === &quot;object&quot; &amp;&amp; typeof processedBy.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof processedBy === &quot;object&quot; &amp;&amp; typeof processedBy.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  if (!(_typeof(sdk) === &quot;object&quot; &amp;&amp; typeof sdk.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof sdk === &quot;object&quot; &amp;&amp; typeof sdk.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;ProducerMetadata&quot;,
    language: language,
    processedBy: processedBy,
    sdk: sdk
  };
  return node;
}
export function producerMetadataVersionedName(name, version) {
  if (!(typeof name === &quot;string&quot;)) {
    throw new Error(&#039;typeof name === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument name must be of type string, given: &quot; + _typeof(name) || &quot;unknown&quot;));
  }

  if (!(typeof version === &quot;string&quot;)) {
    throw new Error(&#039;typeof version === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument version must be of type string, given: &quot; + _typeof(version) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;ProducerMetadataVersionedName&quot;,
    name: name,
    version: version
  };
  return node;
}
export function loopInstruction(label, resulttype, instr) {
  if (!(_typeof(instr) === &quot;object&quot; &amp;&amp; typeof instr.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof instr === &quot;object&quot; &amp;&amp; typeof instr.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;LoopInstruction&quot;,
    id: &quot;loop&quot;,
    label: label,
    resulttype: resulttype,
    instr: instr
  };
  return node;
}
export function instr(id, object, args, namedArgs) {
  if (!(typeof id === &quot;string&quot;)) {
    throw new Error(&#039;typeof id === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument id must be of type string, given: &quot; + _typeof(id) || &quot;unknown&quot;));
  }

  if (!(_typeof(args) === &quot;object&quot; &amp;&amp; typeof args.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof args === &quot;object&quot; &amp;&amp; typeof args.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;Instr&quot;,
    id: id,
    args: args
  };

  if (typeof object !== &quot;undefined&quot;) {
    node.object = object;
  }

  if (typeof namedArgs !== &quot;undefined&quot; &amp;&amp; Object.keys(namedArgs).length !== 0) {
    node.namedArgs = namedArgs;
  }

  return node;
}
export function ifInstruction(testLabel, test, result, consequent, alternate) {
  if (!(_typeof(test) === &quot;object&quot; &amp;&amp; typeof test.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof test === &quot;object&quot; &amp;&amp; typeof test.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  if (!(_typeof(consequent) === &quot;object&quot; &amp;&amp; typeof consequent.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof consequent === &quot;object&quot; &amp;&amp; typeof consequent.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  if (!(_typeof(alternate) === &quot;object&quot; &amp;&amp; typeof alternate.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof alternate === &quot;object&quot; &amp;&amp; typeof alternate.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;IfInstruction&quot;,
    id: &quot;if&quot;,
    testLabel: testLabel,
    test: test,
    result: result,
    consequent: consequent,
    alternate: alternate
  };
  return node;
}
export function stringLiteral(value) {
  if (!(typeof value === &quot;string&quot;)) {
    throw new Error(&#039;typeof value === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument value must be of type string, given: &quot; + _typeof(value) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;StringLiteral&quot;,
    value: value
  };
  return node;
}
export function numberLiteral(value, raw) {
  if (!(typeof value === &quot;number&quot;)) {
    throw new Error(&#039;typeof value === &quot;number&quot;&#039; + &quot; error: &quot; + (&quot;Argument value must be of type number, given: &quot; + _typeof(value) || &quot;unknown&quot;));
  }

  if (!(typeof raw === &quot;string&quot;)) {
    throw new Error(&#039;typeof raw === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument raw must be of type string, given: &quot; + _typeof(raw) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;NumberLiteral&quot;,
    value: value,
    raw: raw
  };
  return node;
}
export function longNumberLiteral(value, raw) {
  if (!(typeof raw === &quot;string&quot;)) {
    throw new Error(&#039;typeof raw === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument raw must be of type string, given: &quot; + _typeof(raw) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;LongNumberLiteral&quot;,
    value: value,
    raw: raw
  };
  return node;
}
export function floatLiteral(value, nan, inf, raw) {
  if (!(typeof value === &quot;number&quot;)) {
    throw new Error(&#039;typeof value === &quot;number&quot;&#039; + &quot; error: &quot; + (&quot;Argument value must be of type number, given: &quot; + _typeof(value) || &quot;unknown&quot;));
  }

  if (nan !== null &amp;&amp; nan !== undefined) {
    if (!(typeof nan === &quot;boolean&quot;)) {
      throw new Error(&#039;typeof nan === &quot;boolean&quot;&#039; + &quot; error: &quot; + (&quot;Argument nan must be of type boolean, given: &quot; + _typeof(nan) || &quot;unknown&quot;));
    }
  }

  if (inf !== null &amp;&amp; inf !== undefined) {
    if (!(typeof inf === &quot;boolean&quot;)) {
      throw new Error(&#039;typeof inf === &quot;boolean&quot;&#039; + &quot; error: &quot; + (&quot;Argument inf must be of type boolean, given: &quot; + _typeof(inf) || &quot;unknown&quot;));
    }
  }

  if (!(typeof raw === &quot;string&quot;)) {
    throw new Error(&#039;typeof raw === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument raw must be of type string, given: &quot; + _typeof(raw) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;FloatLiteral&quot;,
    value: value,
    raw: raw
  };

  if (nan === true) {
    node.nan = true;
  }

  if (inf === true) {
    node.inf = true;
  }

  return node;
}
export function elem(table, offset, funcs) {
  if (!(_typeof(offset) === &quot;object&quot; &amp;&amp; typeof offset.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof offset === &quot;object&quot; &amp;&amp; typeof offset.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  if (!(_typeof(funcs) === &quot;object&quot; &amp;&amp; typeof funcs.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof funcs === &quot;object&quot; &amp;&amp; typeof funcs.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;Elem&quot;,
    table: table,
    offset: offset,
    funcs: funcs
  };
  return node;
}
export function indexInFuncSection(index) {
  var node = {
    type: &quot;IndexInFuncSection&quot;,
    index: index
  };
  return node;
}
export function valtypeLiteral(name) {
  var node = {
    type: &quot;ValtypeLiteral&quot;,
    name: name
  };
  return node;
}
export function typeInstruction(id, functype) {
  var node = {
    type: &quot;TypeInstruction&quot;,
    id: id,
    functype: functype
  };
  return node;
}
export function start(index) {
  var node = {
    type: &quot;Start&quot;,
    index: index
  };
  return node;
}
export function globalType(valtype, mutability) {
  var node = {
    type: &quot;GlobalType&quot;,
    valtype: valtype,
    mutability: mutability
  };
  return node;
}
export function leadingComment(value) {
  if (!(typeof value === &quot;string&quot;)) {
    throw new Error(&#039;typeof value === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument value must be of type string, given: &quot; + _typeof(value) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;LeadingComment&quot;,
    value: value
  };
  return node;
}
export function blockComment(value) {
  if (!(typeof value === &quot;string&quot;)) {
    throw new Error(&#039;typeof value === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument value must be of type string, given: &quot; + _typeof(value) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;BlockComment&quot;,
    value: value
  };
  return node;
}
export function data(memoryIndex, offset, init) {
  var node = {
    type: &quot;Data&quot;,
    memoryIndex: memoryIndex,
    offset: offset,
    init: init
  };
  return node;
}
export function global(globalType, init, name) {
  if (!(_typeof(init) === &quot;object&quot; &amp;&amp; typeof init.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof init === &quot;object&quot; &amp;&amp; typeof init.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;Global&quot;,
    globalType: globalType,
    init: init,
    name: name
  };
  return node;
}
export function table(elementType, limits, name, elements) {
  if (!(limits.type === &quot;Limit&quot;)) {
    throw new Error(&#039;limits.type === &quot;Limit&quot;&#039; + &quot; error: &quot; + (&quot;Argument limits must be of type Limit, given: &quot; + limits.type || &quot;unknown&quot;));
  }

  if (elements !== null &amp;&amp; elements !== undefined) {
    if (!(_typeof(elements) === &quot;object&quot; &amp;&amp; typeof elements.length !== &quot;undefined&quot;)) {
      throw new Error(&#039;typeof elements === &quot;object&quot; &amp;&amp; typeof elements.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
    }
  }

  var node = {
    type: &quot;Table&quot;,
    elementType: elementType,
    limits: limits,
    name: name
  };

  if (typeof elements !== &quot;undefined&quot; &amp;&amp; elements.length &gt; 0) {
    node.elements = elements;
  }

  return node;
}
export function memory(limits, id) {
  var node = {
    type: &quot;Memory&quot;,
    limits: limits,
    id: id
  };
  return node;
}
export function funcImportDescr(id, signature) {
  var node = {
    type: &quot;FuncImportDescr&quot;,
    id: id,
    signature: signature
  };
  return node;
}
export function moduleImport(module, name, descr) {
  if (!(typeof module === &quot;string&quot;)) {
    throw new Error(&#039;typeof module === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument module must be of type string, given: &quot; + _typeof(module) || &quot;unknown&quot;));
  }

  if (!(typeof name === &quot;string&quot;)) {
    throw new Error(&#039;typeof name === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument name must be of type string, given: &quot; + _typeof(name) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;ModuleImport&quot;,
    module: module,
    name: name,
    descr: descr
  };
  return node;
}
export function moduleExportDescr(exportType, id) {
  var node = {
    type: &quot;ModuleExportDescr&quot;,
    exportType: exportType,
    id: id
  };
  return node;
}
export function moduleExport(name, descr) {
  if (!(typeof name === &quot;string&quot;)) {
    throw new Error(&#039;typeof name === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument name must be of type string, given: &quot; + _typeof(name) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;ModuleExport&quot;,
    name: name,
    descr: descr
  };
  return node;
}
export function limit(min, max, shared) {
  if (!(typeof min === &quot;number&quot;)) {
    throw new Error(&#039;typeof min === &quot;number&quot;&#039; + &quot; error: &quot; + (&quot;Argument min must be of type number, given: &quot; + _typeof(min) || &quot;unknown&quot;));
  }

  if (max !== null &amp;&amp; max !== undefined) {
    if (!(typeof max === &quot;number&quot;)) {
      throw new Error(&#039;typeof max === &quot;number&quot;&#039; + &quot; error: &quot; + (&quot;Argument max must be of type number, given: &quot; + _typeof(max) || &quot;unknown&quot;));
    }
  }

  if (shared !== null &amp;&amp; shared !== undefined) {
    if (!(typeof shared === &quot;boolean&quot;)) {
      throw new Error(&#039;typeof shared === &quot;boolean&quot;&#039; + &quot; error: &quot; + (&quot;Argument shared must be of type boolean, given: &quot; + _typeof(shared) || &quot;unknown&quot;));
    }
  }

  var node = {
    type: &quot;Limit&quot;,
    min: min
  };

  if (typeof max !== &quot;undefined&quot;) {
    node.max = max;
  }

  if (shared === true) {
    node.shared = true;
  }

  return node;
}
export function signature(params, results) {
  if (!(_typeof(params) === &quot;object&quot; &amp;&amp; typeof params.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof params === &quot;object&quot; &amp;&amp; typeof params.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  if (!(_typeof(results) === &quot;object&quot; &amp;&amp; typeof results.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof results === &quot;object&quot; &amp;&amp; typeof results.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;Signature&quot;,
    params: params,
    results: results
  };
  return node;
}
export function program(body) {
  if (!(_typeof(body) === &quot;object&quot; &amp;&amp; typeof body.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof body === &quot;object&quot; &amp;&amp; typeof body.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;Program&quot;,
    body: body
  };
  return node;
}
export function identifier(value, raw) {
  if (!(typeof value === &quot;string&quot;)) {
    throw new Error(&#039;typeof value === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument value must be of type string, given: &quot; + _typeof(value) || &quot;unknown&quot;));
  }

  if (raw !== null &amp;&amp; raw !== undefined) {
    if (!(typeof raw === &quot;string&quot;)) {
      throw new Error(&#039;typeof raw === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument raw must be of type string, given: &quot; + _typeof(raw) || &quot;unknown&quot;));
    }
  }

  var node = {
    type: &quot;Identifier&quot;,
    value: value
  };

  if (typeof raw !== &quot;undefined&quot;) {
    node.raw = raw;
  }

  return node;
}
export function blockInstruction(label, instr, result) {
  if (!(_typeof(instr) === &quot;object&quot; &amp;&amp; typeof instr.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof instr === &quot;object&quot; &amp;&amp; typeof instr.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;BlockInstruction&quot;,
    id: &quot;block&quot;,
    label: label,
    instr: instr,
    result: result
  };
  return node;
}
export function callInstruction(index, instrArgs, numeric) {
  if (instrArgs !== null &amp;&amp; instrArgs !== undefined) {
    if (!(_typeof(instrArgs) === &quot;object&quot; &amp;&amp; typeof instrArgs.length !== &quot;undefined&quot;)) {
      throw new Error(&#039;typeof instrArgs === &quot;object&quot; &amp;&amp; typeof instrArgs.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
    }
  }

  var node = {
    type: &quot;CallInstruction&quot;,
    id: &quot;call&quot;,
    index: index
  };

  if (typeof instrArgs !== &quot;undefined&quot; &amp;&amp; instrArgs.length &gt; 0) {
    node.instrArgs = instrArgs;
  }

  if (typeof numeric !== &quot;undefined&quot;) {
    node.numeric = numeric;
  }

  return node;
}
export function callIndirectInstruction(signature, intrs) {
  if (intrs !== null &amp;&amp; intrs !== undefined) {
    if (!(_typeof(intrs) === &quot;object&quot; &amp;&amp; typeof intrs.length !== &quot;undefined&quot;)) {
      throw new Error(&#039;typeof intrs === &quot;object&quot; &amp;&amp; typeof intrs.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
    }
  }

  var node = {
    type: &quot;CallIndirectInstruction&quot;,
    id: &quot;call_indirect&quot;,
    signature: signature
  };

  if (typeof intrs !== &quot;undefined&quot; &amp;&amp; intrs.length &gt; 0) {
    node.intrs = intrs;
  }

  return node;
}
export function byteArray(values) {
  if (!(_typeof(values) === &quot;object&quot; &amp;&amp; typeof values.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof values === &quot;object&quot; &amp;&amp; typeof values.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;ByteArray&quot;,
    values: values
  };
  return node;
}
export function func(name, signature, body, isExternal, metadata) {
  if (!(_typeof(body) === &quot;object&quot; &amp;&amp; typeof body.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof body === &quot;object&quot; &amp;&amp; typeof body.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  if (isExternal !== null &amp;&amp; isExternal !== undefined) {
    if (!(typeof isExternal === &quot;boolean&quot;)) {
      throw new Error(&#039;typeof isExternal === &quot;boolean&quot;&#039; + &quot; error: &quot; + (&quot;Argument isExternal must be of type boolean, given: &quot; + _typeof(isExternal) || &quot;unknown&quot;));
    }
  }

  var node = {
    type: &quot;Func&quot;,
    name: name,
    signature: signature,
    body: body
  };

  if (isExternal === true) {
    node.isExternal = true;
  }

  if (typeof metadata !== &quot;undefined&quot;) {
    node.metadata = metadata;
  }

  return node;
}
export function internalBrUnless(target) {
  if (!(typeof target === &quot;number&quot;)) {
    throw new Error(&#039;typeof target === &quot;number&quot;&#039; + &quot; error: &quot; + (&quot;Argument target must be of type number, given: &quot; + _typeof(target) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;InternalBrUnless&quot;,
    target: target
  };
  return node;
}
export function internalGoto(target) {
  if (!(typeof target === &quot;number&quot;)) {
    throw new Error(&#039;typeof target === &quot;number&quot;&#039; + &quot; error: &quot; + (&quot;Argument target must be of type number, given: &quot; + _typeof(target) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;InternalGoto&quot;,
    target: target
  };
  return node;
}
export function internalCallExtern(target) {
  if (!(typeof target === &quot;number&quot;)) {
    throw new Error(&#039;typeof target === &quot;number&quot;&#039; + &quot; error: &quot; + (&quot;Argument target must be of type number, given: &quot; + _typeof(target) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;InternalCallExtern&quot;,
    target: target
  };
  return node;
}
export function internalEndAndReturn() {
  var node = {
    type: &quot;InternalEndAndReturn&quot;
  };
  return node;
}
export var isModule = isTypeOf(&quot;Module&quot;);
export var isModuleMetadata = isTypeOf(&quot;ModuleMetadata&quot;);
export var isModuleNameMetadata = isTypeOf(&quot;ModuleNameMetadata&quot;);
export var isFunctionNameMetadata = isTypeOf(&quot;FunctionNameMetadata&quot;);
export var isLocalNameMetadata = isTypeOf(&quot;LocalNameMetadata&quot;);
export var isBinaryModule = isTypeOf(&quot;BinaryModule&quot;);
export var isQuoteModule = isTypeOf(&quot;QuoteModule&quot;);
export var isSectionMetadata = isTypeOf(&quot;SectionMetadata&quot;);
export var isProducersSectionMetadata = isTypeOf(&quot;ProducersSectionMetadata&quot;);
export var isProducerMetadata = isTypeOf(&quot;ProducerMetadata&quot;);
export var isProducerMetadataVersionedName = isTypeOf(&quot;ProducerMetadataVersionedName&quot;);
export var isLoopInstruction = isTypeOf(&quot;LoopInstruction&quot;);
export var isInstr = isTypeOf(&quot;Instr&quot;);
export var isIfInstruction = isTypeOf(&quot;IfInstruction&quot;);
export var isStringLiteral = isTypeOf(&quot;StringLiteral&quot;);
export var isNumberLiteral = isTypeOf(&quot;NumberLiteral&quot;);
export var isLongNumberLiteral = isTypeOf(&quot;LongNumberLiteral&quot;);
export var isFloatLiteral = isTypeOf(&quot;FloatLiteral&quot;);
export var isElem = isTypeOf(&quot;Elem&quot;);
export var isIndexInFuncSection = isTypeOf(&quot;IndexInFuncSection&quot;);
export var isValtypeLiteral = isTypeOf(&quot;ValtypeLiteral&quot;);
export var isTypeInstruction = isTypeOf(&quot;TypeInstruction&quot;);
export var isStart = isTypeOf(&quot;Start&quot;);
export var isGlobalType = isTypeOf(&quot;GlobalType&quot;);
export var isLeadingComment = isTypeOf(&quot;LeadingComment&quot;);
export var isBlockComment = isTypeOf(&quot;BlockComment&quot;);
export var isData = isTypeOf(&quot;Data&quot;);
export var isGlobal = isTypeOf(&quot;Global&quot;);
export var isTable = isTypeOf(&quot;Table&quot;);
export var isMemory = isTypeOf(&quot;Memory&quot;);
export var isFuncImportDescr = isTypeOf(&quot;FuncImportDescr&quot;);
export var isModuleImport = isTypeOf(&quot;ModuleImport&quot;);
export var isModuleExportDescr = isTypeOf(&quot;ModuleExportDescr&quot;);
export var isModuleExport = isTypeOf(&quot;ModuleExport&quot;);
export var isLimit = isTypeOf(&quot;Limit&quot;);
export var isSignature = isTypeOf(&quot;Signature&quot;);
export var isProgram = isTypeOf(&quot;Program&quot;);
export var isIdentifier = isTypeOf(&quot;Identifier&quot;);
export var isBlockInstruction = isTypeOf(&quot;BlockInstruction&quot;);
export var isCallInstruction = isTypeOf(&quot;CallInstruction&quot;);
export var isCallIndirectInstruction = isTypeOf(&quot;CallIndirectInstruction&quot;);
export var isByteArray = isTypeOf(&quot;ByteArray&quot;);
export var isFunc = isTypeOf(&quot;Func&quot;);
export var isInternalBrUnless = isTypeOf(&quot;InternalBrUnless&quot;);
export var isInternalGoto = isTypeOf(&quot;InternalGoto&quot;);
export var isInternalCallExtern = isTypeOf(&quot;InternalCallExtern&quot;);
export var isInternalEndAndReturn = isTypeOf(&quot;InternalEndAndReturn&quot;);
export var isNode = function isNode(node) {
  return isModule(node) || isModuleMetadata(node) || isModuleNameMetadata(node) || isFunctionNameMetadata(node) || isLocalNameMetadata(node) || isBinaryModule(node) || isQuoteModule(node) || isSectionMetadata(node) || isProducersSectionMetadata(node) || isProducerMetadata(node) || isProducerMetadataVersionedName(node) || isLoopInstruction(node) || isInstr(node) || isIfInstruction(node) || isStringLiteral(node) || isNumberLiteral(node) || isLongNumberLiteral(node) || isFloatLiteral(node) || isElem(node) || isIndexInFuncSection(node) || isValtypeLiteral(node) || isTypeInstruction(node) || isStart(node) || isGlobalType(node) || isLeadingComment(node) || isBlockComment(node) || isData(node) || isGlobal(node) || isTable(node) || isMemory(node) || isFuncImportDescr(node) || isModuleImport(node) || isModuleExportDescr(node) || isModuleExport(node) || isLimit(node) || isSignature(node) || isProgram(node) || isIdentifier(node) || isBlockInstruction(node) || isCallInstruction(node) || isCallIndirectInstruction(node) || isByteArray(node) || isFunc(node) || isInternalBrUnless(node) || isInternalGoto(node) || isInternalCallExtern(node) || isInternalEndAndReturn(node);
};
export var isBlock = function isBlock(node) {
  return isLoopInstruction(node) || isBlockInstruction(node) || isFunc(node);
};
export var isInstruction = function isInstruction(node) {
  return isLoopInstruction(node) || isInstr(node) || isIfInstruction(node) || isTypeInstruction(node) || isBlockInstruction(node) || isCallInstruction(node) || isCallIndirectInstruction(node);
};
export var isExpression = function isExpression(node) {
  return isInstr(node) || isStringLiteral(node) || isNumberLiteral(node) || isLongNumberLiteral(node) || isFloatLiteral(node) || isValtypeLiteral(node) || isIdentifier(node);
};
export var isNumericLiteral = function isNumericLiteral(node) {
  return isNumberLiteral(node) || isLongNumberLiteral(node) || isFloatLiteral(node);
};
export var isImportDescr = function isImportDescr(node) {
  return isGlobalType(node) || isTable(node) || isMemory(node) || isFuncImportDescr(node);
};
export var isIntrinsic = function isIntrinsic(node) {
  return isInternalBrUnless(node) || isInternalGoto(node) || isInternalCallExtern(node) || isInternalEndAndReturn(node);
};
export var assertModule = assertTypeOf(&quot;Module&quot;);
export var assertModuleMetadata = assertTypeOf(&quot;ModuleMetadata&quot;);
export var assertModuleNameMetadata = assertTypeOf(&quot;ModuleNameMetadata&quot;);
export var assertFunctionNameMetadata = assertTypeOf(&quot;FunctionNameMetadata&quot;);
export var assertLocalNameMetadata = assertTypeOf(&quot;LocalNameMetadata&quot;);
export var assertBinaryModule = assertTypeOf(&quot;BinaryModule&quot;);
export var assertQuoteModule = assertTypeOf(&quot;QuoteModule&quot;);
export var assertSectionMetadata = assertTypeOf(&quot;SectionMetadata&quot;);
export var assertProducersSectionMetadata = assertTypeOf(&quot;ProducersSectionMetadata&quot;);
export var assertProducerMetadata = assertTypeOf(&quot;ProducerMetadata&quot;);
export var assertProducerMetadataVersionedName = assertTypeOf(&quot;ProducerMetadataVersionedName&quot;);
export var assertLoopInstruction = assertTypeOf(&quot;LoopInstruction&quot;);
export var assertInstr = assertTypeOf(&quot;Instr&quot;);
export var assertIfInstruction = assertTypeOf(&quot;IfInstruction&quot;);
export var assertStringLiteral = assertTypeOf(&quot;StringLiteral&quot;);
export var assertNumberLiteral = assertTypeOf(&quot;NumberLiteral&quot;);
export var assertLongNumberLiteral = assertTypeOf(&quot;LongNumberLiteral&quot;);
export var assertFloatLiteral = assertTypeOf(&quot;FloatLiteral&quot;);
export var assertElem = assertTypeOf(&quot;Elem&quot;);
export var assertIndexInFuncSection = assertTypeOf(&quot;IndexInFuncSection&quot;);
export var assertValtypeLiteral = assertTypeOf(&quot;ValtypeLiteral&quot;);
export var assertTypeInstruction = assertTypeOf(&quot;TypeInstruction&quot;);
export var assertStart = assertTypeOf(&quot;Start&quot;);
export var assertGlobalType = assertTypeOf(&quot;GlobalType&quot;);
export var assertLeadingComment = assertTypeOf(&quot;LeadingComment&quot;);
export var assertBlockComment = assertTypeOf(&quot;BlockComment&quot;);
export var assertData = assertTypeOf(&quot;Data&quot;);
export var assertGlobal = assertTypeOf(&quot;Global&quot;);
export var assertTable = assertTypeOf(&quot;Table&quot;);
export var assertMemory = assertTypeOf(&quot;Memory&quot;);
export var assertFuncImportDescr = assertTypeOf(&quot;FuncImportDescr&quot;);
export var assertModuleImport = assertTypeOf(&quot;ModuleImport&quot;);
export var assertModuleExportDescr = assertTypeOf(&quot;ModuleExportDescr&quot;);
export var assertModuleExport = assertTypeOf(&quot;ModuleExport&quot;);
export var assertLimit = assertTypeOf(&quot;Limit&quot;);
export var assertSignature = assertTypeOf(&quot;Signature&quot;);
export var assertProgram = assertTypeOf(&quot;Program&quot;);
export var assertIdentifier = assertTypeOf(&quot;Identifier&quot;);
export var assertBlockInstruction = assertTypeOf(&quot;BlockInstruction&quot;);
export var assertCallInstruction = assertTypeOf(&quot;CallInstruction&quot;);
export var assertCallIndirectInstruction = assertTypeOf(&quot;CallIndirectInstruction&quot;);
export var assertByteArray = assertTypeOf(&quot;ByteArray&quot;);
export var assertFunc = assertTypeOf(&quot;Func&quot;);
export var assertInternalBrUnless = assertTypeOf(&quot;InternalBrUnless&quot;);
export var assertInternalGoto = assertTypeOf(&quot;InternalGoto&quot;);
export var assertInternalCallExtern = assertTypeOf(&quot;InternalCallExtern&quot;);
export var assertInternalEndAndReturn = assertTypeOf(&quot;InternalEndAndReturn&quot;);
export var unionTypesMap = {
  Module: [&quot;Node&quot;],
  ModuleMetadata: [&quot;Node&quot;],
  ModuleNameMetadata: [&quot;Node&quot;],
  FunctionNameMetadata: [&quot;Node&quot;],
  LocalNameMetadata: [&quot;Node&quot;],
  BinaryModule: [&quot;Node&quot;],
  QuoteModule: [&quot;Node&quot;],
  SectionMetadata: [&quot;Node&quot;],
  ProducersSectionMetadata: [&quot;Node&quot;],
  ProducerMetadata: [&quot;Node&quot;],
  ProducerMetadataVersionedName: [&quot;Node&quot;],
  LoopInstruction: [&quot;Node&quot;, &quot;Block&quot;, &quot;Instruction&quot;],
  Instr: [&quot;Node&quot;, &quot;Expression&quot;, &quot;Instruction&quot;],
  IfInstruction: [&quot;Node&quot;, &quot;Instruction&quot;],
  StringLiteral: [&quot;Node&quot;, &quot;Expression&quot;],
  NumberLiteral: [&quot;Node&quot;, &quot;NumericLiteral&quot;, &quot;Expression&quot;],
  LongNumberLiteral: [&quot;Node&quot;, &quot;NumericLiteral&quot;, &quot;Expression&quot;],
  FloatLiteral: [&quot;Node&quot;, &quot;NumericLiteral&quot;, &quot;Expression&quot;],
  Elem: [&quot;Node&quot;],
  IndexInFuncSection: [&quot;Node&quot;],
  ValtypeLiteral: [&quot;Node&quot;, &quot;Expression&quot;],
  TypeInstruction: [&quot;Node&quot;, &quot;Instruction&quot;],
  Start: [&quot;Node&quot;],
  GlobalType: [&quot;Node&quot;, &quot;ImportDescr&quot;],
  LeadingComment: [&quot;Node&quot;],
  BlockComment: [&quot;Node&quot;],
  Data: [&quot;Node&quot;],
  Global: [&quot;Node&quot;],
  Table: [&quot;Node&quot;, &quot;ImportDescr&quot;],
  Memory: [&quot;Node&quot;, &quot;ImportDescr&quot;],
  FuncImportDescr: [&quot;Node&quot;, &quot;ImportDescr&quot;],
  ModuleImport: [&quot;Node&quot;],
  ModuleExportDescr: [&quot;Node&quot;],
  ModuleExport: [&quot;Node&quot;],
  Limit: [&quot;Node&quot;],
  Signature: [&quot;Node&quot;],
  Program: [&quot;Node&quot;],
  Identifier: [&quot;Node&quot;, &quot;Expression&quot;],
  BlockInstruction: [&quot;Node&quot;, &quot;Block&quot;, &quot;Instruction&quot;],
  CallInstruction: [&quot;Node&quot;, &quot;Instruction&quot;],
  CallIndirectInstruction: [&quot;Node&quot;, &quot;Instruction&quot;],
  ByteArray: [&quot;Node&quot;],
  Func: [&quot;Node&quot;, &quot;Block&quot;],
  InternalBrUnless: [&quot;Node&quot;, &quot;Intrinsic&quot;],
  InternalGoto: [&quot;Node&quot;, &quot;Intrinsic&quot;],
  InternalCallExtern: [&quot;Node&quot;, &quot;Intrinsic&quot;],
  InternalEndAndReturn: [&quot;Node&quot;, &quot;Intrinsic&quot;]
};
export var nodeAndUnionTypes = [&quot;Module&quot;, &quot;ModuleMetadata&quot;, &quot;ModuleNameMetadata&quot;, &quot;FunctionNameMetadata&quot;, &quot;LocalNameMetadata&quot;, &quot;BinaryModule&quot;, &quot;QuoteModule&quot;, &quot;SectionMetadata&quot;, &quot;ProducersSectionMetadata&quot;, &quot;ProducerMetadata&quot;, &quot;ProducerMetadataVersionedName&quot;, &quot;LoopInstruction&quot;, &quot;Instr&quot;, &quot;IfInstruction&quot;, &quot;StringLiteral&quot;, &quot;NumberLiteral&quot;, &quot;LongNumberLiteral&quot;, &quot;FloatLiteral&quot;, &quot;Elem&quot;, &quot;IndexInFuncSection&quot;, &quot;ValtypeLiteral&quot;, &quot;TypeInstruction&quot;, &quot;Start&quot;, &quot;GlobalType&quot;, &quot;LeadingComment&quot;, &quot;BlockComment&quot;, &quot;Data&quot;, &quot;Global&quot;, &quot;Table&quot;, &quot;Memory&quot;, &quot;FuncImportDescr&quot;, &quot;ModuleImport&quot;, &quot;ModuleExportDescr&quot;, &quot;ModuleExport&quot;, &quot;Limit&quot;, &quot;Signature&quot;, &quot;Program&quot;, &quot;Identifier&quot;, &quot;BlockInstruction&quot;, &quot;CallInstruction&quot;, &quot;CallIndirectInstruction&quot;, &quot;ByteArray&quot;, &quot;Func&quot;, &quot;InternalBrUnless&quot;, &quot;InternalGoto&quot;, &quot;InternalCallExtern&quot;, &quot;InternalEndAndReturn&quot;, &quot;Node&quot;, &quot;Block&quot;, &quot;Instruction&quot;, &quot;Expression&quot;, &quot;NumericLiteral&quot;, &quot;ImportDescr&quot;, &quot;Intrinsic&quot;];</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
