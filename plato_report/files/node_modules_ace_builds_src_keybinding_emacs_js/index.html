<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/ace-builds/src/keybinding-emacs.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/ace-builds/src/keybinding-emacs.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">65.82</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1025</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">85.65</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">17.30</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">define(&quot;ace/occur&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/range&quot;,&quot;ace/search&quot;,&quot;ace/edit_session&quot;,&quot;ace/search_highlight&quot;,&quot;ace/lib/dom&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;./lib/oop&quot;);
var Range = require(&quot;./range&quot;).Range;
var Search = require(&quot;./search&quot;).Search;
var EditSession = require(&quot;./edit_session&quot;).EditSession;
var SearchHighlight = require(&quot;./search_highlight&quot;).SearchHighlight;
function Occur() { }
oop.inherits(Occur, Search);
(function () {
    this.enter = function (editor, options) {
        if (!options.needle)
            return false;
        var pos = editor.getCursorPosition();
        this.displayOccurContent(editor, options);
        var translatedPos = this.originalToOccurPosition(editor.session, pos);
        editor.moveCursorToPosition(translatedPos);
        return true;
    };
    this.exit = function (editor, options) {
        var pos = options.translatePosition &amp;&amp; editor.getCursorPosition();
        var translatedPos = pos &amp;&amp; this.occurToOriginalPosition(editor.session, pos);
        this.displayOriginalContent(editor);
        if (translatedPos)
            editor.moveCursorToPosition(translatedPos);
        return true;
    };
    this.highlight = function (sess, regexp) {
        var hl = sess.$occurHighlight = sess.$occurHighlight || sess.addDynamicMarker(new SearchHighlight(null, &quot;ace_occur-highlight&quot;, &quot;text&quot;));
        hl.setRegexp(regexp);
        sess._emit(&quot;changeBackMarker&quot;); // force highlight layer redraw
    };
    this.displayOccurContent = function (editor, options) {
        this.$originalSession = editor.session;
        var found = this.matchingLines(editor.session, options);
        var lines = found.map(function (foundLine) { return foundLine.content; });
        var occurSession = new EditSession(lines.join(&#039;\n&#039;));
        occurSession.$occur = this;
        occurSession.$occurMatchingLines = found;
        editor.setSession(occurSession);
        this.$useEmacsStyleLineStart = this.$originalSession.$useEmacsStyleLineStart;
        occurSession.$useEmacsStyleLineStart = this.$useEmacsStyleLineStart;
        this.highlight(occurSession, options.re);
        occurSession._emit(&#039;changeBackMarker&#039;);
    };
    this.displayOriginalContent = function (editor) {
        editor.setSession(this.$originalSession);
        this.$originalSession.$useEmacsStyleLineStart = this.$useEmacsStyleLineStart;
    };
    this.originalToOccurPosition = function (session, pos) {
        var lines = session.$occurMatchingLines;
        var nullPos = { row: 0, column: 0 };
        if (!lines)
            return nullPos;
        for (var i = 0; i &lt; lines.length; i++) {
            if (lines[i].row === pos.row)
                return { row: i, column: pos.column };
        }
        return nullPos;
    };
    this.occurToOriginalPosition = function (session, pos) {
        var lines = session.$occurMatchingLines;
        if (!lines || !lines[pos.row])
            return pos;
        return { row: lines[pos.row].row, column: pos.column };
    };
    this.matchingLines = function (session, options) {
        options = oop.mixin({}, options);
        if (!session || !options.needle)
            return [];
        var search = new Search();
        search.set(options);
        return search.findAll(session).reduce(function (lines, range) {
            var row = range.start.row;
            var last = lines[lines.length - 1];
            return last &amp;&amp; last.row === row ?
                lines :
                lines.concat({ row: row, content: session.getLine(row) });
        }, []);
    };
}).call(Occur.prototype);
var dom = require(&#039;./lib/dom&#039;);
dom.importCssString(&quot;.ace_occur-highlight {\n\
    border-radius: 4px;\n\
    background-color: rgba(87, 255, 8, 0.25);\n\
    position: absolute;\n\
    z-index: 4;\n\
    box-sizing: border-box;\n\
    box-shadow: 0 0 4px rgb(91, 255, 50);\n\
}\n\
.ace_dark .ace_occur-highlight {\n\
    background-color: rgb(80, 140, 85);\n\
    box-shadow: 0 0 4px rgb(60, 120, 70);\n\
}\n&quot;, &quot;incremental-occur-highlighting&quot;, false);
exports.Occur = Occur;

});

define(&quot;ace/commands/occur_commands&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/config&quot;,&quot;ace/occur&quot;,&quot;ace/keyboard/hash_handler&quot;,&quot;ace/lib/oop&quot;], function(require, exports, module){var config = require(&quot;../config&quot;), Occur = require(&quot;../occur&quot;).Occur;
var occurStartCommand = {
    name: &quot;occur&quot;,
    exec: function (editor, options) {
        var alreadyInOccur = !!editor.session.$occur;
        var occurSessionActive = new Occur().enter(editor, options);
        if (occurSessionActive &amp;&amp; !alreadyInOccur)
            OccurKeyboardHandler.installIn(editor);
    },
    readOnly: true
};
var occurCommands = [{
        name: &quot;occurexit&quot;,
        bindKey: &#039;esc|Ctrl-G&#039;,
        exec: function (editor) {
            var occur = editor.session.$occur;
            if (!occur)
                return;
            occur.exit(editor, {});
            if (!editor.session.$occur)
                OccurKeyboardHandler.uninstallFrom(editor);
        },
        readOnly: true
    }, {
        name: &quot;occuraccept&quot;,
        bindKey: &#039;enter&#039;,
        exec: function (editor) {
            var occur = editor.session.$occur;
            if (!occur)
                return;
            occur.exit(editor, { translatePosition: true });
            if (!editor.session.$occur)
                OccurKeyboardHandler.uninstallFrom(editor);
        },
        readOnly: true
    }];
var HashHandler = require(&quot;../keyboard/hash_handler&quot;).HashHandler;
var oop = require(&quot;../lib/oop&quot;);
function OccurKeyboardHandler() { }
oop.inherits(OccurKeyboardHandler, HashHandler);
(function () {
    this.isOccurHandler = true;
    this.attach = function (editor) {
        HashHandler.call(this, occurCommands, editor.commands.platform);
        this.$editor = editor;
    };
    var handleKeyboard$super = this.handleKeyboard;
    this.handleKeyboard = function (data, hashId, key, keyCode) {
        var cmd = handleKeyboard$super.call(this, data, hashId, key, keyCode);
        return (cmd &amp;&amp; cmd.command) ? cmd : undefined;
    };
}).call(OccurKeyboardHandler.prototype);
OccurKeyboardHandler.installIn = function (editor) {
    var handler = new this();
    editor.keyBinding.addKeyboardHandler(handler);
    editor.commands.addCommands(occurCommands);
};
OccurKeyboardHandler.uninstallFrom = function (editor) {
    editor.commands.removeCommands(occurCommands);
    var handler = editor.getKeyboardHandler();
    if (handler.isOccurHandler)
        editor.keyBinding.removeKeyboardHandler(handler);
};
exports.occurStartCommand = occurStartCommand;

});

define(&quot;ace/commands/incremental_search_commands&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/config&quot;,&quot;ace/lib/oop&quot;,&quot;ace/keyboard/hash_handler&quot;,&quot;ace/commands/occur_commands&quot;], function(require, exports, module){var config = require(&quot;../config&quot;);
var oop = require(&quot;../lib/oop&quot;);
var HashHandler = require(&quot;../keyboard/hash_handler&quot;).HashHandler;
var occurStartCommand = require(&quot;./occur_commands&quot;).occurStartCommand;
exports.iSearchStartCommands = [{
        name: &quot;iSearch&quot;,
        bindKey: { win: &quot;Ctrl-F&quot;, mac: &quot;Command-F&quot; },
        exec: function (editor, options) {
            config.loadModule([&quot;core&quot;, &quot;ace/incremental_search&quot;], function (e) {
                var iSearch = e.iSearch = e.iSearch || new e.IncrementalSearch();
                iSearch.activate(editor, options.backwards);
                if (options.jumpToFirstMatch)
                    iSearch.next(options);
            });
        },
        readOnly: true
    }, {
        name: &quot;iSearchBackwards&quot;,
        exec: function (editor, jumpToNext) { editor.execCommand(&#039;iSearch&#039;, { backwards: true }); },
        readOnly: true
    }, {
        name: &quot;iSearchAndGo&quot;,
        bindKey: { win: &quot;Ctrl-K&quot;, mac: &quot;Command-G&quot; },
        exec: function (editor, jumpToNext) { editor.execCommand(&#039;iSearch&#039;, { jumpToFirstMatch: true, useCurrentOrPrevSearch: true }); },
        readOnly: true
    }, {
        name: &quot;iSearchBackwardsAndGo&quot;,
        bindKey: { win: &quot;Ctrl-Shift-K&quot;, mac: &quot;Command-Shift-G&quot; },
        exec: function (editor) { editor.execCommand(&#039;iSearch&#039;, { jumpToFirstMatch: true, backwards: true, useCurrentOrPrevSearch: true }); },
        readOnly: true
    }];
exports.iSearchCommands = [{
        name: &quot;restartSearch&quot;,
        bindKey: { win: &quot;Ctrl-F&quot;, mac: &quot;Command-F&quot; },
        exec: function (iSearch) {
            iSearch.cancelSearch(true);
        }
    }, {
        name: &quot;searchForward&quot;,
        bindKey: { win: &quot;Ctrl-S|Ctrl-K&quot;, mac: &quot;Ctrl-S|Command-G&quot; },
        exec: function (iSearch, options) {
            options.useCurrentOrPrevSearch = true;
            iSearch.next(options);
        }
    }, {
        name: &quot;searchBackward&quot;,
        bindKey: { win: &quot;Ctrl-R|Ctrl-Shift-K&quot;, mac: &quot;Ctrl-R|Command-Shift-G&quot; },
        exec: function (iSearch, options) {
            options.useCurrentOrPrevSearch = true;
            options.backwards = true;
            iSearch.next(options);
        }
    }, {
        name: &quot;extendSearchTerm&quot;,
        exec: function (iSearch, string) {
            iSearch.addString(string);
        }
    }, {
        name: &quot;extendSearchTermSpace&quot;,
        bindKey: &quot;space&quot;,
        exec: function (iSearch) { iSearch.addString(&#039; &#039;); }
    }, {
        name: &quot;shrinkSearchTerm&quot;,
        bindKey: &quot;backspace&quot;,
        exec: function (iSearch) {
            iSearch.removeChar();
        }
    }, {
        name: &#039;confirmSearch&#039;,
        bindKey: &#039;return&#039;,
        exec: function (iSearch) { iSearch.deactivate(); }
    }, {
        name: &#039;cancelSearch&#039;,
        bindKey: &#039;esc|Ctrl-G&#039;,
        exec: function (iSearch) { iSearch.deactivate(true); }
    }, {
        name: &#039;occurisearch&#039;,
        bindKey: &#039;Ctrl-O&#039;,
        exec: function (iSearch) {
            var options = oop.mixin({}, iSearch.$options);
            iSearch.deactivate();
            occurStartCommand.exec(iSearch.$editor, options);
        }
    }, {
        name: &quot;yankNextWord&quot;,
        bindKey: &quot;Ctrl-w&quot;,
        exec: function (iSearch) {
            var ed = iSearch.$editor, range = ed.selection.getRangeOfMovements(function (sel) { sel.moveCursorWordRight(); }), string = ed.session.getTextRange(range);
            iSearch.addString(string);
        }
    }, {
        name: &quot;yankNextChar&quot;,
        bindKey: &quot;Ctrl-Alt-y&quot;,
        exec: function (iSearch) {
            var ed = iSearch.$editor, range = ed.selection.getRangeOfMovements(function (sel) { sel.moveCursorRight(); }), string = ed.session.getTextRange(range);
            iSearch.addString(string);
        }
    }, {
        name: &#039;recenterTopBottom&#039;,
        bindKey: &#039;Ctrl-l&#039;,
        exec: function (iSearch) { iSearch.$editor.execCommand(&#039;recenterTopBottom&#039;); }
    }, {
        name: &#039;selectAllMatches&#039;,
        bindKey: &#039;Ctrl-space&#039;,
        exec: function (iSearch) {
            var ed = iSearch.$editor, hl = ed.session.$isearchHighlight, ranges = hl &amp;&amp; hl.cache ? hl.cache
                .reduce(function (ranges, ea) {
                return ranges.concat(ea ? ea : []);
            }, []) : [];
            iSearch.deactivate(false);
            ranges.forEach(ed.selection.addRange.bind(ed.selection));
        }
    }, {
        name: &#039;searchAsRegExp&#039;,
        bindKey: &#039;Alt-r&#039;,
        exec: function (iSearch) {
            iSearch.convertNeedleToRegExp();
        }
    }].map(function (cmd) {
    cmd.readOnly = true;
    cmd.isIncrementalSearchCommand = true;
    cmd.scrollIntoView = &quot;animate-cursor&quot;;
    return cmd;
});
function IncrementalSearchKeyboardHandler(iSearch) {
    this.$iSearch = iSearch;
}
oop.inherits(IncrementalSearchKeyboardHandler, HashHandler);
(function () {
    this.attach = function (editor) {
        var iSearch = this.$iSearch;
        HashHandler.call(this, exports.iSearchCommands, editor.commands.platform);
        this.$commandExecHandler = editor.commands.on(&#039;exec&#039;, function (e) {
            if (!e.command.isIncrementalSearchCommand)
                return iSearch.deactivate();
            e.stopPropagation();
            e.preventDefault();
            var scrollTop = editor.session.getScrollTop();
            var result = e.command.exec(iSearch, e.args || {});
            editor.renderer.scrollCursorIntoView(null, 0.5);
            editor.renderer.animateScrolling(scrollTop);
            return result;
        });
    };
    this.detach = function (editor) {
        if (!this.$commandExecHandler)
            return;
        editor.commands.off(&#039;exec&#039;, this.$commandExecHandler);
        delete this.$commandExecHandler;
    };
    var handleKeyboard$super = this.handleKeyboard;
    this.handleKeyboard = function (data, hashId, key, keyCode) {
        if (((hashId === 1 /*ctrl*/ || hashId === 8 /*command*/) &amp;&amp; key === &#039;v&#039;)
            || (hashId === 1 /*ctrl*/ &amp;&amp; key === &#039;y&#039;))
            return null;
        var cmd = handleKeyboard$super.call(this, data, hashId, key, keyCode);
        if (cmd &amp;&amp; cmd.command) {
            return cmd;
        }
        if (hashId == -1) {
            var extendCmd = this.commands.extendSearchTerm;
            if (extendCmd) {
                return { command: extendCmd, args: key };
            }
        }
        return false;
    };
}).call(IncrementalSearchKeyboardHandler.prototype);
exports.IncrementalSearchKeyboardHandler = IncrementalSearchKeyboardHandler;

});

define(&quot;ace/incremental_search&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/range&quot;,&quot;ace/search&quot;,&quot;ace/search_highlight&quot;,&quot;ace/commands/incremental_search_commands&quot;,&quot;ace/lib/dom&quot;,&quot;ace/commands/command_manager&quot;,&quot;ace/editor&quot;,&quot;ace/config&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;./lib/oop&quot;);
var Range = require(&quot;./range&quot;).Range;
var Search = require(&quot;./search&quot;).Search;
var SearchHighlight = require(&quot;./search_highlight&quot;).SearchHighlight;
var iSearchCommandModule = require(&quot;./commands/incremental_search_commands&quot;);
var ISearchKbd = iSearchCommandModule.IncrementalSearchKeyboardHandler;
function IncrementalSearch() {
    this.$options = { wrap: false, skipCurrent: false };
    this.$keyboardHandler = new ISearchKbd(this);
}
oop.inherits(IncrementalSearch, Search);
function isRegExp(obj) {
    return obj instanceof RegExp;
}
function regExpToObject(re) {
    var string = String(re), start = string.indexOf(&#039;/&#039;), flagStart = string.lastIndexOf(&#039;/&#039;);
    return {
        expression: string.slice(start + 1, flagStart),
        flags: string.slice(flagStart + 1)
    };
}
function stringToRegExp(string, flags) {
    try {
        return new RegExp(string, flags);
    }
    catch (e) {
        return string;
    }
}
function objectToRegExp(obj) {
    return stringToRegExp(obj.expression, obj.flags);
}
(function () {
    this.activate = function (editor, backwards) {
        this.$editor = editor;
        this.$startPos = this.$currentPos = editor.getCursorPosition();
        this.$options.needle = &#039;&#039;;
        this.$options.backwards = backwards;
        editor.keyBinding.addKeyboardHandler(this.$keyboardHandler);
        this.$originalEditorOnPaste = editor.onPaste;
        editor.onPaste = this.onPaste.bind(this);
        this.$mousedownHandler = editor.on(&#039;mousedown&#039;, this.onMouseDown.bind(this));
        this.selectionFix(editor);
        this.statusMessage(true);
    };
    this.deactivate = function (reset) {
        this.cancelSearch(reset);
        var editor = this.$editor;
        editor.keyBinding.removeKeyboardHandler(this.$keyboardHandler);
        if (this.$mousedownHandler) {
            editor.off(&#039;mousedown&#039;, this.$mousedownHandler);
            delete this.$mousedownHandler;
        }
        editor.onPaste = this.$originalEditorOnPaste;
        this.message(&#039;&#039;);
    };
    this.selectionFix = function (editor) {
        if (editor.selection.isEmpty() &amp;&amp; !editor.session.$emacsMark) {
            editor.clearSelection();
        }
    };
    this.highlight = function (regexp) {
        var sess = this.$editor.session, hl = sess.$isearchHighlight = sess.$isearchHighlight || sess.addDynamicMarker(new SearchHighlight(null, &quot;ace_isearch-result&quot;, &quot;text&quot;));
        hl.setRegexp(regexp);
        sess._emit(&quot;changeBackMarker&quot;); // force highlight layer redraw
    };
    this.cancelSearch = function (reset) {
        var e = this.$editor;
        this.$prevNeedle = this.$options.needle;
        this.$options.needle = &#039;&#039;;
        if (reset) {
            e.moveCursorToPosition(this.$startPos);
            this.$currentPos = this.$startPos;
        }
        else {
            e.pushEmacsMark &amp;&amp; e.pushEmacsMark(this.$startPos, false);
        }
        this.highlight(null);
        return Range.fromPoints(this.$currentPos, this.$currentPos);
    };
    this.highlightAndFindWithNeedle = function (moveToNext, needleUpdateFunc) {
        if (!this.$editor)
            return null;
        var options = this.$options;
        if (needleUpdateFunc) {
            options.needle = needleUpdateFunc.call(this, options.needle || &#039;&#039;) || &#039;&#039;;
        }
        if (options.needle.length === 0) {
            this.statusMessage(true);
            return this.cancelSearch(true);
        }
        options.start = this.$currentPos;
        var session = this.$editor.session, found = this.find(session), shouldSelect = this.$editor.emacsMark ?
            !!this.$editor.emacsMark() : !this.$editor.selection.isEmpty();
        if (found) {
            if (options.backwards)
                found = Range.fromPoints(found.end, found.start);
            this.$editor.selection.setRange(Range.fromPoints(shouldSelect ? this.$startPos : found.end, found.end));
            if (moveToNext)
                this.$currentPos = found.end;
            this.highlight(options.re);
        }
        this.statusMessage(found);
        return found;
    };
    this.addString = function (s) {
        return this.highlightAndFindWithNeedle(false, function (needle) {
            if (!isRegExp(needle))
                return needle + s;
            var reObj = regExpToObject(needle);
            reObj.expression += s;
            return objectToRegExp(reObj);
        });
    };
    this.removeChar = function (c) {
        return this.highlightAndFindWithNeedle(false, function (needle) {
            if (!isRegExp(needle))
                return needle.substring(0, needle.length - 1);
            var reObj = regExpToObject(needle);
            reObj.expression = reObj.expression.substring(0, reObj.expression.length - 1);
            return objectToRegExp(reObj);
        });
    };
    this.next = function (options) {
        options = options || {};
        this.$options.backwards = !!options.backwards;
        this.$currentPos = this.$editor.getCursorPosition();
        return this.highlightAndFindWithNeedle(true, function (needle) {
            return options.useCurrentOrPrevSearch &amp;&amp; needle.length === 0 ?
                this.$prevNeedle || &#039;&#039; : needle;
        });
    };
    this.onMouseDown = function (evt) {
        this.deactivate();
        return true;
    };
    this.onPaste = function (text) {
        this.addString(text);
    };
    this.convertNeedleToRegExp = function () {
        return this.highlightAndFindWithNeedle(false, function (needle) {
            return isRegExp(needle) ? needle : stringToRegExp(needle, &#039;ig&#039;);
        });
    };
    this.convertNeedleToString = function () {
        return this.highlightAndFindWithNeedle(false, function (needle) {
            return isRegExp(needle) ? regExpToObject(needle).expression : needle;
        });
    };
    this.statusMessage = function (found) {
        var options = this.$options, msg = &#039;&#039;;
        msg += options.backwards ? &#039;reverse-&#039; : &#039;&#039;;
        msg += &#039;isearch: &#039; + options.needle;
        msg += found ? &#039;&#039; : &#039; (not found)&#039;;
        this.message(msg);
    };
    this.message = function (msg) {
        if (this.$editor.showCommandLine) {
            this.$editor.showCommandLine(msg);
            this.$editor.focus();
        }
    };
}).call(IncrementalSearch.prototype);
exports.IncrementalSearch = IncrementalSearch;
var dom = require(&#039;./lib/dom&#039;);
dom.importCssString(&quot;\n.ace_marker-layer .ace_isearch-result {\n  position: absolute;\n  z-index: 6;\n  box-sizing: border-box;\n}\ndiv.ace_isearch-result {\n  border-radius: 4px;\n  background-color: rgba(255, 200, 0, 0.5);\n  box-shadow: 0 0 4px rgb(255, 200, 0);\n}\n.ace_dark div.ace_isearch-result {\n  background-color: rgb(100, 110, 160);\n  box-shadow: 0 0 4px rgb(80, 90, 140);\n}&quot;, &quot;incremental-search-highlighting&quot;, false);
var commands = require(&quot;./commands/command_manager&quot;);
(function () {
    this.setupIncrementalSearch = function (editor, val) {
        if (this.usesIncrementalSearch == val)
            return;
        this.usesIncrementalSearch = val;
        var iSearchCommands = iSearchCommandModule.iSearchStartCommands;
        var method = val ? &#039;addCommands&#039; : &#039;removeCommands&#039;;
        this[method](iSearchCommands);
    };
}).call(commands.CommandManager.prototype);
var Editor = require(&quot;./editor&quot;).Editor;
require(&quot;./config&quot;).defineOptions(Editor.prototype, &quot;editor&quot;, {
    useIncrementalSearch: {
        set: function (val) {
            this.keyBinding.$handlers.forEach(function (handler) {
                if (handler.setupIncrementalSearch) {
                    handler.setupIncrementalSearch(this, val);
                }
            });
            this._emit(&#039;incrementalSearchSettingChanged&#039;, { isEnabled: val });
        }
    }
});

});

define(&quot;ace/keyboard/emacs&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/dom&quot;,&quot;ace/incremental_search&quot;,&quot;ace/commands/incremental_search_commands&quot;,&quot;ace/keyboard/hash_handler&quot;,&quot;ace/lib/keys&quot;], function(require, exports, module){&quot;use strict&quot;;
var dom = require(&quot;../lib/dom&quot;);
require(&quot;../incremental_search&quot;);
var iSearchCommandModule = require(&quot;../commands/incremental_search_commands&quot;);
var HashHandler = require(&quot;./hash_handler&quot;).HashHandler;
exports.handler = new HashHandler();
exports.handler.isEmacs = true;
exports.handler.$id = &quot;ace/keyboard/emacs&quot;;
dom.importCssString(&quot;\n.emacs-mode .ace_cursor{\n    border: 1px rgba(50,250,50,0.8) solid!important;\n    box-sizing: border-box!important;\n    background-color: rgba(0,250,0,0.9);\n    opacity: 0.5;\n}\n.emacs-mode .ace_hidden-cursors .ace_cursor{\n    opacity: 1;\n    background-color: transparent;\n}\n.emacs-mode .ace_overwrite-cursors .ace_cursor {\n    opacity: 1;\n    background-color: transparent;\n    border-width: 0 0 2px 2px !important;\n}\n.emacs-mode .ace_text-layer {\n    z-index: 4\n}\n.emacs-mode .ace_cursor-layer {\n    z-index: 2\n}&quot;, &#039;emacsMode&#039;);
var $formerLongWords;
var $formerLineStart;
exports.handler.attach = function (editor) {
    $formerLongWords = editor.session.$selectLongWords;
    editor.session.$selectLongWords = true;
    $formerLineStart = editor.session.$useEmacsStyleLineStart;
    editor.session.$useEmacsStyleLineStart = true;
    editor.session.$emacsMark = null; // the active mark
    editor.session.$emacsMarkRing = editor.session.$emacsMarkRing || [];
    editor.emacsMark = function () {
        return this.session.$emacsMark;
    };
    editor.setEmacsMark = function (p) {
        this.session.$emacsMark = p;
    };
    editor.pushEmacsMark = function (p, activate) {
        var prevMark = this.session.$emacsMark;
        if (prevMark)
            this.session.$emacsMarkRing.push(prevMark);
        if (!p || activate)
            this.setEmacsMark(p);
        else
            this.session.$emacsMarkRing.push(p);
    };
    editor.popEmacsMark = function () {
        var mark = this.emacsMark();
        if (mark) {
            this.setEmacsMark(null);
            return mark;
        }
        return this.session.$emacsMarkRing.pop();
    };
    editor.getLastEmacsMark = function (p) {
        return this.session.$emacsMark || this.session.$emacsMarkRing.slice(-1)[0];
    };
    editor.emacsMarkForSelection = function (replacement) {
        var sel = this.selection, multiRangeLength = this.multiSelect ?
            this.multiSelect.getAllRanges().length : 1, selIndex = sel.index || 0, markRing = this.session.$emacsMarkRing, markIndex = markRing.length - (multiRangeLength - selIndex), lastMark = markRing[markIndex] || sel.anchor;
        if (replacement) {
            markRing.splice(markIndex, 1, &quot;row&quot; in replacement &amp;&amp; &quot;column&quot; in replacement ?
                replacement : undefined);
        }
        return lastMark;
    };
    editor.on(&quot;click&quot;, $resetMarkMode);
    editor.on(&quot;changeSession&quot;, $kbSessionChange);
    editor.renderer.$blockCursor = true;
    editor.setStyle(&quot;emacs-mode&quot;);
    editor.commands.addCommands(commands);
    exports.handler.platform = editor.commands.platform;
    editor.$emacsModeHandler = this;
    editor.on(&#039;copy&#039;, this.onCopy);
    editor.on(&#039;paste&#039;, this.onPaste);
};
exports.handler.detach = function (editor) {
    editor.renderer.$blockCursor = false;
    editor.session.$selectLongWords = $formerLongWords;
    editor.session.$useEmacsStyleLineStart = $formerLineStart;
    editor.off(&quot;click&quot;, $resetMarkMode);
    editor.off(&quot;changeSession&quot;, $kbSessionChange);
    editor.unsetStyle(&quot;emacs-mode&quot;);
    editor.commands.removeCommands(commands);
    editor.off(&#039;copy&#039;, this.onCopy);
    editor.off(&#039;paste&#039;, this.onPaste);
    editor.$emacsModeHandler = null;
};
var $kbSessionChange = function (e) {
    if (e.oldSession) {
        e.oldSession.$selectLongWords = $formerLongWords;
        e.oldSession.$useEmacsStyleLineStart = $formerLineStart;
    }
    $formerLongWords = e.session.$selectLongWords;
    e.session.$selectLongWords = true;
    $formerLineStart = e.session.$useEmacsStyleLineStart;
    e.session.$useEmacsStyleLineStart = true;
    if (!e.session.hasOwnProperty(&#039;$emacsMark&#039;))
        e.session.$emacsMark = null;
    if (!e.session.hasOwnProperty(&#039;$emacsMarkRing&#039;))
        e.session.$emacsMarkRing = [];
};
var $resetMarkMode = function (e) {
    e.editor.session.$emacsMark = null;
};
var keys = require(&quot;../lib/keys&quot;).KEY_MODS;
var eMods = { C: &quot;ctrl&quot;, S: &quot;shift&quot;, M: &quot;alt&quot;, CMD: &quot;command&quot; };
var combinations = [&quot;C-S-M-CMD&quot;,
    &quot;S-M-CMD&quot;, &quot;C-M-CMD&quot;, &quot;C-S-CMD&quot;, &quot;C-S-M&quot;,
    &quot;M-CMD&quot;, &quot;S-CMD&quot;, &quot;S-M&quot;, &quot;C-CMD&quot;, &quot;C-M&quot;, &quot;C-S&quot;,
    &quot;CMD&quot;, &quot;M&quot;, &quot;S&quot;, &quot;C&quot;];
combinations.forEach(function (c) {
    var hashId = 0;
    c.split(&quot;-&quot;).forEach(function (c) {
        hashId = hashId | keys[eMods[c]];
    });
    eMods[hashId] = c.toLowerCase() + &quot;-&quot;;
});
exports.handler.onCopy = function (e, editor) {
    if (editor.$handlesEmacsOnCopy)
        return;
    editor.$handlesEmacsOnCopy = true;
    exports.handler.commands.killRingSave.exec(editor);
    editor.$handlesEmacsOnCopy = false;
};
exports.handler.onPaste = function (e, editor) {
    editor.pushEmacsMark(editor.getCursorPosition());
};
exports.handler.bindKey = function (key, command) {
    if (typeof key == &quot;object&quot;)
        key = key[this.platform];
    if (!key)
        return;
    var ckb = this.commandKeyBinding;
    key.split(&quot;|&quot;).forEach(function (keyPart) {
        keyPart = keyPart.toLowerCase();
        ckb[keyPart] = command;
        var keyParts = keyPart.split(&quot; &quot;).slice(0, -1);
        keyParts.reduce(function (keyMapKeys, keyPart, i) {
            var prefix = keyMapKeys[i - 1] ? keyMapKeys[i - 1] + &#039; &#039; : &#039;&#039;;
            return keyMapKeys.concat([prefix + keyPart]);
        }, []).forEach(function (keyPart) {
            if (!ckb[keyPart])
                ckb[keyPart] = &quot;null&quot;;
        });
    }, this);
};
exports.handler.getStatusText = function (editor, data) {
    var str = &quot;&quot;;
    if (data.count)
        str += data.count;
    if (data.keyChain)
        str += &quot; &quot; + data.keyChain;
    return str;
};
exports.handler.handleKeyboard = function (data, hashId, key, keyCode) {
    if (keyCode === -1)
        return undefined;
    var editor = data.editor;
    editor._signal(&quot;changeStatus&quot;);
    if (hashId == -1) {
        editor.pushEmacsMark();
        if (data.count) {
            var str = new Array(data.count + 1).join(key);
            data.count = null;
            return { command: &quot;insertstring&quot;, args: str };
        }
    }
    var modifier = eMods[hashId];
    if (modifier == &quot;c-&quot; || data.count) {
        var count = parseInt(key[key.length - 1]);
        if (typeof count === &#039;number&#039; &amp;&amp; !isNaN(count)) {
            data.count = Math.max(data.count, 0) || 0;
            data.count = 10 * data.count + count;
            return { command: &quot;null&quot; };
        }
    }
    if (modifier)
        key = modifier + key;
    if (data.keyChain)
        key = data.keyChain += &quot; &quot; + key;
    var command = this.commandKeyBinding[key];
    data.keyChain = command == &quot;null&quot; ? key : &quot;&quot;;
    if (!command)
        return undefined;
    if (command === &quot;null&quot;)
        return { command: &quot;null&quot; };
    if (command === &quot;universalArgument&quot;) {
        data.count = -4;
        return { command: &quot;null&quot; };
    }
    var args;
    if (typeof command !== &quot;string&quot;) {
        args = command.args;
        if (command.command)
            command = command.command;
        if (command === &quot;goorselect&quot;) {
            command = editor.emacsMark() ? args[1] : args[0];
            args = null;
        }
    }
    if (typeof command === &quot;string&quot;) {
        if (command === &quot;insertstring&quot; ||
            command === &quot;splitline&quot; ||
            command === &quot;togglecomment&quot;) {
            editor.pushEmacsMark();
        }
        command = this.commands[command] || editor.commands.commands[command];
        if (!command)
            return undefined;
    }
    if (!command.readOnly &amp;&amp; !command.isYank)
        data.lastCommand = null;
    if (!command.readOnly &amp;&amp; editor.emacsMark())
        editor.setEmacsMark(null);
    if (data.count) {
        var count = data.count;
        data.count = 0;
        if (!command || !command.handlesCount) {
            return {
                args: args,
                command: {
                    exec: function (editor, args) {
                        for (var i = 0; i &lt; count; i++)
                            command.exec(editor, args);
                    },
                    multiSelectAction: command.multiSelectAction
                }
            };
        }
        else {
            if (!args)
                args = {};
            if (typeof args === &#039;object&#039;)
                args.count = count;
        }
    }
    return { command: command, args: args };
};
exports.emacsKeys = {
    &quot;Up|C-p&quot;: { command: &quot;goorselect&quot;, args: [&quot;golineup&quot;, &quot;selectup&quot;] },
    &quot;Down|C-n&quot;: { command: &quot;goorselect&quot;, args: [&quot;golinedown&quot;, &quot;selectdown&quot;] },
    &quot;Left|C-b&quot;: { command: &quot;goorselect&quot;, args: [&quot;gotoleft&quot;, &quot;selectleft&quot;] },
    &quot;Right|C-f&quot;: { command: &quot;goorselect&quot;, args: [&quot;gotoright&quot;, &quot;selectright&quot;] },
    &quot;C-Left|M-b&quot;: { command: &quot;goorselect&quot;, args: [&quot;gotowordleft&quot;, &quot;selectwordleft&quot;] },
    &quot;C-Right|M-f&quot;: { command: &quot;goorselect&quot;, args: [&quot;gotowordright&quot;, &quot;selectwordright&quot;] },
    &quot;Home|C-a&quot;: { command: &quot;goorselect&quot;, args: [&quot;gotolinestart&quot;, &quot;selecttolinestart&quot;] },
    &quot;End|C-e&quot;: { command: &quot;goorselect&quot;, args: [&quot;gotolineend&quot;, &quot;selecttolineend&quot;] },
    &quot;C-Home|S-M-,&quot;: { command: &quot;goorselect&quot;, args: [&quot;gotostart&quot;, &quot;selecttostart&quot;] },
    &quot;C-End|S-M-.&quot;: { command: &quot;goorselect&quot;, args: [&quot;gotoend&quot;, &quot;selecttoend&quot;] },
    &quot;S-Up|S-C-p&quot;: &quot;selectup&quot;,
    &quot;S-Down|S-C-n&quot;: &quot;selectdown&quot;,
    &quot;S-Left|S-C-b&quot;: &quot;selectleft&quot;,
    &quot;S-Right|S-C-f&quot;: &quot;selectright&quot;,
    &quot;S-C-Left|S-M-b&quot;: &quot;selectwordleft&quot;,
    &quot;S-C-Right|S-M-f&quot;: &quot;selectwordright&quot;,
    &quot;S-Home|S-C-a&quot;: &quot;selecttolinestart&quot;,
    &quot;S-End|S-C-e&quot;: &quot;selecttolineend&quot;,
    &quot;S-C-Home&quot;: &quot;selecttostart&quot;,
    &quot;S-C-End&quot;: &quot;selecttoend&quot;,
    &quot;C-l&quot;: &quot;recenterTopBottom&quot;,
    &quot;M-s&quot;: &quot;centerselection&quot;,
    &quot;M-g&quot;: &quot;gotoline&quot;,
    &quot;C-x C-p&quot;: &quot;selectall&quot;,
    &quot;C-Down&quot;: { command: &quot;goorselect&quot;, args: [&quot;gotopagedown&quot;, &quot;selectpagedown&quot;] },
    &quot;C-Up&quot;: { command: &quot;goorselect&quot;, args: [&quot;gotopageup&quot;, &quot;selectpageup&quot;] },
    &quot;PageDown|C-v&quot;: { command: &quot;goorselect&quot;, args: [&quot;gotopagedown&quot;, &quot;selectpagedown&quot;] },
    &quot;PageUp|M-v&quot;: { command: &quot;goorselect&quot;, args: [&quot;gotopageup&quot;, &quot;selectpageup&quot;] },
    &quot;S-C-Down&quot;: &quot;selectpagedown&quot;,
    &quot;S-C-Up&quot;: &quot;selectpageup&quot;,
    &quot;C-s&quot;: &quot;iSearch&quot;,
    &quot;C-r&quot;: &quot;iSearchBackwards&quot;,
    &quot;M-C-s&quot;: &quot;findnext&quot;,
    &quot;M-C-r&quot;: &quot;findprevious&quot;,
    &quot;S-M-5&quot;: &quot;replace&quot;,
    &quot;Backspace&quot;: &quot;backspace&quot;,
    &quot;Delete|C-d&quot;: &quot;del&quot;,
    &quot;Return|C-m&quot;: { command: &quot;insertstring&quot;, args: &quot;\n&quot; },
    &quot;C-o&quot;: &quot;splitline&quot;,
    &quot;M-d|C-Delete&quot;: { command: &quot;killWord&quot;, args: &quot;right&quot; },
    &quot;C-Backspace|M-Backspace|M-Delete&quot;: { command: &quot;killWord&quot;, args: &quot;left&quot; },
    &quot;C-k&quot;: &quot;killLine&quot;,
    &quot;C-y|S-Delete&quot;: &quot;yank&quot;,
    &quot;M-y&quot;: &quot;yankRotate&quot;,
    &quot;C-g&quot;: &quot;keyboardQuit&quot;,
    &quot;C-w|C-S-W&quot;: &quot;killRegion&quot;,
    &quot;M-w&quot;: &quot;killRingSave&quot;,
    &quot;C-Space&quot;: &quot;setMark&quot;,
    &quot;C-x C-x&quot;: &quot;exchangePointAndMark&quot;,
    &quot;C-t&quot;: &quot;transposeletters&quot;,
    &quot;M-u&quot;: &quot;touppercase&quot;,
    &quot;M-l&quot;: &quot;tolowercase&quot;,
    &quot;M-/&quot;: &quot;autocomplete&quot;,
    &quot;C-u&quot;: &quot;universalArgument&quot;,
    &quot;M-;&quot;: &quot;togglecomment&quot;,
    &quot;C-/|C-x u|S-C--|C-z&quot;: &quot;undo&quot;,
    &quot;S-C-/|S-C-x u|C--|S-C-z&quot;: &quot;redo&quot;,
    &quot;C-x r&quot;: &quot;selectRectangularRegion&quot;,
    &quot;M-x&quot;: { command: &quot;focusCommandLine&quot;, args: &quot;M-x &quot; }
};
exports.handler.bindKeys(exports.emacsKeys);
exports.handler.addCommands({
    recenterTopBottom: function (editor) {
        var renderer = editor.renderer;
        var pos = renderer.$cursorLayer.getPixelPosition();
        var h = renderer.$size.scrollerHeight - renderer.lineHeight;
        var scrollTop = renderer.scrollTop;
        if (Math.abs(pos.top - scrollTop) &lt; 2) {
            scrollTop = pos.top - h;
        }
        else if (Math.abs(pos.top - scrollTop - h * 0.5) &lt; 2) {
            scrollTop = pos.top;
        }
        else {
            scrollTop = pos.top - h * 0.5;
        }
        editor.session.setScrollTop(scrollTop);
    },
    selectRectangularRegion: function (editor) {
        editor.multiSelect.toggleBlockSelection();
    },
    setMark: {
        exec: function (editor, args) {
            if (args &amp;&amp; args.count) {
                if (editor.inMultiSelectMode)
                    editor.forEachSelection(moveToMark);
                else
                    moveToMark();
                moveToMark();
                return;
            }
            var mark = editor.emacsMark(), ranges = editor.selection.getAllRanges(), rangePositions = ranges.map(function (r) { return { row: r.start.row, column: r.start.column }; }), transientMarkModeActive = true, hasNoSelection = ranges.every(function (range) { return range.isEmpty(); });
            if (transientMarkModeActive &amp;&amp; (mark || !hasNoSelection)) {
                if (editor.inMultiSelectMode)
                    editor.forEachSelection({ exec: editor.clearSelection.bind(editor) });
                else
                    editor.clearSelection();
                if (mark)
                    editor.pushEmacsMark(null);
                return;
            }
            if (!mark) {
                rangePositions.forEach(function (pos) { editor.pushEmacsMark(pos); });
                editor.setEmacsMark(rangePositions[rangePositions.length - 1]);
                return;
            }
            function moveToMark() {
                var mark = editor.popEmacsMark();
                mark &amp;&amp; editor.moveCursorToPosition(mark);
            }
        },
        readOnly: true,
        handlesCount: true
    },
    exchangePointAndMark: {
        exec: function exchangePointAndMark$exec(editor, args) {
            var sel = editor.selection;
            if (!args.count &amp;&amp; !sel.isEmpty()) { // just invert selection
                sel.setSelectionRange(sel.getRange(), !sel.isBackwards());
                return;
            }
            if (args.count) { // replace mark and point
                var pos = { row: sel.lead.row, column: sel.lead.column };
                sel.clearSelection();
                sel.moveCursorToPosition(editor.emacsMarkForSelection(pos));
            }
            else { // create selection to last mark
                sel.selectToPosition(editor.emacsMarkForSelection());
            }
        },
        readOnly: true,
        handlesCount: true,
        multiSelectAction: &quot;forEach&quot;
    },
    killWord: {
        exec: function (editor, dir) {
            editor.clearSelection();
            if (dir == &quot;left&quot;)
                editor.selection.selectWordLeft();
            else
                editor.selection.selectWordRight();
            var range = editor.getSelectionRange();
            var text = editor.session.getTextRange(range);
            exports.killRing.add(text);
            editor.session.remove(range);
            editor.clearSelection();
        },
        multiSelectAction: &quot;forEach&quot;
    },
    killLine: function (editor) {
        editor.pushEmacsMark(null);
        editor.clearSelection();
        var range = editor.getSelectionRange();
        var line = editor.session.getLine(range.start.row);
        range.end.column = line.length;
        line = line.substr(range.start.column);
        var foldLine = editor.session.getFoldLine(range.start.row);
        if (foldLine &amp;&amp; range.end.row != foldLine.end.row) {
            range.end.row = foldLine.end.row;
            line = &quot;x&quot;;
        }
        if (/^\s*$/.test(line)) {
            range.end.row++;
            line = editor.session.getLine(range.end.row);
            range.end.column = /^\s*$/.test(line) ? line.length : 0;
        }
        var text = editor.session.getTextRange(range);
        if (editor.prevOp.command == this)
            exports.killRing.append(text);
        else
            exports.killRing.add(text);
        editor.session.remove(range);
        editor.clearSelection();
    },
    yank: function (editor) {
        editor.onPaste(exports.killRing.get() || &#039;&#039;);
        editor.keyBinding.$data.lastCommand = &quot;yank&quot;;
    },
    yankRotate: function (editor) {
        if (editor.keyBinding.$data.lastCommand != &quot;yank&quot;)
            return;
        editor.undo();
        editor.session.$emacsMarkRing.pop(); // also undo recording mark
        editor.onPaste(exports.killRing.rotate());
        editor.keyBinding.$data.lastCommand = &quot;yank&quot;;
    },
    killRegion: {
        exec: function (editor) {
            exports.killRing.add(editor.getCopyText());
            editor.commands.byName.cut.exec(editor);
            editor.setEmacsMark(null);
        },
        readOnly: true,
        multiSelectAction: &quot;forEach&quot;
    },
    killRingSave: {
        exec: function (editor) {
            editor.$handlesEmacsOnCopy = true;
            var marks = editor.session.$emacsMarkRing.slice(), deselectedMarks = [];
            exports.killRing.add(editor.getCopyText());
            setTimeout(function () {
                function deselect() {
                    var sel = editor.selection, range = sel.getRange(), pos = sel.isBackwards() ? range.end : range.start;
                    deselectedMarks.push({ row: pos.row, column: pos.column });
                    sel.clearSelection();
                }
                editor.$handlesEmacsOnCopy = false;
                if (editor.inMultiSelectMode)
                    editor.forEachSelection({ exec: deselect });
                else
                    deselect();
                editor.setEmacsMark(null);
                editor.session.$emacsMarkRing = marks.concat(deselectedMarks.reverse());
            }, 0);
        },
        readOnly: true
    },
    keyboardQuit: function (editor) {
        editor.selection.clearSelection();
        editor.setEmacsMark(null);
        editor.keyBinding.$data.count = null;
    },
    focusCommandLine: function (editor, arg) {
        if (editor.showCommandLine)
            editor.showCommandLine(arg);
    }
});
exports.handler.addCommands(iSearchCommandModule.iSearchStartCommands);
var commands = exports.handler.commands;
commands.yank.isYank = true;
commands.yankRotate.isYank = true;
exports.killRing = {
    $data: [],
    add: function (str) {
        str &amp;&amp; this.$data.push(str);
        if (this.$data.length &gt; 30)
            this.$data.shift();
    },
    append: function (str) {
        var idx = this.$data.length - 1;
        var text = this.$data[idx] || &quot;&quot;;
        if (str)
            text += str;
        if (text)
            this.$data[idx] = text;
    },
    get: function (n) {
        n = n || 1;
        return this.$data.slice(this.$data.length - n, this.$data.length).reverse().join(&#039;\n&#039;);
    },
    pop: function () {
        if (this.$data.length &gt; 1)
            this.$data.pop();
        return this.get();
    },
    rotate: function () {
        this.$data.unshift(this.$data.pop());
        return this.get();
    }
};

});                (function() {
                    window.require([&quot;ace/keyboard/emacs&quot;], function(m) {
                        if (typeof module == &quot;object&quot; &amp;&amp; typeof exports == &quot;object&quot; &amp;&amp; module) {
                            module.exports = m;
                        }
                    });
                })();</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
