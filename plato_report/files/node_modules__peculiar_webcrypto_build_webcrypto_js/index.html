<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@peculiar/webcrypto/build/webcrypto.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@peculiar/webcrypto/build/webcrypto.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">68.51</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">2308</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">272.77</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">36.67</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*!
 Copyright (c) Peculiar Ventures, LLC
*/

&#039;use strict&#039;;

var core = require(&#039;webcrypto-core&#039;);
var crypto = require(&#039;crypto&#039;);
var process = require(&#039;process&#039;);
var tslib = require(&#039;tslib&#039;);
var jsonSchema = require(&#039;@peculiar/json-schema&#039;);
var pvtsutils = require(&#039;pvtsutils&#039;);
var asn1Schema = require(&#039;@peculiar/asn1-schema&#039;);

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== &#039;default&#039;) {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var core__namespace = /*#__PURE__*/_interopNamespaceDefault(core);
var crypto__namespace = /*#__PURE__*/_interopNamespaceDefault(crypto);
var process__namespace = /*#__PURE__*/_interopNamespaceDefault(process);

const JsonBase64UrlConverter = {
    fromJSON: (value) =&gt; Buffer.from(pvtsutils.Convert.FromBase64Url(value)),
    toJSON: (value) =&gt; pvtsutils.Convert.ToBase64Url(value),
};

class CryptoKey extends core__namespace.CryptoKey {
    constructor() {
        super(...arguments);
        this.data = Buffer.alloc(0);
        this.algorithm = { name: &quot;&quot; };
        this.extractable = false;
        this.type = &quot;secret&quot;;
        this.usages = [];
        this.kty = &quot;oct&quot;;
        this.alg = &quot;&quot;;
    }
}
tslib.__decorate([
    jsonSchema.JsonProp({ name: &quot;ext&quot;, type: jsonSchema.JsonPropTypes.Boolean, optional: true })
], CryptoKey.prototype, &quot;extractable&quot;, void 0);
tslib.__decorate([
    jsonSchema.JsonProp({ name: &quot;key_ops&quot;, type: jsonSchema.JsonPropTypes.String, repeated: true, optional: true })
], CryptoKey.prototype, &quot;usages&quot;, void 0);
tslib.__decorate([
    jsonSchema.JsonProp({ type: jsonSchema.JsonPropTypes.String })
], CryptoKey.prototype, &quot;kty&quot;, void 0);
tslib.__decorate([
    jsonSchema.JsonProp({ type: jsonSchema.JsonPropTypes.String, optional: true })
], CryptoKey.prototype, &quot;alg&quot;, void 0);

class SymmetricKey extends CryptoKey {
    constructor() {
        super(...arguments);
        this.kty = &quot;oct&quot;;
        this.type = &quot;secret&quot;;
    }
}

class AsymmetricKey extends CryptoKey {
}

class AesCryptoKey extends SymmetricKey {
    get alg() {
        switch (this.algorithm.name.toUpperCase()) {
            case &quot;AES-CBC&quot;:
                return `A${this.algorithm.length}CBC`;
            case &quot;AES-CTR&quot;:
                return `A${this.algorithm.length}CTR`;
            case &quot;AES-GCM&quot;:
                return `A${this.algorithm.length}GCM`;
            case &quot;AES-KW&quot;:
                return `A${this.algorithm.length}KW`;
            case &quot;AES-CMAC&quot;:
                return `A${this.algorithm.length}CMAC`;
            case &quot;AES-ECB&quot;:
                return `A${this.algorithm.length}ECB`;
            default:
                throw new core__namespace.AlgorithmError(&quot;Unsupported algorithm name&quot;);
        }
    }
    set alg(value) {
    }
}
tslib.__decorate([
    jsonSchema.JsonProp({ name: &quot;k&quot;, converter: JsonBase64UrlConverter })
], AesCryptoKey.prototype, &quot;data&quot;, void 0);

const keyStorage = new WeakMap();
function getCryptoKey(key) {
    const res = keyStorage.get(key);
    if (!res) {
        throw new core__namespace.OperationError(&quot;Cannot get CryptoKey from secure storage&quot;);
    }
    return res;
}
function setCryptoKey(value) {
    const key = core__namespace.CryptoKey.create(value.algorithm, value.type, value.extractable, value.usages);
    Object.freeze(key);
    keyStorage.set(key, value);
    return key;
}

class AesCrypto {
    static async generateKey(algorithm, extractable, keyUsages) {
        const key = new AesCryptoKey();
        key.algorithm = algorithm;
        key.extractable = extractable;
        key.usages = keyUsages;
        key.data = crypto.randomBytes(algorithm.length &gt;&gt; 3);
        return key;
    }
    static async exportKey(format, key) {
        if (!(key instanceof AesCryptoKey)) {
            throw new Error(&quot;key: Is not AesCryptoKey&quot;);
        }
        switch (format.toLowerCase()) {
            case &quot;jwk&quot;:
                return jsonSchema.JsonSerializer.toJSON(key);
            case &quot;raw&quot;:
                return new Uint8Array(key.data).buffer;
            default:
                throw new core__namespace.OperationError(&quot;format: Must be &#039;jwk&#039; or &#039;raw&#039;&quot;);
        }
    }
    static async importKey(format, keyData, algorithm, extractable, keyUsages) {
        let key;
        switch (format.toLowerCase()) {
            case &quot;jwk&quot;:
                key = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: AesCryptoKey });
                break;
            case &quot;raw&quot;:
                key = new AesCryptoKey();
                key.data = Buffer.from(keyData);
                break;
            default:
                throw new core__namespace.OperationError(&quot;format: Must be &#039;jwk&#039; or &#039;raw&#039;&quot;);
        }
        key.algorithm = algorithm;
        key.algorithm.length = key.data.length &lt;&lt; 3;
        key.extractable = extractable;
        key.usages = keyUsages;
        switch (key.algorithm.length) {
            case 128:
            case 192:
            case 256:
                break;
            default:
                throw new core__namespace.OperationError(&quot;keyData: Is wrong key length&quot;);
        }
        return key;
    }
    static async encrypt(algorithm, key, data) {
        switch (algorithm.name.toUpperCase()) {
            case &quot;AES-CBC&quot;:
                return this.encryptAesCBC(algorithm, key, Buffer.from(data));
            case &quot;AES-CTR&quot;:
                return this.encryptAesCTR(algorithm, key, Buffer.from(data));
            case &quot;AES-GCM&quot;:
                return this.encryptAesGCM(algorithm, key, Buffer.from(data));
            case &quot;AES-KW&quot;:
                return this.encryptAesKW(algorithm, key, Buffer.from(data));
            case &quot;AES-ECB&quot;:
                return this.encryptAesECB(algorithm, key, Buffer.from(data));
            default:
                throw new core__namespace.OperationError(&quot;algorithm: Is not recognized&quot;);
        }
    }
    static async decrypt(algorithm, key, data) {
        if (!(key instanceof AesCryptoKey)) {
            throw new Error(&quot;key: Is not AesCryptoKey&quot;);
        }
        switch (algorithm.name.toUpperCase()) {
            case &quot;AES-CBC&quot;:
                return this.decryptAesCBC(algorithm, key, Buffer.from(data));
            case &quot;AES-CTR&quot;:
                return this.decryptAesCTR(algorithm, key, Buffer.from(data));
            case &quot;AES-GCM&quot;:
                return this.decryptAesGCM(algorithm, key, Buffer.from(data));
            case &quot;AES-KW&quot;:
                return this.decryptAesKW(algorithm, key, Buffer.from(data));
            case &quot;AES-ECB&quot;:
                return this.decryptAesECB(algorithm, key, Buffer.from(data));
            default:
                throw new core__namespace.OperationError(&quot;algorithm: Is not recognized&quot;);
        }
    }
    static async encryptAesCBC(algorithm, key, data) {
        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-cbc`, key.data, new Uint8Array(algorithm.iv));
        let enc = cipher.update(data);
        enc = Buffer.concat([enc, cipher.final()]);
        const res = new Uint8Array(enc).buffer;
        return res;
    }
    static async decryptAesCBC(algorithm, key, data) {
        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-cbc`, key.data, new Uint8Array(algorithm.iv));
        let dec = decipher.update(data);
        dec = Buffer.concat([dec, decipher.final()]);
        return new Uint8Array(dec).buffer;
    }
    static async encryptAesCTR(algorithm, key, data) {
        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-ctr`, key.data, Buffer.from(algorithm.counter));
        let enc = cipher.update(data);
        enc = Buffer.concat([enc, cipher.final()]);
        const res = new Uint8Array(enc).buffer;
        return res;
    }
    static async decryptAesCTR(algorithm, key, data) {
        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-ctr`, key.data, new Uint8Array(algorithm.counter));
        let dec = decipher.update(data);
        dec = Buffer.concat([dec, decipher.final()]);
        return new Uint8Array(dec).buffer;
    }
    static async encryptAesGCM(algorithm, key, data) {
        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-gcm`, key.data, Buffer.from(algorithm.iv), {
            authTagLength: (algorithm.tagLength || 128) &gt;&gt; 3,
        });
        if (algorithm.additionalData) {
            cipher.setAAD(Buffer.from(algorithm.additionalData));
        }
        let enc = cipher.update(data);
        enc = Buffer.concat([enc, cipher.final(), cipher.getAuthTag()]);
        const res = new Uint8Array(enc).buffer;
        return res;
    }
    static async decryptAesGCM(algorithm, key, data) {
        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-gcm`, key.data, new Uint8Array(algorithm.iv));
        const tagLength = (algorithm.tagLength || 128) &gt;&gt; 3;
        const enc = data.slice(0, data.length - tagLength);
        const tag = data.slice(data.length - tagLength);
        if (algorithm.additionalData) {
            decipher.setAAD(Buffer.from(algorithm.additionalData));
        }
        decipher.setAuthTag(tag);
        let dec = decipher.update(enc);
        dec = Buffer.concat([dec, decipher.final()]);
        return new Uint8Array(dec).buffer;
    }
    static async encryptAesKW(algorithm, key, data) {
        const cipher = crypto.createCipheriv(`id-aes${key.algorithm.length}-wrap`, key.data, this.AES_KW_IV);
        let enc = cipher.update(data);
        enc = Buffer.concat([enc, cipher.final()]);
        return new Uint8Array(enc).buffer;
    }
    static async decryptAesKW(algorithm, key, data) {
        const decipher = crypto.createDecipheriv(`id-aes${key.algorithm.length}-wrap`, key.data, this.AES_KW_IV);
        let dec = decipher.update(data);
        dec = Buffer.concat([dec, decipher.final()]);
        return new Uint8Array(dec).buffer;
    }
    static async encryptAesECB(algorithm, key, data) {
        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-ecb`, key.data, new Uint8Array(0));
        let enc = cipher.update(data);
        enc = Buffer.concat([enc, cipher.final()]);
        const res = new Uint8Array(enc).buffer;
        return res;
    }
    static async decryptAesECB(algorithm, key, data) {
        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-ecb`, key.data, new Uint8Array(0));
        let dec = decipher.update(data);
        dec = Buffer.concat([dec, decipher.final()]);
        return new Uint8Array(dec).buffer;
    }
}
AesCrypto.AES_KW_IV = Buffer.from(&quot;A6A6A6A6A6A6A6A6&quot;, &quot;hex&quot;);

class AesCbcProvider extends core__namespace.AesCbcProvider {
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await AesCrypto.generateKey({
            name: this.name,
            length: algorithm.length,
        }, extractable, keyUsages);
        return setCryptoKey(key);
    }
    async onEncrypt(algorithm, key, data) {
        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onDecrypt(algorithm, key, data) {
        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onExportKey(format, key) {
        return AesCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);
        return setCryptoKey(key);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {
            throw new TypeError(&quot;key: Is not a AesCryptoKey&quot;);
        }
    }
}

const zero = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
const rb = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 135]);
const blockSize = 16;
function bitShiftLeft(buffer) {
    const shifted = Buffer.alloc(buffer.length);
    const last = buffer.length - 1;
    for (let index = 0; index &lt; last; index++) {
        shifted[index] = buffer[index] &lt;&lt; 1;
        if (buffer[index + 1] &amp; 0x80) {
            shifted[index] += 0x01;
        }
    }
    shifted[last] = buffer[last] &lt;&lt; 1;
    return shifted;
}
function xor(a, b) {
    const length = Math.min(a.length, b.length);
    const output = Buffer.alloc(length);
    for (let index = 0; index &lt; length; index++) {
        output[index] = a[index] ^ b[index];
    }
    return output;
}
function aes(key, message) {
    const cipher = crypto__namespace.createCipheriv(`aes${key.length &lt;&lt; 3}`, key, zero);
    const result = cipher.update(message);
    cipher.final();
    return result;
}
function getMessageBlock(message, blockIndex) {
    const block = Buffer.alloc(blockSize);
    const start = blockIndex * blockSize;
    const end = start + blockSize;
    message.copy(block, 0, start, end);
    return block;
}
function getPaddedMessageBlock(message, blockIndex) {
    const block = Buffer.alloc(blockSize);
    const start = blockIndex * blockSize;
    const end = message.length;
    block.fill(0);
    message.copy(block, 0, start, end);
    block[end - start] = 0x80;
    return block;
}
function generateSubkeys(key) {
    const l = aes(key, zero);
    let subkey1 = bitShiftLeft(l);
    if (l[0] &amp; 0x80) {
        subkey1 = xor(subkey1, rb);
    }
    let subkey2 = bitShiftLeft(subkey1);
    if (subkey1[0] &amp; 0x80) {
        subkey2 = xor(subkey2, rb);
    }
    return { subkey1, subkey2 };
}
function aesCmac(key, message) {
    const subkeys = generateSubkeys(key);
    let blockCount = Math.ceil(message.length / blockSize);
    let lastBlockCompleteFlag;
    let lastBlock;
    if (blockCount === 0) {
        blockCount = 1;
        lastBlockCompleteFlag = false;
    }
    else {
        lastBlockCompleteFlag = (message.length % blockSize === 0);
    }
    const lastBlockIndex = blockCount - 1;
    if (lastBlockCompleteFlag) {
        lastBlock = xor(getMessageBlock(message, lastBlockIndex), subkeys.subkey1);
    }
    else {
        lastBlock = xor(getPaddedMessageBlock(message, lastBlockIndex), subkeys.subkey2);
    }
    let x = zero;
    let y;
    for (let index = 0; index &lt; lastBlockIndex; index++) {
        y = xor(x, getMessageBlock(message, index));
        x = aes(key, y);
    }
    y = xor(lastBlock, x);
    return aes(key, y);
}
class AesCmacProvider extends core__namespace.AesCmacProvider {
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await AesCrypto.generateKey({
            name: this.name,
            length: algorithm.length,
        }, extractable, keyUsages);
        return setCryptoKey(key);
    }
    async onSign(algorithm, key, data) {
        const result = aesCmac(getCryptoKey(key).data, Buffer.from(data));
        return new Uint8Array(result).buffer;
    }
    async onVerify(algorithm, key, signature, data) {
        const signature2 = await this.sign(algorithm, key, data);
        return Buffer.from(signature).compare(Buffer.from(signature2)) === 0;
    }
    async onExportKey(format, key) {
        return AesCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);
        return setCryptoKey(res);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {
            throw new TypeError(&quot;key: Is not a AesCryptoKey&quot;);
        }
    }
}

class AesCtrProvider extends core__namespace.AesCtrProvider {
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await AesCrypto.generateKey({
            name: this.name,
            length: algorithm.length,
        }, extractable, keyUsages);
        return setCryptoKey(key);
    }
    async onEncrypt(algorithm, key, data) {
        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onDecrypt(algorithm, key, data) {
        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onExportKey(format, key) {
        return AesCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);
        return setCryptoKey(res);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {
            throw new TypeError(&quot;key: Is not a AesCryptoKey&quot;);
        }
    }
}

class AesGcmProvider extends core__namespace.AesGcmProvider {
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await AesCrypto.generateKey({
            name: this.name,
            length: algorithm.length,
        }, extractable, keyUsages);
        return setCryptoKey(key);
    }
    async onEncrypt(algorithm, key, data) {
        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onDecrypt(algorithm, key, data) {
        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onExportKey(format, key) {
        return AesCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);
        return setCryptoKey(res);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {
            throw new TypeError(&quot;key: Is not a AesCryptoKey&quot;);
        }
    }
}

class AesKwProvider extends core__namespace.AesKwProvider {
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const res = await AesCrypto.generateKey({
            name: this.name,
            length: algorithm.length,
        }, extractable, keyUsages);
        return setCryptoKey(res);
    }
    async onExportKey(format, key) {
        return AesCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);
        return setCryptoKey(res);
    }
    async onEncrypt(algorithm, key, data) {
        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onDecrypt(algorithm, key, data) {
        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {
            throw new TypeError(&quot;key: Is not a AesCryptoKey&quot;);
        }
    }
}

class AesEcbProvider extends core__namespace.AesEcbProvider {
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await AesCrypto.generateKey({
            name: this.name,
            length: algorithm.length,
        }, extractable, keyUsages);
        return setCryptoKey(key);
    }
    async onEncrypt(algorithm, key, data) {
        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onDecrypt(algorithm, key, data) {
        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onExportKey(format, key) {
        return AesCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);
        return setCryptoKey(res);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {
            throw new TypeError(&quot;key: Is not a AesCryptoKey&quot;);
        }
    }
}

class DesCryptoKey extends SymmetricKey {
    get alg() {
        switch (this.algorithm.name.toUpperCase()) {
            case &quot;DES-CBC&quot;:
                return `DES-CBC`;
            case &quot;DES-EDE3-CBC&quot;:
                return `3DES-CBC`;
            default:
                throw new core__namespace.AlgorithmError(&quot;Unsupported algorithm name&quot;);
        }
    }
    set alg(value) {
    }
}
tslib.__decorate([
    jsonSchema.JsonProp({ name: &quot;k&quot;, converter: JsonBase64UrlConverter })
], DesCryptoKey.prototype, &quot;data&quot;, void 0);

class DesCrypto {
    static async generateKey(algorithm, extractable, keyUsages) {
        const key = new DesCryptoKey();
        key.algorithm = algorithm;
        key.extractable = extractable;
        key.usages = keyUsages;
        key.data = crypto.randomBytes(algorithm.length &gt;&gt; 3);
        return key;
    }
    static async exportKey(format, key) {
        switch (format.toLowerCase()) {
            case &quot;jwk&quot;:
                return jsonSchema.JsonSerializer.toJSON(key);
            case &quot;raw&quot;:
                return new Uint8Array(key.data).buffer;
            default:
                throw new core__namespace.OperationError(&quot;format: Must be &#039;jwk&#039; or &#039;raw&#039;&quot;);
        }
    }
    static async importKey(format, keyData, algorithm, extractable, keyUsages) {
        let key;
        switch (format.toLowerCase()) {
            case &quot;jwk&quot;:
                key = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: DesCryptoKey });
                break;
            case &quot;raw&quot;:
                key = new DesCryptoKey();
                key.data = Buffer.from(keyData);
                break;
            default:
                throw new core__namespace.OperationError(&quot;format: Must be &#039;jwk&#039; or &#039;raw&#039;&quot;);
        }
        key.algorithm = algorithm;
        key.extractable = extractable;
        key.usages = keyUsages;
        return key;
    }
    static async encrypt(algorithm, key, data) {
        switch (algorithm.name.toUpperCase()) {
            case &quot;DES-CBC&quot;:
                return this.encryptDesCBC(algorithm, key, Buffer.from(data));
            case &quot;DES-EDE3-CBC&quot;:
                return this.encryptDesEDE3CBC(algorithm, key, Buffer.from(data));
            default:
                throw new core__namespace.OperationError(&quot;algorithm: Is not recognized&quot;);
        }
    }
    static async decrypt(algorithm, key, data) {
        if (!(key instanceof DesCryptoKey)) {
            throw new Error(&quot;key: Is not DesCryptoKey&quot;);
        }
        switch (algorithm.name.toUpperCase()) {
            case &quot;DES-CBC&quot;:
                return this.decryptDesCBC(algorithm, key, Buffer.from(data));
            case &quot;DES-EDE3-CBC&quot;:
                return this.decryptDesEDE3CBC(algorithm, key, Buffer.from(data));
            default:
                throw new core__namespace.OperationError(&quot;algorithm: Is not recognized&quot;);
        }
    }
    static async encryptDesCBC(algorithm, key, data) {
        const cipher = crypto.createCipheriv(`des-cbc`, key.data, new Uint8Array(algorithm.iv));
        let enc = cipher.update(data);
        enc = Buffer.concat([enc, cipher.final()]);
        const res = new Uint8Array(enc).buffer;
        return res;
    }
    static async decryptDesCBC(algorithm, key, data) {
        const decipher = crypto.createDecipheriv(`des-cbc`, key.data, new Uint8Array(algorithm.iv));
        let dec = decipher.update(data);
        dec = Buffer.concat([dec, decipher.final()]);
        return new Uint8Array(dec).buffer;
    }
    static async encryptDesEDE3CBC(algorithm, key, data) {
        const cipher = crypto.createCipheriv(`des-ede3-cbc`, key.data, Buffer.from(algorithm.iv));
        let enc = cipher.update(data);
        enc = Buffer.concat([enc, cipher.final()]);
        const res = new Uint8Array(enc).buffer;
        return res;
    }
    static async decryptDesEDE3CBC(algorithm, key, data) {
        const decipher = crypto.createDecipheriv(`des-ede3-cbc`, key.data, new Uint8Array(algorithm.iv));
        let dec = decipher.update(data);
        dec = Buffer.concat([dec, decipher.final()]);
        return new Uint8Array(dec).buffer;
    }
}

class DesCbcProvider extends core__namespace.DesProvider {
    constructor() {
        super(...arguments);
        this.keySizeBits = 64;
        this.ivSize = 8;
        this.name = &quot;DES-CBC&quot;;
    }
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await DesCrypto.generateKey({
            name: this.name,
            length: this.keySizeBits,
        }, extractable, keyUsages);
        return setCryptoKey(key);
    }
    async onEncrypt(algorithm, key, data) {
        return DesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onDecrypt(algorithm, key, data) {
        return DesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onExportKey(format, key) {
        return DesCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await DesCrypto.importKey(format, keyData, { name: this.name, length: this.keySizeBits }, extractable, keyUsages);
        if (key.data.length !== (this.keySizeBits &gt;&gt; 3)) {
            throw new core__namespace.OperationError(&quot;keyData: Wrong key size&quot;);
        }
        return setCryptoKey(key);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof DesCryptoKey)) {
            throw new TypeError(&quot;key: Is not a DesCryptoKey&quot;);
        }
    }
}

class DesEde3CbcProvider extends core__namespace.DesProvider {
    constructor() {
        super(...arguments);
        this.keySizeBits = 192;
        this.ivSize = 8;
        this.name = &quot;DES-EDE3-CBC&quot;;
    }
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await DesCrypto.generateKey({
            name: this.name,
            length: this.keySizeBits,
        }, extractable, keyUsages);
        return setCryptoKey(key);
    }
    async onEncrypt(algorithm, key, data) {
        return DesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onDecrypt(algorithm, key, data) {
        return DesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onExportKey(format, key) {
        return DesCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await DesCrypto.importKey(format, keyData, { name: this.name, length: this.keySizeBits }, extractable, keyUsages);
        if (key.data.length !== (this.keySizeBits &gt;&gt; 3)) {
            throw new core__namespace.OperationError(&quot;keyData: Wrong key size&quot;);
        }
        return setCryptoKey(key);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof DesCryptoKey)) {
            throw new TypeError(&quot;key: Is not a DesCryptoKey&quot;);
        }
    }
}

function getJwkAlgorithm(algorithm) {
    switch (algorithm.name.toUpperCase()) {
        case &quot;RSA-OAEP&quot;: {
            const mdSize = /(\d+)$/.exec(algorithm.hash.name)[1];
            return `RSA-OAEP${mdSize !== &quot;1&quot; ? `-${mdSize}` : &quot;&quot;}`;
        }
        case &quot;RSASSA-PKCS1-V1_5&quot;:
            return `RS${/(\d+)$/.exec(algorithm.hash.name)[1]}`;
        case &quot;RSA-PSS&quot;:
            return `PS${/(\d+)$/.exec(algorithm.hash.name)[1]}`;
        case &quot;RSA-PKCS1&quot;:
            return `RS1`;
        default:
            throw new core__namespace.OperationError(&quot;algorithm: Is not recognized&quot;);
    }
}

class RsaPrivateKey extends AsymmetricKey {
    constructor() {
        super(...arguments);
        this.type = &quot;private&quot;;
    }
    getKey() {
        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PrivateKeyInfo);
        return asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.RsaPrivateKey);
    }
    toJSON() {
        const key = this.getKey();
        const json = {
            kty: &quot;RSA&quot;,
            alg: getJwkAlgorithm(this.algorithm),
            key_ops: this.usages,
            ext: this.extractable,
        };
        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));
    }
    fromJSON(json) {
        const key = jsonSchema.JsonParser.fromJSON(json, { targetSchema: core__namespace.asn1.RsaPrivateKey });
        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();
        keyInfo.privateKeyAlgorithm.algorithm = &quot;1.2.840.113549.1.1.1&quot;;
        keyInfo.privateKeyAlgorithm.parameters = null;
        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(key);
        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));
    }
}

class RsaPublicKey extends AsymmetricKey {
    constructor() {
        super(...arguments);
        this.type = &quot;public&quot;;
    }
    getKey() {
        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PublicKeyInfo);
        return asn1Schema.AsnParser.parse(keyInfo.publicKey, core__namespace.asn1.RsaPublicKey);
    }
    toJSON() {
        const key = this.getKey();
        const json = {
            kty: &quot;RSA&quot;,
            alg: getJwkAlgorithm(this.algorithm),
            key_ops: this.usages,
            ext: this.extractable,
        };
        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));
    }
    fromJSON(json) {
        const key = jsonSchema.JsonParser.fromJSON(json, { targetSchema: core__namespace.asn1.RsaPublicKey });
        const keyInfo = new core__namespace.asn1.PublicKeyInfo();
        keyInfo.publicKeyAlgorithm.algorithm = &quot;1.2.840.113549.1.1.1&quot;;
        keyInfo.publicKeyAlgorithm.parameters = null;
        keyInfo.publicKey = asn1Schema.AsnSerializer.serialize(key);
        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));
    }
}

class RsaCrypto {
    static async generateKey(algorithm, extractable, keyUsages) {
        const privateKey = new RsaPrivateKey();
        privateKey.algorithm = algorithm;
        privateKey.extractable = extractable;
        privateKey.usages = keyUsages.filter((usage) =&gt; this.privateKeyUsages.indexOf(usage) !== -1);
        const publicKey = new RsaPublicKey();
        publicKey.algorithm = algorithm;
        publicKey.extractable = true;
        publicKey.usages = keyUsages.filter((usage) =&gt; this.publicKeyUsages.indexOf(usage) !== -1);
        const publicExponent = Buffer.concat([
            Buffer.alloc(4 - algorithm.publicExponent.byteLength, 0),
            Buffer.from(algorithm.publicExponent),
        ]).readInt32BE(0);
        const keys = crypto.generateKeyPairSync(&quot;rsa&quot;, {
            modulusLength: algorithm.modulusLength,
            publicExponent,
            publicKeyEncoding: {
                format: &quot;der&quot;,
                type: &quot;spki&quot;,
            },
            privateKeyEncoding: {
                format: &quot;der&quot;,
                type: &quot;pkcs8&quot;,
            },
        });
        privateKey.data = keys.privateKey;
        publicKey.data = keys.publicKey;
        const res = {
            privateKey,
            publicKey,
        };
        return res;
    }
    static async exportKey(format, key) {
        switch (format.toLowerCase()) {
            case &quot;jwk&quot;:
                return jsonSchema.JsonSerializer.toJSON(key);
            case &quot;pkcs8&quot;:
            case &quot;spki&quot;:
                return new Uint8Array(key.data).buffer;
            default:
                throw new core__namespace.OperationError(&quot;format: Must be &#039;jwk&#039;, &#039;pkcs8&#039; or &#039;spki&#039;&quot;);
        }
    }
    static async importKey(format, keyData, algorithm, extractable, keyUsages) {
        switch (format.toLowerCase()) {
            case &quot;jwk&quot;: {
                const jwk = keyData;
                if (jwk.d) {
                    const asnKey = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: core__namespace.asn1.RsaPrivateKey });
                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);
                }
                else {
                    const asnKey = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: core__namespace.asn1.RsaPublicKey });
                    return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);
                }
            }
            case &quot;spki&quot;: {
                const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PublicKeyInfo);
                const asnKey = asn1Schema.AsnParser.parse(keyInfo.publicKey, core__namespace.asn1.RsaPublicKey);
                return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);
            }
            case &quot;pkcs8&quot;: {
                const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PrivateKeyInfo);
                const asnKey = asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.RsaPrivateKey);
                return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);
            }
            default:
                throw new core__namespace.OperationError(&quot;format: Must be &#039;jwk&#039;, &#039;pkcs8&#039; or &#039;spki&#039;&quot;);
        }
    }
    static async sign(algorithm, key, data) {
        switch (algorithm.name.toUpperCase()) {
            case &quot;RSA-PSS&quot;:
            case &quot;RSASSA-PKCS1-V1_5&quot;:
                return this.signRsa(algorithm, key, data);
            default:
                throw new core__namespace.OperationError(&quot;algorithm: Is not recognized&quot;);
        }
    }
    static async verify(algorithm, key, signature, data) {
        switch (algorithm.name.toUpperCase()) {
            case &quot;RSA-PSS&quot;:
            case &quot;RSASSA-PKCS1-V1_5&quot;:
                return this.verifySSA(algorithm, key, data, signature);
            default:
                throw new core__namespace.OperationError(&quot;algorithm: Is not recognized&quot;);
        }
    }
    static async encrypt(algorithm, key, data) {
        switch (algorithm.name.toUpperCase()) {
            case &quot;RSA-OAEP&quot;:
                return this.encryptOAEP(algorithm, key, data);
            default:
                throw new core__namespace.OperationError(&quot;algorithm: Is not recognized&quot;);
        }
    }
    static async decrypt(algorithm, key, data) {
        switch (algorithm.name.toUpperCase()) {
            case &quot;RSA-OAEP&quot;:
                return this.decryptOAEP(algorithm, key, data);
            default:
                throw new core__namespace.OperationError(&quot;algorithm: Is not recognized&quot;);
        }
    }
    static importPrivateKey(asnKey, algorithm, extractable, keyUsages) {
        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();
        keyInfo.privateKeyAlgorithm.algorithm = &quot;1.2.840.113549.1.1.1&quot;;
        keyInfo.privateKeyAlgorithm.parameters = null;
        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(asnKey);
        const key = new RsaPrivateKey();
        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));
        key.algorithm = Object.assign({}, algorithm);
        key.algorithm.publicExponent = new Uint8Array(asnKey.publicExponent);
        key.algorithm.modulusLength = asnKey.modulus.byteLength &lt;&lt; 3;
        key.extractable = extractable;
        key.usages = keyUsages;
        return key;
    }
    static importPublicKey(asnKey, algorithm, extractable, keyUsages) {
        const keyInfo = new core__namespace.asn1.PublicKeyInfo();
        keyInfo.publicKeyAlgorithm.algorithm = &quot;1.2.840.113549.1.1.1&quot;;
        keyInfo.publicKeyAlgorithm.parameters = null;
        keyInfo.publicKey = asn1Schema.AsnSerializer.serialize(asnKey);
        const key = new RsaPublicKey();
        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));
        key.algorithm = Object.assign({}, algorithm);
        key.algorithm.publicExponent = new Uint8Array(asnKey.publicExponent);
        key.algorithm.modulusLength = asnKey.modulus.byteLength &lt;&lt; 3;
        key.extractable = extractable;
        key.usages = keyUsages;
        return key;
    }
    static getCryptoAlgorithm(alg) {
        switch (alg.hash.name.toUpperCase()) {
            case &quot;SHA-1&quot;:
                return &quot;RSA-SHA1&quot;;
            case &quot;SHA-256&quot;:
                return &quot;RSA-SHA256&quot;;
            case &quot;SHA-384&quot;:
                return &quot;RSA-SHA384&quot;;
            case &quot;SHA-512&quot;:
                return &quot;RSA-SHA512&quot;;
            case &quot;SHA3-256&quot;:
                return &quot;RSA-SHA3-256&quot;;
            case &quot;SHA3-384&quot;:
                return &quot;RSA-SHA3-384&quot;;
            case &quot;SHA3-512&quot;:
                return &quot;RSA-SHA3-512&quot;;
            default:
                throw new core__namespace.OperationError(&quot;algorithm.hash: Is not recognized&quot;);
        }
    }
    static signRsa(algorithm, key, data) {
        const cryptoAlg = this.getCryptoAlgorithm(key.algorithm);
        const signer = crypto.createSign(cryptoAlg);
        signer.update(Buffer.from(data));
        if (!key.pem) {
            key.pem = `-----BEGIN PRIVATE KEY-----\n${key.data.toString(&quot;base64&quot;)}\n-----END PRIVATE KEY-----`;
        }
        const options = {
            key: key.pem,
        };
        if (algorithm.name.toUpperCase() === &quot;RSA-PSS&quot;) {
            options.padding = crypto.constants.RSA_PKCS1_PSS_PADDING;
            options.saltLength = algorithm.saltLength;
        }
        const signature = signer.sign(options);
        return new Uint8Array(signature).buffer;
    }
    static verifySSA(algorithm, key, data, signature) {
        const cryptoAlg = this.getCryptoAlgorithm(key.algorithm);
        const signer = crypto.createVerify(cryptoAlg);
        signer.update(Buffer.from(data));
        if (!key.pem) {
            key.pem = `-----BEGIN PUBLIC KEY-----\n${key.data.toString(&quot;base64&quot;)}\n-----END PUBLIC KEY-----`;
        }
        const options = {
            key: key.pem,
        };
        if (algorithm.name.toUpperCase() === &quot;RSA-PSS&quot;) {
            options.padding = crypto.constants.RSA_PKCS1_PSS_PADDING;
            options.saltLength = algorithm.saltLength;
        }
        const ok = signer.verify(options, signature);
        return ok;
    }
    static encryptOAEP(algorithm, key, data) {
        const options = {
            key: `-----BEGIN PUBLIC KEY-----\n${key.data.toString(&quot;base64&quot;)}\n-----END PUBLIC KEY-----`,
            padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,
        };
        if (algorithm.label) ;
        return new Uint8Array(crypto.publicEncrypt(options, data)).buffer;
    }
    static decryptOAEP(algorithm, key, data) {
        const options = {
            key: `-----BEGIN PRIVATE KEY-----\n${key.data.toString(&quot;base64&quot;)}\n-----END PRIVATE KEY-----`,
            padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,
        };
        if (algorithm.label) ;
        return new Uint8Array(crypto.privateDecrypt(options, data)).buffer;
    }
}
RsaCrypto.publicKeyUsages = [&quot;verify&quot;, &quot;encrypt&quot;, &quot;wrapKey&quot;];
RsaCrypto.privateKeyUsages = [&quot;sign&quot;, &quot;decrypt&quot;, &quot;unwrapKey&quot;];

class RsaSsaProvider extends core__namespace.RsaSsaProvider {
    constructor() {
        super(...arguments);
        this.hashAlgorithms = [
            &quot;SHA-1&quot;, &quot;SHA-256&quot;, &quot;SHA-384&quot;, &quot;SHA-512&quot;,
            &quot;shake128&quot;, &quot;shake256&quot;,
            &quot;SHA3-256&quot;, &quot;SHA3-384&quot;, &quot;SHA3-512&quot;
        ];
    }
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await RsaCrypto.generateKey({
            ...algorithm,
            name: this.name,
        }, extractable, keyUsages);
        return {
            privateKey: setCryptoKey(keys.privateKey),
            publicKey: setCryptoKey(keys.publicKey),
        };
    }
    async onSign(algorithm, key, data) {
        return RsaCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onVerify(algorithm, key, signature, data) {
        return RsaCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));
    }
    async onExportKey(format, key) {
        return RsaCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
        return setCryptoKey(key);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        const internalKey = getCryptoKey(key);
        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {
            throw new TypeError(&quot;key: Is not RSA CryptoKey&quot;);
        }
    }
}

class RsaPssProvider extends core__namespace.RsaPssProvider {
    constructor() {
        super(...arguments);
        this.hashAlgorithms = [
            &quot;SHA-1&quot;, &quot;SHA-256&quot;, &quot;SHA-384&quot;, &quot;SHA-512&quot;,
            &quot;shake128&quot;, &quot;shake256&quot;,
            &quot;SHA3-256&quot;, &quot;SHA3-384&quot;, &quot;SHA3-512&quot;
        ];
    }
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await RsaCrypto.generateKey({
            ...algorithm,
            name: this.name,
        }, extractable, keyUsages);
        return {
            privateKey: setCryptoKey(keys.privateKey),
            publicKey: setCryptoKey(keys.publicKey),
        };
    }
    async onSign(algorithm, key, data) {
        return RsaCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onVerify(algorithm, key, signature, data) {
        return RsaCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));
    }
    async onExportKey(format, key) {
        return RsaCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
        return setCryptoKey(key);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        const internalKey = getCryptoKey(key);
        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {
            throw new TypeError(&quot;key: Is not RSA CryptoKey&quot;);
        }
    }
}

class ShaCrypto {
    static size(algorithm) {
        switch (algorithm.name.toUpperCase()) {
            case &quot;SHA-1&quot;:
                return 160;
            case &quot;SHA-256&quot;:
            case &quot;SHA3-256&quot;:
                return 256;
            case &quot;SHA-384&quot;:
            case &quot;SHA3-384&quot;:
                return 384;
            case &quot;SHA-512&quot;:
            case &quot;SHA3-512&quot;:
                return 512;
            default:
                throw new Error(&quot;Unrecognized name&quot;);
        }
    }
    static getAlgorithmName(algorithm) {
        switch (algorithm.name.toUpperCase()) {
            case &quot;SHA-1&quot;:
                return &quot;sha1&quot;;
            case &quot;SHA-256&quot;:
                return &quot;sha256&quot;;
            case &quot;SHA-384&quot;:
                return &quot;sha384&quot;;
            case &quot;SHA-512&quot;:
                return &quot;sha512&quot;;
            case &quot;SHA3-256&quot;:
                return &quot;sha3-256&quot;;
            case &quot;SHA3-384&quot;:
                return &quot;sha3-384&quot;;
            case &quot;SHA3-512&quot;:
                return &quot;sha3-512&quot;;
            default:
                throw new Error(&quot;Unrecognized name&quot;);
        }
    }
    static digest(algorithm, data) {
        const hashAlg = this.getAlgorithmName(algorithm);
        const hash = crypto.createHash(hashAlg)
            .update(Buffer.from(data)).digest();
        return new Uint8Array(hash).buffer;
    }
}

class RsaOaepProvider extends core__namespace.RsaOaepProvider {
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await RsaCrypto.generateKey({
            ...algorithm,
            name: this.name,
        }, extractable, keyUsages);
        return {
            privateKey: setCryptoKey(keys.privateKey),
            publicKey: setCryptoKey(keys.publicKey),
        };
    }
    async onEncrypt(algorithm, key, data) {
        const internalKey = getCryptoKey(key);
        const dataView = new Uint8Array(data);
        const keySize = Math.ceil(internalKey.algorithm.modulusLength &gt;&gt; 3);
        const hashSize = ShaCrypto.size(internalKey.algorithm.hash) &gt;&gt; 3;
        const dataLength = dataView.byteLength;
        const psLength = keySize - dataLength - 2 * hashSize - 2;
        if (dataLength &gt; keySize - 2 * hashSize - 2) {
            throw new Error(&quot;Data too large&quot;);
        }
        const message = new Uint8Array(keySize);
        const seed = message.subarray(1, hashSize + 1);
        const dataBlock = message.subarray(hashSize + 1);
        dataBlock.set(dataView, hashSize + psLength + 1);
        const labelHash = crypto.createHash(internalKey.algorithm.hash.name.replace(&quot;-&quot;, &quot;&quot;))
            .update(core__namespace.BufferSourceConverter.toUint8Array(algorithm.label || new Uint8Array(0)))
            .digest();
        dataBlock.set(labelHash, 0);
        dataBlock[hashSize + psLength] = 1;
        crypto.randomFillSync(seed);
        const dataBlockMask = this.mgf1(internalKey.algorithm.hash, seed, dataBlock.length);
        for (let i = 0; i &lt; dataBlock.length; i++) {
            dataBlock[i] ^= dataBlockMask[i];
        }
        const seedMask = this.mgf1(internalKey.algorithm.hash, dataBlock, seed.length);
        for (let i = 0; i &lt; seed.length; i++) {
            seed[i] ^= seedMask[i];
        }
        if (!internalKey.pem) {
            internalKey.pem = `-----BEGIN PUBLIC KEY-----\n${internalKey.data.toString(&quot;base64&quot;)}\n-----END PUBLIC KEY-----`;
        }
        const pkcs0 = crypto.publicEncrypt({
            key: internalKey.pem,
            padding: crypto.constants.RSA_NO_PADDING,
        }, Buffer.from(message));
        return new Uint8Array(pkcs0).buffer;
    }
    async onDecrypt(algorithm, key, data) {
        const internalKey = getCryptoKey(key);
        const keySize = Math.ceil(internalKey.algorithm.modulusLength &gt;&gt; 3);
        const hashSize = ShaCrypto.size(internalKey.algorithm.hash) &gt;&gt; 3;
        const dataLength = data.byteLength;
        if (dataLength !== keySize) {
            throw new Error(&quot;Bad data&quot;);
        }
        if (!internalKey.pem) {
            internalKey.pem = `-----BEGIN PRIVATE KEY-----\n${internalKey.data.toString(&quot;base64&quot;)}\n-----END PRIVATE KEY-----`;
        }
        let pkcs0 = crypto.privateDecrypt({
            key: internalKey.pem,
            padding: crypto.constants.RSA_NO_PADDING,
        }, Buffer.from(data));
        const z = pkcs0[0];
        const seed = pkcs0.subarray(1, hashSize + 1);
        const dataBlock = pkcs0.subarray(hashSize + 1);
        if (z !== 0) {
            throw new Error(&quot;Decryption failed&quot;);
        }
        const seedMask = this.mgf1(internalKey.algorithm.hash, dataBlock, seed.length);
        for (let i = 0; i &lt; seed.length; i++) {
            seed[i] ^= seedMask[i];
        }
        const dataBlockMask = this.mgf1(internalKey.algorithm.hash, seed, dataBlock.length);
        for (let i = 0; i &lt; dataBlock.length; i++) {
            dataBlock[i] ^= dataBlockMask[i];
        }
        const labelHash = crypto.createHash(internalKey.algorithm.hash.name.replace(&quot;-&quot;, &quot;&quot;))
            .update(core__namespace.BufferSourceConverter.toUint8Array(algorithm.label || new Uint8Array(0)))
            .digest();
        for (let i = 0; i &lt; hashSize; i++) {
            if (labelHash[i] !== dataBlock[i]) {
                throw new Error(&quot;Decryption failed&quot;);
            }
        }
        let psEnd = hashSize;
        for (; psEnd &lt; dataBlock.length; psEnd++) {
            const psz = dataBlock[psEnd];
            if (psz === 1) {
                break;
            }
            if (psz !== 0) {
                throw new Error(&quot;Decryption failed&quot;);
            }
        }
        if (psEnd === dataBlock.length) {
            throw new Error(&quot;Decryption failed&quot;);
        }
        pkcs0 = dataBlock.subarray(psEnd + 1);
        return new Uint8Array(pkcs0).buffer;
    }
    async onExportKey(format, key) {
        return RsaCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
        return setCryptoKey(key);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        const internalKey = getCryptoKey(key);
        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {
            throw new TypeError(&quot;key: Is not RSA CryptoKey&quot;);
        }
    }
    mgf1(algorithm, seed, length = 0) {
        const hashSize = ShaCrypto.size(algorithm) &gt;&gt; 3;
        const mask = new Uint8Array(length);
        const counter = new Uint8Array(4);
        const chunks = Math.ceil(length / hashSize);
        for (let i = 0; i &lt; chunks; i++) {
            counter[0] = i &gt;&gt;&gt; 24;
            counter[1] = (i &gt;&gt;&gt; 16) &amp; 255;
            counter[2] = (i &gt;&gt;&gt; 8) &amp; 255;
            counter[3] = i &amp; 255;
            const submask = mask.subarray(i * hashSize);
            let chunk = crypto.createHash(algorithm.name.replace(&quot;-&quot;, &quot;&quot;))
                .update(seed)
                .update(counter)
                .digest();
            if (chunk.length &gt; submask.length) {
                chunk = chunk.subarray(0, submask.length);
            }
            submask.set(chunk);
        }
        return mask;
    }
}

class RsaEsProvider extends core__namespace.ProviderCrypto {
    constructor() {
        super(...arguments);
        this.name = &quot;RSAES-PKCS1-v1_5&quot;;
        this.usages = {
            publicKey: [&quot;encrypt&quot;, &quot;wrapKey&quot;],
            privateKey: [&quot;decrypt&quot;, &quot;unwrapKey&quot;],
        };
    }
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await RsaCrypto.generateKey({
            ...algorithm,
            name: this.name,
        }, extractable, keyUsages);
        return {
            privateKey: setCryptoKey(keys.privateKey),
            publicKey: setCryptoKey(keys.publicKey),
        };
    }
    checkGenerateKeyParams(algorithm) {
        this.checkRequiredProperty(algorithm, &quot;publicExponent&quot;);
        if (!(algorithm.publicExponent &amp;&amp; algorithm.publicExponent instanceof Uint8Array)) {
            throw new TypeError(&quot;publicExponent: Missing or not a Uint8Array&quot;);
        }
        const publicExponent = pvtsutils.Convert.ToBase64(algorithm.publicExponent);
        if (!(publicExponent === &quot;Aw==&quot; || publicExponent === &quot;AQAB&quot;)) {
            throw new TypeError(&quot;publicExponent: Must be [3] or [1,0,1]&quot;);
        }
        this.checkRequiredProperty(algorithm, &quot;modulusLength&quot;);
        switch (algorithm.modulusLength) {
            case 1024:
            case 2048:
            case 4096:
                break;
            default:
                throw new TypeError(&quot;modulusLength: Must be 1024, 2048, or 4096&quot;);
        }
    }
    async onEncrypt(algorithm, key, data) {
        const options = this.toCryptoOptions(key);
        const enc = crypto__namespace.publicEncrypt(options, new Uint8Array(data));
        return new Uint8Array(enc).buffer;
    }
    async onDecrypt(algorithm, key, data) {
        const options = this.toCryptoOptions(key);
        const dec = crypto__namespace.privateDecrypt(options, new Uint8Array(data));
        return new Uint8Array(dec).buffer;
    }
    async onExportKey(format, key) {
        return RsaCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
        return setCryptoKey(key);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        const internalKey = getCryptoKey(key);
        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {
            throw new TypeError(&quot;key: Is not RSA CryptoKey&quot;);
        }
    }
    toCryptoOptions(key) {
        const type = key.type.toUpperCase();
        return {
            key: `-----BEGIN ${type} KEY-----\n${getCryptoKey(key).data.toString(&quot;base64&quot;)}\n-----END ${type} KEY-----`,
            padding: crypto__namespace.constants.RSA_PKCS1_PADDING,
        };
    }
}

const namedOIDs = {
    &quot;1.2.840.10045.3.1.7&quot;: &quot;P-256&quot;,
    &quot;P-256&quot;: &quot;1.2.840.10045.3.1.7&quot;,
    &quot;1.3.132.0.34&quot;: &quot;P-384&quot;,
    &quot;P-384&quot;: &quot;1.3.132.0.34&quot;,
    &quot;1.3.132.0.35&quot;: &quot;P-521&quot;,
    &quot;P-521&quot;: &quot;1.3.132.0.35&quot;,
    &quot;1.3.132.0.10&quot;: &quot;K-256&quot;,
    &quot;K-256&quot;: &quot;1.3.132.0.10&quot;,
    &quot;brainpoolP160r1&quot;: &quot;1.3.36.3.3.2.8.1.1.1&quot;,
    &quot;1.3.36.3.3.2.8.1.1.1&quot;: &quot;brainpoolP160r1&quot;,
    &quot;brainpoolP160t1&quot;: &quot;1.3.36.3.3.2.8.1.1.2&quot;,
    &quot;1.3.36.3.3.2.8.1.1.2&quot;: &quot;brainpoolP160t1&quot;,
    &quot;brainpoolP192r1&quot;: &quot;1.3.36.3.3.2.8.1.1.3&quot;,
    &quot;1.3.36.3.3.2.8.1.1.3&quot;: &quot;brainpoolP192r1&quot;,
    &quot;brainpoolP192t1&quot;: &quot;1.3.36.3.3.2.8.1.1.4&quot;,
    &quot;1.3.36.3.3.2.8.1.1.4&quot;: &quot;brainpoolP192t1&quot;,
    &quot;brainpoolP224r1&quot;: &quot;1.3.36.3.3.2.8.1.1.5&quot;,
    &quot;1.3.36.3.3.2.8.1.1.5&quot;: &quot;brainpoolP224r1&quot;,
    &quot;brainpoolP224t1&quot;: &quot;1.3.36.3.3.2.8.1.1.6&quot;,
    &quot;1.3.36.3.3.2.8.1.1.6&quot;: &quot;brainpoolP224t1&quot;,
    &quot;brainpoolP256r1&quot;: &quot;1.3.36.3.3.2.8.1.1.7&quot;,
    &quot;1.3.36.3.3.2.8.1.1.7&quot;: &quot;brainpoolP256r1&quot;,
    &quot;brainpoolP256t1&quot;: &quot;1.3.36.3.3.2.8.1.1.8&quot;,
    &quot;1.3.36.3.3.2.8.1.1.8&quot;: &quot;brainpoolP256t1&quot;,
    &quot;brainpoolP320r1&quot;: &quot;1.3.36.3.3.2.8.1.1.9&quot;,
    &quot;1.3.36.3.3.2.8.1.1.9&quot;: &quot;brainpoolP320r1&quot;,
    &quot;brainpoolP320t1&quot;: &quot;1.3.36.3.3.2.8.1.1.10&quot;,
    &quot;1.3.36.3.3.2.8.1.1.10&quot;: &quot;brainpoolP320t1&quot;,
    &quot;brainpoolP384r1&quot;: &quot;1.3.36.3.3.2.8.1.1.11&quot;,
    &quot;1.3.36.3.3.2.8.1.1.11&quot;: &quot;brainpoolP384r1&quot;,
    &quot;brainpoolP384t1&quot;: &quot;1.3.36.3.3.2.8.1.1.12&quot;,
    &quot;1.3.36.3.3.2.8.1.1.12&quot;: &quot;brainpoolP384t1&quot;,
    &quot;brainpoolP512r1&quot;: &quot;1.3.36.3.3.2.8.1.1.13&quot;,
    &quot;1.3.36.3.3.2.8.1.1.13&quot;: &quot;brainpoolP512r1&quot;,
    &quot;brainpoolP512t1&quot;: &quot;1.3.36.3.3.2.8.1.1.14&quot;,
    &quot;1.3.36.3.3.2.8.1.1.14&quot;: &quot;brainpoolP512t1&quot;,
};
function getOidByNamedCurve$1(namedCurve) {
    const oid = namedOIDs[namedCurve];
    if (!oid) {
        throw new core__namespace.OperationError(`Cannot convert WebCrypto named curve &#039;${namedCurve}&#039; to OID`);
    }
    return oid;
}

class EcPrivateKey extends AsymmetricKey {
    constructor() {
        super(...arguments);
        this.type = &quot;private&quot;;
    }
    getKey() {
        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PrivateKeyInfo);
        return asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.EcPrivateKey);
    }
    toJSON() {
        const key = this.getKey();
        const json = {
            kty: &quot;EC&quot;,
            crv: this.algorithm.namedCurve,
            key_ops: this.usages,
            ext: this.extractable,
        };
        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));
    }
    fromJSON(json) {
        if (!json.crv) {
            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property &#039;crv&#039; is required`);
        }
        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();
        keyInfo.privateKeyAlgorithm.algorithm = &quot;1.2.840.10045.2.1&quot;;
        keyInfo.privateKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(getOidByNamedCurve$1(json.crv)));
        const key = jsonSchema.JsonParser.fromJSON(json, { targetSchema: core__namespace.asn1.EcPrivateKey });
        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(key);
        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));
        return this;
    }
}

class EcPublicKey extends AsymmetricKey {
    constructor() {
        super(...arguments);
        this.type = &quot;public&quot;;
    }
    getKey() {
        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PublicKeyInfo);
        return new core__namespace.asn1.EcPublicKey(keyInfo.publicKey);
    }
    toJSON() {
        const key = this.getKey();
        const json = {
            kty: &quot;EC&quot;,
            crv: this.algorithm.namedCurve,
            key_ops: this.usages,
            ext: this.extractable,
        };
        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));
    }
    fromJSON(json) {
        if (!json.crv) {
            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property &#039;crv&#039; is required`);
        }
        const key = jsonSchema.JsonParser.fromJSON(json, { targetSchema: core__namespace.asn1.EcPublicKey });
        const keyInfo = new core__namespace.asn1.PublicKeyInfo();
        keyInfo.publicKeyAlgorithm.algorithm = &quot;1.2.840.10045.2.1&quot;;
        keyInfo.publicKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(getOidByNamedCurve$1(json.crv)));
        keyInfo.publicKey = asn1Schema.AsnSerializer.toASN(key).valueHex;
        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));
        return this;
    }
}

class Sha1Provider extends core__namespace.ProviderCrypto {
    constructor() {
        super(...arguments);
        this.name = &quot;SHA-1&quot;;
        this.usages = [];
    }
    async onDigest(algorithm, data) {
        return ShaCrypto.digest(algorithm, data);
    }
}

class Sha256Provider extends core__namespace.ProviderCrypto {
    constructor() {
        super(...arguments);
        this.name = &quot;SHA-256&quot;;
        this.usages = [];
    }
    async onDigest(algorithm, data) {
        return ShaCrypto.digest(algorithm, data);
    }
}

class Sha384Provider extends core__namespace.ProviderCrypto {
    constructor() {
        super(...arguments);
        this.name = &quot;SHA-384&quot;;
        this.usages = [];
    }
    async onDigest(algorithm, data) {
        return ShaCrypto.digest(algorithm, data);
    }
}

class Sha512Provider extends core__namespace.ProviderCrypto {
    constructor() {
        super(...arguments);
        this.name = &quot;SHA-512&quot;;
        this.usages = [];
    }
    async onDigest(algorithm, data) {
        return ShaCrypto.digest(algorithm, data);
    }
}

class Sha3256Provider extends core__namespace.ProviderCrypto {
    constructor() {
        super(...arguments);
        this.name = &quot;SHA3-256&quot;;
        this.usages = [];
    }
    async onDigest(algorithm, data) {
        return ShaCrypto.digest(algorithm, data);
    }
}

class Sha3384Provider extends core__namespace.ProviderCrypto {
    constructor() {
        super(...arguments);
        this.name = &quot;SHA3-384&quot;;
        this.usages = [];
    }
    async onDigest(algorithm, data) {
        return ShaCrypto.digest(algorithm, data);
    }
}

class Sha3512Provider extends core__namespace.ProviderCrypto {
    constructor() {
        super(...arguments);
        this.name = &quot;SHA3-512&quot;;
        this.usages = [];
    }
    async onDigest(algorithm, data) {
        return ShaCrypto.digest(algorithm, data);
    }
}

class EcCrypto {
    static async generateKey(algorithm, extractable, keyUsages) {
        const privateKey = new EcPrivateKey();
        privateKey.algorithm = algorithm;
        privateKey.extractable = extractable;
        privateKey.usages = keyUsages.filter((usage) =&gt; this.privateKeyUsages.indexOf(usage) !== -1);
        const publicKey = new EcPublicKey();
        publicKey.algorithm = algorithm;
        publicKey.extractable = true;
        publicKey.usages = keyUsages.filter((usage) =&gt; this.publicKeyUsages.indexOf(usage) !== -1);
        const keys = crypto.generateKeyPairSync(&quot;ec&quot;, {
            namedCurve: this.getOpenSSLNamedCurve(algorithm.namedCurve),
            publicKeyEncoding: {
                format: &quot;der&quot;,
                type: &quot;spki&quot;,
            },
            privateKeyEncoding: {
                format: &quot;der&quot;,
                type: &quot;pkcs8&quot;,
            },
        });
        privateKey.data = keys.privateKey;
        publicKey.data = keys.publicKey;
        const res = {
            privateKey,
            publicKey,
        };
        return res;
    }
    static async sign(algorithm, key, data) {
        const cryptoAlg = ShaCrypto.getAlgorithmName(algorithm.hash);
        const signer = crypto.createSign(cryptoAlg);
        signer.update(Buffer.from(data));
        if (!key.pem) {
            key.pem = `-----BEGIN PRIVATE KEY-----\n${key.data.toString(&quot;base64&quot;)}\n-----END PRIVATE KEY-----`;
        }
        const options = {
            key: key.pem,
        };
        const signature = signer.sign(options);
        const ecSignature = asn1Schema.AsnParser.parse(signature, core__namespace.asn1.EcDsaSignature);
        const signatureRaw = core__namespace.EcUtils.encodeSignature(ecSignature, core__namespace.EcCurves.get(key.algorithm.namedCurve).size);
        return signatureRaw.buffer;
    }
    static async verify(algorithm, key, signature, data) {
        const cryptoAlg = ShaCrypto.getAlgorithmName(algorithm.hash);
        const signer = crypto.createVerify(cryptoAlg);
        signer.update(Buffer.from(data));
        if (!key.pem) {
            key.pem = `-----BEGIN PUBLIC KEY-----\n${key.data.toString(&quot;base64&quot;)}\n-----END PUBLIC KEY-----`;
        }
        const options = {
            key: key.pem,
        };
        const ecSignature = new core__namespace.asn1.EcDsaSignature();
        const namedCurve = core__namespace.EcCurves.get(key.algorithm.namedCurve);
        const signaturePoint = core__namespace.EcUtils.decodeSignature(signature, namedCurve.size);
        ecSignature.r = pvtsutils.BufferSourceConverter.toArrayBuffer(signaturePoint.r);
        ecSignature.s = pvtsutils.BufferSourceConverter.toArrayBuffer(signaturePoint.s);
        const ecSignatureRaw = Buffer.from(asn1Schema.AsnSerializer.serialize(ecSignature));
        const ok = signer.verify(options, ecSignatureRaw);
        return ok;
    }
    static async deriveBits(algorithm, baseKey, length) {
        const cryptoAlg = this.getOpenSSLNamedCurve(baseKey.algorithm.namedCurve);
        const ecdh = crypto.createECDH(cryptoAlg);
        const asnPrivateKey = asn1Schema.AsnParser.parse(baseKey.data, core__namespace.asn1.PrivateKeyInfo);
        const asnEcPrivateKey = asn1Schema.AsnParser.parse(asnPrivateKey.privateKey, core__namespace.asn1.EcPrivateKey);
        ecdh.setPrivateKey(Buffer.from(asnEcPrivateKey.privateKey));
        const asnPublicKey = asn1Schema.AsnParser.parse(algorithm.public.data, core__namespace.asn1.PublicKeyInfo);
        const bits = ecdh.computeSecret(Buffer.from(asnPublicKey.publicKey));
        if (length === null) {
            return bits;
        }
        return new Uint8Array(bits).buffer.slice(0, length &gt;&gt; 3);
    }
    static async exportKey(format, key) {
        switch (format.toLowerCase()) {
            case &quot;jwk&quot;:
                return jsonSchema.JsonSerializer.toJSON(key);
            case &quot;pkcs8&quot;:
            case &quot;spki&quot;:
                return new Uint8Array(key.data).buffer;
            case &quot;raw&quot;: {
                const publicKeyInfo = asn1Schema.AsnParser.parse(key.data, core__namespace.asn1.PublicKeyInfo);
                return publicKeyInfo.publicKey;
            }
            default:
                throw new core__namespace.OperationError(&quot;format: Must be &#039;jwk&#039;, &#039;raw&#039;, pkcs8&#039; or &#039;spki&#039;&quot;);
        }
    }
    static async importKey(format, keyData, algorithm, extractable, keyUsages) {
        switch (format.toLowerCase()) {
            case &quot;jwk&quot;: {
                const jwk = keyData;
                if (jwk.d) {
                    const asnKey = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: core__namespace.asn1.EcPrivateKey });
                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);
                }
                else {
                    const asnKey = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: core__namespace.asn1.EcPublicKey });
                    return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);
                }
            }
            case &quot;raw&quot;: {
                const asnKey = new core__namespace.asn1.EcPublicKey(keyData);
                return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);
            }
            case &quot;spki&quot;: {
                const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PublicKeyInfo);
                const asnKey = new core__namespace.asn1.EcPublicKey(keyInfo.publicKey);
                this.assertKeyParameters(keyInfo.publicKeyAlgorithm.parameters, algorithm.namedCurve);
                return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);
            }
            case &quot;pkcs8&quot;: {
                const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PrivateKeyInfo);
                const asnKey = asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.EcPrivateKey);
                this.assertKeyParameters(keyInfo.privateKeyAlgorithm.parameters, algorithm.namedCurve);
                return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);
            }
            default:
                throw new core__namespace.OperationError(&quot;format: Must be &#039;jwk&#039;, &#039;raw&#039;, &#039;pkcs8&#039; or &#039;spki&#039;&quot;);
        }
    }
    static assertKeyParameters(parameters, namedCurve) {
        if (!parameters) {
            throw new core__namespace.CryptoError(&quot;Key info doesn&#039;t have required parameters&quot;);
        }
        let namedCurveIdentifier = &quot;&quot;;
        try {
            namedCurveIdentifier = asn1Schema.AsnParser.parse(parameters, core__namespace.asn1.ObjectIdentifier).value;
        }
        catch (e) {
            throw new core__namespace.CryptoError(&quot;Cannot read key info parameters&quot;);
        }
        if (getOidByNamedCurve$1(namedCurve) !== namedCurveIdentifier) {
            throw new core__namespace.CryptoError(&quot;Key info parameter doesn&#039;t match to named curve&quot;);
        }
    }
    static async importPrivateKey(asnKey, algorithm, extractable, keyUsages) {
        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();
        keyInfo.privateKeyAlgorithm.algorithm = &quot;1.2.840.10045.2.1&quot;;
        keyInfo.privateKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(getOidByNamedCurve$1(algorithm.namedCurve)));
        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(asnKey);
        const key = new EcPrivateKey();
        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));
        key.algorithm = Object.assign({}, algorithm);
        key.extractable = extractable;
        key.usages = keyUsages;
        return key;
    }
    static async importPublicKey(asnKey, algorithm, extractable, keyUsages) {
        const keyInfo = new core__namespace.asn1.PublicKeyInfo();
        keyInfo.publicKeyAlgorithm.algorithm = &quot;1.2.840.10045.2.1&quot;;
        const namedCurve = getOidByNamedCurve$1(algorithm.namedCurve);
        keyInfo.publicKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(namedCurve));
        keyInfo.publicKey = asnKey.value;
        const key = new EcPublicKey();
        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));
        key.algorithm = Object.assign({}, algorithm);
        key.extractable = extractable;
        key.usages = keyUsages;
        return key;
    }
    static getOpenSSLNamedCurve(curve) {
        switch (curve.toUpperCase()) {
            case &quot;P-256&quot;:
                return &quot;prime256v1&quot;;
            case &quot;K-256&quot;:
                return &quot;secp256k1&quot;;
            case &quot;P-384&quot;:
                return &quot;secp384r1&quot;;
            case &quot;P-521&quot;:
                return &quot;secp521r1&quot;;
            default:
                return curve;
        }
    }
}
EcCrypto.publicKeyUsages = [&quot;verify&quot;];
EcCrypto.privateKeyUsages = [&quot;sign&quot;, &quot;deriveKey&quot;, &quot;deriveBits&quot;];

class EcdsaProvider extends core__namespace.EcdsaProvider {
    constructor() {
        super(...arguments);
        this.namedCurves = core__namespace.EcCurves.names;
        this.hashAlgorithms = [
            &quot;SHA-1&quot;, &quot;SHA-256&quot;, &quot;SHA-384&quot;, &quot;SHA-512&quot;,
            &quot;shake128&quot;, &quot;shake256&quot;,
            &quot;SHA3-256&quot;, &quot;SHA3-384&quot;, &quot;SHA3-512&quot;
        ];
    }
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await EcCrypto.generateKey({
            ...algorithm,
            name: this.name,
        }, extractable, keyUsages);
        return {
            privateKey: setCryptoKey(keys.privateKey),
            publicKey: setCryptoKey(keys.publicKey),
        };
    }
    async onSign(algorithm, key, data) {
        return EcCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onVerify(algorithm, key, signature, data) {
        return EcCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));
    }
    async onExportKey(format, key) {
        return EcCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await EcCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
        return setCryptoKey(key);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        const internalKey = getCryptoKey(key);
        if (!(internalKey instanceof EcPrivateKey || internalKey instanceof EcPublicKey)) {
            throw new TypeError(&quot;key: Is not EC CryptoKey&quot;);
        }
    }
}

class EcdhProvider extends core__namespace.EcdhProvider {
    constructor() {
        super(...arguments);
        this.namedCurves = core__namespace.EcCurves.names;
    }
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await EcCrypto.generateKey({
            ...algorithm,
            name: this.name,
        }, extractable, keyUsages);
        return {
            privateKey: setCryptoKey(keys.privateKey),
            publicKey: setCryptoKey(keys.publicKey),
        };
    }
    async onExportKey(format, key) {
        return EcCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await EcCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
        return setCryptoKey(key);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        const internalKey = getCryptoKey(key);
        if (!(internalKey instanceof EcPrivateKey || internalKey instanceof EcPublicKey)) {
            throw new TypeError(&quot;key: Is not EC CryptoKey&quot;);
        }
    }
    async onDeriveBits(algorithm, baseKey, length) {
        const bits = await EcCrypto.deriveBits({ ...algorithm, public: getCryptoKey(algorithm.public) }, getCryptoKey(baseKey), length);
        return bits;
    }
}

const edOIDs = {
    [core__namespace.asn1.idEd448]: &quot;Ed448&quot;,
    &quot;ed448&quot;: core__namespace.asn1.idEd448,
    [core__namespace.asn1.idX448]: &quot;X448&quot;,
    &quot;x448&quot;: core__namespace.asn1.idX448,
    [core__namespace.asn1.idEd25519]: &quot;Ed25519&quot;,
    &quot;ed25519&quot;: core__namespace.asn1.idEd25519,
    [core__namespace.asn1.idX25519]: &quot;X25519&quot;,
    &quot;x25519&quot;: core__namespace.asn1.idX25519,
};
function getOidByNamedCurve(namedCurve) {
    const oid = edOIDs[namedCurve.toLowerCase()];
    if (!oid) {
        throw new core__namespace.OperationError(`Cannot convert WebCrypto named curve &#039;${namedCurve}&#039; to OID`);
    }
    return oid;
}

class EdPrivateKey extends AsymmetricKey {
    constructor() {
        super(...arguments);
        this.type = &quot;private&quot;;
    }
    getKey() {
        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PrivateKeyInfo);
        return asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.CurvePrivateKey);
    }
    toJSON() {
        const key = this.getKey();
        const json = {
            kty: &quot;OKP&quot;,
            crv: this.algorithm.namedCurve,
            key_ops: this.usages,
            ext: this.extractable,
        };
        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));
    }
    fromJSON(json) {
        if (!json.crv) {
            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property &#039;crv&#039; is required`);
        }
        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();
        keyInfo.privateKeyAlgorithm.algorithm = getOidByNamedCurve(json.crv);
        const key = jsonSchema.JsonParser.fromJSON(json, { targetSchema: core__namespace.asn1.CurvePrivateKey });
        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(key);
        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));
        return this;
    }
}

class EdPublicKey extends AsymmetricKey {
    constructor() {
        super(...arguments);
        this.type = &quot;public&quot;;
    }
    getKey() {
        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PublicKeyInfo);
        return keyInfo.publicKey;
    }
    toJSON() {
        const key = this.getKey();
        const json = {
            kty: &quot;OKP&quot;,
            crv: this.algorithm.namedCurve,
            key_ops: this.usages,
            ext: this.extractable,
        };
        return Object.assign(json, {
            x: pvtsutils.Convert.ToBase64Url(key)
        });
    }
    fromJSON(json) {
        if (!json.crv) {
            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property &#039;crv&#039; is required`);
        }
        if (!json.x) {
            throw new core__namespace.OperationError(`Cannot get property from JWK. Property &#039;x&#039; is required`);
        }
        const keyInfo = new core__namespace.asn1.PublicKeyInfo();
        keyInfo.publicKeyAlgorithm.algorithm = getOidByNamedCurve(json.crv);
        keyInfo.publicKey = pvtsutils.Convert.FromBase64Url(json.x);
        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));
        return this;
    }
}

class EdCrypto {
    static async generateKey(algorithm, extractable, keyUsages) {
        const privateKey = new EdPrivateKey();
        privateKey.algorithm = algorithm;
        privateKey.extractable = extractable;
        privateKey.usages = keyUsages.filter((usage) =&gt; this.privateKeyUsages.indexOf(usage) !== -1);
        const publicKey = new EdPublicKey();
        publicKey.algorithm = algorithm;
        publicKey.extractable = true;
        publicKey.usages = keyUsages.filter((usage) =&gt; this.publicKeyUsages.indexOf(usage) !== -1);
        const type = algorithm.namedCurve.toLowerCase();
        const keys = crypto.generateKeyPairSync(type, {
            publicKeyEncoding: {
                format: &quot;der&quot;,
                type: &quot;spki&quot;,
            },
            privateKeyEncoding: {
                format: &quot;der&quot;,
                type: &quot;pkcs8&quot;,
            },
        });
        privateKey.data = keys.privateKey;
        publicKey.data = keys.publicKey;
        const res = {
            privateKey,
            publicKey,
        };
        return res;
    }
    static async sign(algorithm, key, data) {
        if (!key.pem) {
            key.pem = `-----BEGIN PRIVATE KEY-----\n${key.data.toString(&quot;base64&quot;)}\n-----END PRIVATE KEY-----`;
        }
        const options = {
            key: key.pem,
        };
        const signature = crypto.sign(null, Buffer.from(data), options);
        return core__namespace.BufferSourceConverter.toArrayBuffer(signature);
    }
    static async verify(algorithm, key, signature, data) {
        if (!key.pem) {
            key.pem = `-----BEGIN PUBLIC KEY-----\n${key.data.toString(&quot;base64&quot;)}\n-----END PUBLIC KEY-----`;
        }
        const options = {
            key: key.pem,
        };
        const ok = crypto.verify(null, Buffer.from(data), options, Buffer.from(signature));
        return ok;
    }
    static async deriveBits(algorithm, baseKey, length) {
        const publicKey = crypto.createPublicKey({
            key: algorithm.public.data,
            format: &quot;der&quot;,
            type: &quot;spki&quot;,
        });
        const privateKey = crypto.createPrivateKey({
            key: baseKey.data,
            format: &quot;der&quot;,
            type: &quot;pkcs8&quot;,
        });
        const bits = crypto.diffieHellman({
            publicKey,
            privateKey,
        });
        return new Uint8Array(bits).buffer.slice(0, length &gt;&gt; 3);
    }
    static async exportKey(format, key) {
        switch (format.toLowerCase()) {
            case &quot;jwk&quot;:
                return jsonSchema.JsonSerializer.toJSON(key);
            case &quot;pkcs8&quot;:
            case &quot;spki&quot;:
                return new Uint8Array(key.data).buffer;
            case &quot;raw&quot;: {
                const publicKeyInfo = asn1Schema.AsnParser.parse(key.data, core__namespace.asn1.PublicKeyInfo);
                return publicKeyInfo.publicKey;
            }
            default:
                throw new core__namespace.OperationError(&quot;format: Must be &#039;jwk&#039;, &#039;raw&#039;, pkcs8&#039; or &#039;spki&#039;&quot;);
        }
    }
    static async importKey(format, keyData, algorithm, extractable, keyUsages) {
        switch (format.toLowerCase()) {
            case &quot;jwk&quot;: {
                const jwk = keyData;
                if (jwk.d) {
                    const asnKey = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: core__namespace.asn1.CurvePrivateKey });
                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);
                }
                else {
                    if (!jwk.x) {
                        throw new TypeError(&quot;keyData: Cannot get required &#039;x&#039; filed&quot;);
                    }
                    return this.importPublicKey(pvtsutils.Convert.FromBase64Url(jwk.x), algorithm, extractable, keyUsages);
                }
            }
            case &quot;raw&quot;: {
                return this.importPublicKey(keyData, algorithm, extractable, keyUsages);
            }
            case &quot;spki&quot;: {
                const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PublicKeyInfo);
                return this.importPublicKey(keyInfo.publicKey, algorithm, extractable, keyUsages);
            }
            case &quot;pkcs8&quot;: {
                const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PrivateKeyInfo);
                const asnKey = asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.CurvePrivateKey);
                return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);
            }
            default:
                throw new core__namespace.OperationError(&quot;format: Must be &#039;jwk&#039;, &#039;raw&#039;, &#039;pkcs8&#039; or &#039;spki&#039;&quot;);
        }
    }
    static importPrivateKey(asnKey, algorithm, extractable, keyUsages) {
        const key = new EdPrivateKey();
        key.fromJSON({
            crv: algorithm.namedCurve,
            d: pvtsutils.Convert.ToBase64Url(asnKey.d),
        });
        key.algorithm = Object.assign({}, algorithm);
        key.extractable = extractable;
        key.usages = keyUsages;
        return key;
    }
    static async importPublicKey(asnKey, algorithm, extractable, keyUsages) {
        const key = new EdPublicKey();
        key.fromJSON({
            crv: algorithm.namedCurve,
            x: pvtsutils.Convert.ToBase64Url(asnKey),
        });
        key.algorithm = Object.assign({}, algorithm);
        key.extractable = extractable;
        key.usages = keyUsages;
        return key;
    }
}
EdCrypto.publicKeyUsages = [&quot;verify&quot;];
EdCrypto.privateKeyUsages = [&quot;sign&quot;, &quot;deriveKey&quot;, &quot;deriveBits&quot;];

class EdDsaProvider extends core__namespace.EdDsaProvider {
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await EdCrypto.generateKey({
            name: this.name,
            namedCurve: algorithm.namedCurve.replace(/^ed/i, &quot;Ed&quot;),
        }, extractable, keyUsages);
        return {
            privateKey: setCryptoKey(keys.privateKey),
            publicKey: setCryptoKey(keys.publicKey),
        };
    }
    async onSign(algorithm, key, data) {
        return EdCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onVerify(algorithm, key, signature, data) {
        return EdCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));
    }
    async onExportKey(format, key) {
        return EdCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await EdCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
        return setCryptoKey(key);
    }
}

class EcdhEsProvider extends core__namespace.EcdhEsProvider {
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await EdCrypto.generateKey({
            name: this.name,
            namedCurve: algorithm.namedCurve.toUpperCase(),
        }, extractable, keyUsages);
        return {
            privateKey: setCryptoKey(keys.privateKey),
            publicKey: setCryptoKey(keys.publicKey),
        };
    }
    async onDeriveBits(algorithm, baseKey, length) {
        const bits = await EdCrypto.deriveBits({ ...algorithm, public: getCryptoKey(algorithm.public) }, getCryptoKey(baseKey), length);
        return bits;
    }
    async onExportKey(format, key) {
        return EdCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await EdCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
        return setCryptoKey(key);
    }
}

class PbkdfCryptoKey extends CryptoKey {
}

class Pbkdf2Provider extends core__namespace.Pbkdf2Provider {
    async onDeriveBits(algorithm, baseKey, length) {
        return new Promise((resolve, reject) =&gt; {
            const salt = core__namespace.BufferSourceConverter.toArrayBuffer(algorithm.salt);
            const hash = algorithm.hash.name.replace(&quot;-&quot;, &quot;&quot;);
            crypto.pbkdf2(getCryptoKey(baseKey).data, Buffer.from(salt), algorithm.iterations, length &gt;&gt; 3, hash, (err, derivedBits) =&gt; {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(new Uint8Array(derivedBits).buffer);
                }
            });
        });
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        if (format === &quot;raw&quot;) {
            const key = new PbkdfCryptoKey();
            key.data = Buffer.from(keyData);
            key.algorithm = { name: this.name };
            key.extractable = false;
            key.usages = keyUsages;
            return setCryptoKey(key);
        }
        throw new core__namespace.OperationError(&quot;format: Must be &#039;raw&#039;&quot;);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof PbkdfCryptoKey)) {
            throw new TypeError(&quot;key: Is not PBKDF CryptoKey&quot;);
        }
    }
}

class HmacCryptoKey extends CryptoKey {
    get alg() {
        const hash = this.algorithm.hash.name.toUpperCase();
        return `HS${hash.replace(&quot;SHA-&quot;, &quot;&quot;)}`;
    }
    set alg(value) {
    }
}
tslib.__decorate([
    jsonSchema.JsonProp({ name: &quot;k&quot;, converter: JsonBase64UrlConverter })
], HmacCryptoKey.prototype, &quot;data&quot;, void 0);

class HmacProvider extends core__namespace.HmacProvider {
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const length = (algorithm.length || this.getDefaultLength(algorithm.hash.name)) &gt;&gt; 3 &lt;&lt; 3;
        const key = new HmacCryptoKey();
        key.algorithm = {
            ...algorithm,
            length,
            name: this.name,
        };
        key.extractable = extractable;
        key.usages = keyUsages;
        key.data = crypto.randomBytes(length &gt;&gt; 3);
        return setCryptoKey(key);
    }
    async onSign(algorithm, key, data) {
        const cryptoAlg = ShaCrypto.getAlgorithmName(key.algorithm.hash);
        const hmac = crypto.createHmac(cryptoAlg, getCryptoKey(key).data)
            .update(Buffer.from(data)).digest();
        return new Uint8Array(hmac).buffer;
    }
    async onVerify(algorithm, key, signature, data) {
        const cryptoAlg = ShaCrypto.getAlgorithmName(key.algorithm.hash);
        const hmac = crypto.createHmac(cryptoAlg, getCryptoKey(key).data)
            .update(Buffer.from(data)).digest();
        return hmac.compare(Buffer.from(signature)) === 0;
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        let key;
        switch (format.toLowerCase()) {
            case &quot;jwk&quot;:
                key = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: HmacCryptoKey });
                break;
            case &quot;raw&quot;:
                key = new HmacCryptoKey();
                key.data = Buffer.from(keyData);
                break;
            default:
                throw new core__namespace.OperationError(&quot;format: Must be &#039;jwk&#039; or &#039;raw&#039;&quot;);
        }
        key.algorithm = {
            hash: { name: algorithm.hash.name },
            name: this.name,
            length: key.data.length &lt;&lt; 3,
        };
        key.extractable = extractable;
        key.usages = keyUsages;
        return setCryptoKey(key);
    }
    async onExportKey(format, key) {
        switch (format.toLowerCase()) {
            case &quot;jwk&quot;:
                return jsonSchema.JsonSerializer.toJSON(getCryptoKey(key));
            case &quot;raw&quot;:
                return new Uint8Array(getCryptoKey(key).data).buffer;
            default:
                throw new core__namespace.OperationError(&quot;format: Must be &#039;jwk&#039; or &#039;raw&#039;&quot;);
        }
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof HmacCryptoKey)) {
            throw new TypeError(&quot;key: Is not HMAC CryptoKey&quot;);
        }
    }
}

class HkdfCryptoKey extends CryptoKey {
}

class HkdfProvider extends core__namespace.HkdfProvider {
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        if (format.toLowerCase() !== &quot;raw&quot;) {
            throw new core__namespace.OperationError(&quot;Operation not supported&quot;);
        }
        const key = new HkdfCryptoKey();
        key.data = Buffer.from(keyData);
        key.algorithm = { name: this.name };
        key.extractable = extractable;
        key.usages = keyUsages;
        return setCryptoKey(key);
    }
    async onDeriveBits(params, baseKey, length) {
        const hash = params.hash.name.replace(&quot;-&quot;, &quot;&quot;);
        const hashLength = crypto.createHash(hash).digest().length;
        const byteLength = length / 8;
        const info = core.BufferSourceConverter.toUint8Array(params.info);
        const PRK = crypto.createHmac(hash, core.BufferSourceConverter.toUint8Array(params.salt))
            .update(core.BufferSourceConverter.toUint8Array(getCryptoKey(baseKey).data))
            .digest();
        const blocks = [Buffer.alloc(0)];
        const blockCount = Math.ceil(byteLength / hashLength) + 1;
        for (let i = 1; i &lt; blockCount; ++i) {
            blocks.push(crypto.createHmac(hash, PRK)
                .update(Buffer.concat([blocks[i - 1], info, Buffer.from([i])]))
                .digest());
        }
        return Buffer.concat(blocks).slice(0, byteLength);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof HkdfCryptoKey)) {
            throw new TypeError(&quot;key: Is not HKDF CryptoKey&quot;);
        }
    }
}

class ShakeCrypto {
    static digest(algorithm, data) {
        const hash = crypto.createHash(algorithm.name.toLowerCase(), { outputLength: algorithm.length })
            .update(Buffer.from(data)).digest();
        return new Uint8Array(hash).buffer;
    }
}

class Shake128Provider extends core__namespace.Shake128Provider {
    async onDigest(algorithm, data) {
        return ShakeCrypto.digest(algorithm, data);
    }
}

class Shake256Provider extends core__namespace.Shake256Provider {
    async onDigest(algorithm, data) {
        return ShakeCrypto.digest(algorithm, data);
    }
}

class SubtleCrypto extends core__namespace.SubtleCrypto {
    constructor() {
        var _a;
        super();
        this.providers.set(new AesCbcProvider());
        this.providers.set(new AesCtrProvider());
        this.providers.set(new AesGcmProvider());
        this.providers.set(new AesCmacProvider());
        this.providers.set(new AesKwProvider());
        this.providers.set(new AesEcbProvider());
        this.providers.set(new DesCbcProvider());
        this.providers.set(new DesEde3CbcProvider());
        this.providers.set(new RsaSsaProvider());
        this.providers.set(new RsaPssProvider());
        this.providers.set(new RsaOaepProvider());
        this.providers.set(new RsaEsProvider());
        this.providers.set(new EcdsaProvider());
        this.providers.set(new EcdhProvider());
        this.providers.set(new Sha1Provider());
        this.providers.set(new Sha256Provider());
        this.providers.set(new Sha384Provider());
        this.providers.set(new Sha512Provider());
        this.providers.set(new Pbkdf2Provider());
        this.providers.set(new HmacProvider());
        this.providers.set(new HkdfProvider());
        const nodeMajorVersion = (_a = /^v(\d+)/.exec(process__namespace.version)) === null || _a === void 0 ? void 0 : _a[1];
        if (nodeMajorVersion &amp;&amp; parseInt(nodeMajorVersion, 10) &gt;= 12) {
            this.providers.set(new Shake128Provider());
            this.providers.set(new Shake256Provider());
        }
        const hashes = crypto__namespace.getHashes();
        if (hashes.includes(&quot;sha3-256&quot;)) {
            this.providers.set(new Sha3256Provider());
        }
        if (hashes.includes(&quot;sha3-384&quot;)) {
            this.providers.set(new Sha3384Provider());
        }
        if (hashes.includes(&quot;sha3-512&quot;)) {
            this.providers.set(new Sha3512Provider());
        }
        if (nodeMajorVersion &amp;&amp; parseInt(nodeMajorVersion, 10) &gt;= 14) {
            this.providers.set(new EdDsaProvider());
            this.providers.set(new EcdhEsProvider());
        }
    }
}

class Crypto extends core__namespace.Crypto {
    constructor() {
        super(...arguments);
        this.subtle = new SubtleCrypto();
    }
    getRandomValues(array) {
        if (!ArrayBuffer.isView(array)) {
            throw new TypeError(&quot;Failed to execute &#039;getRandomValues&#039; on &#039;Crypto&#039;: parameter 1 is not of type &#039;ArrayBufferView&#039;&quot;);
        }
        const buffer = Buffer.from(array.buffer, array.byteOffset, array.byteLength);
        crypto.randomFillSync(buffer);
        return array;
    }
}

Object.defineProperty(exports, &#039;CryptoKey&#039;, {
  enumerable: true,
  get: function () { return core.CryptoKey; }
});
exports.Crypto = Crypto;</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
