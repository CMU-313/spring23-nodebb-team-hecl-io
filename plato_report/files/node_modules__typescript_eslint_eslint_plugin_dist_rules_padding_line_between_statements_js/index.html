<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@typescript-eslint/eslint-plugin/dist/rules/padding-line-between-statements.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@typescript-eslint/eslint-plugin/dist/rules/padding-line-between-statements.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">70.00</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">652</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">65.39</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.25</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
var __createBinding = (this &amp;&amp; this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (&quot;get&quot; in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this &amp;&amp; this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, &quot;default&quot;, { enumerable: true, value: v });
}) : function(o, v) {
    o[&quot;default&quot;] = v;
});
var __importStar = (this &amp;&amp; this.__importStar) || function (mod) {
    if (mod &amp;&amp; mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== &quot;default&quot; &amp;&amp; Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
const utils_1 = require(&quot;@typescript-eslint/utils&quot;);
const util = __importStar(require(&quot;../util&quot;));
const LT = `[${Array.from(new Set([&#039;\r\n&#039;, &#039;\r&#039;, &#039;\n&#039;, &#039;\u2028&#039;, &#039;\u2029&#039;])).join(&#039;&#039;)}]`;
const PADDING_LINE_SEQUENCE = new RegExp(String.raw `^(\s*?${LT})\s*${LT}(\s*;?)$`, &#039;u&#039;);
/**
 * Creates tester which check if a node starts with specific keyword with the
 * appropriate AST_NODE_TYPES.
 * @param keyword The keyword to test.
 * @returns the created tester.
 * @private
 */
function newKeywordTester(type, keyword) {
    return {
        test(node, sourceCode) {
            var _a;
            const isSameKeyword = ((_a = sourceCode.getFirstToken(node)) === null || _a === void 0 ? void 0 : _a.value) === keyword;
            const isSameType = Array.isArray(type)
                ? type.some(val =&gt; val === node.type)
                : type === node.type;
            return isSameKeyword &amp;&amp; isSameType;
        },
    };
}
/**
 * Creates tester which check if a node starts with specific keyword and spans a single line.
 * @param keyword The keyword to test.
 * @returns the created tester.
 * @private
 */
function newSinglelineKeywordTester(keyword) {
    return {
        test(node, sourceCode) {
            return (node.loc.start.line === node.loc.end.line &amp;&amp;
                sourceCode.getFirstToken(node).value === keyword);
        },
    };
}
/**
 * Creates tester which check if a node starts with specific keyword and spans multiple lines.
 * @param keyword The keyword to test.
 * @returns the created tester.
 * @private
 */
function newMultilineKeywordTester(keyword) {
    return {
        test(node, sourceCode) {
            return (node.loc.start.line !== node.loc.end.line &amp;&amp;
                sourceCode.getFirstToken(node).value === keyword);
        },
    };
}
/**
 * Creates tester which check if a node is specific type.
 * @param type The node type to test.
 * @returns the created tester.
 * @private
 */
function newNodeTypeTester(type) {
    return {
        test: (node) =&gt; node.type === type,
    };
}
/**
 * Skips a chain expression node
 * @param node The node to test
 * @returnsA non-chain expression
 * @private
 */
function skipChainExpression(node) {
    return node &amp;&amp; node.type === utils_1.AST_NODE_TYPES.ChainExpression
        ? node.expression
        : node;
}
/**
 * Checks the given node is an expression statement of IIFE.
 * @param node The node to check.
 * @returns `true` if the node is an expression statement of IIFE.
 * @private
 */
function isIIFEStatement(node) {
    if (node.type === utils_1.AST_NODE_TYPES.ExpressionStatement) {
        let expression = skipChainExpression(node.expression);
        if (expression.type === utils_1.AST_NODE_TYPES.UnaryExpression) {
            expression = skipChainExpression(expression.argument);
        }
        if (expression.type === utils_1.AST_NODE_TYPES.CallExpression) {
            let node = expression.callee;
            while (node.type === utils_1.AST_NODE_TYPES.SequenceExpression) {
                node = node.expressions[node.expressions.length - 1];
            }
            return util.isFunction(node);
        }
    }
    return false;
}
/**
 * Checks the given node is a CommonJS require statement
 * @param node The node to check.
 * @returns `true` if the node is a CommonJS require statement.
 * @private
 */
function isCJSRequire(node) {
    if (node.type === utils_1.AST_NODE_TYPES.VariableDeclaration) {
        const declaration = node.declarations[0];
        if (declaration === null || declaration === void 0 ? void 0 : declaration.init) {
            let call = declaration === null || declaration === void 0 ? void 0 : declaration.init;
            while (call.type === utils_1.AST_NODE_TYPES.MemberExpression) {
                call = call.object;
            }
            if (call.type === utils_1.AST_NODE_TYPES.CallExpression &amp;&amp;
                call.callee.type === utils_1.AST_NODE_TYPES.Identifier) {
                return call.callee.name === &#039;require&#039;;
            }
        }
    }
    return false;
}
/**
 * Checks whether the given node is a block-like statement.
 * This checks the last token of the node is the closing brace of a block.
 * @param sourceCode The source code to get tokens.
 * @param node The node to check.
 * @returns `true` if the node is a block-like statement.
 * @private
 */
function isBlockLikeStatement(node, sourceCode) {
    // do-while with a block is a block-like statement.
    if (node.type === utils_1.AST_NODE_TYPES.DoWhileStatement &amp;&amp;
        node.body.type === utils_1.AST_NODE_TYPES.BlockStatement) {
        return true;
    }
    /**
     * IIFE is a block-like statement specially from
     * JSCS#disallowPaddingNewLinesAfterBlocks.
     */
    if (isIIFEStatement(node)) {
        return true;
    }
    // Checks the last token is a closing brace of blocks.
    const lastToken = sourceCode.getLastToken(node, util.isNotSemicolonToken);
    const belongingNode = lastToken &amp;&amp; util.isClosingBraceToken(lastToken)
        ? sourceCode.getNodeByRangeIndex(lastToken.range[0])
        : null;
    return (!!belongingNode &amp;&amp;
        (belongingNode.type === utils_1.AST_NODE_TYPES.BlockStatement ||
            belongingNode.type === utils_1.AST_NODE_TYPES.SwitchStatement));
}
/**
 * Check whether the given node is a directive or not.
 * @param node The node to check.
 * @param sourceCode The source code object to get tokens.
 * @returns `true` if the node is a directive.
 */
function isDirective(node, sourceCode) {
    var _a, _b;
    return (node.type === utils_1.AST_NODE_TYPES.ExpressionStatement &amp;&amp;
        (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.Program ||
            (((_b = node.parent) === null || _b === void 0 ? void 0 : _b.type) === utils_1.AST_NODE_TYPES.BlockStatement &amp;&amp;
                util.isFunction(node.parent.parent))) &amp;&amp;
        node.expression.type === utils_1.AST_NODE_TYPES.Literal &amp;&amp;
        typeof node.expression.value === &#039;string&#039; &amp;&amp;
        !util.isParenthesized(node.expression, sourceCode));
}
/**
 * Check whether the given node is a part of directive prologue or not.
 * @param node The node to check.
 * @param sourceCode The source code object to get tokens.
 * @returns `true` if the node is a part of directive prologue.
 */
function isDirectivePrologue(node, sourceCode) {
    if (isDirective(node, sourceCode) &amp;&amp;
        node.parent &amp;&amp;
        &#039;body&#039; in node.parent &amp;&amp;
        Array.isArray(node.parent.body)) {
        for (const sibling of node.parent.body) {
            if (sibling === node) {
                break;
            }
            if (!isDirective(sibling, sourceCode)) {
                return false;
            }
        }
        return true;
    }
    return false;
}
/**
 * Checks the given node is a CommonJS export statement
 * @param node The node to check.
 * @returns `true` if the node is a CommonJS export statement.
 * @private
 */
function isCJSExport(node) {
    if (node.type === utils_1.AST_NODE_TYPES.ExpressionStatement) {
        const expression = node.expression;
        if (expression.type === utils_1.AST_NODE_TYPES.AssignmentExpression) {
            let left = expression.left;
            if (left.type === utils_1.AST_NODE_TYPES.MemberExpression) {
                while (left.object.type === utils_1.AST_NODE_TYPES.MemberExpression) {
                    left = left.object;
                }
                return (left.object.type === utils_1.AST_NODE_TYPES.Identifier &amp;&amp;
                    (left.object.name === &#039;exports&#039; ||
                        (left.object.name === &#039;module&#039; &amp;&amp;
                            left.property.type === utils_1.AST_NODE_TYPES.Identifier &amp;&amp;
                            left.property.name === &#039;exports&#039;)));
            }
        }
    }
    return false;
}
/**
 * Check whether the given node is an expression
 * @param node The node to check.
 * @param sourceCode The source code object to get tokens.
 * @returns `true` if the node is an expression
 */
function isExpression(node, sourceCode) {
    return (node.type === utils_1.AST_NODE_TYPES.ExpressionStatement &amp;&amp;
        !isDirectivePrologue(node, sourceCode));
}
/**
 * Gets the actual last token.
 *
 * If a semicolon is semicolon-less style&#039;s semicolon, this ignores it.
 * For example:
 *
 *     foo()
 *     ;[1, 2, 3].forEach(bar)
 * @param sourceCode The source code to get tokens.
 * @param node The node to get.
 * @returns The actual last token.
 * @private
 */
function getActualLastToken(node, sourceCode) {
    const semiToken = sourceCode.getLastToken(node);
    const prevToken = sourceCode.getTokenBefore(semiToken);
    const nextToken = sourceCode.getTokenAfter(semiToken);
    const isSemicolonLessStyle = prevToken &amp;&amp;
        nextToken &amp;&amp;
        prevToken.range[0] &gt;= node.range[0] &amp;&amp;
        util.isSemicolonToken(semiToken) &amp;&amp;
        semiToken.loc.start.line !== prevToken.loc.end.line &amp;&amp;
        semiToken.loc.end.line === nextToken.loc.start.line;
    return isSemicolonLessStyle ? prevToken : semiToken;
}
/**
 * This returns the concatenation of the first 2 captured strings.
 * @param _ Unused. Whole matched string.
 * @param trailingSpaces The trailing spaces of the first line.
 * @param indentSpaces The indentation spaces of the last line.
 * @returns The concatenation of trailingSpaces and indentSpaces.
 * @private
 */
function replacerToRemovePaddingLines(_, trailingSpaces, indentSpaces) {
    return trailingSpaces + indentSpaces;
}
/**
 * Check and report statements for `any` configuration.
 * It does nothing.
 *
 * @private
 */
function verifyForAny() {
    // Empty
}
/**
 * Check and report statements for `never` configuration.
 * This autofix removes blank lines between the given 2 statements.
 * However, if comments exist between 2 blank lines, it does not remove those
 * blank lines automatically.
 * @param context The rule context to report.
 * @param _ Unused. The previous node to check.
 * @param nextNode The next node to check.
 * @param paddingLines The array of token pairs that blank
 * lines exist between the pair.
 *
 * @private
 */
function verifyForNever(context, _, nextNode, paddingLines) {
    if (paddingLines.length === 0) {
        return;
    }
    context.report({
        node: nextNode,
        messageId: &#039;unexpectedBlankLine&#039;,
        fix(fixer) {
            if (paddingLines.length &gt;= 2) {
                return null;
            }
            const prevToken = paddingLines[0][0];
            const nextToken = paddingLines[0][1];
            const start = prevToken.range[1];
            const end = nextToken.range[0];
            const text = context
                .getSourceCode()
                .text.slice(start, end)
                .replace(PADDING_LINE_SEQUENCE, replacerToRemovePaddingLines);
            return fixer.replaceTextRange([start, end], text);
        },
    });
}
/**
 * Check and report statements for `always` configuration.
 * This autofix inserts a blank line between the given 2 statements.
 * If the `prevNode` has trailing comments, it inserts a blank line after the
 * trailing comments.
 * @param context The rule context to report.
 * @param prevNode The previous node to check.
 * @param nextNode The next node to check.
 * @param paddingLines The array of token pairs that blank
 * lines exist between the pair.
 *
 * @private
 */
function verifyForAlways(context, prevNode, nextNode, paddingLines) {
    if (paddingLines.length &gt; 0) {
        return;
    }
    context.report({
        node: nextNode,
        messageId: &#039;expectedBlankLine&#039;,
        fix(fixer) {
            const sourceCode = context.getSourceCode();
            let prevToken = getActualLastToken(prevNode, sourceCode);
            const nextToken = sourceCode.getFirstTokenBetween(prevToken, nextNode, {
                includeComments: true,
                /**
                 * Skip the trailing comments of the previous node.
                 * This inserts a blank line after the last trailing comment.
                 *
                 * For example:
                 *
                 *     foo(); // trailing comment.
                 *     // comment.
                 *     bar();
                 *
                 * Get fixed to:
                 *
                 *     foo(); // trailing comment.
                 *
                 *     // comment.
                 *     bar();
                 * @param token The token to check.
                 * @returns `true` if the token is not a trailing comment.
                 * @private
                 */
                filter(token) {
                    if (util.isTokenOnSameLine(prevToken, token)) {
                        prevToken = token;
                        return false;
                    }
                    return true;
                },
            }) || nextNode;
            const insertText = util.isTokenOnSameLine(prevToken, nextToken)
                ? &#039;\n\n&#039;
                : &#039;\n&#039;;
            return fixer.insertTextAfter(prevToken, insertText);
        },
    });
}
/**
 * Types of blank lines.
 * `any`, `never`, and `always` are defined.
 * Those have `verify` method to check and report statements.
 * @private
 */
const PaddingTypes = {
    any: { verify: verifyForAny },
    never: { verify: verifyForNever },
    always: { verify: verifyForAlways },
};
/**
 * Types of statements.
 * Those have `test` method to check it matches to the given statement.
 * @private
 */
const StatementTypes = {
    &#039;*&#039;: { test: () =&gt; true },
    &#039;block-like&#039;: { test: isBlockLikeStatement },
    exports: { test: isCJSExport },
    require: { test: isCJSRequire },
    directive: { test: isDirectivePrologue },
    expression: { test: isExpression },
    iife: { test: isIIFEStatement },
    &#039;multiline-block-like&#039;: {
        test: (node, sourceCode) =&gt; node.loc.start.line !== node.loc.end.line &amp;&amp;
            isBlockLikeStatement(node, sourceCode),
    },
    &#039;multiline-expression&#039;: {
        test: (node, sourceCode) =&gt; node.loc.start.line !== node.loc.end.line &amp;&amp;
            node.type === utils_1.AST_NODE_TYPES.ExpressionStatement &amp;&amp;
            !isDirectivePrologue(node, sourceCode),
    },
    &#039;multiline-const&#039;: newMultilineKeywordTester(&#039;const&#039;),
    &#039;multiline-let&#039;: newMultilineKeywordTester(&#039;let&#039;),
    &#039;multiline-var&#039;: newMultilineKeywordTester(&#039;var&#039;),
    &#039;singleline-const&#039;: newSinglelineKeywordTester(&#039;const&#039;),
    &#039;singleline-let&#039;: newSinglelineKeywordTester(&#039;let&#039;),
    &#039;singleline-var&#039;: newSinglelineKeywordTester(&#039;var&#039;),
    block: newNodeTypeTester(utils_1.AST_NODE_TYPES.BlockStatement),
    empty: newNodeTypeTester(utils_1.AST_NODE_TYPES.EmptyStatement),
    function: newNodeTypeTester(utils_1.AST_NODE_TYPES.FunctionDeclaration),
    break: newKeywordTester(utils_1.AST_NODE_TYPES.BreakStatement, &#039;break&#039;),
    case: newKeywordTester(utils_1.AST_NODE_TYPES.SwitchCase, &#039;case&#039;),
    class: newKeywordTester(utils_1.AST_NODE_TYPES.ClassDeclaration, &#039;class&#039;),
    const: newKeywordTester(utils_1.AST_NODE_TYPES.VariableDeclaration, &#039;const&#039;),
    continue: newKeywordTester(utils_1.AST_NODE_TYPES.ContinueStatement, &#039;continue&#039;),
    debugger: newKeywordTester(utils_1.AST_NODE_TYPES.DebuggerStatement, &#039;debugger&#039;),
    default: newKeywordTester([utils_1.AST_NODE_TYPES.SwitchCase, utils_1.AST_NODE_TYPES.ExportDefaultDeclaration], &#039;default&#039;),
    do: newKeywordTester(utils_1.AST_NODE_TYPES.DoWhileStatement, &#039;do&#039;),
    export: newKeywordTester([
        utils_1.AST_NODE_TYPES.ExportDefaultDeclaration,
        utils_1.AST_NODE_TYPES.ExportNamedDeclaration,
    ], &#039;export&#039;),
    for: newKeywordTester([
        utils_1.AST_NODE_TYPES.ForStatement,
        utils_1.AST_NODE_TYPES.ForInStatement,
        utils_1.AST_NODE_TYPES.ForOfStatement,
    ], &#039;for&#039;),
    if: newKeywordTester(utils_1.AST_NODE_TYPES.IfStatement, &#039;if&#039;),
    import: newKeywordTester(utils_1.AST_NODE_TYPES.ImportDeclaration, &#039;import&#039;),
    let: newKeywordTester(utils_1.AST_NODE_TYPES.VariableDeclaration, &#039;let&#039;),
    return: newKeywordTester(utils_1.AST_NODE_TYPES.ReturnStatement, &#039;return&#039;),
    switch: newKeywordTester(utils_1.AST_NODE_TYPES.SwitchStatement, &#039;switch&#039;),
    throw: newKeywordTester(utils_1.AST_NODE_TYPES.ThrowStatement, &#039;throw&#039;),
    try: newKeywordTester(utils_1.AST_NODE_TYPES.TryStatement, &#039;try&#039;),
    var: newKeywordTester(utils_1.AST_NODE_TYPES.VariableDeclaration, &#039;var&#039;),
    while: newKeywordTester([utils_1.AST_NODE_TYPES.WhileStatement, utils_1.AST_NODE_TYPES.DoWhileStatement], &#039;while&#039;),
    with: newKeywordTester(utils_1.AST_NODE_TYPES.WithStatement, &#039;with&#039;),
    // Additional Typescript constructs
    interface: newKeywordTester(utils_1.AST_NODE_TYPES.TSInterfaceDeclaration, &#039;interface&#039;),
    type: newKeywordTester(utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration, &#039;type&#039;),
};
//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
exports.default = util.createRule({
    name: &#039;padding-line-between-statements&#039;,
    meta: {
        type: &#039;layout&#039;,
        docs: {
            description: &#039;Require or disallow padding lines between statements&#039;,
            recommended: false,
            extendsBaseRule: true,
        },
        fixable: &#039;whitespace&#039;,
        hasSuggestions: false,
        schema: {
            $defs: {
                paddingType: {
                    enum: Object.keys(PaddingTypes),
                },
                statementType: {
                    anyOf: [
                        { enum: Object.keys(StatementTypes) },
                        {
                            type: &#039;array&#039;,
                            items: { enum: Object.keys(StatementTypes) },
                            minItems: 1,
                            uniqueItems: true,
                            additionalItems: false,
                        },
                    ],
                },
            },
            type: &#039;array&#039;,
            items: {
                type: &#039;object&#039;,
                properties: {
                    blankLine: { $ref: &#039;#/$defs/paddingType&#039; },
                    prev: { $ref: &#039;#/$defs/statementType&#039; },
                    next: { $ref: &#039;#/$defs/statementType&#039; },
                },
                additionalProperties: false,
                required: [&#039;blankLine&#039;, &#039;prev&#039;, &#039;next&#039;],
            },
            additionalItems: false,
        },
        messages: {
            unexpectedBlankLine: &#039;Unexpected blank line before this statement.&#039;,
            expectedBlankLine: &#039;Expected blank line before this statement.&#039;,
        },
    },
    defaultOptions: [],
    create(context) {
        const sourceCode = context.getSourceCode();
        // eslint-disable-next-line no-restricted-syntax -- We need all raw options.
        const configureList = context.options || [];
        let scopeInfo = null;
        /**
         * Processes to enter to new scope.
         * This manages the current previous statement.
         *
         * @private
         */
        function enterScope() {
            scopeInfo = {
                upper: scopeInfo,
                prevNode: null,
            };
        }
        /**
         * Processes to exit from the current scope.
         *
         * @private
         */
        function exitScope() {
            if (scopeInfo) {
                scopeInfo = scopeInfo.upper;
            }
        }
        /**
         * Checks whether the given node matches the given type.
         * @param node The statement node to check.
         * @param type The statement type to check.
         * @returns `true` if the statement node matched the type.
         * @private
         */
        function match(node, type) {
            let innerStatementNode = node;
            while (innerStatementNode.type === utils_1.AST_NODE_TYPES.LabeledStatement) {
                innerStatementNode = innerStatementNode.body;
            }
            if (Array.isArray(type)) {
                return type.some(match.bind(null, innerStatementNode));
            }
            return StatementTypes[type].test(innerStatementNode, sourceCode);
        }
        /**
         * Finds the last matched configure from configureList.
         * @paramprevNode The previous statement to match.
         * @paramnextNode The current statement to match.
         * @returns The tester of the last matched configure.
         * @private
         */
        function getPaddingType(prevNode, nextNode) {
            for (let i = configureList.length - 1; i &gt;= 0; --i) {
                const configure = configureList[i];
                if (match(prevNode, configure.prev) &amp;&amp;
                    match(nextNode, configure.next)) {
                    return PaddingTypes[configure.blankLine];
                }
            }
            return PaddingTypes.any;
        }
        /**
         * Gets padding line sequences between the given 2 statements.
         * Comments are separators of the padding line sequences.
         * @paramprevNode The previous statement to count.
         * @paramnextNode The current statement to count.
         * @returns The array of token pairs.
         * @private
         */
        function getPaddingLineSequences(prevNode, nextNode) {
            const pairs = [];
            let prevToken = getActualLastToken(prevNode, sourceCode);
            if (nextNode.loc.start.line - prevToken.loc.end.line &gt;= 2) {
                do {
                    const token = sourceCode.getTokenAfter(prevToken, {
                        includeComments: true,
                    });
                    if (token.loc.start.line - prevToken.loc.end.line &gt;= 2) {
                        pairs.push([prevToken, token]);
                    }
                    prevToken = token;
                } while (prevToken.range[0] &lt; nextNode.range[0]);
            }
            return pairs;
        }
        /**
         * Verify padding lines between the given node and the previous node.
         * @param node The node to verify.
         *
         * @private
         */
        function verify(node) {
            if (!node.parent ||
                ![
                    utils_1.AST_NODE_TYPES.BlockStatement,
                    utils_1.AST_NODE_TYPES.Program,
                    utils_1.AST_NODE_TYPES.SwitchCase,
                    utils_1.AST_NODE_TYPES.SwitchStatement,
                    utils_1.AST_NODE_TYPES.TSModuleBlock,
                ].includes(node.parent.type)) {
                return;
            }
            // Save this node as the current previous statement.
            const prevNode = scopeInfo.prevNode;
            // Verify.
            if (prevNode) {
                const type = getPaddingType(prevNode, node);
                const paddingLines = getPaddingLineSequences(prevNode, node);
                type.verify(context, prevNode, node, paddingLines);
            }
            scopeInfo.prevNode = node;
        }
        /**
         * Verify padding lines between the given node and the previous node.
         * Then process to enter to new scope.
         * @param node The node to verify.
         *
         * @private
         */
        function verifyThenEnterScope(node) {
            verify(node);
            enterScope();
        }
        return {
            Program: enterScope,
            BlockStatement: enterScope,
            SwitchStatement: enterScope,
            TSModuleBlock: enterScope,
            &#039;Program:exit&#039;: exitScope,
            &#039;BlockStatement:exit&#039;: exitScope,
            &#039;SwitchStatement:exit&#039;: exitScope,
            &#039;TSModuleBlock:exit&#039;: exitScope,
            &#039;:statement&#039;: verify,
            SwitchCase: verifyThenEnterScope,
            TSDeclareFunction: verifyThenEnterScope,
            &#039;SwitchCase:exit&#039;: exitScope,
            &#039;TSDeclareFunction:exit&#039;: exitScope,
        };
    },
});
//# sourceMappingURL=padding-line-between-statements.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
