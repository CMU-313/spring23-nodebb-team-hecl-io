<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@babel/types/lib/definitions/core.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@babel/types/lib/definitions/core.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">72.66</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1648</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">132.22</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">21.27</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

Object.defineProperty(exports, &quot;__esModule&quot;, {
  value: true
});
exports.patternLikeCommon = exports.functionTypeAnnotationCommon = exports.functionDeclarationCommon = exports.functionCommon = exports.classMethodOrPropertyCommon = exports.classMethodOrDeclareMethodCommon = void 0;
var _is = require(&quot;../validators/is&quot;);
var _isValidIdentifier = require(&quot;../validators/isValidIdentifier&quot;);
var _helperValidatorIdentifier = require(&quot;@babel/helper-validator-identifier&quot;);
var _helperStringParser = require(&quot;@babel/helper-string-parser&quot;);
var _constants = require(&quot;../constants&quot;);
var _utils = require(&quot;./utils&quot;);
const defineType = (0, _utils.defineAliasedType)(&quot;Standardized&quot;);
defineType(&quot;ArrayExpression&quot;, {
  fields: {
    elements: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(&quot;null&quot;, &quot;Expression&quot;, &quot;SpreadElement&quot;))),
      default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined
    }
  },
  visitor: [&quot;elements&quot;],
  aliases: [&quot;Expression&quot;]
});
defineType(&quot;AssignmentExpression&quot;, {
  fields: {
    operator: {
      validate: function () {
        if (!process.env.BABEL_TYPES_8_BREAKING) {
          return (0, _utils.assertValueType)(&quot;string&quot;);
        }
        const identifier = (0, _utils.assertOneOf)(..._constants.ASSIGNMENT_OPERATORS);
        const pattern = (0, _utils.assertOneOf)(&quot;=&quot;);
        return function (node, key, val) {
          const validator = (0, _is.default)(&quot;Pattern&quot;, node.left) ? pattern : identifier;
          validator(node, key, val);
        };
      }()
    },
    left: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(&quot;LVal&quot;) : (0, _utils.assertNodeType)(&quot;Identifier&quot;, &quot;MemberExpression&quot;, &quot;ArrayPattern&quot;, &quot;ObjectPattern&quot;, &quot;TSAsExpression&quot;, &quot;TSSatisfiesExpression&quot;, &quot;TSTypeAssertion&quot;, &quot;TSNonNullExpression&quot;)
    },
    right: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;)
    }
  },
  builder: [&quot;operator&quot;, &quot;left&quot;, &quot;right&quot;],
  visitor: [&quot;left&quot;, &quot;right&quot;],
  aliases: [&quot;Expression&quot;]
});
defineType(&quot;BinaryExpression&quot;, {
  builder: [&quot;operator&quot;, &quot;left&quot;, &quot;right&quot;],
  fields: {
    operator: {
      validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)
    },
    left: {
      validate: function () {
        const expression = (0, _utils.assertNodeType)(&quot;Expression&quot;);
        const inOp = (0, _utils.assertNodeType)(&quot;Expression&quot;, &quot;PrivateName&quot;);
        const validator = Object.assign(function (node, key, val) {
          const validator = node.operator === &quot;in&quot; ? inOp : expression;
          validator(node, key, val);
        }, {
          oneOfNodeTypes: [&quot;Expression&quot;, &quot;PrivateName&quot;]
        });
        return validator;
      }()
    },
    right: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;)
    }
  },
  visitor: [&quot;left&quot;, &quot;right&quot;],
  aliases: [&quot;Binary&quot;, &quot;Expression&quot;]
});
defineType(&quot;InterpreterDirective&quot;, {
  builder: [&quot;value&quot;],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)(&quot;string&quot;)
    }
  }
});
defineType(&quot;Directive&quot;, {
  visitor: [&quot;value&quot;],
  fields: {
    value: {
      validate: (0, _utils.assertNodeType)(&quot;DirectiveLiteral&quot;)
    }
  }
});
defineType(&quot;DirectiveLiteral&quot;, {
  builder: [&quot;value&quot;],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)(&quot;string&quot;)
    }
  }
});
defineType(&quot;BlockStatement&quot;, {
  builder: [&quot;body&quot;, &quot;directives&quot;],
  visitor: [&quot;directives&quot;, &quot;body&quot;],
  fields: {
    directives: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;Directive&quot;))),
      default: []
    },
    body: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;Statement&quot;)))
    }
  },
  aliases: [&quot;Scopable&quot;, &quot;BlockParent&quot;, &quot;Block&quot;, &quot;Statement&quot;]
});
defineType(&quot;BreakStatement&quot;, {
  visitor: [&quot;label&quot;],
  fields: {
    label: {
      validate: (0, _utils.assertNodeType)(&quot;Identifier&quot;),
      optional: true
    }
  },
  aliases: [&quot;Statement&quot;, &quot;Terminatorless&quot;, &quot;CompletionStatement&quot;]
});
defineType(&quot;CallExpression&quot;, {
  visitor: [&quot;callee&quot;, &quot;arguments&quot;, &quot;typeParameters&quot;, &quot;typeArguments&quot;],
  builder: [&quot;callee&quot;, &quot;arguments&quot;],
  aliases: [&quot;Expression&quot;],
  fields: Object.assign({
    callee: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;, &quot;Super&quot;, &quot;V8IntrinsicIdentifier&quot;)
    },
    arguments: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;Expression&quot;, &quot;SpreadElement&quot;, &quot;JSXNamespacedName&quot;, &quot;ArgumentPlaceholder&quot;)))
    }
  }, !process.env.BABEL_TYPES_8_BREAKING ? {
    optional: {
      validate: (0, _utils.assertOneOf)(true, false),
      optional: true
    }
  } : {}, {
    typeArguments: {
      validate: (0, _utils.assertNodeType)(&quot;TypeParameterInstantiation&quot;),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)(&quot;TSTypeParameterInstantiation&quot;),
      optional: true
    }
  })
});
defineType(&quot;CatchClause&quot;, {
  visitor: [&quot;param&quot;, &quot;body&quot;],
  fields: {
    param: {
      validate: (0, _utils.assertNodeType)(&quot;Identifier&quot;, &quot;ArrayPattern&quot;, &quot;ObjectPattern&quot;),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)(&quot;BlockStatement&quot;)
    }
  },
  aliases: [&quot;Scopable&quot;, &quot;BlockParent&quot;]
});
defineType(&quot;ConditionalExpression&quot;, {
  visitor: [&quot;test&quot;, &quot;consequent&quot;, &quot;alternate&quot;],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;)
    },
    consequent: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;)
    },
    alternate: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;)
    }
  },
  aliases: [&quot;Expression&quot;, &quot;Conditional&quot;]
});
defineType(&quot;ContinueStatement&quot;, {
  visitor: [&quot;label&quot;],
  fields: {
    label: {
      validate: (0, _utils.assertNodeType)(&quot;Identifier&quot;),
      optional: true
    }
  },
  aliases: [&quot;Statement&quot;, &quot;Terminatorless&quot;, &quot;CompletionStatement&quot;]
});
defineType(&quot;DebuggerStatement&quot;, {
  aliases: [&quot;Statement&quot;]
});
defineType(&quot;DoWhileStatement&quot;, {
  visitor: [&quot;test&quot;, &quot;body&quot;],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;)
    },
    body: {
      validate: (0, _utils.assertNodeType)(&quot;Statement&quot;)
    }
  },
  aliases: [&quot;Statement&quot;, &quot;BlockParent&quot;, &quot;Loop&quot;, &quot;While&quot;, &quot;Scopable&quot;]
});
defineType(&quot;EmptyStatement&quot;, {
  aliases: [&quot;Statement&quot;]
});
defineType(&quot;ExpressionStatement&quot;, {
  visitor: [&quot;expression&quot;],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;)
    }
  },
  aliases: [&quot;Statement&quot;, &quot;ExpressionWrapper&quot;]
});
defineType(&quot;File&quot;, {
  builder: [&quot;program&quot;, &quot;comments&quot;, &quot;tokens&quot;],
  visitor: [&quot;program&quot;],
  fields: {
    program: {
      validate: (0, _utils.assertNodeType)(&quot;Program&quot;)
    },
    comments: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() =&gt; {}, {
        each: {
          oneOfNodeTypes: [&quot;CommentBlock&quot;, &quot;CommentLine&quot;]
        }
      }) : (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;CommentBlock&quot;, &quot;CommentLine&quot;)),
      optional: true
    },
    tokens: {
      validate: (0, _utils.assertEach)(Object.assign(() =&gt; {}, {
        type: &quot;any&quot;
      })),
      optional: true
    }
  }
});
defineType(&quot;ForInStatement&quot;, {
  visitor: [&quot;left&quot;, &quot;right&quot;, &quot;body&quot;],
  aliases: [&quot;Scopable&quot;, &quot;Statement&quot;, &quot;For&quot;, &quot;BlockParent&quot;, &quot;Loop&quot;, &quot;ForXStatement&quot;],
  fields: {
    left: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(&quot;VariableDeclaration&quot;, &quot;LVal&quot;) : (0, _utils.assertNodeType)(&quot;VariableDeclaration&quot;, &quot;Identifier&quot;, &quot;MemberExpression&quot;, &quot;ArrayPattern&quot;, &quot;ObjectPattern&quot;, &quot;TSAsExpression&quot;, &quot;TSSatisfiesExpression&quot;, &quot;TSTypeAssertion&quot;, &quot;TSNonNullExpression&quot;)
    },
    right: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;)
    },
    body: {
      validate: (0, _utils.assertNodeType)(&quot;Statement&quot;)
    }
  }
});
defineType(&quot;ForStatement&quot;, {
  visitor: [&quot;init&quot;, &quot;test&quot;, &quot;update&quot;, &quot;body&quot;],
  aliases: [&quot;Scopable&quot;, &quot;Statement&quot;, &quot;For&quot;, &quot;BlockParent&quot;, &quot;Loop&quot;],
  fields: {
    init: {
      validate: (0, _utils.assertNodeType)(&quot;VariableDeclaration&quot;, &quot;Expression&quot;),
      optional: true
    },
    test: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;),
      optional: true
    },
    update: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)(&quot;Statement&quot;)
    }
  }
});
const functionCommon = () =&gt; ({
  params: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;Identifier&quot;, &quot;Pattern&quot;, &quot;RestElement&quot;)))
  },
  generator: {
    default: false
  },
  async: {
    default: false
  }
});
exports.functionCommon = functionCommon;
const functionTypeAnnotationCommon = () =&gt; ({
  returnType: {
    validate: (0, _utils.assertNodeType)(&quot;TypeAnnotation&quot;, &quot;TSTypeAnnotation&quot;, &quot;Noop&quot;),
    optional: true
  },
  typeParameters: {
    validate: (0, _utils.assertNodeType)(&quot;TypeParameterDeclaration&quot;, &quot;TSTypeParameterDeclaration&quot;, &quot;Noop&quot;),
    optional: true
  }
});
exports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
const functionDeclarationCommon = () =&gt; Object.assign({}, functionCommon(), {
  declare: {
    validate: (0, _utils.assertValueType)(&quot;boolean&quot;),
    optional: true
  },
  id: {
    validate: (0, _utils.assertNodeType)(&quot;Identifier&quot;),
    optional: true
  }
});
exports.functionDeclarationCommon = functionDeclarationCommon;
defineType(&quot;FunctionDeclaration&quot;, {
  builder: [&quot;id&quot;, &quot;params&quot;, &quot;body&quot;, &quot;generator&quot;, &quot;async&quot;],
  visitor: [&quot;id&quot;, &quot;params&quot;, &quot;body&quot;, &quot;returnType&quot;, &quot;typeParameters&quot;],
  fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {
    body: {
      validate: (0, _utils.assertNodeType)(&quot;BlockStatement&quot;)
    },
    predicate: {
      validate: (0, _utils.assertNodeType)(&quot;DeclaredPredicate&quot;, &quot;InferredPredicate&quot;),
      optional: true
    }
  }),
  aliases: [&quot;Scopable&quot;, &quot;Function&quot;, &quot;BlockParent&quot;, &quot;FunctionParent&quot;, &quot;Statement&quot;, &quot;Pureish&quot;, &quot;Declaration&quot;],
  validate: function () {
    if (!process.env.BABEL_TYPES_8_BREAKING) return () =&gt; {};
    const identifier = (0, _utils.assertNodeType)(&quot;Identifier&quot;);
    return function (parent, key, node) {
      if (!(0, _is.default)(&quot;ExportDefaultDeclaration&quot;, parent)) {
        identifier(node, &quot;id&quot;, node.id);
      }
    };
  }()
});
defineType(&quot;FunctionExpression&quot;, {
  inherits: &quot;FunctionDeclaration&quot;,
  aliases: [&quot;Scopable&quot;, &quot;Function&quot;, &quot;BlockParent&quot;, &quot;FunctionParent&quot;, &quot;Expression&quot;, &quot;Pureish&quot;],
  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
    id: {
      validate: (0, _utils.assertNodeType)(&quot;Identifier&quot;),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)(&quot;BlockStatement&quot;)
    },
    predicate: {
      validate: (0, _utils.assertNodeType)(&quot;DeclaredPredicate&quot;, &quot;InferredPredicate&quot;),
      optional: true
    }
  })
});
const patternLikeCommon = () =&gt; ({
  typeAnnotation: {
    validate: (0, _utils.assertNodeType)(&quot;TypeAnnotation&quot;, &quot;TSTypeAnnotation&quot;, &quot;Noop&quot;),
    optional: true
  },
  optional: {
    validate: (0, _utils.assertValueType)(&quot;boolean&quot;),
    optional: true
  },
  decorators: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;Decorator&quot;))),
    optional: true
  }
});
exports.patternLikeCommon = patternLikeCommon;
defineType(&quot;Identifier&quot;, {
  builder: [&quot;name&quot;],
  visitor: [&quot;typeAnnotation&quot;, &quot;decorators&quot;],
  aliases: [&quot;Expression&quot;, &quot;PatternLike&quot;, &quot;LVal&quot;, &quot;TSEntityName&quot;],
  fields: Object.assign({}, patternLikeCommon(), {
    name: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;string&quot;), Object.assign(function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        if (!(0, _isValidIdentifier.default)(val, false)) {
          throw new TypeError(`&quot;${val}&quot; is not a valid identifier name`);
        }
      }, {
        type: &quot;string&quot;
      }))
    }
  }),
  validate(parent, key, node) {
    if (!process.env.BABEL_TYPES_8_BREAKING) return;
    const match = /\.(\w+)$/.exec(key);
    if (!match) return;
    const [, parentKey] = match;
    const nonComp = {
      computed: false
    };
    if (parentKey === &quot;property&quot;) {
      if ((0, _is.default)(&quot;MemberExpression&quot;, parent, nonComp)) return;
      if ((0, _is.default)(&quot;OptionalMemberExpression&quot;, parent, nonComp)) return;
    } else if (parentKey === &quot;key&quot;) {
      if ((0, _is.default)(&quot;Property&quot;, parent, nonComp)) return;
      if ((0, _is.default)(&quot;Method&quot;, parent, nonComp)) return;
    } else if (parentKey === &quot;exported&quot;) {
      if ((0, _is.default)(&quot;ExportSpecifier&quot;, parent)) return;
    } else if (parentKey === &quot;imported&quot;) {
      if ((0, _is.default)(&quot;ImportSpecifier&quot;, parent, {
        imported: node
      })) return;
    } else if (parentKey === &quot;meta&quot;) {
      if ((0, _is.default)(&quot;MetaProperty&quot;, parent, {
        meta: node
      })) return;
    }
    if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) &amp;&amp; node.name !== &quot;this&quot;) {
      throw new TypeError(`&quot;${node.name}&quot; is not a valid identifier`);
    }
  }
});
defineType(&quot;IfStatement&quot;, {
  visitor: [&quot;test&quot;, &quot;consequent&quot;, &quot;alternate&quot;],
  aliases: [&quot;Statement&quot;, &quot;Conditional&quot;],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;)
    },
    consequent: {
      validate: (0, _utils.assertNodeType)(&quot;Statement&quot;)
    },
    alternate: {
      optional: true,
      validate: (0, _utils.assertNodeType)(&quot;Statement&quot;)
    }
  }
});
defineType(&quot;LabeledStatement&quot;, {
  visitor: [&quot;label&quot;, &quot;body&quot;],
  aliases: [&quot;Statement&quot;],
  fields: {
    label: {
      validate: (0, _utils.assertNodeType)(&quot;Identifier&quot;)
    },
    body: {
      validate: (0, _utils.assertNodeType)(&quot;Statement&quot;)
    }
  }
});
defineType(&quot;StringLiteral&quot;, {
  builder: [&quot;value&quot;],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)(&quot;string&quot;)
    }
  },
  aliases: [&quot;Expression&quot;, &quot;Pureish&quot;, &quot;Literal&quot;, &quot;Immutable&quot;]
});
defineType(&quot;NumericLiteral&quot;, {
  builder: [&quot;value&quot;],
  deprecatedAlias: &quot;NumberLiteral&quot;,
  fields: {
    value: {
      validate: (0, _utils.assertValueType)(&quot;number&quot;)
    }
  },
  aliases: [&quot;Expression&quot;, &quot;Pureish&quot;, &quot;Literal&quot;, &quot;Immutable&quot;]
});
defineType(&quot;NullLiteral&quot;, {
  aliases: [&quot;Expression&quot;, &quot;Pureish&quot;, &quot;Literal&quot;, &quot;Immutable&quot;]
});
defineType(&quot;BooleanLiteral&quot;, {
  builder: [&quot;value&quot;],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)(&quot;boolean&quot;)
    }
  },
  aliases: [&quot;Expression&quot;, &quot;Pureish&quot;, &quot;Literal&quot;, &quot;Immutable&quot;]
});
defineType(&quot;RegExpLiteral&quot;, {
  builder: [&quot;pattern&quot;, &quot;flags&quot;],
  deprecatedAlias: &quot;RegexLiteral&quot;,
  aliases: [&quot;Expression&quot;, &quot;Pureish&quot;, &quot;Literal&quot;],
  fields: {
    pattern: {
      validate: (0, _utils.assertValueType)(&quot;string&quot;)
    },
    flags: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;string&quot;), Object.assign(function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        const invalid = /[^gimsuy]/.exec(val);
        if (invalid) {
          throw new TypeError(`&quot;${invalid[0]}&quot; is not a valid RegExp flag`);
        }
      }, {
        type: &quot;string&quot;
      })),
      default: &quot;&quot;
    }
  }
});
defineType(&quot;LogicalExpression&quot;, {
  builder: [&quot;operator&quot;, &quot;left&quot;, &quot;right&quot;],
  visitor: [&quot;left&quot;, &quot;right&quot;],
  aliases: [&quot;Binary&quot;, &quot;Expression&quot;],
  fields: {
    operator: {
      validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)
    },
    left: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;)
    },
    right: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;)
    }
  }
});
defineType(&quot;MemberExpression&quot;, {
  builder: [&quot;object&quot;, &quot;property&quot;, &quot;computed&quot;, ...(!process.env.BABEL_TYPES_8_BREAKING ? [&quot;optional&quot;] : [])],
  visitor: [&quot;object&quot;, &quot;property&quot;],
  aliases: [&quot;Expression&quot;, &quot;LVal&quot;],
  fields: Object.assign({
    object: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;, &quot;Super&quot;)
    },
    property: {
      validate: function () {
        const normal = (0, _utils.assertNodeType)(&quot;Identifier&quot;, &quot;PrivateName&quot;);
        const computed = (0, _utils.assertNodeType)(&quot;Expression&quot;);
        const validator = function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };
        validator.oneOfNodeTypes = [&quot;Expression&quot;, &quot;Identifier&quot;, &quot;PrivateName&quot;];
        return validator;
      }()
    },
    computed: {
      default: false
    }
  }, !process.env.BABEL_TYPES_8_BREAKING ? {
    optional: {
      validate: (0, _utils.assertOneOf)(true, false),
      optional: true
    }
  } : {})
});
defineType(&quot;NewExpression&quot;, {
  inherits: &quot;CallExpression&quot;
});
defineType(&quot;Program&quot;, {
  visitor: [&quot;directives&quot;, &quot;body&quot;],
  builder: [&quot;body&quot;, &quot;directives&quot;, &quot;sourceType&quot;, &quot;interpreter&quot;],
  fields: {
    sourceFile: {
      validate: (0, _utils.assertValueType)(&quot;string&quot;)
    },
    sourceType: {
      validate: (0, _utils.assertOneOf)(&quot;script&quot;, &quot;module&quot;),
      default: &quot;script&quot;
    },
    interpreter: {
      validate: (0, _utils.assertNodeType)(&quot;InterpreterDirective&quot;),
      default: null,
      optional: true
    },
    directives: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;Directive&quot;))),
      default: []
    },
    body: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;Statement&quot;)))
    }
  },
  aliases: [&quot;Scopable&quot;, &quot;BlockParent&quot;, &quot;Block&quot;]
});
defineType(&quot;ObjectExpression&quot;, {
  visitor: [&quot;properties&quot;],
  aliases: [&quot;Expression&quot;],
  fields: {
    properties: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;ObjectMethod&quot;, &quot;ObjectProperty&quot;, &quot;SpreadElement&quot;)))
    }
  }
});
defineType(&quot;ObjectMethod&quot;, {
  builder: [&quot;kind&quot;, &quot;key&quot;, &quot;params&quot;, &quot;body&quot;, &quot;computed&quot;, &quot;generator&quot;, &quot;async&quot;],
  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
    kind: Object.assign({
      validate: (0, _utils.assertOneOf)(&quot;method&quot;, &quot;get&quot;, &quot;set&quot;)
    }, !process.env.BABEL_TYPES_8_BREAKING ? {
      default: &quot;method&quot;
    } : {}),
    computed: {
      default: false
    },
    key: {
      validate: function () {
        const normal = (0, _utils.assertNodeType)(&quot;Identifier&quot;, &quot;StringLiteral&quot;, &quot;NumericLiteral&quot;, &quot;BigIntLiteral&quot;);
        const computed = (0, _utils.assertNodeType)(&quot;Expression&quot;);
        const validator = function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };
        validator.oneOfNodeTypes = [&quot;Expression&quot;, &quot;Identifier&quot;, &quot;StringLiteral&quot;, &quot;NumericLiteral&quot;, &quot;BigIntLiteral&quot;];
        return validator;
      }()
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;Decorator&quot;))),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)(&quot;BlockStatement&quot;)
    }
  }),
  visitor: [&quot;key&quot;, &quot;params&quot;, &quot;body&quot;, &quot;decorators&quot;, &quot;returnType&quot;, &quot;typeParameters&quot;],
  aliases: [&quot;UserWhitespacable&quot;, &quot;Function&quot;, &quot;Scopable&quot;, &quot;BlockParent&quot;, &quot;FunctionParent&quot;, &quot;Method&quot;, &quot;ObjectMember&quot;]
});
defineType(&quot;ObjectProperty&quot;, {
  builder: [&quot;key&quot;, &quot;value&quot;, &quot;computed&quot;, &quot;shorthand&quot;, ...(!process.env.BABEL_TYPES_8_BREAKING ? [&quot;decorators&quot;] : [])],
  fields: {
    computed: {
      default: false
    },
    key: {
      validate: function () {
        const normal = (0, _utils.assertNodeType)(&quot;Identifier&quot;, &quot;StringLiteral&quot;, &quot;NumericLiteral&quot;, &quot;BigIntLiteral&quot;, &quot;DecimalLiteral&quot;, &quot;PrivateName&quot;);
        const computed = (0, _utils.assertNodeType)(&quot;Expression&quot;);
        const validator = Object.assign(function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        }, {
          oneOfNodeTypes: [&quot;Expression&quot;, &quot;Identifier&quot;, &quot;StringLiteral&quot;, &quot;NumericLiteral&quot;, &quot;BigIntLiteral&quot;, &quot;DecimalLiteral&quot;, &quot;PrivateName&quot;]
        });
        return validator;
      }()
    },
    value: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;, &quot;PatternLike&quot;)
    },
    shorthand: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;boolean&quot;), Object.assign(function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        if (val &amp;&amp; node.computed) {
          throw new TypeError(&quot;Property shorthand of ObjectProperty cannot be true if computed is true&quot;);
        }
      }, {
        type: &quot;boolean&quot;
      }), function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        if (val &amp;&amp; !(0, _is.default)(&quot;Identifier&quot;, node.key)) {
          throw new TypeError(&quot;Property shorthand of ObjectProperty cannot be true if key is not an Identifier&quot;);
        }
      }),
      default: false
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;Decorator&quot;))),
      optional: true
    }
  },
  visitor: [&quot;key&quot;, &quot;value&quot;, &quot;decorators&quot;],
  aliases: [&quot;UserWhitespacable&quot;, &quot;Property&quot;, &quot;ObjectMember&quot;],
  validate: function () {
    const pattern = (0, _utils.assertNodeType)(&quot;Identifier&quot;, &quot;Pattern&quot;, &quot;TSAsExpression&quot;, &quot;TSSatisfiesExpression&quot;, &quot;TSNonNullExpression&quot;, &quot;TSTypeAssertion&quot;);
    const expression = (0, _utils.assertNodeType)(&quot;Expression&quot;);
    return function (parent, key, node) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      const validator = (0, _is.default)(&quot;ObjectPattern&quot;, parent) ? pattern : expression;
      validator(node, &quot;value&quot;, node.value);
    };
  }()
});
defineType(&quot;RestElement&quot;, {
  visitor: [&quot;argument&quot;, &quot;typeAnnotation&quot;],
  builder: [&quot;argument&quot;],
  aliases: [&quot;LVal&quot;, &quot;PatternLike&quot;],
  deprecatedAlias: &quot;RestProperty&quot;,
  fields: Object.assign({}, patternLikeCommon(), {
    argument: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(&quot;LVal&quot;) : (0, _utils.assertNodeType)(&quot;Identifier&quot;, &quot;ArrayPattern&quot;, &quot;ObjectPattern&quot;, &quot;MemberExpression&quot;, &quot;TSAsExpression&quot;, &quot;TSSatisfiesExpression&quot;, &quot;TSTypeAssertion&quot;, &quot;TSNonNullExpression&quot;)
    }
  }),
  validate(parent, key) {
    if (!process.env.BABEL_TYPES_8_BREAKING) return;
    const match = /(\w+)\[(\d+)\]/.exec(key);
    if (!match) throw new Error(&quot;Internal Babel error: malformed key.&quot;);
    const [, listKey, index] = match;
    if (parent[listKey].length &gt; +index + 1) {
      throw new TypeError(`RestElement must be last element of ${listKey}`);
    }
  }
});
defineType(&quot;ReturnStatement&quot;, {
  visitor: [&quot;argument&quot;],
  aliases: [&quot;Statement&quot;, &quot;Terminatorless&quot;, &quot;CompletionStatement&quot;],
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;),
      optional: true
    }
  }
});
defineType(&quot;SequenceExpression&quot;, {
  visitor: [&quot;expressions&quot;],
  fields: {
    expressions: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;Expression&quot;)))
    }
  },
  aliases: [&quot;Expression&quot;]
});
defineType(&quot;ParenthesizedExpression&quot;, {
  visitor: [&quot;expression&quot;],
  aliases: [&quot;Expression&quot;, &quot;ExpressionWrapper&quot;],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;)
    }
  }
});
defineType(&quot;SwitchCase&quot;, {
  visitor: [&quot;test&quot;, &quot;consequent&quot;],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;),
      optional: true
    },
    consequent: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;Statement&quot;)))
    }
  }
});
defineType(&quot;SwitchStatement&quot;, {
  visitor: [&quot;discriminant&quot;, &quot;cases&quot;],
  aliases: [&quot;Statement&quot;, &quot;BlockParent&quot;, &quot;Scopable&quot;],
  fields: {
    discriminant: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;)
    },
    cases: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;SwitchCase&quot;)))
    }
  }
});
defineType(&quot;ThisExpression&quot;, {
  aliases: [&quot;Expression&quot;]
});
defineType(&quot;ThrowStatement&quot;, {
  visitor: [&quot;argument&quot;],
  aliases: [&quot;Statement&quot;, &quot;Terminatorless&quot;, &quot;CompletionStatement&quot;],
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;)
    }
  }
});
defineType(&quot;TryStatement&quot;, {
  visitor: [&quot;block&quot;, &quot;handler&quot;, &quot;finalizer&quot;],
  aliases: [&quot;Statement&quot;],
  fields: {
    block: {
      validate: (0, _utils.chain)((0, _utils.assertNodeType)(&quot;BlockStatement&quot;), Object.assign(function (node) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        if (!node.handler &amp;&amp; !node.finalizer) {
          throw new TypeError(&quot;TryStatement expects either a handler or finalizer, or both&quot;);
        }
      }, {
        oneOfNodeTypes: [&quot;BlockStatement&quot;]
      }))
    },
    handler: {
      optional: true,
      validate: (0, _utils.assertNodeType)(&quot;CatchClause&quot;)
    },
    finalizer: {
      optional: true,
      validate: (0, _utils.assertNodeType)(&quot;BlockStatement&quot;)
    }
  }
});
defineType(&quot;UnaryExpression&quot;, {
  builder: [&quot;operator&quot;, &quot;argument&quot;, &quot;prefix&quot;],
  fields: {
    prefix: {
      default: true
    },
    argument: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;)
    },
    operator: {
      validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)
    }
  },
  visitor: [&quot;argument&quot;],
  aliases: [&quot;UnaryLike&quot;, &quot;Expression&quot;]
});
defineType(&quot;UpdateExpression&quot;, {
  builder: [&quot;operator&quot;, &quot;argument&quot;, &quot;prefix&quot;],
  fields: {
    prefix: {
      default: false
    },
    argument: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(&quot;Expression&quot;) : (0, _utils.assertNodeType)(&quot;Identifier&quot;, &quot;MemberExpression&quot;)
    },
    operator: {
      validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)
    }
  },
  visitor: [&quot;argument&quot;],
  aliases: [&quot;Expression&quot;]
});
defineType(&quot;VariableDeclaration&quot;, {
  builder: [&quot;kind&quot;, &quot;declarations&quot;],
  visitor: [&quot;declarations&quot;],
  aliases: [&quot;Statement&quot;, &quot;Declaration&quot;],
  fields: {
    declare: {
      validate: (0, _utils.assertValueType)(&quot;boolean&quot;),
      optional: true
    },
    kind: {
      validate: (0, _utils.assertOneOf)(&quot;var&quot;, &quot;let&quot;, &quot;const&quot;, &quot;using&quot;)
    },
    declarations: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;VariableDeclarator&quot;)))
    }
  },
  validate(parent, key, node) {
    if (!process.env.BABEL_TYPES_8_BREAKING) return;
    if (!(0, _is.default)(&quot;ForXStatement&quot;, parent, {
      left: node
    })) return;
    if (node.declarations.length !== 1) {
      throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);
    }
  }
});
defineType(&quot;VariableDeclarator&quot;, {
  visitor: [&quot;id&quot;, &quot;init&quot;],
  fields: {
    id: {
      validate: function () {
        if (!process.env.BABEL_TYPES_8_BREAKING) {
          return (0, _utils.assertNodeType)(&quot;LVal&quot;);
        }
        const normal = (0, _utils.assertNodeType)(&quot;Identifier&quot;, &quot;ArrayPattern&quot;, &quot;ObjectPattern&quot;);
        const without = (0, _utils.assertNodeType)(&quot;Identifier&quot;);
        return function (node, key, val) {
          const validator = node.init ? normal : without;
          validator(node, key, val);
        };
      }()
    },
    definite: {
      optional: true,
      validate: (0, _utils.assertValueType)(&quot;boolean&quot;)
    },
    init: {
      optional: true,
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;)
    }
  }
});
defineType(&quot;WhileStatement&quot;, {
  visitor: [&quot;test&quot;, &quot;body&quot;],
  aliases: [&quot;Statement&quot;, &quot;BlockParent&quot;, &quot;Loop&quot;, &quot;While&quot;, &quot;Scopable&quot;],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;)
    },
    body: {
      validate: (0, _utils.assertNodeType)(&quot;Statement&quot;)
    }
  }
});
defineType(&quot;WithStatement&quot;, {
  visitor: [&quot;object&quot;, &quot;body&quot;],
  aliases: [&quot;Statement&quot;],
  fields: {
    object: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;)
    },
    body: {
      validate: (0, _utils.assertNodeType)(&quot;Statement&quot;)
    }
  }
});
defineType(&quot;AssignmentPattern&quot;, {
  visitor: [&quot;left&quot;, &quot;right&quot;, &quot;decorators&quot;],
  builder: [&quot;left&quot;, &quot;right&quot;],
  aliases: [&quot;Pattern&quot;, &quot;PatternLike&quot;, &quot;LVal&quot;],
  fields: Object.assign({}, patternLikeCommon(), {
    left: {
      validate: (0, _utils.assertNodeType)(&quot;Identifier&quot;, &quot;ObjectPattern&quot;, &quot;ArrayPattern&quot;, &quot;MemberExpression&quot;, &quot;TSAsExpression&quot;, &quot;TSSatisfiesExpression&quot;, &quot;TSTypeAssertion&quot;, &quot;TSNonNullExpression&quot;)
    },
    right: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;)
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;Decorator&quot;))),
      optional: true
    }
  })
});
defineType(&quot;ArrayPattern&quot;, {
  visitor: [&quot;elements&quot;, &quot;typeAnnotation&quot;],
  builder: [&quot;elements&quot;],
  aliases: [&quot;Pattern&quot;, &quot;PatternLike&quot;, &quot;LVal&quot;],
  fields: Object.assign({}, patternLikeCommon(), {
    elements: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(&quot;null&quot;, &quot;PatternLike&quot;, &quot;LVal&quot;)))
    }
  })
});
defineType(&quot;ArrowFunctionExpression&quot;, {
  builder: [&quot;params&quot;, &quot;body&quot;, &quot;async&quot;],
  visitor: [&quot;params&quot;, &quot;body&quot;, &quot;returnType&quot;, &quot;typeParameters&quot;],
  aliases: [&quot;Scopable&quot;, &quot;Function&quot;, &quot;BlockParent&quot;, &quot;FunctionParent&quot;, &quot;Expression&quot;, &quot;Pureish&quot;],
  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
    expression: {
      validate: (0, _utils.assertValueType)(&quot;boolean&quot;)
    },
    body: {
      validate: (0, _utils.assertNodeType)(&quot;BlockStatement&quot;, &quot;Expression&quot;)
    },
    predicate: {
      validate: (0, _utils.assertNodeType)(&quot;DeclaredPredicate&quot;, &quot;InferredPredicate&quot;),
      optional: true
    }
  })
});
defineType(&quot;ClassBody&quot;, {
  visitor: [&quot;body&quot;],
  fields: {
    body: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;ClassMethod&quot;, &quot;ClassPrivateMethod&quot;, &quot;ClassProperty&quot;, &quot;ClassPrivateProperty&quot;, &quot;ClassAccessorProperty&quot;, &quot;TSDeclareMethod&quot;, &quot;TSIndexSignature&quot;, &quot;StaticBlock&quot;)))
    }
  }
});
defineType(&quot;ClassExpression&quot;, {
  builder: [&quot;id&quot;, &quot;superClass&quot;, &quot;body&quot;, &quot;decorators&quot;],
  visitor: [&quot;id&quot;, &quot;body&quot;, &quot;superClass&quot;, &quot;mixins&quot;, &quot;typeParameters&quot;, &quot;superTypeParameters&quot;, &quot;implements&quot;, &quot;decorators&quot;],
  aliases: [&quot;Scopable&quot;, &quot;Class&quot;, &quot;Expression&quot;],
  fields: {
    id: {
      validate: (0, _utils.assertNodeType)(&quot;Identifier&quot;),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)(&quot;TypeParameterDeclaration&quot;, &quot;TSTypeParameterDeclaration&quot;, &quot;Noop&quot;),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)(&quot;ClassBody&quot;)
    },
    superClass: {
      optional: true,
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;)
    },
    superTypeParameters: {
      validate: (0, _utils.assertNodeType)(&quot;TypeParameterInstantiation&quot;, &quot;TSTypeParameterInstantiation&quot;),
      optional: true
    },
    implements: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;TSExpressionWithTypeArguments&quot;, &quot;ClassImplements&quot;))),
      optional: true
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;Decorator&quot;))),
      optional: true
    },
    mixins: {
      validate: (0, _utils.assertNodeType)(&quot;InterfaceExtends&quot;),
      optional: true
    }
  }
});
defineType(&quot;ClassDeclaration&quot;, {
  inherits: &quot;ClassExpression&quot;,
  aliases: [&quot;Scopable&quot;, &quot;Class&quot;, &quot;Statement&quot;, &quot;Declaration&quot;],
  fields: {
    id: {
      validate: (0, _utils.assertNodeType)(&quot;Identifier&quot;)
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)(&quot;TypeParameterDeclaration&quot;, &quot;TSTypeParameterDeclaration&quot;, &quot;Noop&quot;),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)(&quot;ClassBody&quot;)
    },
    superClass: {
      optional: true,
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;)
    },
    superTypeParameters: {
      validate: (0, _utils.assertNodeType)(&quot;TypeParameterInstantiation&quot;, &quot;TSTypeParameterInstantiation&quot;),
      optional: true
    },
    implements: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;TSExpressionWithTypeArguments&quot;, &quot;ClassImplements&quot;))),
      optional: true
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;Decorator&quot;))),
      optional: true
    },
    mixins: {
      validate: (0, _utils.assertNodeType)(&quot;InterfaceExtends&quot;),
      optional: true
    },
    declare: {
      validate: (0, _utils.assertValueType)(&quot;boolean&quot;),
      optional: true
    },
    abstract: {
      validate: (0, _utils.assertValueType)(&quot;boolean&quot;),
      optional: true
    }
  },
  validate: function () {
    const identifier = (0, _utils.assertNodeType)(&quot;Identifier&quot;);
    return function (parent, key, node) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      if (!(0, _is.default)(&quot;ExportDefaultDeclaration&quot;, parent)) {
        identifier(node, &quot;id&quot;, node.id);
      }
    };
  }()
});
defineType(&quot;ExportAllDeclaration&quot;, {
  visitor: [&quot;source&quot;],
  aliases: [&quot;Statement&quot;, &quot;Declaration&quot;, &quot;ImportOrExportDeclaration&quot;, &quot;ExportDeclaration&quot;],
  fields: {
    source: {
      validate: (0, _utils.assertNodeType)(&quot;StringLiteral&quot;)
    },
    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(&quot;type&quot;, &quot;value&quot;)),
    assertions: {
      optional: true,
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;ImportAttribute&quot;)))
    }
  }
});
defineType(&quot;ExportDefaultDeclaration&quot;, {
  visitor: [&quot;declaration&quot;],
  aliases: [&quot;Statement&quot;, &quot;Declaration&quot;, &quot;ImportOrExportDeclaration&quot;, &quot;ExportDeclaration&quot;],
  fields: {
    declaration: {
      validate: (0, _utils.assertNodeType)(&quot;TSDeclareFunction&quot;, &quot;FunctionDeclaration&quot;, &quot;ClassDeclaration&quot;, &quot;Expression&quot;)
    },
    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(&quot;value&quot;))
  }
});
defineType(&quot;ExportNamedDeclaration&quot;, {
  visitor: [&quot;declaration&quot;, &quot;specifiers&quot;, &quot;source&quot;],
  aliases: [&quot;Statement&quot;, &quot;Declaration&quot;, &quot;ImportOrExportDeclaration&quot;, &quot;ExportDeclaration&quot;],
  fields: {
    declaration: {
      optional: true,
      validate: (0, _utils.chain)((0, _utils.assertNodeType)(&quot;Declaration&quot;), Object.assign(function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        if (val &amp;&amp; node.specifiers.length) {
          throw new TypeError(&quot;Only declaration or specifiers is allowed on ExportNamedDeclaration&quot;);
        }
      }, {
        oneOfNodeTypes: [&quot;Declaration&quot;]
      }), function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        if (val &amp;&amp; node.source) {
          throw new TypeError(&quot;Cannot export a declaration from a source&quot;);
        }
      })
    },
    assertions: {
      optional: true,
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;ImportAttribute&quot;)))
    },
    specifiers: {
      default: [],
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)(function () {
        const sourced = (0, _utils.assertNodeType)(&quot;ExportSpecifier&quot;, &quot;ExportDefaultSpecifier&quot;, &quot;ExportNamespaceSpecifier&quot;);
        const sourceless = (0, _utils.assertNodeType)(&quot;ExportSpecifier&quot;);
        if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;
        return function (node, key, val) {
          const validator = node.source ? sourced : sourceless;
          validator(node, key, val);
        };
      }()))
    },
    source: {
      validate: (0, _utils.assertNodeType)(&quot;StringLiteral&quot;),
      optional: true
    },
    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(&quot;type&quot;, &quot;value&quot;))
  }
});
defineType(&quot;ExportSpecifier&quot;, {
  visitor: [&quot;local&quot;, &quot;exported&quot;],
  aliases: [&quot;ModuleSpecifier&quot;],
  fields: {
    local: {
      validate: (0, _utils.assertNodeType)(&quot;Identifier&quot;)
    },
    exported: {
      validate: (0, _utils.assertNodeType)(&quot;Identifier&quot;, &quot;StringLiteral&quot;)
    },
    exportKind: {
      validate: (0, _utils.assertOneOf)(&quot;type&quot;, &quot;value&quot;),
      optional: true
    }
  }
});
defineType(&quot;ForOfStatement&quot;, {
  visitor: [&quot;left&quot;, &quot;right&quot;, &quot;body&quot;],
  builder: [&quot;left&quot;, &quot;right&quot;, &quot;body&quot;, &quot;await&quot;],
  aliases: [&quot;Scopable&quot;, &quot;Statement&quot;, &quot;For&quot;, &quot;BlockParent&quot;, &quot;Loop&quot;, &quot;ForXStatement&quot;],
  fields: {
    left: {
      validate: function () {
        if (!process.env.BABEL_TYPES_8_BREAKING) {
          return (0, _utils.assertNodeType)(&quot;VariableDeclaration&quot;, &quot;LVal&quot;);
        }
        const declaration = (0, _utils.assertNodeType)(&quot;VariableDeclaration&quot;);
        const lval = (0, _utils.assertNodeType)(&quot;Identifier&quot;, &quot;MemberExpression&quot;, &quot;ArrayPattern&quot;, &quot;ObjectPattern&quot;, &quot;TSAsExpression&quot;, &quot;TSSatisfiesExpression&quot;, &quot;TSTypeAssertion&quot;, &quot;TSNonNullExpression&quot;);
        return function (node, key, val) {
          if ((0, _is.default)(&quot;VariableDeclaration&quot;, val)) {
            declaration(node, key, val);
          } else {
            lval(node, key, val);
          }
        };
      }()
    },
    right: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;)
    },
    body: {
      validate: (0, _utils.assertNodeType)(&quot;Statement&quot;)
    },
    await: {
      default: false
    }
  }
});
defineType(&quot;ImportDeclaration&quot;, {
  visitor: [&quot;specifiers&quot;, &quot;source&quot;],
  aliases: [&quot;Statement&quot;, &quot;Declaration&quot;, &quot;ImportOrExportDeclaration&quot;],
  fields: {
    assertions: {
      optional: true,
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;ImportAttribute&quot;)))
    },
    module: {
      optional: true,
      validate: (0, _utils.assertValueType)(&quot;boolean&quot;)
    },
    specifiers: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;ImportSpecifier&quot;, &quot;ImportDefaultSpecifier&quot;, &quot;ImportNamespaceSpecifier&quot;)))
    },
    source: {
      validate: (0, _utils.assertNodeType)(&quot;StringLiteral&quot;)
    },
    importKind: {
      validate: (0, _utils.assertOneOf)(&quot;type&quot;, &quot;typeof&quot;, &quot;value&quot;),
      optional: true
    }
  }
});
defineType(&quot;ImportDefaultSpecifier&quot;, {
  visitor: [&quot;local&quot;],
  aliases: [&quot;ModuleSpecifier&quot;],
  fields: {
    local: {
      validate: (0, _utils.assertNodeType)(&quot;Identifier&quot;)
    }
  }
});
defineType(&quot;ImportNamespaceSpecifier&quot;, {
  visitor: [&quot;local&quot;],
  aliases: [&quot;ModuleSpecifier&quot;],
  fields: {
    local: {
      validate: (0, _utils.assertNodeType)(&quot;Identifier&quot;)
    }
  }
});
defineType(&quot;ImportSpecifier&quot;, {
  visitor: [&quot;local&quot;, &quot;imported&quot;],
  aliases: [&quot;ModuleSpecifier&quot;],
  fields: {
    local: {
      validate: (0, _utils.assertNodeType)(&quot;Identifier&quot;)
    },
    imported: {
      validate: (0, _utils.assertNodeType)(&quot;Identifier&quot;, &quot;StringLiteral&quot;)
    },
    importKind: {
      validate: (0, _utils.assertOneOf)(&quot;type&quot;, &quot;typeof&quot;, &quot;value&quot;),
      optional: true
    }
  }
});
defineType(&quot;MetaProperty&quot;, {
  visitor: [&quot;meta&quot;, &quot;property&quot;],
  aliases: [&quot;Expression&quot;],
  fields: {
    meta: {
      validate: (0, _utils.chain)((0, _utils.assertNodeType)(&quot;Identifier&quot;), Object.assign(function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        let property;
        switch (val.name) {
          case &quot;function&quot;:
            property = &quot;sent&quot;;
            break;
          case &quot;new&quot;:
            property = &quot;target&quot;;
            break;
          case &quot;import&quot;:
            property = &quot;meta&quot;;
            break;
        }
        if (!(0, _is.default)(&quot;Identifier&quot;, node.property, {
          name: property
        })) {
          throw new TypeError(&quot;Unrecognised MetaProperty&quot;);
        }
      }, {
        oneOfNodeTypes: [&quot;Identifier&quot;]
      }))
    },
    property: {
      validate: (0, _utils.assertNodeType)(&quot;Identifier&quot;)
    }
  }
});
const classMethodOrPropertyCommon = () =&gt; ({
  abstract: {
    validate: (0, _utils.assertValueType)(&quot;boolean&quot;),
    optional: true
  },
  accessibility: {
    validate: (0, _utils.assertOneOf)(&quot;public&quot;, &quot;private&quot;, &quot;protected&quot;),
    optional: true
  },
  static: {
    default: false
  },
  override: {
    default: false
  },
  computed: {
    default: false
  },
  optional: {
    validate: (0, _utils.assertValueType)(&quot;boolean&quot;),
    optional: true
  },
  key: {
    validate: (0, _utils.chain)(function () {
      const normal = (0, _utils.assertNodeType)(&quot;Identifier&quot;, &quot;StringLiteral&quot;, &quot;NumericLiteral&quot;);
      const computed = (0, _utils.assertNodeType)(&quot;Expression&quot;);
      return function (node, key, val) {
        const validator = node.computed ? computed : normal;
        validator(node, key, val);
      };
    }(), (0, _utils.assertNodeType)(&quot;Identifier&quot;, &quot;StringLiteral&quot;, &quot;NumericLiteral&quot;, &quot;BigIntLiteral&quot;, &quot;Expression&quot;))
  }
});
exports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
const classMethodOrDeclareMethodCommon = () =&gt; Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
  params: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;Identifier&quot;, &quot;Pattern&quot;, &quot;RestElement&quot;, &quot;TSParameterProperty&quot;)))
  },
  kind: {
    validate: (0, _utils.assertOneOf)(&quot;get&quot;, &quot;set&quot;, &quot;method&quot;, &quot;constructor&quot;),
    default: &quot;method&quot;
  },
  access: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;string&quot;), (0, _utils.assertOneOf)(&quot;public&quot;, &quot;private&quot;, &quot;protected&quot;)),
    optional: true
  },
  decorators: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;Decorator&quot;))),
    optional: true
  }
});
exports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
defineType(&quot;ClassMethod&quot;, {
  aliases: [&quot;Function&quot;, &quot;Scopable&quot;, &quot;BlockParent&quot;, &quot;FunctionParent&quot;, &quot;Method&quot;],
  builder: [&quot;kind&quot;, &quot;key&quot;, &quot;params&quot;, &quot;body&quot;, &quot;computed&quot;, &quot;static&quot;, &quot;generator&quot;, &quot;async&quot;],
  visitor: [&quot;key&quot;, &quot;params&quot;, &quot;body&quot;, &quot;decorators&quot;, &quot;returnType&quot;, &quot;typeParameters&quot;],
  fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
    body: {
      validate: (0, _utils.assertNodeType)(&quot;BlockStatement&quot;)
    }
  })
});
defineType(&quot;ObjectPattern&quot;, {
  visitor: [&quot;properties&quot;, &quot;typeAnnotation&quot;, &quot;decorators&quot;],
  builder: [&quot;properties&quot;],
  aliases: [&quot;Pattern&quot;, &quot;PatternLike&quot;, &quot;LVal&quot;],
  fields: Object.assign({}, patternLikeCommon(), {
    properties: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;RestElement&quot;, &quot;ObjectProperty&quot;)))
    }
  })
});
defineType(&quot;SpreadElement&quot;, {
  visitor: [&quot;argument&quot;],
  aliases: [&quot;UnaryLike&quot;],
  deprecatedAlias: &quot;SpreadProperty&quot;,
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;)
    }
  }
});
defineType(&quot;Super&quot;, {
  aliases: [&quot;Expression&quot;]
});
defineType(&quot;TaggedTemplateExpression&quot;, {
  visitor: [&quot;tag&quot;, &quot;quasi&quot;, &quot;typeParameters&quot;],
  builder: [&quot;tag&quot;, &quot;quasi&quot;],
  aliases: [&quot;Expression&quot;],
  fields: {
    tag: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;)
    },
    quasi: {
      validate: (0, _utils.assertNodeType)(&quot;TemplateLiteral&quot;)
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)(&quot;TypeParameterInstantiation&quot;, &quot;TSTypeParameterInstantiation&quot;),
      optional: true
    }
  }
});
defineType(&quot;TemplateElement&quot;, {
  builder: [&quot;value&quot;, &quot;tail&quot;],
  fields: {
    value: {
      validate: (0, _utils.chain)((0, _utils.assertShape)({
        raw: {
          validate: (0, _utils.assertValueType)(&quot;string&quot;)
        },
        cooked: {
          validate: (0, _utils.assertValueType)(&quot;string&quot;),
          optional: true
        }
      }), function templateElementCookedValidator(node) {
        const raw = node.value.raw;
        let unterminatedCalled = false;
        const error = () =&gt; {
          throw new Error(&quot;Internal @babel/types error.&quot;);
        };
        const {
          str,
          firstInvalidLoc
        } = (0, _helperStringParser.readStringContents)(&quot;template&quot;, raw, 0, 0, 0, {
          unterminated() {
            unterminatedCalled = true;
          },
          strictNumericEscape: error,
          invalidEscapeSequence: error,
          numericSeparatorInEscapeSequence: error,
          unexpectedNumericSeparator: error,
          invalidDigit: error,
          invalidCodePoint: error
        });
        if (!unterminatedCalled) throw new Error(&quot;Invalid raw&quot;);
        node.value.cooked = firstInvalidLoc ? null : str;
      })
    },
    tail: {
      default: false
    }
  }
});
defineType(&quot;TemplateLiteral&quot;, {
  visitor: [&quot;quasis&quot;, &quot;expressions&quot;],
  aliases: [&quot;Expression&quot;, &quot;Literal&quot;],
  fields: {
    quasis: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;TemplateElement&quot;)))
    },
    expressions: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;Expression&quot;, &quot;TSType&quot;)), function (node, key, val) {
        if (node.quasis.length !== val.length + 1) {
          throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);
        }
      })
    }
  }
});
defineType(&quot;YieldExpression&quot;, {
  builder: [&quot;argument&quot;, &quot;delegate&quot;],
  visitor: [&quot;argument&quot;],
  aliases: [&quot;Expression&quot;, &quot;Terminatorless&quot;],
  fields: {
    delegate: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;boolean&quot;), Object.assign(function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        if (val &amp;&amp; !node.argument) {
          throw new TypeError(&quot;Property delegate of YieldExpression cannot be true if there is no argument&quot;);
        }
      }, {
        type: &quot;boolean&quot;
      })),
      default: false
    },
    argument: {
      optional: true,
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;)
    }
  }
});
defineType(&quot;AwaitExpression&quot;, {
  builder: [&quot;argument&quot;],
  visitor: [&quot;argument&quot;],
  aliases: [&quot;Expression&quot;, &quot;Terminatorless&quot;],
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;)
    }
  }
});
defineType(&quot;Import&quot;, {
  aliases: [&quot;Expression&quot;]
});
defineType(&quot;BigIntLiteral&quot;, {
  builder: [&quot;value&quot;],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)(&quot;string&quot;)
    }
  },
  aliases: [&quot;Expression&quot;, &quot;Pureish&quot;, &quot;Literal&quot;, &quot;Immutable&quot;]
});
defineType(&quot;ExportNamespaceSpecifier&quot;, {
  visitor: [&quot;exported&quot;],
  aliases: [&quot;ModuleSpecifier&quot;],
  fields: {
    exported: {
      validate: (0, _utils.assertNodeType)(&quot;Identifier&quot;)
    }
  }
});
defineType(&quot;OptionalMemberExpression&quot;, {
  builder: [&quot;object&quot;, &quot;property&quot;, &quot;computed&quot;, &quot;optional&quot;],
  visitor: [&quot;object&quot;, &quot;property&quot;],
  aliases: [&quot;Expression&quot;],
  fields: {
    object: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;)
    },
    property: {
      validate: function () {
        const normal = (0, _utils.assertNodeType)(&quot;Identifier&quot;);
        const computed = (0, _utils.assertNodeType)(&quot;Expression&quot;);
        const validator = Object.assign(function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        }, {
          oneOfNodeTypes: [&quot;Expression&quot;, &quot;Identifier&quot;]
        });
        return validator;
      }()
    },
    computed: {
      default: false
    },
    optional: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(&quot;boolean&quot;) : (0, _utils.chain)((0, _utils.assertValueType)(&quot;boolean&quot;), (0, _utils.assertOptionalChainStart)())
    }
  }
});
defineType(&quot;OptionalCallExpression&quot;, {
  visitor: [&quot;callee&quot;, &quot;arguments&quot;, &quot;typeParameters&quot;, &quot;typeArguments&quot;],
  builder: [&quot;callee&quot;, &quot;arguments&quot;, &quot;optional&quot;],
  aliases: [&quot;Expression&quot;],
  fields: {
    callee: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;)
    },
    arguments: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;Expression&quot;, &quot;SpreadElement&quot;, &quot;JSXNamespacedName&quot;, &quot;ArgumentPlaceholder&quot;)))
    },
    optional: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(&quot;boolean&quot;) : (0, _utils.chain)((0, _utils.assertValueType)(&quot;boolean&quot;), (0, _utils.assertOptionalChainStart)())
    },
    typeArguments: {
      validate: (0, _utils.assertNodeType)(&quot;TypeParameterInstantiation&quot;),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)(&quot;TSTypeParameterInstantiation&quot;),
      optional: true
    }
  }
});
defineType(&quot;ClassProperty&quot;, {
  visitor: [&quot;key&quot;, &quot;value&quot;, &quot;typeAnnotation&quot;, &quot;decorators&quot;],
  builder: [&quot;key&quot;, &quot;value&quot;, &quot;typeAnnotation&quot;, &quot;decorators&quot;, &quot;computed&quot;, &quot;static&quot;],
  aliases: [&quot;Property&quot;],
  fields: Object.assign({}, classMethodOrPropertyCommon(), {
    value: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;),
      optional: true
    },
    definite: {
      validate: (0, _utils.assertValueType)(&quot;boolean&quot;),
      optional: true
    },
    typeAnnotation: {
      validate: (0, _utils.assertNodeType)(&quot;TypeAnnotation&quot;, &quot;TSTypeAnnotation&quot;, &quot;Noop&quot;),
      optional: true
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;Decorator&quot;))),
      optional: true
    },
    readonly: {
      validate: (0, _utils.assertValueType)(&quot;boolean&quot;),
      optional: true
    },
    declare: {
      validate: (0, _utils.assertValueType)(&quot;boolean&quot;),
      optional: true
    },
    variance: {
      validate: (0, _utils.assertNodeType)(&quot;Variance&quot;),
      optional: true
    }
  })
});
defineType(&quot;ClassAccessorProperty&quot;, {
  visitor: [&quot;key&quot;, &quot;value&quot;, &quot;typeAnnotation&quot;, &quot;decorators&quot;],
  builder: [&quot;key&quot;, &quot;value&quot;, &quot;typeAnnotation&quot;, &quot;decorators&quot;, &quot;computed&quot;, &quot;static&quot;],
  aliases: [&quot;Property&quot;, &quot;Accessor&quot;],
  fields: Object.assign({}, classMethodOrPropertyCommon(), {
    key: {
      validate: (0, _utils.chain)(function () {
        const normal = (0, _utils.assertNodeType)(&quot;Identifier&quot;, &quot;StringLiteral&quot;, &quot;NumericLiteral&quot;, &quot;BigIntLiteral&quot;, &quot;PrivateName&quot;);
        const computed = (0, _utils.assertNodeType)(&quot;Expression&quot;);
        return function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };
      }(), (0, _utils.assertNodeType)(&quot;Identifier&quot;, &quot;StringLiteral&quot;, &quot;NumericLiteral&quot;, &quot;BigIntLiteral&quot;, &quot;Expression&quot;, &quot;PrivateName&quot;))
    },
    value: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;),
      optional: true
    },
    definite: {
      validate: (0, _utils.assertValueType)(&quot;boolean&quot;),
      optional: true
    },
    typeAnnotation: {
      validate: (0, _utils.assertNodeType)(&quot;TypeAnnotation&quot;, &quot;TSTypeAnnotation&quot;, &quot;Noop&quot;),
      optional: true
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;Decorator&quot;))),
      optional: true
    },
    readonly: {
      validate: (0, _utils.assertValueType)(&quot;boolean&quot;),
      optional: true
    },
    declare: {
      validate: (0, _utils.assertValueType)(&quot;boolean&quot;),
      optional: true
    },
    variance: {
      validate: (0, _utils.assertNodeType)(&quot;Variance&quot;),
      optional: true
    }
  })
});
defineType(&quot;ClassPrivateProperty&quot;, {
  visitor: [&quot;key&quot;, &quot;value&quot;, &quot;decorators&quot;, &quot;typeAnnotation&quot;],
  builder: [&quot;key&quot;, &quot;value&quot;, &quot;decorators&quot;, &quot;static&quot;],
  aliases: [&quot;Property&quot;, &quot;Private&quot;],
  fields: {
    key: {
      validate: (0, _utils.assertNodeType)(&quot;PrivateName&quot;)
    },
    value: {
      validate: (0, _utils.assertNodeType)(&quot;Expression&quot;),
      optional: true
    },
    typeAnnotation: {
      validate: (0, _utils.assertNodeType)(&quot;TypeAnnotation&quot;, &quot;TSTypeAnnotation&quot;, &quot;Noop&quot;),
      optional: true
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;Decorator&quot;))),
      optional: true
    },
    static: {
      validate: (0, _utils.assertValueType)(&quot;boolean&quot;),
      default: false
    },
    readonly: {
      validate: (0, _utils.assertValueType)(&quot;boolean&quot;),
      optional: true
    },
    definite: {
      validate: (0, _utils.assertValueType)(&quot;boolean&quot;),
      optional: true
    },
    variance: {
      validate: (0, _utils.assertNodeType)(&quot;Variance&quot;),
      optional: true
    }
  }
});
defineType(&quot;ClassPrivateMethod&quot;, {
  builder: [&quot;kind&quot;, &quot;key&quot;, &quot;params&quot;, &quot;body&quot;, &quot;static&quot;],
  visitor: [&quot;key&quot;, &quot;params&quot;, &quot;body&quot;, &quot;decorators&quot;, &quot;returnType&quot;, &quot;typeParameters&quot;],
  aliases: [&quot;Function&quot;, &quot;Scopable&quot;, &quot;BlockParent&quot;, &quot;FunctionParent&quot;, &quot;Method&quot;, &quot;Private&quot;],
  fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
    kind: {
      validate: (0, _utils.assertOneOf)(&quot;get&quot;, &quot;set&quot;, &quot;method&quot;),
      default: &quot;method&quot;
    },
    key: {
      validate: (0, _utils.assertNodeType)(&quot;PrivateName&quot;)
    },
    body: {
      validate: (0, _utils.assertNodeType)(&quot;BlockStatement&quot;)
    }
  })
});
defineType(&quot;PrivateName&quot;, {
  visitor: [&quot;id&quot;],
  aliases: [&quot;Private&quot;],
  fields: {
    id: {
      validate: (0, _utils.assertNodeType)(&quot;Identifier&quot;)
    }
  }
});
defineType(&quot;StaticBlock&quot;, {
  visitor: [&quot;body&quot;],
  fields: {
    body: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)(&quot;array&quot;), (0, _utils.assertEach)((0, _utils.assertNodeType)(&quot;Statement&quot;)))
    }
  },
  aliases: [&quot;Scopable&quot;, &quot;BlockParent&quot;, &quot;FunctionParent&quot;]
});

//# sourceMappingURL=core.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
