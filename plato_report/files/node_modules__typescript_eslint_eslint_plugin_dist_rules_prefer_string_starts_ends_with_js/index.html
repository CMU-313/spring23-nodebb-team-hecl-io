<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@typescript-eslint/eslint-plugin/dist/rules/prefer-string-starts-ends-with.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@typescript-eslint/eslint-plugin/dist/rules/prefer-string-starts-ends-with.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">69.96</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">489</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">80.54</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.87</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
const regexpp_1 = require(&quot;@eslint-community/regexpp&quot;);
const utils_1 = require(&quot;@typescript-eslint/utils&quot;);
const util_1 = require(&quot;../util&quot;);
const EQ_OPERATORS = /^[=!]=/;
const regexpp = new regexpp_1.RegExpParser();
exports.default = (0, util_1.createRule)({
    name: &#039;prefer-string-starts-ends-with&#039;,
    defaultOptions: [],
    meta: {
        type: &#039;suggestion&#039;,
        docs: {
            description: &#039;Enforce using `String#startsWith` and `String#endsWith` over other equivalent methods of checking substrings&#039;,
            recommended: &#039;strict&#039;,
            requiresTypeChecking: true,
        },
        messages: {
            preferStartsWith: &quot;Use &#039;String#startsWith&#039; method instead.&quot;,
            preferEndsWith: &quot;Use the &#039;String#endsWith&#039; method instead.&quot;,
        },
        schema: [],
        fixable: &#039;code&#039;,
    },
    create(context) {
        const globalScope = context.getScope();
        const sourceCode = context.getSourceCode();
        const service = (0, util_1.getParserServices)(context);
        const typeChecker = service.program.getTypeChecker();
        /**
         * Check if a given node is a string.
         * @param node The node to check.
         */
        function isStringType(node) {
            const objectType = typeChecker.getTypeAtLocation(service.esTreeNodeToTSNodeMap.get(node));
            return (0, util_1.getTypeName)(typeChecker, objectType) === &#039;string&#039;;
        }
        /**
         * Check if a given node is a `Literal` node that is null.
         * @param node The node to check.
         */
        function isNull(node) {
            const evaluated = (0, util_1.getStaticValue)(node, globalScope);
            return evaluated != null &amp;&amp; evaluated.value == null;
        }
        /**
         * Check if a given node is a `Literal` node that is a given value.
         * @param node The node to check.
         * @param value The expected value of the `Literal` node.
         */
        function isNumber(node, value) {
            const evaluated = (0, util_1.getStaticValue)(node, globalScope);
            return evaluated != null &amp;&amp; evaluated.value === value;
        }
        /**
         * Check if a given node is a `Literal` node that is a character.
         * @param node The node to check.
         * @param kind The method name to get a character.
         */
        function isCharacter(node) {
            const evaluated = (0, util_1.getStaticValue)(node, globalScope);
            return (evaluated != null &amp;&amp;
                typeof evaluated.value === &#039;string&#039; &amp;&amp;
                // checks if the string is a character long
                evaluated.value[0] === evaluated.value);
        }
        /**
         * Check if a given node is `==`, `===`, `!=`, or `!==`.
         * @param node The node to check.
         */
        function isEqualityComparison(node) {
            return (node.type === utils_1.AST_NODE_TYPES.BinaryExpression &amp;&amp;
                EQ_OPERATORS.test(node.operator));
        }
        /**
         * Check if two given nodes are the same meaning.
         * @param node1 A node to compare.
         * @param node2 Another node to compare.
         */
        function isSameTokens(node1, node2) {
            const tokens1 = sourceCode.getTokens(node1);
            const tokens2 = sourceCode.getTokens(node2);
            if (tokens1.length !== tokens2.length) {
                return false;
            }
            for (let i = 0; i &lt; tokens1.length; ++i) {
                const token1 = tokens1[i];
                const token2 = tokens2[i];
                if (token1.type !== token2.type || token1.value !== token2.value) {
                    return false;
                }
            }
            return true;
        }
        /**
         * Check if a given node is the expression of the length of a string.
         *
         * - If `length` property access of `expectedObjectNode`, it&#039;s `true`.
         *   E.g., `foo` → `foo.length` / `&quot;foo&quot;` → `&quot;foo&quot;.length`
         * - If `expectedObjectNode` is a string literal, `node` can be a number.
         *   E.g., `&quot;foo&quot;` → `3`
         *
         * @param node The node to check.
         * @param expectedObjectNode The node which is expected as the receiver of `length` property.
         */
        function isLengthExpression(node, expectedObjectNode) {
            if (node.type === utils_1.AST_NODE_TYPES.MemberExpression) {
                return ((0, util_1.getPropertyName)(node, globalScope) === &#039;length&#039; &amp;&amp;
                    isSameTokens(node.object, expectedObjectNode));
            }
            const evaluatedLength = (0, util_1.getStaticValue)(node, globalScope);
            const evaluatedString = (0, util_1.getStaticValue)(expectedObjectNode, globalScope);
            return (evaluatedLength != null &amp;&amp;
                evaluatedString != null &amp;&amp;
                typeof evaluatedLength.value === &#039;number&#039; &amp;&amp;
                typeof evaluatedString.value === &#039;string&#039; &amp;&amp;
                evaluatedLength.value === evaluatedString.value.length);
        }
        /**
         * Check if a given node is a negative index expression
         *
         * E.g. `s.slice(- &lt;expr&gt;)`, `s.substring(s.length - &lt;expr&gt;)`
         *
         * @param node The node to check.
         * @param expectedIndexedNode The node which is expected as the receiver of index expression.
         */
        function isNegativeIndexExpression(node, expectedIndexedNode) {
            return ((node.type === utils_1.AST_NODE_TYPES.UnaryExpression &amp;&amp;
                node.operator === &#039;-&#039;) ||
                (node.type === utils_1.AST_NODE_TYPES.BinaryExpression &amp;&amp;
                    node.operator === &#039;-&#039; &amp;&amp;
                    isLengthExpression(node.left, expectedIndexedNode)));
        }
        /**
         * Check if a given node is the expression of the last index.
         *
         * E.g. `foo.length - 1`
         *
         * @param node The node to check.
         * @param expectedObjectNode The node which is expected as the receiver of `length` property.
         */
        function isLastIndexExpression(node, expectedObjectNode) {
            return (node.type === utils_1.AST_NODE_TYPES.BinaryExpression &amp;&amp;
                node.operator === &#039;-&#039; &amp;&amp;
                isLengthExpression(node.left, expectedObjectNode) &amp;&amp;
                isNumber(node.right, 1));
        }
        /**
         * Get the range of the property of a given `MemberExpression` node.
         *
         * - `obj[foo]` → the range of `[foo]`
         * - `obf.foo` → the range of `.foo`
         * - `(obj).foo` → the range of `.foo`
         *
         * @param node The member expression node to get.
         */
        function getPropertyRange(node) {
            const dotOrOpenBracket = sourceCode.getTokenAfter(node.object, util_1.isNotClosingParenToken);
            return [dotOrOpenBracket.range[0], node.range[1]];
        }
        /**
         * Parse a given `RegExp` pattern to that string if it&#039;s a static string.
         * @param pattern The RegExp pattern text to parse.
         * @param uFlag The Unicode flag of the RegExp.
         */
        function parseRegExpText(pattern, uFlag) {
            // Parse it.
            const ast = regexpp.parsePattern(pattern, undefined, undefined, uFlag);
            if (ast.alternatives.length !== 1) {
                return null;
            }
            // Drop `^`/`$` assertion.
            const chars = ast.alternatives[0].elements;
            const first = chars[0];
            if (first.type === &#039;Assertion&#039; &amp;&amp; first.kind === &#039;start&#039;) {
                chars.shift();
            }
            else {
                chars.pop();
            }
            // Check if it can determine a unique string.
            if (!chars.every(c =&gt; c.type === &#039;Character&#039;)) {
                return null;
            }
            // To string.
            return String.fromCodePoint(...chars.map(c =&gt; c.value));
        }
        /**
         * Parse a given node if it&#039;s a `RegExp` instance.
         * @param node The node to parse.
         */
        function parseRegExp(node) {
            const evaluated = (0, util_1.getStaticValue)(node, globalScope);
            if (evaluated == null || !(evaluated.value instanceof RegExp)) {
                return null;
            }
            const { source, flags } = evaluated.value;
            const isStartsWith = source.startsWith(&#039;^&#039;);
            const isEndsWith = source.endsWith(&#039;$&#039;);
            if (isStartsWith === isEndsWith ||
                flags.includes(&#039;i&#039;) ||
                flags.includes(&#039;m&#039;)) {
                return null;
            }
            const text = parseRegExpText(source, flags.includes(&#039;u&#039;));
            if (text == null) {
                return null;
            }
            return { isEndsWith, isStartsWith, text };
        }
        function getLeftNode(node) {
            if (node.type === utils_1.AST_NODE_TYPES.ChainExpression) {
                return getLeftNode(node.expression);
            }
            let leftNode;
            if (node.type === utils_1.AST_NODE_TYPES.CallExpression) {
                leftNode = node.callee;
            }
            else {
                leftNode = node;
            }
            if (leftNode.type !== utils_1.AST_NODE_TYPES.MemberExpression) {
                throw new Error(`Expected a MemberExpression, got ${leftNode.type}`);
            }
            return leftNode;
        }
        /**
         * Fix code with using the right operand as the search string.
         * For example: `foo.slice(0, 3) === &#039;bar&#039;` → `foo.startsWith(&#039;bar&#039;)`
         * @param fixer The rule fixer.
         * @param node The node which was reported.
         * @param kind The kind of the report.
         * @param isNegative The flag to fix to negative condition.
         */
        function* fixWithRightOperand(fixer, node, kind, isNegative, isOptional) {
            // left is CallExpression or MemberExpression.
            const leftNode = getLeftNode(node.left);
            const propertyRange = getPropertyRange(leftNode);
            if (isNegative) {
                yield fixer.insertTextBefore(node, &#039;!&#039;);
            }
            yield fixer.replaceTextRange([propertyRange[0], node.right.range[0]], `${isOptional ? &#039;?.&#039; : &#039;.&#039;}${kind}sWith(`);
            yield fixer.replaceTextRange([node.right.range[1], node.range[1]], &#039;)&#039;);
        }
        /**
         * Fix code with using the first argument as the search string.
         * For example: `foo.indexOf(&#039;bar&#039;) === 0` → `foo.startsWith(&#039;bar&#039;)`
         * @param fixer The rule fixer.
         * @param node The node which was reported.
         * @param kind The kind of the report.
         * @param negative The flag to fix to negative condition.
         */
        function* fixWithArgument(fixer, node, callNode, calleeNode, kind, negative, isOptional) {
            if (negative) {
                yield fixer.insertTextBefore(node, &#039;!&#039;);
            }
            yield fixer.replaceTextRange(getPropertyRange(calleeNode), `${isOptional ? &#039;?.&#039; : &#039;.&#039;}${kind}sWith`);
            yield fixer.removeRange([callNode.range[1], node.range[1]]);
        }
        function getParent(node) {
            var _a;
            return (0, util_1.nullThrows)(((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.ChainExpression
                ? node.parent.parent
                : node.parent, util_1.NullThrowsReasons.MissingParent);
        }
        return {
            // foo[0] === &quot;a&quot;
            // foo.charAt(0) === &quot;a&quot;
            // foo[foo.length - 1] === &quot;a&quot;
            // foo.charAt(foo.length - 1) === &quot;a&quot;
            [[
                &#039;BinaryExpression &gt; MemberExpression.left[computed=true]&#039;,
                &#039;BinaryExpression &gt; CallExpression.left &gt; MemberExpression.callee[property.name=&quot;charAt&quot;][computed=false]&#039;,
                &#039;BinaryExpression &gt; ChainExpression.left &gt; MemberExpression[computed=true]&#039;,
                &#039;BinaryExpression &gt; ChainExpression.left &gt; CallExpression &gt; MemberExpression.callee[property.name=&quot;charAt&quot;][computed=false]&#039;,
            ].join(&#039;, &#039;)](node) {
                let parentNode = getParent(node);
                let indexNode = null;
                if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.type) === utils_1.AST_NODE_TYPES.CallExpression) {
                    if (parentNode.arguments.length === 1) {
                        indexNode = parentNode.arguments[0];
                    }
                    parentNode = getParent(parentNode);
                }
                else {
                    indexNode = node.property;
                }
                if (indexNode == null ||
                    !isEqualityComparison(parentNode) ||
                    !isStringType(node.object)) {
                    return;
                }
                const isEndsWith = isLastIndexExpression(indexNode, node.object);
                const isStartsWith = !isEndsWith &amp;&amp; isNumber(indexNode, 0);
                if (!isStartsWith &amp;&amp; !isEndsWith) {
                    return;
                }
                const eqNode = parentNode;
                context.report({
                    node: parentNode,
                    messageId: isStartsWith ? &#039;preferStartsWith&#039; : &#039;preferEndsWith&#039;,
                    fix(fixer) {
                        // Don&#039;t fix if it can change the behavior.
                        if (!isCharacter(eqNode.right)) {
                            return null;
                        }
                        return fixWithRightOperand(fixer, eqNode, isStartsWith ? &#039;start&#039; : &#039;end&#039;, eqNode.operator.startsWith(&#039;!&#039;), node.optional);
                    },
                });
            },
            // foo.indexOf(&#039;bar&#039;) === 0
            [[
                &#039;BinaryExpression &gt; CallExpression.left &gt; MemberExpression.callee[property.name=&quot;indexOf&quot;][computed=false]&#039;,
                &#039;BinaryExpression &gt; ChainExpression.left &gt; CallExpression &gt; MemberExpression.callee[property.name=&quot;indexOf&quot;][computed=false]&#039;,
            ].join(&#039;, &#039;)](node) {
                const callNode = getParent(node);
                const parentNode = getParent(callNode);
                if (callNode.arguments.length !== 1 ||
                    !isEqualityComparison(parentNode) ||
                    !isNumber(parentNode.right, 0) ||
                    !isStringType(node.object)) {
                    return;
                }
                context.report({
                    node: parentNode,
                    messageId: &#039;preferStartsWith&#039;,
                    fix(fixer) {
                        return fixWithArgument(fixer, parentNode, callNode, node, &#039;start&#039;, parentNode.operator.startsWith(&#039;!&#039;), node.optional);
                    },
                });
            },
            // foo.lastIndexOf(&#039;bar&#039;) === foo.length - 3
            // foo.lastIndexOf(bar) === foo.length - bar.length
            [[
                &#039;BinaryExpression &gt; CallExpression.left &gt; MemberExpression.callee[property.name=&quot;lastIndexOf&quot;][computed=false]&#039;,
                &#039;BinaryExpression &gt; ChainExpression.left &gt; CallExpression &gt; MemberExpression.callee[property.name=&quot;lastIndexOf&quot;][computed=false]&#039;,
            ].join(&#039;, &#039;)](node) {
                const callNode = getParent(node);
                const parentNode = getParent(callNode);
                if (callNode.arguments.length !== 1 ||
                    !isEqualityComparison(parentNode) ||
                    parentNode.right.type !== utils_1.AST_NODE_TYPES.BinaryExpression ||
                    parentNode.right.operator !== &#039;-&#039; ||
                    !isLengthExpression(parentNode.right.left, node.object) ||
                    !isLengthExpression(parentNode.right.right, callNode.arguments[0]) ||
                    !isStringType(node.object)) {
                    return;
                }
                context.report({
                    node: parentNode,
                    messageId: &#039;preferEndsWith&#039;,
                    fix(fixer) {
                        return fixWithArgument(fixer, parentNode, callNode, node, &#039;end&#039;, parentNode.operator.startsWith(&#039;!&#039;), node.optional);
                    },
                });
            },
            // foo.match(/^bar/) === null
            // foo.match(/bar$/) === null
            [[
                &#039;BinaryExpression &gt; CallExpression.left &gt; MemberExpression.callee[property.name=&quot;match&quot;][computed=false]&#039;,
                &#039;BinaryExpression &gt; ChainExpression.left &gt; CallExpression &gt; MemberExpression.callee[property.name=&quot;match&quot;][computed=false]&#039;,
            ].join(&#039;, &#039;)](node) {
                const callNode = getParent(node);
                const parentNode = getParent(callNode);
                if (!isEqualityComparison(parentNode) ||
                    !isNull(parentNode.right) ||
                    !isStringType(node.object)) {
                    return;
                }
                const parsed = callNode.arguments.length === 1
                    ? parseRegExp(callNode.arguments[0])
                    : null;
                if (parsed == null) {
                    return;
                }
                const { isStartsWith, text } = parsed;
                context.report({
                    node: callNode,
                    messageId: isStartsWith ? &#039;preferStartsWith&#039; : &#039;preferEndsWith&#039;,
                    *fix(fixer) {
                        if (!parentNode.operator.startsWith(&#039;!&#039;)) {
                            yield fixer.insertTextBefore(parentNode, &#039;!&#039;);
                        }
                        yield fixer.replaceTextRange(getPropertyRange(node), `${node.optional ? &#039;?.&#039; : &#039;.&#039;}${isStartsWith ? &#039;start&#039; : &#039;end&#039;}sWith`);
                        yield fixer.replaceText(callNode.arguments[0], JSON.stringify(text));
                        yield fixer.removeRange([callNode.range[1], parentNode.range[1]]);
                    },
                });
            },
            // foo.slice(0, 3) === &#039;bar&#039;
            // foo.slice(-3) === &#039;bar&#039;
            // foo.slice(-3, foo.length) === &#039;bar&#039;
            // foo.substring(0, 3) === &#039;bar&#039;
            // foo.substring(foo.length - 3) === &#039;bar&#039;
            // foo.substring(foo.length - 3, foo.length) === &#039;bar&#039;
            [[
                &#039;BinaryExpression &gt; CallExpression.left &gt; MemberExpression.callee[property.name=&quot;slice&quot;][computed=false]&#039;,
                &#039;BinaryExpression &gt; CallExpression.left &gt; MemberExpression.callee[property.name=&quot;substring&quot;][computed=false]&#039;,
                &#039;BinaryExpression &gt; ChainExpression.left &gt; CallExpression &gt; MemberExpression.callee[property.name=&quot;slice&quot;][computed=false]&#039;,
                &#039;BinaryExpression &gt; ChainExpression.left &gt; CallExpression &gt; MemberExpression.callee[property.name=&quot;substring&quot;][computed=false]&#039;,
            ].join(&#039;, &#039;)](node) {
                const callNode = getParent(node);
                const parentNode = getParent(callNode);
                if (!isEqualityComparison(parentNode) || !isStringType(node.object)) {
                    return;
                }
                const isEndsWith = (callNode.arguments.length === 1 ||
                    (callNode.arguments.length === 2 &amp;&amp;
                        isLengthExpression(callNode.arguments[1], node.object))) &amp;&amp;
                    isNegativeIndexExpression(callNode.arguments[0], node.object);
                const isStartsWith = !isEndsWith &amp;&amp;
                    callNode.arguments.length === 2 &amp;&amp;
                    isNumber(callNode.arguments[0], 0) &amp;&amp;
                    !isNegativeIndexExpression(callNode.arguments[1], node.object);
                if (!isStartsWith &amp;&amp; !isEndsWith) {
                    return;
                }
                const eqNode = parentNode;
                const negativeIndexSupported = node.property.name === &#039;slice&#039;;
                context.report({
                    node: parentNode,
                    messageId: isStartsWith ? &#039;preferStartsWith&#039; : &#039;preferEndsWith&#039;,
                    fix(fixer) {
                        // Don&#039;t fix if it can change the behavior.
                        if (eqNode.operator.length === 2 &amp;&amp;
                            (eqNode.right.type !== utils_1.AST_NODE_TYPES.Literal ||
                                typeof eqNode.right.value !== &#039;string&#039;)) {
                            return null;
                        }
                        // code being checked is likely mistake:
                        // unequal length of strings being checked for equality
                        // or reliant on behavior of substring (negative indices interpreted as 0)
                        if (isStartsWith) {
                            if (!isLengthExpression(callNode.arguments[1], eqNode.right)) {
                                return null;
                            }
                        }
                        else {
                            const posNode = callNode.arguments[0];
                            const posNodeIsAbsolutelyValid = (posNode.type === utils_1.AST_NODE_TYPES.BinaryExpression &amp;&amp;
                                posNode.operator === &#039;-&#039; &amp;&amp;
                                isLengthExpression(posNode.left, node.object) &amp;&amp;
                                isLengthExpression(posNode.right, eqNode.right)) ||
                                (negativeIndexSupported &amp;&amp;
                                    posNode.type === utils_1.AST_NODE_TYPES.UnaryExpression &amp;&amp;
                                    posNode.operator === &#039;-&#039; &amp;&amp;
                                    isLengthExpression(posNode.argument, eqNode.right));
                            if (!posNodeIsAbsolutelyValid) {
                                return null;
                            }
                        }
                        return fixWithRightOperand(fixer, parentNode, isStartsWith ? &#039;start&#039; : &#039;end&#039;, parentNode.operator.startsWith(&#039;!&#039;), node.optional);
                    },
                });
            },
            // /^bar/.test(foo)
            // /bar$/.test(foo)
            &#039;CallExpression &gt; MemberExpression.callee[property.name=&quot;test&quot;][computed=false]&#039;(node) {
                const callNode = getParent(node);
                const parsed = callNode.arguments.length === 1 ? parseRegExp(node.object) : null;
                if (parsed == null) {
                    return;
                }
                const { isStartsWith, text } = parsed;
                const messageId = isStartsWith ? &#039;preferStartsWith&#039; : &#039;preferEndsWith&#039;;
                const methodName = isStartsWith ? &#039;startsWith&#039; : &#039;endsWith&#039;;
                context.report({
                    node: callNode,
                    messageId,
                    *fix(fixer) {
                        const argNode = callNode.arguments[0];
                        const needsParen = argNode.type !== utils_1.AST_NODE_TYPES.Literal &amp;&amp;
                            argNode.type !== utils_1.AST_NODE_TYPES.TemplateLiteral &amp;&amp;
                            argNode.type !== utils_1.AST_NODE_TYPES.Identifier &amp;&amp;
                            argNode.type !== utils_1.AST_NODE_TYPES.MemberExpression &amp;&amp;
                            argNode.type !== utils_1.AST_NODE_TYPES.CallExpression;
                        yield fixer.removeRange([callNode.range[0], argNode.range[0]]);
                        if (needsParen) {
                            yield fixer.insertTextBefore(argNode, &#039;(&#039;);
                            yield fixer.insertTextAfter(argNode, &#039;)&#039;);
                        }
                        yield fixer.insertTextAfter(argNode, `${node.optional ? &#039;?.&#039; : &#039;.&#039;}${methodName}(${JSON.stringify(text)}`);
                    },
                });
            },
        };
    },
});
//# sourceMappingURL=prefer-string-starts-ends-with.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
