<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/ace-builds/src/ext-emmet.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/ace-builds/src/ext-emmet.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">62.66</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1255</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">121.46</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">22.29</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">define(&quot;ace/snippets&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/dom&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/event_emitter&quot;,&quot;ace/lib/lang&quot;,&quot;ace/range&quot;,&quot;ace/range_list&quot;,&quot;ace/keyboard/hash_handler&quot;,&quot;ace/tokenizer&quot;,&quot;ace/clipboard&quot;,&quot;ace/editor&quot;], function(require, exports, module){&quot;use strict&quot;;
var dom = require(&quot;./lib/dom&quot;);
var oop = require(&quot;./lib/oop&quot;);
var EventEmitter = require(&quot;./lib/event_emitter&quot;).EventEmitter;
var lang = require(&quot;./lib/lang&quot;);
var Range = require(&quot;./range&quot;).Range;
var RangeList = require(&quot;./range_list&quot;).RangeList;
var HashHandler = require(&quot;./keyboard/hash_handler&quot;).HashHandler;
var Tokenizer = require(&quot;./tokenizer&quot;).Tokenizer;
var clipboard = require(&quot;./clipboard&quot;);
var VARIABLES = {
    CURRENT_WORD: function (editor) {
        return editor.session.getTextRange(editor.session.getWordRange());
    },
    SELECTION: function (editor, name, indentation) {
        var text = editor.session.getTextRange();
        if (indentation)
            return text.replace(/\n\r?([ \t]*\S)/g, &quot;\n&quot; + indentation + &quot;$1&quot;);
        return text;
    },
    CURRENT_LINE: function (editor) {
        return editor.session.getLine(editor.getCursorPosition().row);
    },
    PREV_LINE: function (editor) {
        return editor.session.getLine(editor.getCursorPosition().row - 1);
    },
    LINE_INDEX: function (editor) {
        return editor.getCursorPosition().row;
    },
    LINE_NUMBER: function (editor) {
        return editor.getCursorPosition().row + 1;
    },
    SOFT_TABS: function (editor) {
        return editor.session.getUseSoftTabs() ? &quot;YES&quot; : &quot;NO&quot;;
    },
    TAB_SIZE: function (editor) {
        return editor.session.getTabSize();
    },
    CLIPBOARD: function (editor) {
        return clipboard.getText &amp;&amp; clipboard.getText();
    },
    FILENAME: function (editor) {
        return /[^/\\]*$/.exec(this.FILEPATH(editor))[0];
    },
    FILENAME_BASE: function (editor) {
        return /[^/\\]*$/.exec(this.FILEPATH(editor))[0].replace(/\.[^.]*$/, &quot;&quot;);
    },
    DIRECTORY: function (editor) {
        return this.FILEPATH(editor).replace(/[^/\\]*$/, &quot;&quot;);
    },
    FILEPATH: function (editor) { return &quot;/not implemented.txt&quot;; },
    WORKSPACE_NAME: function () { return &quot;Unknown&quot;; },
    FULLNAME: function () { return &quot;Unknown&quot;; },
    BLOCK_COMMENT_START: function (editor) {
        var mode = editor.session.$mode || {};
        return mode.blockComment &amp;&amp; mode.blockComment.start || &quot;&quot;;
    },
    BLOCK_COMMENT_END: function (editor) {
        var mode = editor.session.$mode || {};
        return mode.blockComment &amp;&amp; mode.blockComment.end || &quot;&quot;;
    },
    LINE_COMMENT: function (editor) {
        var mode = editor.session.$mode || {};
        return mode.lineCommentStart || &quot;&quot;;
    },
    CURRENT_YEAR: date.bind(null, { year: &quot;numeric&quot; }),
    CURRENT_YEAR_SHORT: date.bind(null, { year: &quot;2-digit&quot; }),
    CURRENT_MONTH: date.bind(null, { month: &quot;numeric&quot; }),
    CURRENT_MONTH_NAME: date.bind(null, { month: &quot;long&quot; }),
    CURRENT_MONTH_NAME_SHORT: date.bind(null, { month: &quot;short&quot; }),
    CURRENT_DATE: date.bind(null, { day: &quot;2-digit&quot; }),
    CURRENT_DAY_NAME: date.bind(null, { weekday: &quot;long&quot; }),
    CURRENT_DAY_NAME_SHORT: date.bind(null, { weekday: &quot;short&quot; }),
    CURRENT_HOUR: date.bind(null, { hour: &quot;2-digit&quot;, hour12: false }),
    CURRENT_MINUTE: date.bind(null, { minute: &quot;2-digit&quot; }),
    CURRENT_SECOND: date.bind(null, { second: &quot;2-digit&quot; })
};
VARIABLES.SELECTED_TEXT = VARIABLES.SELECTION;
function date(dateFormat) {
    var str = new Date().toLocaleString(&quot;en-us&quot;, dateFormat);
    return str.length == 1 ? &quot;0&quot; + str : str;
}
var SnippetManager = function () {
    this.snippetMap = {};
    this.snippetNameMap = {};
};
(function () {
    oop.implement(this, EventEmitter);
    this.getTokenizer = function () {
        return SnippetManager.$tokenizer || this.createTokenizer();
    };
    this.createTokenizer = function () {
        function TabstopToken(str) {
            str = str.substr(1);
            if (/^\d+$/.test(str))
                return [{ tabstopId: parseInt(str, 10) }];
            return [{ text: str }];
        }
        function escape(ch) {
            return &quot;(?:[^\\\\&quot; + ch + &quot;]|\\\\.)&quot;;
        }
        var formatMatcher = {
            regex: &quot;/(&quot; + escape(&quot;/&quot;) + &quot;+)/&quot;,
            onMatch: function (val, state, stack) {
                var ts = stack[0];
                ts.fmtString = true;
                ts.guard = val.slice(1, -1);
                ts.flag = &quot;&quot;;
                return &quot;&quot;;
            },
            next: &quot;formatString&quot;
        };
        SnippetManager.$tokenizer = new Tokenizer({
            start: [
                { regex: /\\./, onMatch: function (val, state, stack) {
                        var ch = val[1];
                        if (ch == &quot;}&quot; &amp;&amp; stack.length) {
                            val = ch;
                        }
                        else if (&quot;`$\\&quot;.indexOf(ch) != -1) {
                            val = ch;
                        }
                        return [val];
                    } },
                { regex: /}/, onMatch: function (val, state, stack) {
                        return [stack.length ? stack.shift() : val];
                    } },
                { regex: /\$(?:\d+|\w+)/, onMatch: TabstopToken },
                { regex: /\$\{[\dA-Z_a-z]+/, onMatch: function (str, state, stack) {
                        var t = TabstopToken(str.substr(1));
                        stack.unshift(t[0]);
                        return t;
                    }, next: &quot;snippetVar&quot; },
                { regex: /\n/, token: &quot;newline&quot;, merge: false }
            ],
            snippetVar: [
                { regex: &quot;\\|&quot; + escape(&quot;\\|&quot;) + &quot;*\\|&quot;, onMatch: function (val, state, stack) {
                        var choices = val.slice(1, -1).replace(/\\[,|\\]|,/g, function (operator) {
                            return operator.length == 2 ? operator[1] : &quot;\x00&quot;;
                        }).split(&quot;\x00&quot;).map(function (value) {
                            return { value: value };
                        });
                        stack[0].choices = choices;
                        return [choices[0]];
                    }, next: &quot;start&quot; },
                formatMatcher,
                { regex: &quot;([^:}\\\\]|\\\\.)*:?&quot;, token: &quot;&quot;, next: &quot;start&quot; }
            ],
            formatString: [
                { regex: /:/, onMatch: function (val, state, stack) {
                        if (stack.length &amp;&amp; stack[0].expectElse) {
                            stack[0].expectElse = false;
                            stack[0].ifEnd = { elseEnd: stack[0] };
                            return [stack[0].ifEnd];
                        }
                        return &quot;:&quot;;
                    } },
                { regex: /\\./, onMatch: function (val, state, stack) {
                        var ch = val[1];
                        if (ch == &quot;}&quot; &amp;&amp; stack.length)
                            val = ch;
                        else if (&quot;`$\\&quot;.indexOf(ch) != -1)
                            val = ch;
                        else if (ch == &quot;n&quot;)
                            val = &quot;\n&quot;;
                        else if (ch == &quot;t&quot;)
                            val = &quot;\t&quot;;
                        else if (&quot;ulULE&quot;.indexOf(ch) != -1)
                            val = { changeCase: ch, local: ch &gt; &quot;a&quot; };
                        return [val];
                    } },
                { regex: &quot;/\\w*}&quot;, onMatch: function (val, state, stack) {
                        var next = stack.shift();
                        if (next)
                            next.flag = val.slice(1, -1);
                        this.next = next &amp;&amp; next.tabstopId ? &quot;start&quot; : &quot;&quot;;
                        return [next || val];
                    }, next: &quot;start&quot; },
                { regex: /\$(?:\d+|\w+)/, onMatch: function (val, state, stack) {
                        return [{ text: val.slice(1) }];
                    } },
                { regex: /\${\w+/, onMatch: function (val, state, stack) {
                        var token = { text: val.slice(2) };
                        stack.unshift(token);
                        return [token];
                    }, next: &quot;formatStringVar&quot; },
                { regex: /\n/, token: &quot;newline&quot;, merge: false },
                { regex: /}/, onMatch: function (val, state, stack) {
                        var next = stack.shift();
                        this.next = next &amp;&amp; next.tabstopId ? &quot;start&quot; : &quot;&quot;;
                        return [next || val];
                    }, next: &quot;start&quot; }
            ],
            formatStringVar: [
                { regex: /:\/\w+}/, onMatch: function (val, state, stack) {
                        var ts = stack[0];
                        ts.formatFunction = val.slice(2, -1);
                        return [stack.shift()];
                    }, next: &quot;formatString&quot; },
                formatMatcher,
                { regex: /:[\?\-+]?/, onMatch: function (val, state, stack) {
                        if (val[1] == &quot;+&quot;)
                            stack[0].ifEnd = stack[0];
                        if (val[1] == &quot;?&quot;)
                            stack[0].expectElse = true;
                    }, next: &quot;formatString&quot; },
                { regex: &quot;([^:}\\\\]|\\\\.)*:?&quot;, token: &quot;&quot;, next: &quot;formatString&quot; }
            ]
        });
        return SnippetManager.$tokenizer;
    };
    this.tokenizeTmSnippet = function (str, startState) {
        return this.getTokenizer().getLineTokens(str, startState).tokens.map(function (x) {
            return x.value || x;
        });
    };
    this.getVariableValue = function (editor, name, indentation) {
        if (/^\d+$/.test(name))
            return (this.variables.__ || {})[name] || &quot;&quot;;
        if (/^[A-Z]\d+$/.test(name))
            return (this.variables[name[0] + &quot;__&quot;] || {})[name.substr(1)] || &quot;&quot;;
        name = name.replace(/^TM_/, &quot;&quot;);
        if (!this.variables.hasOwnProperty(name))
            return &quot;&quot;;
        var value = this.variables[name];
        if (typeof value == &quot;function&quot;)
            value = this.variables[name](editor, name, indentation);
        return value == null ? &quot;&quot; : value;
    };
    this.variables = VARIABLES;
    this.tmStrFormat = function (str, ch, editor) {
        if (!ch.fmt)
            return str;
        var flag = ch.flag || &quot;&quot;;
        var re = ch.guard;
        re = new RegExp(re, flag.replace(/[^gim]/g, &quot;&quot;));
        var fmtTokens = typeof ch.fmt == &quot;string&quot; ? this.tokenizeTmSnippet(ch.fmt, &quot;formatString&quot;) : ch.fmt;
        var _self = this;
        var formatted = str.replace(re, function () {
            var oldArgs = _self.variables.__;
            _self.variables.__ = [].slice.call(arguments);
            var fmtParts = _self.resolveVariables(fmtTokens, editor);
            var gChangeCase = &quot;E&quot;;
            for (var i = 0; i &lt; fmtParts.length; i++) {
                var ch = fmtParts[i];
                if (typeof ch == &quot;object&quot;) {
                    fmtParts[i] = &quot;&quot;;
                    if (ch.changeCase &amp;&amp; ch.local) {
                        var next = fmtParts[i + 1];
                        if (next &amp;&amp; typeof next == &quot;string&quot;) {
                            if (ch.changeCase == &quot;u&quot;)
                                fmtParts[i] = next[0].toUpperCase();
                            else
                                fmtParts[i] = next[0].toLowerCase();
                            fmtParts[i + 1] = next.substr(1);
                        }
                    }
                    else if (ch.changeCase) {
                        gChangeCase = ch.changeCase;
                    }
                }
                else if (gChangeCase == &quot;U&quot;) {
                    fmtParts[i] = ch.toUpperCase();
                }
                else if (gChangeCase == &quot;L&quot;) {
                    fmtParts[i] = ch.toLowerCase();
                }
            }
            _self.variables.__ = oldArgs;
            return fmtParts.join(&quot;&quot;);
        });
        return formatted;
    };
    this.tmFormatFunction = function (str, ch, editor) {
        if (ch.formatFunction == &quot;upcase&quot;)
            return str.toUpperCase();
        if (ch.formatFunction == &quot;downcase&quot;)
            return str.toLowerCase();
        return str;
    };
    this.resolveVariables = function (snippet, editor) {
        var result = [];
        var indentation = &quot;&quot;;
        var afterNewLine = true;
        for (var i = 0; i &lt; snippet.length; i++) {
            var ch = snippet[i];
            if (typeof ch == &quot;string&quot;) {
                result.push(ch);
                if (ch == &quot;\n&quot;) {
                    afterNewLine = true;
                    indentation = &quot;&quot;;
                }
                else if (afterNewLine) {
                    indentation = /^\t*/.exec(ch)[0];
                    afterNewLine = /\S/.test(ch);
                }
                continue;
            }
            if (!ch)
                continue;
            afterNewLine = false;
            if (ch.fmtString) {
                var j = snippet.indexOf(ch, i + 1);
                if (j == -1)
                    j = snippet.length;
                ch.fmt = snippet.slice(i + 1, j);
                i = j;
            }
            if (ch.text) {
                var value = this.getVariableValue(editor, ch.text, indentation) + &quot;&quot;;
                if (ch.fmtString)
                    value = this.tmStrFormat(value, ch, editor);
                if (ch.formatFunction)
                    value = this.tmFormatFunction(value, ch, editor);
                if (value &amp;&amp; !ch.ifEnd) {
                    result.push(value);
                    gotoNext(ch);
                }
                else if (!value &amp;&amp; ch.ifEnd) {
                    gotoNext(ch.ifEnd);
                }
            }
            else if (ch.elseEnd) {
                gotoNext(ch.elseEnd);
            }
            else if (ch.tabstopId != null) {
                result.push(ch);
            }
            else if (ch.changeCase != null) {
                result.push(ch);
            }
        }
        function gotoNext(ch) {
            var i1 = snippet.indexOf(ch, i + 1);
            if (i1 != -1)
                i = i1;
        }
        return result;
    };
    this.insertSnippetForSelection = function (editor, snippetText) {
        var cursor = editor.getCursorPosition();
        var line = editor.session.getLine(cursor.row);
        var tabString = editor.session.getTabString();
        var indentString = line.match(/^\s*/)[0];
        if (cursor.column &lt; indentString.length)
            indentString = indentString.slice(0, cursor.column);
        snippetText = snippetText.replace(/\r/g, &quot;&quot;);
        var tokens = this.tokenizeTmSnippet(snippetText);
        tokens = this.resolveVariables(tokens, editor);
        tokens = tokens.map(function (x) {
            if (x == &quot;\n&quot;)
                return x + indentString;
            if (typeof x == &quot;string&quot;)
                return x.replace(/\t/g, tabString);
            return x;
        });
        var tabstops = [];
        tokens.forEach(function (p, i) {
            if (typeof p != &quot;object&quot;)
                return;
            var id = p.tabstopId;
            var ts = tabstops[id];
            if (!ts) {
                ts = tabstops[id] = [];
                ts.index = id;
                ts.value = &quot;&quot;;
                ts.parents = {};
            }
            if (ts.indexOf(p) !== -1)
                return;
            if (p.choices &amp;&amp; !ts.choices)
                ts.choices = p.choices;
            ts.push(p);
            var i1 = tokens.indexOf(p, i + 1);
            if (i1 === -1)
                return;
            var value = tokens.slice(i + 1, i1);
            var isNested = value.some(function (t) { return typeof t === &quot;object&quot;; });
            if (isNested &amp;&amp; !ts.value) {
                ts.value = value;
            }
            else if (value.length &amp;&amp; (!ts.value || typeof ts.value !== &quot;string&quot;)) {
                ts.value = value.join(&quot;&quot;);
            }
        });
        tabstops.forEach(function (ts) { ts.length = 0; });
        var expanding = {};
        function copyValue(val) {
            var copy = [];
            for (var i = 0; i &lt; val.length; i++) {
                var p = val[i];
                if (typeof p == &quot;object&quot;) {
                    if (expanding[p.tabstopId])
                        continue;
                    var j = val.lastIndexOf(p, i - 1);
                    p = copy[j] || { tabstopId: p.tabstopId };
                }
                copy[i] = p;
            }
            return copy;
        }
        for (var i = 0; i &lt; tokens.length; i++) {
            var p = tokens[i];
            if (typeof p != &quot;object&quot;)
                continue;
            var id = p.tabstopId;
            var ts = tabstops[id];
            var i1 = tokens.indexOf(p, i + 1);
            if (expanding[id]) {
                if (expanding[id] === p) {
                    delete expanding[id];
                    Object.keys(expanding).forEach(function (parentId) {
                        ts.parents[parentId] = true;
                    });
                }
                continue;
            }
            expanding[id] = p;
            var value = ts.value;
            if (typeof value !== &quot;string&quot;)
                value = copyValue(value);
            else if (p.fmt)
                value = this.tmStrFormat(value, p, editor);
            tokens.splice.apply(tokens, [i + 1, Math.max(0, i1 - i)].concat(value, p));
            if (ts.indexOf(p) === -1)
                ts.push(p);
        }
        var row = 0, column = 0;
        var text = &quot;&quot;;
        tokens.forEach(function (t) {
            if (typeof t === &quot;string&quot;) {
                var lines = t.split(&quot;\n&quot;);
                if (lines.length &gt; 1) {
                    column = lines[lines.length - 1].length;
                    row += lines.length - 1;
                }
                else
                    column += t.length;
                text += t;
            }
            else if (t) {
                if (!t.start)
                    t.start = { row: row, column: column };
                else
                    t.end = { row: row, column: column };
            }
        });
        var range = editor.getSelectionRange();
        var end = editor.session.replace(range, text);
        var tabstopManager = new TabstopManager(editor);
        var selectionId = editor.inVirtualSelectionMode &amp;&amp; editor.selection.index;
        tabstopManager.addTabstops(tabstops, range.start, end, selectionId);
    };
    this.insertSnippet = function (editor, snippetText) {
        var self = this;
        if (editor.inVirtualSelectionMode)
            return self.insertSnippetForSelection(editor, snippetText);
        editor.forEachSelection(function () {
            self.insertSnippetForSelection(editor, snippetText);
        }, null, { keepOrder: true });
        if (editor.tabstopManager)
            editor.tabstopManager.tabNext();
    };
    this.$getScope = function (editor) {
        var scope = editor.session.$mode.$id || &quot;&quot;;
        scope = scope.split(&quot;/&quot;).pop();
        if (scope === &quot;html&quot; || scope === &quot;php&quot;) {
            if (scope === &quot;php&quot; &amp;&amp; !editor.session.$mode.inlinePhp)
                scope = &quot;html&quot;;
            var c = editor.getCursorPosition();
            var state = editor.session.getState(c.row);
            if (typeof state === &quot;object&quot;) {
                state = state[0];
            }
            if (state.substring) {
                if (state.substring(0, 3) == &quot;js-&quot;)
                    scope = &quot;javascript&quot;;
                else if (state.substring(0, 4) == &quot;css-&quot;)
                    scope = &quot;css&quot;;
                else if (state.substring(0, 4) == &quot;php-&quot;)
                    scope = &quot;php&quot;;
            }
        }
        return scope;
    };
    this.getActiveScopes = function (editor) {
        var scope = this.$getScope(editor);
        var scopes = [scope];
        var snippetMap = this.snippetMap;
        if (snippetMap[scope] &amp;&amp; snippetMap[scope].includeScopes) {
            scopes.push.apply(scopes, snippetMap[scope].includeScopes);
        }
        scopes.push(&quot;_&quot;);
        return scopes;
    };
    this.expandWithTab = function (editor, options) {
        var self = this;
        var result = editor.forEachSelection(function () {
            return self.expandSnippetForSelection(editor, options);
        }, null, { keepOrder: true });
        if (result &amp;&amp; editor.tabstopManager)
            editor.tabstopManager.tabNext();
        return result;
    };
    this.expandSnippetForSelection = function (editor, options) {
        var cursor = editor.getCursorPosition();
        var line = editor.session.getLine(cursor.row);
        var before = line.substring(0, cursor.column);
        var after = line.substr(cursor.column);
        var snippetMap = this.snippetMap;
        var snippet;
        this.getActiveScopes(editor).some(function (scope) {
            var snippets = snippetMap[scope];
            if (snippets)
                snippet = this.findMatchingSnippet(snippets, before, after);
            return !!snippet;
        }, this);
        if (!snippet)
            return false;
        if (options &amp;&amp; options.dryRun)
            return true;
        editor.session.doc.removeInLine(cursor.row, cursor.column - snippet.replaceBefore.length, cursor.column + snippet.replaceAfter.length);
        this.variables.M__ = snippet.matchBefore;
        this.variables.T__ = snippet.matchAfter;
        this.insertSnippetForSelection(editor, snippet.content);
        this.variables.M__ = this.variables.T__ = null;
        return true;
    };
    this.findMatchingSnippet = function (snippetList, before, after) {
        for (var i = snippetList.length; i--;) {
            var s = snippetList[i];
            if (s.startRe &amp;&amp; !s.startRe.test(before))
                continue;
            if (s.endRe &amp;&amp; !s.endRe.test(after))
                continue;
            if (!s.startRe &amp;&amp; !s.endRe)
                continue;
            s.matchBefore = s.startRe ? s.startRe.exec(before) : [&quot;&quot;];
            s.matchAfter = s.endRe ? s.endRe.exec(after) : [&quot;&quot;];
            s.replaceBefore = s.triggerRe ? s.triggerRe.exec(before)[0] : &quot;&quot;;
            s.replaceAfter = s.endTriggerRe ? s.endTriggerRe.exec(after)[0] : &quot;&quot;;
            return s;
        }
    };
    this.snippetMap = {};
    this.snippetNameMap = {};
    this.register = function (snippets, scope) {
        var snippetMap = this.snippetMap;
        var snippetNameMap = this.snippetNameMap;
        var self = this;
        if (!snippets)
            snippets = [];
        function wrapRegexp(src) {
            if (src &amp;&amp; !/^\^?\(.*\)\$?$|^\\b$/.test(src))
                src = &quot;(?:&quot; + src + &quot;)&quot;;
            return src || &quot;&quot;;
        }
        function guardedRegexp(re, guard, opening) {
            re = wrapRegexp(re);
            guard = wrapRegexp(guard);
            if (opening) {
                re = guard + re;
                if (re &amp;&amp; re[re.length - 1] != &quot;$&quot;)
                    re = re + &quot;$&quot;;
            }
            else {
                re = re + guard;
                if (re &amp;&amp; re[0] != &quot;^&quot;)
                    re = &quot;^&quot; + re;
            }
            return new RegExp(re);
        }
        function addSnippet(s) {
            if (!s.scope)
                s.scope = scope || &quot;_&quot;;
            scope = s.scope;
            if (!snippetMap[scope]) {
                snippetMap[scope] = [];
                snippetNameMap[scope] = {};
            }
            var map = snippetNameMap[scope];
            if (s.name) {
                var old = map[s.name];
                if (old)
                    self.unregister(old);
                map[s.name] = s;
            }
            snippetMap[scope].push(s);
            if (s.prefix)
                s.tabTrigger = s.prefix;
            if (!s.content &amp;&amp; s.body)
                s.content = Array.isArray(s.body) ? s.body.join(&quot;\n&quot;) : s.body;
            if (s.tabTrigger &amp;&amp; !s.trigger) {
                if (!s.guard &amp;&amp; /^\w/.test(s.tabTrigger))
                    s.guard = &quot;\\b&quot;;
                s.trigger = lang.escapeRegExp(s.tabTrigger);
            }
            if (!s.trigger &amp;&amp; !s.guard &amp;&amp; !s.endTrigger &amp;&amp; !s.endGuard)
                return;
            s.startRe = guardedRegexp(s.trigger, s.guard, true);
            s.triggerRe = new RegExp(s.trigger);
            s.endRe = guardedRegexp(s.endTrigger, s.endGuard, true);
            s.endTriggerRe = new RegExp(s.endTrigger);
        }
        if (Array.isArray(snippets)) {
            snippets.forEach(addSnippet);
        }
        else {
            Object.keys(snippets).forEach(function (key) {
                addSnippet(snippets[key]);
            });
        }
        this._signal(&quot;registerSnippets&quot;, { scope: scope });
    };
    this.unregister = function (snippets, scope) {
        var snippetMap = this.snippetMap;
        var snippetNameMap = this.snippetNameMap;
        function removeSnippet(s) {
            var nameMap = snippetNameMap[s.scope || scope];
            if (nameMap &amp;&amp; nameMap[s.name]) {
                delete nameMap[s.name];
                var map = snippetMap[s.scope || scope];
                var i = map &amp;&amp; map.indexOf(s);
                if (i &gt;= 0)
                    map.splice(i, 1);
            }
        }
        if (snippets.content)
            removeSnippet(snippets);
        else if (Array.isArray(snippets))
            snippets.forEach(removeSnippet);
    };
    this.parseSnippetFile = function (str) {
        str = str.replace(/\r/g, &quot;&quot;);
        var list = [], snippet = {};
        var re = /^#.*|^({[\s\S]*})\s*$|^(\S+) (.*)$|^((?:\n*\t.*)+)/gm;
        var m;
        while (m = re.exec(str)) {
            if (m[1]) {
                try {
                    snippet = JSON.parse(m[1]);
                    list.push(snippet);
                }
                catch (e) { }
            }
            if (m[4]) {
                snippet.content = m[4].replace(/^\t/gm, &quot;&quot;);
                list.push(snippet);
                snippet = {};
            }
            else {
                var key = m[2], val = m[3];
                if (key == &quot;regex&quot;) {
                    var guardRe = /\/((?:[^\/\\]|\\.)*)|$/g;
                    snippet.guard = guardRe.exec(val)[1];
                    snippet.trigger = guardRe.exec(val)[1];
                    snippet.endTrigger = guardRe.exec(val)[1];
                    snippet.endGuard = guardRe.exec(val)[1];
                }
                else if (key == &quot;snippet&quot;) {
                    snippet.tabTrigger = val.match(/^\S*/)[0];
                    if (!snippet.name)
                        snippet.name = val;
                }
                else if (key) {
                    snippet[key] = val;
                }
            }
        }
        return list;
    };
    this.getSnippetByName = function (name, editor) {
        var snippetMap = this.snippetNameMap;
        var snippet;
        this.getActiveScopes(editor).some(function (scope) {
            var snippets = snippetMap[scope];
            if (snippets)
                snippet = snippets[name];
            return !!snippet;
        }, this);
        return snippet;
    };
}).call(SnippetManager.prototype);
var TabstopManager = function (editor) {
    if (editor.tabstopManager)
        return editor.tabstopManager;
    editor.tabstopManager = this;
    this.$onChange = this.onChange.bind(this);
    this.$onChangeSelection = lang.delayedCall(this.onChangeSelection.bind(this)).schedule;
    this.$onChangeSession = this.onChangeSession.bind(this);
    this.$onAfterExec = this.onAfterExec.bind(this);
    this.attach(editor);
};
(function () {
    this.attach = function (editor) {
        this.index = 0;
        this.ranges = [];
        this.tabstops = [];
        this.$openTabstops = null;
        this.selectedTabstop = null;
        this.editor = editor;
        this.editor.on(&quot;change&quot;, this.$onChange);
        this.editor.on(&quot;changeSelection&quot;, this.$onChangeSelection);
        this.editor.on(&quot;changeSession&quot;, this.$onChangeSession);
        this.editor.commands.on(&quot;afterExec&quot;, this.$onAfterExec);
        this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
    };
    this.detach = function () {
        this.tabstops.forEach(this.removeTabstopMarkers, this);
        this.ranges = null;
        this.tabstops = null;
        this.selectedTabstop = null;
        this.editor.removeListener(&quot;change&quot;, this.$onChange);
        this.editor.removeListener(&quot;changeSelection&quot;, this.$onChangeSelection);
        this.editor.removeListener(&quot;changeSession&quot;, this.$onChangeSession);
        this.editor.commands.removeListener(&quot;afterExec&quot;, this.$onAfterExec);
        this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler);
        this.editor.tabstopManager = null;
        this.editor = null;
    };
    this.onChange = function (delta) {
        var isRemove = delta.action[0] == &quot;r&quot;;
        var selectedTabstop = this.selectedTabstop || {};
        var parents = selectedTabstop.parents || {};
        var tabstops = (this.tabstops || []).slice();
        for (var i = 0; i &lt; tabstops.length; i++) {
            var ts = tabstops[i];
            var active = ts == selectedTabstop || parents[ts.index];
            ts.rangeList.$bias = active ? 0 : 1;
            if (delta.action == &quot;remove&quot; &amp;&amp; ts !== selectedTabstop) {
                var parentActive = ts.parents &amp;&amp; ts.parents[selectedTabstop.index];
                var startIndex = ts.rangeList.pointIndex(delta.start, parentActive);
                startIndex = startIndex &lt; 0 ? -startIndex - 1 : startIndex + 1;
                var endIndex = ts.rangeList.pointIndex(delta.end, parentActive);
                endIndex = endIndex &lt; 0 ? -endIndex - 1 : endIndex - 1;
                var toRemove = ts.rangeList.ranges.slice(startIndex, endIndex);
                for (var j = 0; j &lt; toRemove.length; j++)
                    this.removeRange(toRemove[j]);
            }
            ts.rangeList.$onChange(delta);
        }
        var session = this.editor.session;
        if (!this.$inChange &amp;&amp; isRemove &amp;&amp; session.getLength() == 1 &amp;&amp; !session.getValue())
            this.detach();
    };
    this.updateLinkedFields = function () {
        var ts = this.selectedTabstop;
        if (!ts || !ts.hasLinkedRanges || !ts.firstNonLinked)
            return;
        this.$inChange = true;
        var session = this.editor.session;
        var text = session.getTextRange(ts.firstNonLinked);
        for (var i = 0; i &lt; ts.length; i++) {
            var range = ts[i];
            if (!range.linked)
                continue;
            var original = range.original;
            var fmt = exports.snippetManager.tmStrFormat(text, original, this.editor);
            session.replace(range, fmt);
        }
        this.$inChange = false;
    };
    this.onAfterExec = function (e) {
        if (e.command &amp;&amp; !e.command.readOnly)
            this.updateLinkedFields();
    };
    this.onChangeSelection = function () {
        if (!this.editor)
            return;
        var lead = this.editor.selection.lead;
        var anchor = this.editor.selection.anchor;
        var isEmpty = this.editor.selection.isEmpty();
        for (var i = 0; i &lt; this.ranges.length; i++) {
            if (this.ranges[i].linked)
                continue;
            var containsLead = this.ranges[i].contains(lead.row, lead.column);
            var containsAnchor = isEmpty || this.ranges[i].contains(anchor.row, anchor.column);
            if (containsLead &amp;&amp; containsAnchor)
                return;
        }
        this.detach();
    };
    this.onChangeSession = function () {
        this.detach();
    };
    this.tabNext = function (dir) {
        var max = this.tabstops.length;
        var index = this.index + (dir || 1);
        index = Math.min(Math.max(index, 1), max);
        if (index == max)
            index = 0;
        this.selectTabstop(index);
        if (index === 0)
            this.detach();
    };
    this.selectTabstop = function (index) {
        this.$openTabstops = null;
        var ts = this.tabstops[this.index];
        if (ts)
            this.addTabstopMarkers(ts);
        this.index = index;
        ts = this.tabstops[this.index];
        if (!ts || !ts.length)
            return;
        this.selectedTabstop = ts;
        var range = ts.firstNonLinked || ts;
        if (ts.choices)
            range.cursor = range.start;
        if (!this.editor.inVirtualSelectionMode) {
            var sel = this.editor.multiSelect;
            sel.toSingleRange(range);
            for (var i = 0; i &lt; ts.length; i++) {
                if (ts.hasLinkedRanges &amp;&amp; ts[i].linked)
                    continue;
                sel.addRange(ts[i].clone(), true);
            }
        }
        else {
            this.editor.selection.fromOrientedRange(range);
        }
        this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
        if (this.selectedTabstop &amp;&amp; this.selectedTabstop.choices)
            this.editor.execCommand(&quot;startAutocomplete&quot;, { matches: this.selectedTabstop.choices });
    };
    this.addTabstops = function (tabstops, start, end) {
        var useLink = this.useLink || !this.editor.getOption(&quot;enableMultiselect&quot;);
        if (!this.$openTabstops)
            this.$openTabstops = [];
        if (!tabstops[0]) {
            var p = Range.fromPoints(end, end);
            moveRelative(p.start, start);
            moveRelative(p.end, start);
            tabstops[0] = [p];
            tabstops[0].index = 0;
        }
        var i = this.index;
        var arg = [i + 1, 0];
        var ranges = this.ranges;
        tabstops.forEach(function (ts, index) {
            var dest = this.$openTabstops[index] || ts;
            for (var i = 0; i &lt; ts.length; i++) {
                var p = ts[i];
                var range = Range.fromPoints(p.start, p.end || p.start);
                movePoint(range.start, start);
                movePoint(range.end, start);
                range.original = p;
                range.tabstop = dest;
                ranges.push(range);
                if (dest != ts)
                    dest.unshift(range);
                else
                    dest[i] = range;
                if (p.fmtString || (dest.firstNonLinked &amp;&amp; useLink)) {
                    range.linked = true;
                    dest.hasLinkedRanges = true;
                }
                else if (!dest.firstNonLinked)
                    dest.firstNonLinked = range;
            }
            if (!dest.firstNonLinked)
                dest.hasLinkedRanges = false;
            if (dest === ts) {
                arg.push(dest);
                this.$openTabstops[index] = dest;
            }
            this.addTabstopMarkers(dest);
            dest.rangeList = dest.rangeList || new RangeList();
            dest.rangeList.$bias = 0;
            dest.rangeList.addList(dest);
        }, this);
        if (arg.length &gt; 2) {
            if (this.tabstops.length)
                arg.push(arg.splice(2, 1)[0]);
            this.tabstops.splice.apply(this.tabstops, arg);
        }
    };
    this.addTabstopMarkers = function (ts) {
        var session = this.editor.session;
        ts.forEach(function (range) {
            if (!range.markerId)
                range.markerId = session.addMarker(range, &quot;ace_snippet-marker&quot;, &quot;text&quot;);
        });
    };
    this.removeTabstopMarkers = function (ts) {
        var session = this.editor.session;
        ts.forEach(function (range) {
            session.removeMarker(range.markerId);
            range.markerId = null;
        });
    };
    this.removeRange = function (range) {
        var i = range.tabstop.indexOf(range);
        if (i != -1)
            range.tabstop.splice(i, 1);
        i = this.ranges.indexOf(range);
        if (i != -1)
            this.ranges.splice(i, 1);
        i = range.tabstop.rangeList.ranges.indexOf(range);
        if (i != -1)
            range.tabstop.splice(i, 1);
        this.editor.session.removeMarker(range.markerId);
        if (!range.tabstop.length) {
            i = this.tabstops.indexOf(range.tabstop);
            if (i != -1)
                this.tabstops.splice(i, 1);
            if (!this.tabstops.length)
                this.detach();
        }
    };
    this.keyboardHandler = new HashHandler();
    this.keyboardHandler.bindKeys({
        &quot;Tab&quot;: function (editor) {
            if (exports.snippetManager &amp;&amp; exports.snippetManager.expandWithTab(editor))
                return;
            editor.tabstopManager.tabNext(1);
            editor.renderer.scrollCursorIntoView();
        },
        &quot;Shift-Tab&quot;: function (editor) {
            editor.tabstopManager.tabNext(-1);
            editor.renderer.scrollCursorIntoView();
        },
        &quot;Esc&quot;: function (editor) {
            editor.tabstopManager.detach();
        }
    });
}).call(TabstopManager.prototype);
var movePoint = function (point, diff) {
    if (point.row == 0)
        point.column += diff.column;
    point.row += diff.row;
};
var moveRelative = function (point, start) {
    if (point.row == start.row)
        point.column -= start.column;
    point.row -= start.row;
};
dom.importCssString(&quot;\n.ace_snippet-marker {\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n    background: rgba(194, 193, 208, 0.09);\n    border: 1px dotted rgba(211, 208, 235, 0.62);\n    position: absolute;\n}&quot;, &quot;snippets.css&quot;, false);
exports.snippetManager = new SnippetManager();
var Editor = require(&quot;./editor&quot;).Editor;
(function () {
    this.insertSnippet = function (content, options) {
        return exports.snippetManager.insertSnippet(this, content, options);
    };
    this.expandSnippet = function (options) {
        return exports.snippetManager.expandWithTab(this, options);
    };
}).call(Editor.prototype);

});

define(&quot;ace/ext/emmet&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/keyboard/hash_handler&quot;,&quot;ace/editor&quot;,&quot;ace/snippets&quot;,&quot;ace/range&quot;,&quot;ace/config&quot;,&quot;resources&quot;,&quot;resources&quot;,&quot;tabStops&quot;,&quot;resources&quot;,&quot;utils&quot;,&quot;actions&quot;], function(require, exports, module){&quot;use strict&quot;;
var HashHandler = require(&quot;../keyboard/hash_handler&quot;).HashHandler;
var Editor = require(&quot;../editor&quot;).Editor;
var snippetManager = require(&quot;../snippets&quot;).snippetManager;
var Range = require(&quot;../range&quot;).Range;
var config = require(&quot;../config&quot;);
var emmet, emmetPath;
function AceEmmetEditor() { }
AceEmmetEditor.prototype = {
    setupContext: function (editor) {
        this.ace = editor;
        this.indentation = editor.session.getTabString();
        if (!emmet)
            emmet = window.emmet;
        var resources = emmet.resources || emmet.require(&quot;resources&quot;);
        resources.setVariable(&quot;indentation&quot;, this.indentation);
        this.$syntax = null;
        this.$syntax = this.getSyntax();
    },
    getSelectionRange: function () {
        var range = this.ace.getSelectionRange();
        var doc = this.ace.session.doc;
        return {
            start: doc.positionToIndex(range.start),
            end: doc.positionToIndex(range.end)
        };
    },
    createSelection: function (start, end) {
        var doc = this.ace.session.doc;
        this.ace.selection.setRange({
            start: doc.indexToPosition(start),
            end: doc.indexToPosition(end)
        });
    },
    getCurrentLineRange: function () {
        var ace = this.ace;
        var row = ace.getCursorPosition().row;
        var lineLength = ace.session.getLine(row).length;
        var index = ace.session.doc.positionToIndex({ row: row, column: 0 });
        return {
            start: index,
            end: index + lineLength
        };
    },
    getCaretPos: function () {
        var pos = this.ace.getCursorPosition();
        return this.ace.session.doc.positionToIndex(pos);
    },
    setCaretPos: function (index) {
        var pos = this.ace.session.doc.indexToPosition(index);
        this.ace.selection.moveToPosition(pos);
    },
    getCurrentLine: function () {
        var row = this.ace.getCursorPosition().row;
        return this.ace.session.getLine(row);
    },
    replaceContent: function (value, start, end, noIndent) {
        if (end == null)
            end = start == null ? this.getContent().length : start;
        if (start == null)
            start = 0;
        var editor = this.ace;
        var doc = editor.session.doc;
        var range = Range.fromPoints(doc.indexToPosition(start), doc.indexToPosition(end));
        editor.session.remove(range);
        range.end = range.start;
        value = this.$updateTabstops(value);
        snippetManager.insertSnippet(editor, value);
    },
    getContent: function () {
        return this.ace.getValue();
    },
    getSyntax: function () {
        if (this.$syntax)
            return this.$syntax;
        var syntax = this.ace.session.$modeId.split(&quot;/&quot;).pop();
        if (syntax == &quot;html&quot; || syntax == &quot;php&quot;) {
            var cursor = this.ace.getCursorPosition();
            var state = this.ace.session.getState(cursor.row);
            if (typeof state != &quot;string&quot;)
                state = state[0];
            if (state) {
                state = state.split(&quot;-&quot;);
                if (state.length &gt; 1)
                    syntax = state[0];
                else if (syntax == &quot;php&quot;)
                    syntax = &quot;html&quot;;
            }
        }
        return syntax;
    },
    getProfileName: function () {
        var resources = emmet.resources || emmet.require(&quot;resources&quot;);
        switch (this.getSyntax()) {
            case &quot;css&quot;: return &quot;css&quot;;
            case &quot;xml&quot;:
            case &quot;xsl&quot;:
                return &quot;xml&quot;;
            case &quot;html&quot;:
                var profile = resources.getVariable(&quot;profile&quot;);
                if (!profile)
                    profile = this.ace.session.getLines(0, 2).join(&quot;&quot;).search(/&lt;!DOCTYPE[^&gt;]+XHTML/i) != -1 ? &quot;xhtml&quot; : &quot;html&quot;;
                return profile;
            default:
                var mode = this.ace.session.$mode;
                return mode.emmetConfig &amp;&amp; mode.emmetConfig.profile || &quot;xhtml&quot;;
        }
    },
    prompt: function (title) {
        return prompt(title); // eslint-disable-line no-alert
    },
    getSelection: function () {
        return this.ace.session.getTextRange();
    },
    getFilePath: function () {
        return &quot;&quot;;
    },
    $updateTabstops: function (value) {
        var base = 1000;
        var zeroBase = 0;
        var lastZero = null;
        var ts = emmet.tabStops || emmet.require(&#039;tabStops&#039;);
        var resources = emmet.resources || emmet.require(&quot;resources&quot;);
        var settings = resources.getVocabulary(&quot;user&quot;);
        var tabstopOptions = {
            tabstop: function (data) {
                var group = parseInt(data.group, 10);
                var isZero = group === 0;
                if (isZero)
                    group = ++zeroBase;
                else
                    group += base;
                var placeholder = data.placeholder;
                if (placeholder) {
                    placeholder = ts.processText(placeholder, tabstopOptions);
                }
                var result = &#039;${&#039; + group + (placeholder ? &#039;:&#039; + placeholder : &#039;&#039;) + &#039;}&#039;;
                if (isZero) {
                    lastZero = [data.start, result];
                }
                return result;
            },
            escape: function (ch) {
                if (ch == &#039;$&#039;)
                    return &#039;\\$&#039;;
                if (ch == &#039;\\&#039;)
                    return &#039;\\\\&#039;;
                return ch;
            }
        };
        value = ts.processText(value, tabstopOptions);
        if (settings.variables[&#039;insert_final_tabstop&#039;] &amp;&amp; !/\$\{0\}$/.test(value)) {
            value += &#039;${0}&#039;;
        }
        else if (lastZero) {
            var common = emmet.utils ? emmet.utils.common : emmet.require(&#039;utils&#039;);
            value = common.replaceSubstring(value, &#039;${0}&#039;, lastZero[0], lastZero[1]);
        }
        return value;
    }
};
var keymap = {
    expand_abbreviation: { &quot;mac&quot;: &quot;ctrl+alt+e&quot;, &quot;win&quot;: &quot;alt+e&quot; },
    match_pair_outward: { &quot;mac&quot;: &quot;ctrl+d&quot;, &quot;win&quot;: &quot;ctrl+,&quot; },
    match_pair_inward: { &quot;mac&quot;: &quot;ctrl+j&quot;, &quot;win&quot;: &quot;ctrl+shift+0&quot; },
    matching_pair: { &quot;mac&quot;: &quot;ctrl+alt+j&quot;, &quot;win&quot;: &quot;alt+j&quot; },
    next_edit_point: &quot;alt+right&quot;,
    prev_edit_point: &quot;alt+left&quot;,
    toggle_comment: { &quot;mac&quot;: &quot;command+/&quot;, &quot;win&quot;: &quot;ctrl+/&quot; },
    split_join_tag: { &quot;mac&quot;: &quot;shift+command+&#039;&quot;, &quot;win&quot;: &quot;shift+ctrl+`&quot; },
    remove_tag: { &quot;mac&quot;: &quot;command+&#039;&quot;, &quot;win&quot;: &quot;shift+ctrl+;&quot; },
    evaluate_math_expression: { &quot;mac&quot;: &quot;shift+command+y&quot;, &quot;win&quot;: &quot;shift+ctrl+y&quot; },
    increment_number_by_1: &quot;ctrl+up&quot;,
    decrement_number_by_1: &quot;ctrl+down&quot;,
    increment_number_by_01: &quot;alt+up&quot;,
    decrement_number_by_01: &quot;alt+down&quot;,
    increment_number_by_10: { &quot;mac&quot;: &quot;alt+command+up&quot;, &quot;win&quot;: &quot;shift+alt+up&quot; },
    decrement_number_by_10: { &quot;mac&quot;: &quot;alt+command+down&quot;, &quot;win&quot;: &quot;shift+alt+down&quot; },
    select_next_item: { &quot;mac&quot;: &quot;shift+command+.&quot;, &quot;win&quot;: &quot;shift+ctrl+.&quot; },
    select_previous_item: { &quot;mac&quot;: &quot;shift+command+,&quot;, &quot;win&quot;: &quot;shift+ctrl+,&quot; },
    reflect_css_value: { &quot;mac&quot;: &quot;shift+command+r&quot;, &quot;win&quot;: &quot;shift+ctrl+r&quot; },
    encode_decode_data_url: { &quot;mac&quot;: &quot;shift+ctrl+d&quot;, &quot;win&quot;: &quot;ctrl+&#039;&quot; },
    expand_abbreviation_with_tab: &quot;Tab&quot;,
    wrap_with_abbreviation: { &quot;mac&quot;: &quot;shift+ctrl+a&quot;, &quot;win&quot;: &quot;shift+ctrl+a&quot; }
};
var editorProxy = new AceEmmetEditor();
exports.commands = new HashHandler();
exports.runEmmetCommand = function runEmmetCommand(editor) {
    if (this.action == &quot;expand_abbreviation_with_tab&quot;) {
        if (!editor.selection.isEmpty())
            return false;
        var pos = editor.selection.lead;
        var token = editor.session.getTokenAt(pos.row, pos.column);
        if (token &amp;&amp; /\btag\b/.test(token.type))
            return false;
    }
    try {
        editorProxy.setupContext(editor);
        var actions = emmet.actions || emmet.require(&quot;actions&quot;);
        if (this.action == &quot;wrap_with_abbreviation&quot;) {
            return setTimeout(function () {
                actions.run(&quot;wrap_with_abbreviation&quot;, editorProxy);
            }, 0);
        }
        var result = actions.run(this.action, editorProxy);
    }
    catch (e) {
        if (!emmet) {
            var loading = exports.load(runEmmetCommand.bind(this, editor));
            if (this.action == &quot;expand_abbreviation_with_tab&quot;)
                return false;
            return loading;
        }
        editor._signal(&quot;changeStatus&quot;, typeof e == &quot;string&quot; ? e : e.message);
        config.warn(e);
        result = false;
    }
    return result;
};
for (var command in keymap) {
    exports.commands.addCommand({
        name: &quot;emmet:&quot; + command,
        action: command,
        bindKey: keymap[command],
        exec: exports.runEmmetCommand,
        multiSelectAction: &quot;forEach&quot;
    });
}
exports.updateCommands = function (editor, enabled) {
    if (enabled) {
        editor.keyBinding.addKeyboardHandler(exports.commands);
    }
    else {
        editor.keyBinding.removeKeyboardHandler(exports.commands);
    }
};
exports.isSupportedMode = function (mode) {
    if (!mode)
        return false;
    if (mode.emmetConfig)
        return true;
    var id = mode.$id || mode;
    return /css|less|scss|sass|stylus|html|php|twig|ejs|handlebars/.test(id);
};
exports.isAvailable = function (editor, command) {
    if (/(evaluate_math_expression|expand_abbreviation)$/.test(command))
        return true;
    var mode = editor.session.$mode;
    var isSupported = exports.isSupportedMode(mode);
    if (isSupported &amp;&amp; mode.$modes) {
        try {
            editorProxy.setupContext(editor);
            if (/js|php/.test(editorProxy.getSyntax()))
                isSupported = false;
        }
        catch (e) { }
    }
    return isSupported;
};
var onChangeMode = function (e, target) {
    var editor = target;
    if (!editor)
        return;
    var enabled = exports.isSupportedMode(editor.session.$mode);
    if (e.enableEmmet === false)
        enabled = false;
    if (enabled)
        exports.load();
    exports.updateCommands(editor, enabled);
};
exports.load = function (cb) {
    if (typeof emmetPath !== &quot;string&quot;) {
        config.warn(&quot;script for emmet-core is not loaded&quot;);
        return false;
    }
    config.loadModule(emmetPath, function () {
        emmetPath = null;
        cb &amp;&amp; cb();
    });
    return true;
};
exports.AceEmmetEditor = AceEmmetEditor;
config.defineOptions(Editor.prototype, &quot;editor&quot;, {
    enableEmmet: {
        set: function (val) {
            this[val ? &quot;on&quot; : &quot;removeListener&quot;](&quot;changeMode&quot;, onChangeMode);
            onChangeMode({ enableEmmet: !!val }, this);
        },
        value: true
    }
});
exports.setCore = function (e) {
    if (typeof e == &quot;string&quot;)
        emmetPath = e;
    else
        emmet = e;
};

});                (function() {
                    window.require([&quot;ace/ext/emmet&quot;], function(m) {
                        if (typeof module == &quot;object&quot; &amp;&amp; typeof exports == &quot;object&quot; &amp;&amp; module) {
                            module.exports = m;
                        }
                    });
                })();</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
