<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@babel/helpers/lib/helpers.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@babel/helpers/lib/helpers.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">97.77</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1782</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">10.10</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">1.88</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

Object.defineProperty(exports, &quot;__esModule&quot;, {
  value: true
});
exports.default = void 0;
var _template = require(&quot;@babel/template&quot;);
var _helpersGenerated = require(&quot;./helpers-generated&quot;);
const helpers = Object.assign({
  __proto__: null
}, _helpersGenerated.default);
var _default = helpers;
exports.default = _default;
const helper = minVersion =&gt; tpl =&gt; ({
  minVersion,
  ast: () =&gt; _template.default.program.ast(tpl)
});
{
  helpers.AwaitValue = helper(&quot;7.0.0-beta.0&quot;)`
    export default function _AwaitValue(value) {
      this.wrapped = value;
    }
  `;
}
helpers.wrapAsyncGenerator = helper(&quot;7.0.0-beta.0&quot;)`
  import AsyncGenerator from &quot;AsyncGenerator&quot;;

  export default function _wrapAsyncGenerator(fn) {
    return function () {
      return new AsyncGenerator(fn.apply(this, arguments));
    };
  }
`;
helpers.asyncToGenerator = helper(&quot;7.0.0-beta.0&quot;)`
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  export default function _asyncToGenerator(fn) {
    return function () {
      var self = this, args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, &quot;next&quot;, value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, &quot;throw&quot;, err);
        }

        _next(undefined);
      });
    };
  }
`;
helpers.classCallCheck = helper(&quot;7.0.0-beta.0&quot;)`
  export default function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError(&quot;Cannot call a class as a function&quot;);
    }
  }
`;
helpers.createClass = helper(&quot;7.0.0-beta.0&quot;)`
  import toPropertyKey from &quot;toPropertyKey&quot;;
  function _defineProperties(target, props) {
    for (var i = 0; i &lt; props.length; i ++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if (&quot;value&quot; in descriptor) descriptor.writable = true;
      Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
    }
  }

  export default function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, &quot;prototype&quot;, { writable: false });
    return Constructor;
  }
`;
helpers.defineEnumerableProperties = helper(&quot;7.0.0-beta.0&quot;)`
  export default function _defineEnumerableProperties(obj, descs) {
    for (var key in descs) {
      var desc = descs[key];
      desc.configurable = desc.enumerable = true;
      if (&quot;value&quot; in desc) desc.writable = true;
      Object.defineProperty(obj, key, desc);
    }

    // Symbols are not enumerated over by for-in loops. If native
    // Symbols are available, fetch all of the descs object&#039;s own
    // symbol properties and define them on our target object too.
    if (Object.getOwnPropertySymbols) {
      var objectSymbols = Object.getOwnPropertySymbols(descs);
      for (var i = 0; i &lt; objectSymbols.length; i++) {
        var sym = objectSymbols[i];
        var desc = descs[sym];
        desc.configurable = desc.enumerable = true;
        if (&quot;value&quot; in desc) desc.writable = true;
        Object.defineProperty(obj, sym, desc);
      }
    }
    return obj;
  }
`;
helpers.defaults = helper(&quot;7.0.0-beta.0&quot;)`
  export default function _defaults(obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);
    for (var i = 0; i &lt; keys.length; i++) {
      var key = keys[i];
      var value = Object.getOwnPropertyDescriptor(defaults, key);
      if (value &amp;&amp; value.configurable &amp;&amp; obj[key] === undefined) {
        Object.defineProperty(obj, key, value);
      }
    }
    return obj;
  }
`;
helpers.defineProperty = helper(&quot;7.0.0-beta.0&quot;)`
  import toPropertyKey from &quot;toPropertyKey&quot;;
  export default function _defineProperty(obj, key, value) {
    key = toPropertyKey(key);
    // Shortcircuit the slow defineProperty path when possible.
    // We are trying to avoid issues where setters defined on the
    // prototype cause side effects under the fast path of simple
    // assignment. By checking for existence of the property with
    // the in operator, we can optimize most of this overhead away.
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
`;
helpers.extends = helper(&quot;7.0.0-beta.0&quot;)`
  export default function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i &lt; arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };

    return _extends.apply(this, arguments);
  }
`;
helpers.objectSpread = helper(&quot;7.0.0-beta.0&quot;)`
  import defineProperty from &quot;defineProperty&quot;;

  export default function _objectSpread(target) {
    for (var i = 1; i &lt; arguments.length; i++) {
      var source = (arguments[i] != null) ? Object(arguments[i]) : {};
      var ownKeys = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === &#039;function&#039;) {
        ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys.forEach(function(key) {
        defineProperty(target, key, source[key]);
      });
    }
    return target;
  }
`;
helpers.inherits = helper(&quot;7.0.0-beta.0&quot;)`
  import setPrototypeOf from &quot;setPrototypeOf&quot;;

  export default function _inherits(subClass, superClass) {
    if (typeof superClass !== &quot;function&quot; &amp;&amp; superClass !== null) {
      throw new TypeError(&quot;Super expression must either be null or a function&quot;);
    }
    // We can&#039;t use defineProperty to set the prototype in a single step because it
    // doesn&#039;t work in Chrome &lt;= 36. https://github.com/babel/babel/issues/14056
    // V8 bug: https://bugs.chromium.org/p/v8/issues/detail?id=3334
    subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, &quot;prototype&quot;, { writable: false });
    if (superClass) setPrototypeOf(subClass, superClass);
  }
`;
helpers.inheritsLoose = helper(&quot;7.0.0-beta.0&quot;)`
  import setPrototypeOf from &quot;setPrototypeOf&quot;;

  export default function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    setPrototypeOf(subClass, superClass);
  }
`;
helpers.getPrototypeOf = helper(&quot;7.0.0-beta.0&quot;)`
  export default function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
    return _getPrototypeOf(o);
  }
`;
helpers.setPrototypeOf = helper(&quot;7.0.0-beta.0&quot;)`
  export default function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };
    return _setPrototypeOf(o, p);
  }
`;
helpers.isNativeReflectConstruct = helper(&quot;7.9.0&quot;)`
  export default function _isNativeReflectConstruct() {
    if (typeof Reflect === &quot;undefined&quot; || !Reflect.construct) return false;

    // core-js@3
    if (Reflect.construct.sham) return false;

    // Proxy can&#039;t be polyfilled. Every browser implemented
    // proxies before or at the same time as Reflect.construct,
    // so if they support Proxy they also support Reflect.construct.
    if (typeof Proxy === &quot;function&quot;) return true;

    // Since Reflect.construct can&#039;t be properly polyfilled, some
    // implementations (e.g. core-js@2) don&#039;t set the correct internal slots.
    // Those polyfills don&#039;t allow us to subclass built-ins, so we need to
    // use our fallback implementation.
    try {
      // If the internal slots aren&#039;t set, this throws an error similar to
      //   TypeError: this is not a Boolean object.

      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
      return true;
    } catch (e) {
      return false;
    }
  }
`;
helpers.construct = helper(&quot;7.0.0-beta.0&quot;)`
  import setPrototypeOf from &quot;setPrototypeOf&quot;;
  import isNativeReflectConstruct from &quot;isNativeReflectConstruct&quot;;

  export default function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      _construct = Reflect.construct.bind();
    } else {
      // NOTE: If Parent !== Class, the correct __proto__ is set *after*
      //       calling the constructor.
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }
    // Avoid issues with Class being present but undefined when it wasn&#039;t
    // present in the original call.
    return _construct.apply(null, arguments);
  }
`;
helpers.isNativeFunction = helper(&quot;7.0.0-beta.0&quot;)`
  export default function _isNativeFunction(fn) {
    // Note: This function returns &quot;true&quot; for core-js functions.
    return Function.toString.call(fn).indexOf(&quot;[native code]&quot;) !== -1;
  }
`;
helpers.wrapNativeSuper = helper(&quot;7.0.0-beta.0&quot;)`
  import getPrototypeOf from &quot;getPrototypeOf&quot;;
  import setPrototypeOf from &quot;setPrototypeOf&quot;;
  import isNativeFunction from &quot;isNativeFunction&quot;;
  import construct from &quot;construct&quot;;

  export default function _wrapNativeSuper(Class) {
    var _cache = typeof Map === &quot;function&quot; ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !isNativeFunction(Class)) return Class;
      if (typeof Class !== &quot;function&quot;) {
        throw new TypeError(&quot;Super expression must either be null or a function&quot;);
      }
      if (typeof _cache !== &quot;undefined&quot;) {
        if (_cache.has(Class)) return _cache.get(Class);
        _cache.set(Class, Wrapper);
      }
      function Wrapper() {
        return construct(Class, arguments, getPrototypeOf(this).constructor)
      }
      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true,
        }
      });

      return setPrototypeOf(Wrapper, Class);
    }

    return _wrapNativeSuper(Class)
  }
`;
helpers.instanceof = helper(&quot;7.0.0-beta.0&quot;)`
  export default function _instanceof(left, right) {
    if (right != null &amp;&amp; typeof Symbol !== &quot;undefined&quot; &amp;&amp; right[Symbol.hasInstance]) {
      return !!right[Symbol.hasInstance](left);
    } else {
      return left instanceof right;
    }
  }
`;
helpers.interopRequireDefault = helper(&quot;7.0.0-beta.0&quot;)`
  export default function _interopRequireDefault(obj) {
    return obj &amp;&amp; obj.__esModule ? obj : { default: obj };
  }
`;
helpers.interopRequireWildcard = helper(&quot;7.14.0&quot;)`
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== &quot;function&quot;) return null;

    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function (nodeInterop) {
      return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }

  export default function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop &amp;&amp; obj &amp;&amp; obj.__esModule) {
      return obj;
    }

    if (obj === null || (typeof obj !== &quot;object&quot; &amp;&amp; typeof obj !== &quot;function&quot;)) {
      return { default: obj }
    }

    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache &amp;&amp; cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== &quot;default&quot; &amp;&amp; Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;
        if (desc &amp;&amp; (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
`;
helpers.newArrowCheck = helper(&quot;7.0.0-beta.0&quot;)`
  export default function _newArrowCheck(innerThis, boundThis) {
    if (innerThis !== boundThis) {
      throw new TypeError(&quot;Cannot instantiate an arrow function&quot;);
    }
  }
`;
helpers.objectDestructuringEmpty = helper(&quot;7.0.0-beta.0&quot;)`
  export default function _objectDestructuringEmpty(obj) {
    if (obj == null) throw new TypeError(&quot;Cannot destructure &quot; + obj);
  }
`;
helpers.objectWithoutPropertiesLoose = helper(&quot;7.0.0-beta.0&quot;)`
  export default function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};

    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i &lt; sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) &gt;= 0) continue;
      target[key] = source[key];
    }

    return target;
  }
`;
helpers.objectWithoutProperties = helper(&quot;7.0.0-beta.0&quot;)`
  import objectWithoutPropertiesLoose from &quot;objectWithoutPropertiesLoose&quot;;

  export default function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = objectWithoutPropertiesLoose(source, excluded);
    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i &lt; sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) &gt;= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }
`;
helpers.assertThisInitialized = helper(&quot;7.0.0-beta.0&quot;)`
  export default function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError(&quot;this hasn&#039;t been initialised - super() hasn&#039;t been called&quot;);
    }
    return self;
  }
`;
helpers.possibleConstructorReturn = helper(&quot;7.0.0-beta.0&quot;)`
  import assertThisInitialized from &quot;assertThisInitialized&quot;;

  export default function _possibleConstructorReturn(self, call) {
    if (call &amp;&amp; (typeof call === &quot;object&quot; || typeof call === &quot;function&quot;)) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError(&quot;Derived constructors may only return object or undefined&quot;);
    }

    return assertThisInitialized(self);
  }
`;
helpers.createSuper = helper(&quot;7.9.0&quot;)`
  import getPrototypeOf from &quot;getPrototypeOf&quot;;
  import isNativeReflectConstruct from &quot;isNativeReflectConstruct&quot;;
  import possibleConstructorReturn from &quot;possibleConstructorReturn&quot;;

  export default function _createSuper(Derived) {
    var hasNativeReflectConstruct = isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        // NOTE: This doesn&#039;t work if this.__proto__.constructor has been modified.
        var NewTarget = getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return possibleConstructorReturn(this, result);
    }
  }
 `;
helpers.superPropBase = helper(&quot;7.0.0-beta.0&quot;)`
  import getPrototypeOf from &quot;getPrototypeOf&quot;;

  export default function _superPropBase(object, property) {
    // Yes, this throws if object is null to being with, that&#039;s on purpose.
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = getPrototypeOf(object);
      if (object === null) break;
    }
    return object;
  }
`;
helpers.get = helper(&quot;7.0.0-beta.0&quot;)`
  import superPropBase from &quot;superPropBase&quot;;

  export default function _get() {
    if (typeof Reflect !== &quot;undefined&quot; &amp;&amp; Reflect.get) {
      _get = Reflect.get.bind();
    } else {
      _get = function _get(target, property, receiver) {
        var base = superPropBase(target, property);

        if (!base) return;

        var desc = Object.getOwnPropertyDescriptor(base, property);
        if (desc.get) {
          // STEP 3. If receiver is not present, then set receiver to target.
          return desc.get.call(arguments.length &lt; 3 ? target : receiver);
        }

        return desc.value;
      };
    }
    return _get.apply(this, arguments);
  }
`;
helpers.set = helper(&quot;7.0.0-beta.0&quot;)`
  import superPropBase from &quot;superPropBase&quot;;
  import defineProperty from &quot;defineProperty&quot;;

  function set(target, property, value, receiver) {
    if (typeof Reflect !== &quot;undefined&quot; &amp;&amp; Reflect.set) {
      set = Reflect.set;
    } else {
      set = function set(target, property, value, receiver) {
        var base = superPropBase(target, property);
        var desc;

        if (base) {
          desc = Object.getOwnPropertyDescriptor(base, property);
          if (desc.set) {
            desc.set.call(receiver, value);
            return true;
          } else if (!desc.writable) {
            // Both getter and non-writable fall into this.
            return false;
          }
        }

        // Without a super that defines the property, spec boils down to
        // &quot;define on receiver&quot; for some reason.
        desc = Object.getOwnPropertyDescriptor(receiver, property);
        if (desc) {
          if (!desc.writable) {
            // Setter, getter, and non-writable fall into this.
            return false;
          }

          desc.value = value;
          Object.defineProperty(receiver, property, desc);
        } else {
          // Avoid setters that may be defined on Sub&#039;s prototype, but not on
          // the instance.
          defineProperty(receiver, property, value);
        }

        return true;
      };
    }

    return set(target, property, value, receiver);
  }

  export default function _set(target, property, value, receiver, isStrict) {
    var s = set(target, property, value, receiver || target);
    if (!s &amp;&amp; isStrict) {
      throw new TypeError(&#039;failed to set property&#039;);
    }

    return value;
  }
`;
helpers.taggedTemplateLiteral = helper(&quot;7.0.0-beta.0&quot;)`
  export default function _taggedTemplateLiteral(strings, raw) {
    if (!raw) { raw = strings.slice(0); }
    return Object.freeze(Object.defineProperties(strings, {
        raw: { value: Object.freeze(raw) }
    }));
  }
`;
helpers.taggedTemplateLiteralLoose = helper(&quot;7.0.0-beta.0&quot;)`
  export default function _taggedTemplateLiteralLoose(strings, raw) {
    if (!raw) { raw = strings.slice(0); }
    strings.raw = raw;
    return strings;
  }
`;
helpers.readOnlyError = helper(&quot;7.0.0-beta.0&quot;)`
  export default function _readOnlyError(name) {
    throw new TypeError(&quot;\\&quot;&quot; + name + &quot;\\&quot; is read-only&quot;);
  }
`;
helpers.writeOnlyError = helper(&quot;7.12.13&quot;)`
  export default function _writeOnlyError(name) {
    throw new TypeError(&quot;\\&quot;&quot; + name + &quot;\\&quot; is write-only&quot;);
  }
`;
helpers.classNameTDZError = helper(&quot;7.0.0-beta.0&quot;)`
  export default function _classNameTDZError(name) {
    throw new ReferenceError(&quot;Class \\&quot;&quot; + name + &quot;\\&quot; cannot be referenced in computed property keys.&quot;);
  }
`;
helpers.temporalUndefined = helper(&quot;7.0.0-beta.0&quot;)`
  // This function isn&#039;t mean to be called, but to be used as a reference.
  // We can&#039;t use a normal object because it isn&#039;t hoisted.
  export default function _temporalUndefined() {}
`;
helpers.tdz = helper(&quot;7.5.5&quot;)`
  export default function _tdzError(name) {
    throw new ReferenceError(name + &quot; is not defined - temporal dead zone&quot;);
  }
`;
helpers.temporalRef = helper(&quot;7.0.0-beta.0&quot;)`
  import undef from &quot;temporalUndefined&quot;;
  import err from &quot;tdz&quot;;

  export default function _temporalRef(val, name) {
    return val === undef ? err(name) : val;
  }
`;
helpers.slicedToArray = helper(&quot;7.0.0-beta.0&quot;)`
  import arrayWithHoles from &quot;arrayWithHoles&quot;;
  import iterableToArrayLimit from &quot;iterableToArrayLimit&quot;;
  import unsupportedIterableToArray from &quot;unsupportedIterableToArray&quot;;
  import nonIterableRest from &quot;nonIterableRest&quot;;

  export default function _slicedToArray(arr, i) {
    return (
      arrayWithHoles(arr) ||
      iterableToArrayLimit(arr, i) ||
      unsupportedIterableToArray(arr, i) ||
      nonIterableRest()
    );
  }
`;
helpers.slicedToArrayLoose = helper(&quot;7.0.0-beta.0&quot;)`
  import arrayWithHoles from &quot;arrayWithHoles&quot;;
  import iterableToArrayLimitLoose from &quot;iterableToArrayLimitLoose&quot;;
  import unsupportedIterableToArray from &quot;unsupportedIterableToArray&quot;;
  import nonIterableRest from &quot;nonIterableRest&quot;;

  export default function _slicedToArrayLoose(arr, i) {
    return (
      arrayWithHoles(arr) ||
      iterableToArrayLimitLoose(arr, i) ||
      unsupportedIterableToArray(arr, i) ||
      nonIterableRest()
    );
  }
`;
helpers.toArray = helper(&quot;7.0.0-beta.0&quot;)`
  import arrayWithHoles from &quot;arrayWithHoles&quot;;
  import iterableToArray from &quot;iterableToArray&quot;;
  import unsupportedIterableToArray from &quot;unsupportedIterableToArray&quot;;
  import nonIterableRest from &quot;nonIterableRest&quot;;

  export default function _toArray(arr) {
    return (
      arrayWithHoles(arr) ||
      iterableToArray(arr) ||
      unsupportedIterableToArray(arr) ||
      nonIterableRest()
    );
  }
`;
helpers.toConsumableArray = helper(&quot;7.0.0-beta.0&quot;)`
  import arrayWithoutHoles from &quot;arrayWithoutHoles&quot;;
  import iterableToArray from &quot;iterableToArray&quot;;
  import unsupportedIterableToArray from &quot;unsupportedIterableToArray&quot;;
  import nonIterableSpread from &quot;nonIterableSpread&quot;;

  export default function _toConsumableArray(arr) {
    return (
      arrayWithoutHoles(arr) ||
      iterableToArray(arr) ||
      unsupportedIterableToArray(arr) ||
      nonIterableSpread()
    );
  }
`;
helpers.arrayWithoutHoles = helper(&quot;7.0.0-beta.0&quot;)`
  import arrayLikeToArray from &quot;arrayLikeToArray&quot;;

  export default function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return arrayLikeToArray(arr);
  }
`;
helpers.arrayWithHoles = helper(&quot;7.0.0-beta.0&quot;)`
  export default function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
`;
helpers.maybeArrayLike = helper(&quot;7.9.0&quot;)`
  import arrayLikeToArray from &quot;arrayLikeToArray&quot;;

  export default function _maybeArrayLike(next, arr, i) {
    if (arr &amp;&amp; !Array.isArray(arr) &amp;&amp; typeof arr.length === &quot;number&quot;) {
      var len = arr.length;
      return arrayLikeToArray(arr, i !== void 0 &amp;&amp; i &lt; len ? i : len);
    }
    return next(arr, i);
  }
`;
helpers.iterableToArray = helper(&quot;7.0.0-beta.0&quot;)`
  export default function _iterableToArray(iter) {
    if (typeof Symbol !== &quot;undefined&quot; &amp;&amp; iter[Symbol.iterator] != null || iter[&quot;@@iterator&quot;] != null) return Array.from(iter);
  }
`;
helpers.unsupportedIterableToArray = helper(&quot;7.9.0&quot;)`
  import arrayLikeToArray from &quot;arrayLikeToArray&quot;;

  export default function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === &quot;string&quot;) return arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === &quot;Object&quot; &amp;&amp; o.constructor) n = o.constructor.name;
    if (n === &quot;Map&quot; || n === &quot;Set&quot;) return Array.from(o);
    if (n === &quot;Arguments&quot; || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return arrayLikeToArray(o, minLen);
  }
`;
helpers.arrayLikeToArray = helper(&quot;7.9.0&quot;)`
  export default function _arrayLikeToArray(arr, len) {
    if (len == null || len &gt; arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i &lt; len; i++) arr2[i] = arr[i];
    return arr2;
  }
`;
helpers.nonIterableSpread = helper(&quot;7.0.0-beta.0&quot;)`
  export default function _nonIterableSpread() {
    throw new TypeError(
      &quot;Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;
    );
  }
`;
helpers.nonIterableRest = helper(&quot;7.0.0-beta.0&quot;)`
  export default function _nonIterableRest() {
    throw new TypeError(
      &quot;Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;
    );
  }
`;
helpers.createForOfIteratorHelper = helper(&quot;7.9.0&quot;)`
  import unsupportedIterableToArray from &quot;unsupportedIterableToArray&quot;;

  // s: start (create the iterator)
  // n: next
  // e: error (called whenever something throws)
  // f: finish (always called at the end)

  export default function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== &quot;undefined&quot; &amp;&amp; o[Symbol.iterator] || o[&quot;@@iterator&quot;];

    if (!it) {
      // Fallback for engines without symbol support
      if (
        Array.isArray(o) ||
        (it = unsupportedIterableToArray(o)) ||
        (allowArrayLike &amp;&amp; o &amp;&amp; typeof o.length === &quot;number&quot;)
      ) {
        if (it) o = it;
        var i = 0;
        var F = function(){};
        return {
          s: F,
          n: function() {
            if (i &gt;= o.length) return { done: true };
            return { done: false, value: o[i++] };
          },
          e: function(e) { throw e; },
          f: F,
        };
      }

      throw new TypeError(&quot;Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;);
    }

    var normalCompletion = true, didErr = false, err;

    return {
      s: function() {
        it = it.call(o);
      },
      n: function() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function(e) {
        didErr = true;
        err = e;
      },
      f: function() {
        try {
          if (!normalCompletion &amp;&amp; it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }
`;
helpers.createForOfIteratorHelperLoose = helper(&quot;7.9.0&quot;)`
  import unsupportedIterableToArray from &quot;unsupportedIterableToArray&quot;;

  export default function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== &quot;undefined&quot; &amp;&amp; o[Symbol.iterator] || o[&quot;@@iterator&quot;];

    if (it) return (it = it.call(o)).next.bind(it);

    // Fallback for engines without symbol support
    if (
      Array.isArray(o) ||
      (it = unsupportedIterableToArray(o)) ||
      (allowArrayLike &amp;&amp; o &amp;&amp; typeof o.length === &quot;number&quot;)
    ) {
      if (it) o = it;
      var i = 0;
      return function() {
        if (i &gt;= o.length) return { done: true };
        return { done: false, value: o[i++] };
      }
    }

    throw new TypeError(&quot;Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;);
  }
`;
helpers.skipFirstGeneratorNext = helper(&quot;7.0.0-beta.0&quot;)`
  export default function _skipFirstGeneratorNext(fn) {
    return function () {
      var it = fn.apply(this, arguments);
      it.next();
      return it;
    }
  }
`;
helpers.toPrimitive = helper(&quot;7.1.5&quot;)`
  export default function _toPrimitive(
    input,
    hint /*: &quot;default&quot; | &quot;string&quot; | &quot;number&quot; | void */
  ) {
    if (typeof input !== &quot;object&quot; || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || &quot;default&quot;);
      if (typeof res !== &quot;object&quot;) return res;
      throw new TypeError(&quot;@@toPrimitive must return a primitive value.&quot;);
    }
    return (hint === &quot;string&quot; ? String : Number)(input);
  }
`;
helpers.toPropertyKey = helper(&quot;7.1.5&quot;)`
  import toPrimitive from &quot;toPrimitive&quot;;

  export default function _toPropertyKey(arg) {
    var key = toPrimitive(arg, &quot;string&quot;);
    return typeof key === &quot;symbol&quot; ? key : String(key);
  }
`;
helpers.initializerWarningHelper = helper(&quot;7.0.0-beta.0&quot;)`
    export default function _initializerWarningHelper(descriptor, context){
        throw new Error(
          &#039;Decorating class property failed. Please ensure that &#039; +
          &#039;proposal-class-properties is enabled and runs after the decorators transform.&#039;
        );
    }
`;
helpers.initializerDefineProperty = helper(&quot;7.0.0-beta.0&quot;)`
    export default function _initializerDefineProperty(target, property, descriptor, context){
        if (!descriptor) return;

        Object.defineProperty(target, property, {
            enumerable: descriptor.enumerable,
            configurable: descriptor.configurable,
            writable: descriptor.writable,
            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,
        });
    }
`;
helpers.applyDecoratedDescriptor = helper(&quot;7.0.0-beta.0&quot;)`
    export default function _applyDecoratedDescriptor(target, property, decorators, descriptor, context){
        var desc = {};
        Object.keys(descriptor).forEach(function(key){
            desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;
        if (&#039;value&#039; in desc || desc.initializer){
            desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function(desc, decorator){
            return decorator(target, property, desc) || desc;
        }, desc);

        if (context &amp;&amp; desc.initializer !== void 0){
            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
            desc.initializer = undefined;
        }

        if (desc.initializer === void 0){
            Object.defineProperty(target, property, desc);
            desc = null;
        }

        return desc;
    }
`;
helpers.classPrivateFieldLooseKey = helper(&quot;7.0.0-beta.0&quot;)`
  var id = 0;
  export default function _classPrivateFieldKey(name) {
    return &quot;__private_&quot; + (id++) + &quot;_&quot; + name;
  }
`;
helpers.classPrivateFieldLooseBase = helper(&quot;7.0.0-beta.0&quot;)`
  export default function _classPrivateFieldBase(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError(&quot;attempted to use private field on non-instance&quot;);
    }
    return receiver;
  }
`;
helpers.classPrivateFieldGet = helper(&quot;7.0.0-beta.0&quot;)`
  import classApplyDescriptorGet from &quot;classApplyDescriptorGet&quot;;
  import classExtractFieldDescriptor from &quot;classExtractFieldDescriptor&quot;;
  export default function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, &quot;get&quot;);
    return classApplyDescriptorGet(receiver, descriptor);
  }
`;
helpers.classPrivateFieldSet = helper(&quot;7.0.0-beta.0&quot;)`
  import classApplyDescriptorSet from &quot;classApplyDescriptorSet&quot;;
  import classExtractFieldDescriptor from &quot;classExtractFieldDescriptor&quot;;
  export default function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, &quot;set&quot;);
    classApplyDescriptorSet(receiver, descriptor, value);
    return value;
  }
`;
helpers.classPrivateFieldDestructureSet = helper(&quot;7.4.4&quot;)`
  import classApplyDescriptorDestructureSet from &quot;classApplyDescriptorDestructureSet&quot;;
  import classExtractFieldDescriptor from &quot;classExtractFieldDescriptor&quot;;
  export default function _classPrivateFieldDestructureSet(receiver, privateMap) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, &quot;set&quot;);
    return classApplyDescriptorDestructureSet(receiver, descriptor);
  }
`;
helpers.classExtractFieldDescriptor = helper(&quot;7.13.10&quot;)`
  export default function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
      throw new TypeError(&quot;attempted to &quot; + action + &quot; private field on non-instance&quot;);
    }
    return privateMap.get(receiver);
  }
`;
helpers.classStaticPrivateFieldSpecGet = helper(&quot;7.0.2&quot;)`
  import classApplyDescriptorGet from &quot;classApplyDescriptorGet&quot;;
  import classCheckPrivateStaticAccess from &quot;classCheckPrivateStaticAccess&quot;;
  import classCheckPrivateStaticFieldDescriptor from &quot;classCheckPrivateStaticFieldDescriptor&quot;;
  export default function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, &quot;get&quot;);
    return classApplyDescriptorGet(receiver, descriptor);
  }
`;
helpers.classStaticPrivateFieldSpecSet = helper(&quot;7.0.2&quot;)`
  import classApplyDescriptorSet from &quot;classApplyDescriptorSet&quot;;
  import classCheckPrivateStaticAccess from &quot;classCheckPrivateStaticAccess&quot;;
  import classCheckPrivateStaticFieldDescriptor from &quot;classCheckPrivateStaticFieldDescriptor&quot;;
  export default function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, &quot;set&quot;);
    classApplyDescriptorSet(receiver, descriptor, value);
    return value;
  }
`;
helpers.classStaticPrivateMethodGet = helper(&quot;7.3.2&quot;)`
  import classCheckPrivateStaticAccess from &quot;classCheckPrivateStaticAccess&quot;;
  export default function _classStaticPrivateMethodGet(receiver, classConstructor, method) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    return method;
  }
`;
helpers.classStaticPrivateMethodSet = helper(&quot;7.3.2&quot;)`
  export default function _classStaticPrivateMethodSet() {
    throw new TypeError(&quot;attempted to set read only static private field&quot;);
  }
`;
helpers.classApplyDescriptorGet = helper(&quot;7.13.10&quot;)`
  export default function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
      return descriptor.get.call(receiver);
    }
    return descriptor.value;
  }
`;
helpers.classApplyDescriptorSet = helper(&quot;7.13.10&quot;)`
  export default function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
      descriptor.set.call(receiver, value);
    } else {
      if (!descriptor.writable) {
        // This should only throw in strict mode, but class bodies are
        // always strict and private fields can only be used inside
        // class bodies.
        throw new TypeError(&quot;attempted to set read only private field&quot;);
      }
      descriptor.value = value;
    }
  }
`;
helpers.classApplyDescriptorDestructureSet = helper(&quot;7.13.10&quot;)`
  export default function _classApplyDescriptorDestructureSet(receiver, descriptor) {
    if (descriptor.set) {
      if (!(&quot;__destrObj&quot; in descriptor)) {
        descriptor.__destrObj = {
          set value(v) {
            descriptor.set.call(receiver, v)
          },
        };
      }
      return descriptor.__destrObj;
    } else {
      if (!descriptor.writable) {
        // This should only throw in strict mode, but class bodies are
        // always strict and private fields can only be used inside
        // class bodies.
        throw new TypeError(&quot;attempted to set read only private field&quot;);
      }

      return descriptor;
    }
  }
`;
helpers.classStaticPrivateFieldDestructureSet = helper(&quot;7.13.10&quot;)`
  import classApplyDescriptorDestructureSet from &quot;classApplyDescriptorDestructureSet&quot;;
  import classCheckPrivateStaticAccess from &quot;classCheckPrivateStaticAccess&quot;;
  import classCheckPrivateStaticFieldDescriptor from &quot;classCheckPrivateStaticFieldDescriptor&quot;;
  export default function _classStaticPrivateFieldDestructureSet(receiver, classConstructor, descriptor) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, &quot;set&quot;);
    return classApplyDescriptorDestructureSet(receiver, descriptor);
  }
`;
helpers.classCheckPrivateStaticAccess = helper(&quot;7.13.10&quot;)`
  export default function _classCheckPrivateStaticAccess(receiver, classConstructor) {
    if (receiver !== classConstructor) {
      throw new TypeError(&quot;Private static access of wrong provenance&quot;);
    }
  }
`;
helpers.classCheckPrivateStaticFieldDescriptor = helper(&quot;7.13.10&quot;)`
  export default function _classCheckPrivateStaticFieldDescriptor(descriptor, action) {
    if (descriptor === undefined) {
      throw new TypeError(&quot;attempted to &quot; + action + &quot; private static field before its declaration&quot;);
    }
  }
`;
helpers.decorate = helper(&quot;7.1.5&quot;)`
  import toArray from &quot;toArray&quot;;
  import toPropertyKey from &quot;toPropertyKey&quot;;

  // These comments are stripped by @babel/template
  /*::
  type PropertyDescriptor =
    | {
        value: any,
        writable: boolean,
        configurable: boolean,
        enumerable: boolean,
      }
    | {
        get?: () =&gt; any,
        set?: (v: any) =&gt; void,
        configurable: boolean,
        enumerable: boolean,
      };

  type FieldDescriptor ={
    writable: boolean,
    configurable: boolean,
    enumerable: boolean,
  };

  type Placement = &quot;static&quot; | &quot;prototype&quot; | &quot;own&quot;;
  type Key = string | symbol; // PrivateName is not supported yet.

  type ElementDescriptor =
    | {
        kind: &quot;method&quot;,
        key: Key,
        placement: Placement,
        descriptor: PropertyDescriptor
      }
    | {
        kind: &quot;field&quot;,
        key: Key,
        placement: Placement,
        descriptor: FieldDescriptor,
        initializer?: () =&gt; any,
      };

  // This is exposed to the user code
  type ElementObjectInput = ElementDescriptor &amp; {
    [@@toStringTag]?: &quot;Descriptor&quot;
  };

  // This is exposed to the user code
  type ElementObjectOutput = ElementDescriptor &amp; {
    [@@toStringTag]?: &quot;Descriptor&quot;
    extras?: ElementDescriptor[],
    finisher?: ClassFinisher,
  };

  // This is exposed to the user code
  type ClassObject = {
    [@@toStringTag]?: &quot;Descriptor&quot;,
    kind: &quot;class&quot;,
    elements: ElementDescriptor[],
  };

  type ElementDecorator = (descriptor: ElementObjectInput) =&gt; ?ElementObjectOutput;
  type ClassDecorator = (descriptor: ClassObject) =&gt; ?ClassObject;
  type ClassFinisher = &lt;A, B&gt;(cl: Class&lt;A&gt;) =&gt; Class&lt;B&gt;;

  // Only used by Babel in the transform output, not part of the spec.
  type ElementDefinition =
    | {
        kind: &quot;method&quot;,
        value: any,
        key: Key,
        static?: boolean,
        decorators?: ElementDecorator[],
      }
    | {
        kind: &quot;field&quot;,
        value: () =&gt; any,
        key: Key,
        static?: boolean,
        decorators?: ElementDecorator[],
    };

  declare function ClassFactory&lt;C&gt;(initialize: (instance: C) =&gt; void): {
    F: Class&lt;C&gt;,
    d: ElementDefinition[]
  }

  */

  /*::
  // Various combinations with/without extras and with one or many finishers

  type ElementFinisherExtras = {
    element: ElementDescriptor,
    finisher?: ClassFinisher,
    extras?: ElementDescriptor[],
  };

  type ElementFinishersExtras = {
    element: ElementDescriptor,
    finishers: ClassFinisher[],
    extras: ElementDescriptor[],
  };

  type ElementsFinisher = {
    elements: ElementDescriptor[],
    finisher?: ClassFinisher,
  };

  type ElementsFinishers = {
    elements: ElementDescriptor[],
    finishers: ClassFinisher[],
  };

  */

  /*::

  type Placements = {
    static: Key[],
    prototype: Key[],
    own: Key[],
  };

  */

  // ClassDefinitionEvaluation (Steps 26-*)
  export default function _decorate(
    decorators /*: ClassDecorator[] */,
    factory /*: ClassFactory */,
    superClass /*: ?Class&lt;*&gt; */,
    mixins /*: ?Array&lt;Function&gt; */,
  ) /*: Class&lt;*&gt; */ {
    var api = _getDecoratorsApi();
    if (mixins) {
      for (var i = 0; i &lt; mixins.length; i++) {
        api = mixins[i](api);
      }
    }

    var r = factory(function initialize(O) {
      api.initializeInstanceElements(O, decorated.elements);
    }, superClass);
    var decorated = api.decorateClass(
      _coalesceClassElements(r.d.map(_createElementDescriptor)),
      decorators,
    );

    api.initializeClassElements(r.F, decorated.elements);

    return api.runClassFinishers(r.F, decorated.finishers);
  }

  function _getDecoratorsApi() {
    _getDecoratorsApi = function() {
      return api;
    };

    var api = {
      elementsDefinitionOrder: [[&quot;method&quot;], [&quot;field&quot;]],

      // InitializeInstanceElements
      initializeInstanceElements: function(
        /*::&lt;C&gt;*/ O /*: C */,
        elements /*: ElementDescriptor[] */,
      ) {
        [&quot;method&quot;, &quot;field&quot;].forEach(function(kind) {
          elements.forEach(function(element /*: ElementDescriptor */) {
            if (element.kind === kind &amp;&amp; element.placement === &quot;own&quot;) {
              this.defineClassElement(O, element);
            }
          }, this);
        }, this);
      },

      // InitializeClassElements
      initializeClassElements: function(
        /*::&lt;C&gt;*/ F /*: Class&lt;C&gt; */,
        elements /*: ElementDescriptor[] */,
      ) {
        var proto = F.prototype;

        [&quot;method&quot;, &quot;field&quot;].forEach(function(kind) {
          elements.forEach(function(element /*: ElementDescriptor */) {
            var placement = element.placement;
            if (
              element.kind === kind &amp;&amp;
              (placement === &quot;static&quot; || placement === &quot;prototype&quot;)
            ) {
              var receiver = placement === &quot;static&quot; ? F : proto;
              this.defineClassElement(receiver, element);
            }
          }, this);
        }, this);
      },

      // DefineClassElement
      defineClassElement: function(
        /*::&lt;C&gt;*/ receiver /*: C | Class&lt;C&gt; */,
        element /*: ElementDescriptor */,
      ) {
        var descriptor /*: PropertyDescriptor */ = element.descriptor;
        if (element.kind === &quot;field&quot;) {
          var initializer = element.initializer;
          descriptor = {
            enumerable: descriptor.enumerable,
            writable: descriptor.writable,
            configurable: descriptor.configurable,
            value: initializer === void 0 ? void 0 : initializer.call(receiver),
          };
        }
        Object.defineProperty(receiver, element.key, descriptor);
      },

      // DecorateClass
      decorateClass: function(
        elements /*: ElementDescriptor[] */,
        decorators /*: ClassDecorator[] */,
      ) /*: ElementsFinishers */ {
        var newElements /*: ElementDescriptor[] */ = [];
        var finishers /*: ClassFinisher[] */ = [];
        var placements /*: Placements */ = {
          static: [],
          prototype: [],
          own: [],
        };

        elements.forEach(function(element /*: ElementDescriptor */) {
          this.addElementPlacement(element, placements);
        }, this);

        elements.forEach(function(element /*: ElementDescriptor */) {
          if (!_hasDecorators(element)) return newElements.push(element);

          var elementFinishersExtras /*: ElementFinishersExtras */ = this.decorateElement(
            element,
            placements,
          );
          newElements.push(elementFinishersExtras.element);
          newElements.push.apply(newElements, elementFinishersExtras.extras);
          finishers.push.apply(finishers, elementFinishersExtras.finishers);
        }, this);

        if (!decorators) {
          return { elements: newElements, finishers: finishers };
        }

        var result /*: ElementsFinishers */ = this.decorateConstructor(
          newElements,
          decorators,
        );
        finishers.push.apply(finishers, result.finishers);
        result.finishers = finishers;

        return result;
      },

      // AddElementPlacement
      addElementPlacement: function(
        element /*: ElementDescriptor */,
        placements /*: Placements */,
        silent /*: boolean */,
      ) {
        var keys = placements[element.placement];
        if (!silent &amp;&amp; keys.indexOf(element.key) !== -1) {
          throw new TypeError(&quot;Duplicated element (&quot; + element.key + &quot;)&quot;);
        }
        keys.push(element.key);
      },

      // DecorateElement
      decorateElement: function(
        element /*: ElementDescriptor */,
        placements /*: Placements */,
      ) /*: ElementFinishersExtras */ {
        var extras /*: ElementDescriptor[] */ = [];
        var finishers /*: ClassFinisher[] */ = [];

        for (
          var decorators = element.decorators, i = decorators.length - 1;
          i &gt;= 0;
          i--
        ) {
          // (inlined) RemoveElementPlacement
          var keys = placements[element.placement];
          keys.splice(keys.indexOf(element.key), 1);

          var elementObject /*: ElementObjectInput */ = this.fromElementDescriptor(
            element,
          );
          var elementFinisherExtras /*: ElementFinisherExtras */ = this.toElementFinisherExtras(
            (0, decorators[i])(elementObject) /*: ElementObjectOutput */ ||
              elementObject,
          );

          element = elementFinisherExtras.element;
          this.addElementPlacement(element, placements);

          if (elementFinisherExtras.finisher) {
            finishers.push(elementFinisherExtras.finisher);
          }

          var newExtras /*: ElementDescriptor[] | void */ =
            elementFinisherExtras.extras;
          if (newExtras) {
            for (var j = 0; j &lt; newExtras.length; j++) {
              this.addElementPlacement(newExtras[j], placements);
            }
            extras.push.apply(extras, newExtras);
          }
        }

        return { element: element, finishers: finishers, extras: extras };
      },

      // DecorateConstructor
      decorateConstructor: function(
        elements /*: ElementDescriptor[] */,
        decorators /*: ClassDecorator[] */,
      ) /*: ElementsFinishers */ {
        var finishers /*: ClassFinisher[] */ = [];

        for (var i = decorators.length - 1; i &gt;= 0; i--) {
          var obj /*: ClassObject */ = this.fromClassDescriptor(elements);
          var elementsAndFinisher /*: ElementsFinisher */ = this.toClassDescriptor(
            (0, decorators[i])(obj) /*: ClassObject */ || obj,
          );

          if (elementsAndFinisher.finisher !== undefined) {
            finishers.push(elementsAndFinisher.finisher);
          }

          if (elementsAndFinisher.elements !== undefined) {
            elements = elementsAndFinisher.elements;

            for (var j = 0; j &lt; elements.length - 1; j++) {
              for (var k = j + 1; k &lt; elements.length; k++) {
                if (
                  elements[j].key === elements[k].key &amp;&amp;
                  elements[j].placement === elements[k].placement
                ) {
                  throw new TypeError(
                    &quot;Duplicated element (&quot; + elements[j].key + &quot;)&quot;,
                  );
                }
              }
            }
          }
        }

        return { elements: elements, finishers: finishers };
      },

      // FromElementDescriptor
      fromElementDescriptor: function(
        element /*: ElementDescriptor */,
      ) /*: ElementObject */ {
        var obj /*: ElementObject */ = {
          kind: element.kind,
          key: element.key,
          placement: element.placement,
          descriptor: element.descriptor,
        };

        var desc = {
          value: &quot;Descriptor&quot;,
          configurable: true,
        };
        Object.defineProperty(obj, Symbol.toStringTag, desc);

        if (element.kind === &quot;field&quot;) obj.initializer = element.initializer;

        return obj;
      },

      // ToElementDescriptors
      toElementDescriptors: function(
        elementObjects /*: ElementObject[] */,
      ) /*: ElementDescriptor[] */ {
        if (elementObjects === undefined) return;
        return toArray(elementObjects).map(function(elementObject) {
          var element = this.toElementDescriptor(elementObject);
          this.disallowProperty(elementObject, &quot;finisher&quot;, &quot;An element descriptor&quot;);
          this.disallowProperty(elementObject, &quot;extras&quot;, &quot;An element descriptor&quot;);
          return element;
        }, this);
      },

      // ToElementDescriptor
      toElementDescriptor: function(
        elementObject /*: ElementObject */,
      ) /*: ElementDescriptor */ {
        var kind = String(elementObject.kind);
        if (kind !== &quot;method&quot; &amp;&amp; kind !== &quot;field&quot;) {
          throw new TypeError(
            &#039;An element descriptor\\&#039;s .kind property must be either &quot;method&quot; or&#039; +
              &#039; &quot;field&quot;, but a decorator created an element descriptor with&#039; +
              &#039; .kind &quot;&#039; +
              kind +
              &#039;&quot;&#039;,
          );
        }

        var key = toPropertyKey(elementObject.key);

        var placement = String(elementObject.placement);
        if (
          placement !== &quot;static&quot; &amp;&amp;
          placement !== &quot;prototype&quot; &amp;&amp;
          placement !== &quot;own&quot;
        ) {
          throw new TypeError(
            &#039;An element descriptor\\&#039;s .placement property must be one of &quot;static&quot;,&#039; +
              &#039; &quot;prototype&quot; or &quot;own&quot;, but a decorator created an element descriptor&#039; +
              &#039; with .placement &quot;&#039; +
              placement +
              &#039;&quot;&#039;,
          );
        }

        var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;

        this.disallowProperty(elementObject, &quot;elements&quot;, &quot;An element descriptor&quot;);

        var element /*: ElementDescriptor */ = {
          kind: kind,
          key: key,
          placement: placement,
          descriptor: Object.assign({}, descriptor),
        };

        if (kind !== &quot;field&quot;) {
          this.disallowProperty(elementObject, &quot;initializer&quot;, &quot;A method descriptor&quot;);
        } else {
          this.disallowProperty(
            descriptor,
            &quot;get&quot;,
            &quot;The property descriptor of a field descriptor&quot;,
          );
          this.disallowProperty(
            descriptor,
            &quot;set&quot;,
            &quot;The property descriptor of a field descriptor&quot;,
          );
          this.disallowProperty(
            descriptor,
            &quot;value&quot;,
            &quot;The property descriptor of a field descriptor&quot;,
          );

          element.initializer = elementObject.initializer;
        }

        return element;
      },

      toElementFinisherExtras: function(
        elementObject /*: ElementObject */,
      ) /*: ElementFinisherExtras */ {
        var element /*: ElementDescriptor */ = this.toElementDescriptor(
          elementObject,
        );
        var finisher /*: ClassFinisher */ = _optionalCallableProperty(
          elementObject,
          &quot;finisher&quot;,
        );
        var extras /*: ElementDescriptors[] */ = this.toElementDescriptors(
          elementObject.extras,
        );

        return { element: element, finisher: finisher, extras: extras };
      },

      // FromClassDescriptor
      fromClassDescriptor: function(
        elements /*: ElementDescriptor[] */,
      ) /*: ClassObject */ {
        var obj = {
          kind: &quot;class&quot;,
          elements: elements.map(this.fromElementDescriptor, this),
        };

        var desc = { value: &quot;Descriptor&quot;, configurable: true };
        Object.defineProperty(obj, Symbol.toStringTag, desc);

        return obj;
      },

      // ToClassDescriptor
      toClassDescriptor: function(
        obj /*: ClassObject */,
      ) /*: ElementsFinisher */ {
        var kind = String(obj.kind);
        if (kind !== &quot;class&quot;) {
          throw new TypeError(
            &#039;A class descriptor\\&#039;s .kind property must be &quot;class&quot;, but a decorator&#039; +
              &#039; created a class descriptor with .kind &quot;&#039; +
              kind +
              &#039;&quot;&#039;,
          );
        }

        this.disallowProperty(obj, &quot;key&quot;, &quot;A class descriptor&quot;);
        this.disallowProperty(obj, &quot;placement&quot;, &quot;A class descriptor&quot;);
        this.disallowProperty(obj, &quot;descriptor&quot;, &quot;A class descriptor&quot;);
        this.disallowProperty(obj, &quot;initializer&quot;, &quot;A class descriptor&quot;);
        this.disallowProperty(obj, &quot;extras&quot;, &quot;A class descriptor&quot;);

        var finisher = _optionalCallableProperty(obj, &quot;finisher&quot;);
        var elements = this.toElementDescriptors(obj.elements);

        return { elements: elements, finisher: finisher };
      },

      // RunClassFinishers
      runClassFinishers: function(
        constructor /*: Class&lt;*&gt; */,
        finishers /*: ClassFinisher[] */,
      ) /*: Class&lt;*&gt; */ {
        for (var i = 0; i &lt; finishers.length; i++) {
          var newConstructor /*: ?Class&lt;*&gt; */ = (0, finishers[i])(constructor);
          if (newConstructor !== undefined) {
            // NOTE: This should check if IsConstructor(newConstructor) is false.
            if (typeof newConstructor !== &quot;function&quot;) {
              throw new TypeError(&quot;Finishers must return a constructor.&quot;);
            }
            constructor = newConstructor;
          }
        }
        return constructor;
      },

      disallowProperty: function(obj, name, objectType) {
        if (obj[name] !== undefined) {
          throw new TypeError(objectType + &quot; can&#039;t have a .&quot; + name + &quot; property.&quot;);
        }
      }
    };

    return api;
  }

  // ClassElementEvaluation
  function _createElementDescriptor(
    def /*: ElementDefinition */,
  ) /*: ElementDescriptor */ {
    var key = toPropertyKey(def.key);

    var descriptor /*: PropertyDescriptor */;
    if (def.kind === &quot;method&quot;) {
      descriptor = {
        value: def.value,
        writable: true,
        configurable: true,
        enumerable: false,
      };
    } else if (def.kind === &quot;get&quot;) {
      descriptor = { get: def.value, configurable: true, enumerable: false };
    } else if (def.kind === &quot;set&quot;) {
      descriptor = { set: def.value, configurable: true, enumerable: false };
    } else if (def.kind === &quot;field&quot;) {
      descriptor = { configurable: true, writable: true, enumerable: true };
    }

    var element /*: ElementDescriptor */ = {
      kind: def.kind === &quot;field&quot; ? &quot;field&quot; : &quot;method&quot;,
      key: key,
      placement: def.static
        ? &quot;static&quot;
        : def.kind === &quot;field&quot;
        ? &quot;own&quot;
        : &quot;prototype&quot;,
      descriptor: descriptor,
    };
    if (def.decorators) element.decorators = def.decorators;
    if (def.kind === &quot;field&quot;) element.initializer = def.value;

    return element;
  }

  // CoalesceGetterSetter
  function _coalesceGetterSetter(
    element /*: ElementDescriptor */,
    other /*: ElementDescriptor */,
  ) {
    if (element.descriptor.get !== undefined) {
      other.descriptor.get = element.descriptor.get;
    } else {
      other.descriptor.set = element.descriptor.set;
    }
  }

  // CoalesceClassElements
  function _coalesceClassElements(
    elements /*: ElementDescriptor[] */,
  ) /*: ElementDescriptor[] */ {
    var newElements /*: ElementDescriptor[] */ = [];

    var isSameElement = function(
      other /*: ElementDescriptor */,
    ) /*: boolean */ {
      return (
        other.kind === &quot;method&quot; &amp;&amp;
        other.key === element.key &amp;&amp;
        other.placement === element.placement
      );
    };

    for (var i = 0; i &lt; elements.length; i++) {
      var element /*: ElementDescriptor */ = elements[i];
      var other /*: ElementDescriptor */;

      if (
        element.kind === &quot;method&quot; &amp;&amp;
        (other = newElements.find(isSameElement))
      ) {
        if (
          _isDataDescriptor(element.descriptor) ||
          _isDataDescriptor(other.descriptor)
        ) {
          if (_hasDecorators(element) || _hasDecorators(other)) {
            throw new ReferenceError(
              &quot;Duplicated methods (&quot; + element.key + &quot;) can&#039;t be decorated.&quot;,
            );
          }
          other.descriptor = element.descriptor;
        } else {
          if (_hasDecorators(element)) {
            if (_hasDecorators(other)) {
              throw new ReferenceError(
                &quot;Decorators can&#039;t be placed on different accessors with for &quot; +
                  &quot;the same property (&quot; +
                  element.key +
                  &quot;).&quot;,
              );
            }
            other.decorators = element.decorators;
          }
          _coalesceGetterSetter(element, other);
        }
      } else {
        newElements.push(element);
      }
    }

    return newElements;
  }

  function _hasDecorators(element /*: ElementDescriptor */) /*: boolean */ {
    return element.decorators &amp;&amp; element.decorators.length;
  }

  function _isDataDescriptor(desc /*: PropertyDescriptor */) /*: boolean */ {
    return (
      desc !== undefined &amp;&amp;
      !(desc.value === undefined &amp;&amp; desc.writable === undefined)
    );
  }

  function _optionalCallableProperty /*::&lt;T&gt;*/(
    obj /*: T */,
    name /*: $Keys&lt;T&gt; */,
  ) /*: ?Function */ {
    var value = obj[name];
    if (value !== undefined &amp;&amp; typeof value !== &quot;function&quot;) {
      throw new TypeError(&quot;Expected &#039;&quot; + name + &quot;&#039; to be a function&quot;);
    }
    return value;
  }

`;
helpers.classPrivateMethodGet = helper(&quot;7.1.6&quot;)`
  export default function _classPrivateMethodGet(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
      throw new TypeError(&quot;attempted to get private field on non-instance&quot;);
    }
    return fn;
  }
`;
helpers.checkPrivateRedeclaration = helper(&quot;7.14.1&quot;)`
  export default function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
      throw new TypeError(&quot;Cannot initialize the same private elements twice on an object&quot;);
    }
  }
`;
helpers.classPrivateFieldInitSpec = helper(&quot;7.14.1&quot;)`
  import checkPrivateRedeclaration from &quot;checkPrivateRedeclaration&quot;;

  export default function _classPrivateFieldInitSpec(obj, privateMap, value) {
    checkPrivateRedeclaration(obj, privateMap);
    privateMap.set(obj, value);
  }
`;
helpers.classPrivateMethodInitSpec = helper(&quot;7.14.1&quot;)`
  import checkPrivateRedeclaration from &quot;checkPrivateRedeclaration&quot;;

  export default function _classPrivateMethodInitSpec(obj, privateSet) {
    checkPrivateRedeclaration(obj, privateSet);
    privateSet.add(obj);
  }
`;
{
  helpers.classPrivateMethodSet = helper(&quot;7.1.6&quot;)`
    export default function _classPrivateMethodSet() {
      throw new TypeError(&quot;attempted to reassign private method&quot;);
    }
  `;
}
helpers.identity = helper(&quot;7.17.0&quot;)`
  export default function _identity(x) {
    return x;
  }
`;

//# sourceMappingURL=helpers.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
