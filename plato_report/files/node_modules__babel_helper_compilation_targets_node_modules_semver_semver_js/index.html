<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@babel/helper-compilation-targets/node_modules/semver/semver.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@babel/helper-compilation-targets/node_modules/semver/semver.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">63.35</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1596</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">164.25</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">17.95</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">exports = module.exports = SemVer

var debug
/* istanbul ignore next */
if (typeof process === &#039;object&#039; &amp;&amp;
    process.env &amp;&amp;
    process.env.NODE_DEBUG &amp;&amp;
    /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
  debug = function () {
    var args = Array.prototype.slice.call(arguments, 0)
    args.unshift(&#039;SEMVER&#039;)
    console.log.apply(console, args)
  }
} else {
  debug = function () {}
}

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = &#039;2.0.0&#039;

var MAX_LENGTH = 256
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16

// The actual regexps go on exports.re
var re = exports.re = []
var src = exports.src = []
var t = exports.tokens = {}
var R = 0

function tok (n) {
  t[n] = R++
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

tok(&#039;NUMERICIDENTIFIER&#039;)
src[t.NUMERICIDENTIFIER] = &#039;0|[1-9]\\d*&#039;
tok(&#039;NUMERICIDENTIFIERLOOSE&#039;)
src[t.NUMERICIDENTIFIERLOOSE] = &#039;[0-9]+&#039;

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

tok(&#039;NONNUMERICIDENTIFIER&#039;)
src[t.NONNUMERICIDENTIFIER] = &#039;\\d*[a-zA-Z-][a-zA-Z0-9-]*&#039;

// ## Main Version
// Three dot-separated numeric identifiers.

tok(&#039;MAINVERSION&#039;)
src[t.MAINVERSION] = &#039;(&#039; + src[t.NUMERICIDENTIFIER] + &#039;)\\.&#039; +
                   &#039;(&#039; + src[t.NUMERICIDENTIFIER] + &#039;)\\.&#039; +
                   &#039;(&#039; + src[t.NUMERICIDENTIFIER] + &#039;)&#039;

tok(&#039;MAINVERSIONLOOSE&#039;)
src[t.MAINVERSIONLOOSE] = &#039;(&#039; + src[t.NUMERICIDENTIFIERLOOSE] + &#039;)\\.&#039; +
                        &#039;(&#039; + src[t.NUMERICIDENTIFIERLOOSE] + &#039;)\\.&#039; +
                        &#039;(&#039; + src[t.NUMERICIDENTIFIERLOOSE] + &#039;)&#039;

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

tok(&#039;PRERELEASEIDENTIFIER&#039;)
src[t.PRERELEASEIDENTIFIER] = &#039;(?:&#039; + src[t.NUMERICIDENTIFIER] +
                            &#039;|&#039; + src[t.NONNUMERICIDENTIFIER] + &#039;)&#039;

tok(&#039;PRERELEASEIDENTIFIERLOOSE&#039;)
src[t.PRERELEASEIDENTIFIERLOOSE] = &#039;(?:&#039; + src[t.NUMERICIDENTIFIERLOOSE] +
                                 &#039;|&#039; + src[t.NONNUMERICIDENTIFIER] + &#039;)&#039;

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

tok(&#039;PRERELEASE&#039;)
src[t.PRERELEASE] = &#039;(?:-(&#039; + src[t.PRERELEASEIDENTIFIER] +
                  &#039;(?:\\.&#039; + src[t.PRERELEASEIDENTIFIER] + &#039;)*))&#039;

tok(&#039;PRERELEASELOOSE&#039;)
src[t.PRERELEASELOOSE] = &#039;(?:-?(&#039; + src[t.PRERELEASEIDENTIFIERLOOSE] +
                       &#039;(?:\\.&#039; + src[t.PRERELEASEIDENTIFIERLOOSE] + &#039;)*))&#039;

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

tok(&#039;BUILDIDENTIFIER&#039;)
src[t.BUILDIDENTIFIER] = &#039;[0-9A-Za-z-]+&#039;

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

tok(&#039;BUILD&#039;)
src[t.BUILD] = &#039;(?:\\+(&#039; + src[t.BUILDIDENTIFIER] +
             &#039;(?:\\.&#039; + src[t.BUILDIDENTIFIER] + &#039;)*))&#039;

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

tok(&#039;FULL&#039;)
tok(&#039;FULLPLAIN&#039;)
src[t.FULLPLAIN] = &#039;v?&#039; + src[t.MAINVERSION] +
                  src[t.PRERELEASE] + &#039;?&#039; +
                  src[t.BUILD] + &#039;?&#039;

src[t.FULL] = &#039;^&#039; + src[t.FULLPLAIN] + &#039;$&#039;

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
tok(&#039;LOOSEPLAIN&#039;)
src[t.LOOSEPLAIN] = &#039;[v=\\s]*&#039; + src[t.MAINVERSIONLOOSE] +
                  src[t.PRERELEASELOOSE] + &#039;?&#039; +
                  src[t.BUILD] + &#039;?&#039;

tok(&#039;LOOSE&#039;)
src[t.LOOSE] = &#039;^&#039; + src[t.LOOSEPLAIN] + &#039;$&#039;

tok(&#039;GTLT&#039;)
src[t.GTLT] = &#039;((?:&lt;|&gt;)?=?)&#039;

// Something like &quot;2.*&quot; or &quot;1.2.x&quot;.
// Note that &quot;x.x&quot; is a valid xRange identifer, meaning &quot;any version&quot;
// Only the first item is strictly required.
tok(&#039;XRANGEIDENTIFIERLOOSE&#039;)
src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + &#039;|x|X|\\*&#039;
tok(&#039;XRANGEIDENTIFIER&#039;)
src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + &#039;|x|X|\\*&#039;

tok(&#039;XRANGEPLAIN&#039;)
src[t.XRANGEPLAIN] = &#039;[v=\\s]*(&#039; + src[t.XRANGEIDENTIFIER] + &#039;)&#039; +
                   &#039;(?:\\.(&#039; + src[t.XRANGEIDENTIFIER] + &#039;)&#039; +
                   &#039;(?:\\.(&#039; + src[t.XRANGEIDENTIFIER] + &#039;)&#039; +
                   &#039;(?:&#039; + src[t.PRERELEASE] + &#039;)?&#039; +
                   src[t.BUILD] + &#039;?&#039; +
                   &#039;)?)?&#039;

tok(&#039;XRANGEPLAINLOOSE&#039;)
src[t.XRANGEPLAINLOOSE] = &#039;[v=\\s]*(&#039; + src[t.XRANGEIDENTIFIERLOOSE] + &#039;)&#039; +
                        &#039;(?:\\.(&#039; + src[t.XRANGEIDENTIFIERLOOSE] + &#039;)&#039; +
                        &#039;(?:\\.(&#039; + src[t.XRANGEIDENTIFIERLOOSE] + &#039;)&#039; +
                        &#039;(?:&#039; + src[t.PRERELEASELOOSE] + &#039;)?&#039; +
                        src[t.BUILD] + &#039;?&#039; +
                        &#039;)?)?&#039;

tok(&#039;XRANGE&#039;)
src[t.XRANGE] = &#039;^&#039; + src[t.GTLT] + &#039;\\s*&#039; + src[t.XRANGEPLAIN] + &#039;$&#039;
tok(&#039;XRANGELOOSE&#039;)
src[t.XRANGELOOSE] = &#039;^&#039; + src[t.GTLT] + &#039;\\s*&#039; + src[t.XRANGEPLAINLOOSE] + &#039;$&#039;

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
tok(&#039;COERCE&#039;)
src[t.COERCE] = &#039;(^|[^\\d])&#039; +
              &#039;(\\d{1,&#039; + MAX_SAFE_COMPONENT_LENGTH + &#039;})&#039; +
              &#039;(?:\\.(\\d{1,&#039; + MAX_SAFE_COMPONENT_LENGTH + &#039;}))?&#039; +
              &#039;(?:\\.(\\d{1,&#039; + MAX_SAFE_COMPONENT_LENGTH + &#039;}))?&#039; +
              &#039;(?:$|[^\\d])&#039;
tok(&#039;COERCERTL&#039;)
re[t.COERCERTL] = new RegExp(src[t.COERCE], &#039;g&#039;)

// Tilde ranges.
// Meaning is &quot;reasonably at or greater than&quot;
tok(&#039;LONETILDE&#039;)
src[t.LONETILDE] = &#039;(?:~&gt;?)&#039;

tok(&#039;TILDETRIM&#039;)
src[t.TILDETRIM] = &#039;(\\s*)&#039; + src[t.LONETILDE] + &#039;\\s+&#039;
re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], &#039;g&#039;)
var tildeTrimReplace = &#039;$1~&#039;

tok(&#039;TILDE&#039;)
src[t.TILDE] = &#039;^&#039; + src[t.LONETILDE] + src[t.XRANGEPLAIN] + &#039;$&#039;
tok(&#039;TILDELOOSE&#039;)
src[t.TILDELOOSE] = &#039;^&#039; + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + &#039;$&#039;

// Caret ranges.
// Meaning is &quot;at least and backwards compatible with&quot;
tok(&#039;LONECARET&#039;)
src[t.LONECARET] = &#039;(?:\\^)&#039;

tok(&#039;CARETTRIM&#039;)
src[t.CARETTRIM] = &#039;(\\s*)&#039; + src[t.LONECARET] + &#039;\\s+&#039;
re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], &#039;g&#039;)
var caretTrimReplace = &#039;$1^&#039;

tok(&#039;CARET&#039;)
src[t.CARET] = &#039;^&#039; + src[t.LONECARET] + src[t.XRANGEPLAIN] + &#039;$&#039;
tok(&#039;CARETLOOSE&#039;)
src[t.CARETLOOSE] = &#039;^&#039; + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + &#039;$&#039;

// A simple gt/lt/eq thing, or just &quot;&quot; to indicate &quot;any version&quot;
tok(&#039;COMPARATORLOOSE&#039;)
src[t.COMPARATORLOOSE] = &#039;^&#039; + src[t.GTLT] + &#039;\\s*(&#039; + src[t.LOOSEPLAIN] + &#039;)$|^$&#039;
tok(&#039;COMPARATOR&#039;)
src[t.COMPARATOR] = &#039;^&#039; + src[t.GTLT] + &#039;\\s*(&#039; + src[t.FULLPLAIN] + &#039;)$|^$&#039;

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `&gt; 1.2.3` ==&gt; `&gt;1.2.3`
tok(&#039;COMPARATORTRIM&#039;)
src[t.COMPARATORTRIM] = &#039;(\\s*)&#039; + src[t.GTLT] +
                      &#039;\\s*(&#039; + src[t.LOOSEPLAIN] + &#039;|&#039; + src[t.XRANGEPLAIN] + &#039;)&#039;

// this one has to use the /g flag
re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], &#039;g&#039;)
var comparatorTrimReplace = &#039;$1$2$3&#039;

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they&#039;ll be
// checked against either the strict or loose comparator form
// later.
tok(&#039;HYPHENRANGE&#039;)
src[t.HYPHENRANGE] = &#039;^\\s*(&#039; + src[t.XRANGEPLAIN] + &#039;)&#039; +
                   &#039;\\s+-\\s+&#039; +
                   &#039;(&#039; + src[t.XRANGEPLAIN] + &#039;)&#039; +
                   &#039;\\s*$&#039;

tok(&#039;HYPHENRANGELOOSE&#039;)
src[t.HYPHENRANGELOOSE] = &#039;^\\s*(&#039; + src[t.XRANGEPLAINLOOSE] + &#039;)&#039; +
                        &#039;\\s+-\\s+&#039; +
                        &#039;(&#039; + src[t.XRANGEPLAINLOOSE] + &#039;)&#039; +
                        &#039;\\s*$&#039;

// Star ranges basically just allow anything at all.
tok(&#039;STAR&#039;)
src[t.STAR] = &#039;(&lt;|&gt;)?=?\\s*\\*&#039;

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i &lt; R; i++) {
  debug(i, src[i])
  if (!re[i]) {
    re[i] = new RegExp(src[i])
  }
}

exports.parse = parse
function parse (version, options) {
  if (!options || typeof options !== &#039;object&#039;) {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== &#039;string&#039;) {
    return null
  }

  if (version.length &gt; MAX_LENGTH) {
    return null
  }

  var r = options.loose ? re[t.LOOSE] : re[t.FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

exports.valid = valid
function valid (version, options) {
  var v = parse(version, options)
  return v ? v.version : null
}

exports.clean = clean
function clean (version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, &#039;&#039;), options)
  return s ? s.version : null
}

exports.SemVer = SemVer

function SemVer (version, options) {
  if (!options || typeof options !== &#039;object&#039;) {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }
  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version
    } else {
      version = version.version
    }
  } else if (typeof version !== &#039;string&#039;) {
    throw new TypeError(&#039;Invalid Version: &#039; + version)
  }

  if (version.length &gt; MAX_LENGTH) {
    throw new TypeError(&#039;version is longer than &#039; + MAX_LENGTH + &#039; characters&#039;)
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options)
  }

  debug(&#039;SemVer&#039;, version, options)
  this.options = options
  this.loose = !!options.loose

  var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])

  if (!m) {
    throw new TypeError(&#039;Invalid Version: &#039; + version)
  }

  this.raw = version

  // these are actually numbers
  this.major = +m[1]
  this.minor = +m[2]
  this.patch = +m[3]

  if (this.major &gt; MAX_SAFE_INTEGER || this.major &lt; 0) {
    throw new TypeError(&#039;Invalid major version&#039;)
  }

  if (this.minor &gt; MAX_SAFE_INTEGER || this.minor &lt; 0) {
    throw new TypeError(&#039;Invalid minor version&#039;)
  }

  if (this.patch &gt; MAX_SAFE_INTEGER || this.patch &lt; 0) {
    throw new TypeError(&#039;Invalid patch version&#039;)
  }

  // numberify any prerelease numeric ids
  if (!m[4]) {
    this.prerelease = []
  } else {
    this.prerelease = m[4].split(&#039;.&#039;).map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id
        if (num &gt;= 0 &amp;&amp; num &lt; MAX_SAFE_INTEGER) {
          return num
        }
      }
      return id
    })
  }

  this.build = m[5] ? m[5].split(&#039;.&#039;) : []
  this.format()
}

SemVer.prototype.format = function () {
  this.version = this.major + &#039;.&#039; + this.minor + &#039;.&#039; + this.patch
  if (this.prerelease.length) {
    this.version += &#039;-&#039; + this.prerelease.join(&#039;.&#039;)
  }
  return this.version
}

SemVer.prototype.toString = function () {
  return this.version
}

SemVer.prototype.compare = function (other) {
  debug(&#039;SemVer.compare&#039;, this.version, this.options, other)
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return this.compareMain(other) || this.comparePre(other)
}

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch)
}

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  // NOT having a prerelease is &gt; having one
  if (this.prerelease.length &amp;&amp; !other.prerelease.length) {
    return -1
  } else if (!this.prerelease.length &amp;&amp; other.prerelease.length) {
    return 1
  } else if (!this.prerelease.length &amp;&amp; !other.prerelease.length) {
    return 0
  }

  var i = 0
  do {
    var a = this.prerelease[i]
    var b = other.prerelease[i]
    debug(&#039;prerelease compare&#039;, i, a, b)
    if (a === undefined &amp;&amp; b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

SemVer.prototype.compareBuild = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  var i = 0
  do {
    var a = this.build[i]
    var b = other.build[i]
    debug(&#039;prerelease compare&#039;, i, a, b)
    if (a === undefined &amp;&amp; b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case &#039;premajor&#039;:
      this.prerelease.length = 0
      this.patch = 0
      this.minor = 0
      this.major++
      this.inc(&#039;pre&#039;, identifier)
      break
    case &#039;preminor&#039;:
      this.prerelease.length = 0
      this.patch = 0
      this.minor++
      this.inc(&#039;pre&#039;, identifier)
      break
    case &#039;prepatch&#039;:
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0
      this.inc(&#039;patch&#039;, identifier)
      this.inc(&#039;pre&#039;, identifier)
      break
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case &#039;prerelease&#039;:
      if (this.prerelease.length === 0) {
        this.inc(&#039;patch&#039;, identifier)
      }
      this.inc(&#039;pre&#039;, identifier)
      break

    case &#039;major&#039;:
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0) {
        this.major++
      }
      this.minor = 0
      this.patch = 0
      this.prerelease = []
      break
    case &#039;minor&#039;:
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++
      }
      this.patch = 0
      this.prerelease = []
      break
    case &#039;patch&#039;:
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++
      }
      this.prerelease = []
      break
    // This probably shouldn&#039;t be used publicly.
    // 1.0.0 &quot;pre&quot; would become 1.0.0-0 which is the wrong direction.
    case &#039;pre&#039;:
      if (this.prerelease.length === 0) {
        this.prerelease = [0]
      } else {
        var i = this.prerelease.length
        while (--i &gt;= 0) {
          if (typeof this.prerelease[i] === &#039;number&#039;) {
            this.prerelease[i]++
            i = -2
          }
        }
        if (i === -1) {
          // didn&#039;t increment anything
          this.prerelease.push(0)
        }
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0]
          }
        } else {
          this.prerelease = [identifier, 0]
        }
      }
      break

    default:
      throw new Error(&#039;invalid increment argument: &#039; + release)
  }
  this.format()
  this.raw = this.version
  return this
}

exports.inc = inc
function inc (version, release, loose, identifier) {
  if (typeof (loose) === &#039;string&#039;) {
    identifier = loose
    loose = undefined
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version
  } catch (er) {
    return null
  }
}

exports.diff = diff
function diff (version1, version2) {
  if (eq(version1, version2)) {
    return null
  } else {
    var v1 = parse(version1)
    var v2 = parse(version2)
    var prefix = &#039;&#039;
    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = &#039;pre&#039;
      var defaultResult = &#039;prerelease&#039;
    }
    for (var key in v1) {
      if (key === &#039;major&#039; || key === &#039;minor&#039; || key === &#039;patch&#039;) {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers

var numeric = /^[0-9]+$/
function compareIdentifiers (a, b) {
  var anum = numeric.test(a)
  var bnum = numeric.test(b)

  if (anum &amp;&amp; bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum &amp;&amp; !bnum) ? -1
    : (bnum &amp;&amp; !anum) ? 1
    : a &lt; b ? -1
    : 1
}

exports.rcompareIdentifiers = rcompareIdentifiers
function rcompareIdentifiers (a, b) {
  return compareIdentifiers(b, a)
}

exports.major = major
function major (a, loose) {
  return new SemVer(a, loose).major
}

exports.minor = minor
function minor (a, loose) {
  return new SemVer(a, loose).minor
}

exports.patch = patch
function patch (a, loose) {
  return new SemVer(a, loose).patch
}

exports.compare = compare
function compare (a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose))
}

exports.compareLoose = compareLoose
function compareLoose (a, b) {
  return compare(a, b, true)
}

exports.compareBuild = compareBuild
function compareBuild (a, b, loose) {
  var versionA = new SemVer(a, loose)
  var versionB = new SemVer(b, loose)
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
}

exports.rcompare = rcompare
function rcompare (a, b, loose) {
  return compare(b, a, loose)
}

exports.sort = sort
function sort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compareBuild(a, b, loose)
  })
}

exports.rsort = rsort
function rsort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compareBuild(b, a, loose)
  })
}

exports.gt = gt
function gt (a, b, loose) {
  return compare(a, b, loose) &gt; 0
}

exports.lt = lt
function lt (a, b, loose) {
  return compare(a, b, loose) &lt; 0
}

exports.eq = eq
function eq (a, b, loose) {
  return compare(a, b, loose) === 0
}

exports.neq = neq
function neq (a, b, loose) {
  return compare(a, b, loose) !== 0
}

exports.gte = gte
function gte (a, b, loose) {
  return compare(a, b, loose) &gt;= 0
}

exports.lte = lte
function lte (a, b, loose) {
  return compare(a, b, loose) &lt;= 0
}

exports.cmp = cmp
function cmp (a, op, b, loose) {
  switch (op) {
    case &#039;===&#039;:
      if (typeof a === &#039;object&#039;)
        a = a.version
      if (typeof b === &#039;object&#039;)
        b = b.version
      return a === b

    case &#039;!==&#039;:
      if (typeof a === &#039;object&#039;)
        a = a.version
      if (typeof b === &#039;object&#039;)
        b = b.version
      return a !== b

    case &#039;&#039;:
    case &#039;=&#039;:
    case &#039;==&#039;:
      return eq(a, b, loose)

    case &#039;!=&#039;:
      return neq(a, b, loose)

    case &#039;&gt;&#039;:
      return gt(a, b, loose)

    case &#039;&gt;=&#039;:
      return gte(a, b, loose)

    case &#039;&lt;&#039;:
      return lt(a, b, loose)

    case &#039;&lt;=&#039;:
      return lte(a, b, loose)

    default:
      throw new TypeError(&#039;Invalid operator: &#039; + op)
  }
}

exports.Comparator = Comparator
function Comparator (comp, options) {
  if (!options || typeof options !== &#039;object&#039;) {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp
    } else {
      comp = comp.value
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options)
  }

  debug(&#039;comparator&#039;, comp, options)
  this.options = options
  this.loose = !!options.loose
  this.parse(comp)

  if (this.semver === ANY) {
    this.value = &#039;&#039;
  } else {
    this.value = this.operator + this.semver.version
  }

  debug(&#039;comp&#039;, this)
}

var ANY = {}
Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
  var m = comp.match(r)

  if (!m) {
    throw new TypeError(&#039;Invalid comparator: &#039; + comp)
  }

  this.operator = m[1] !== undefined ? m[1] : &#039;&#039;
  if (this.operator === &#039;=&#039;) {
    this.operator = &#039;&#039;
  }

  // if it literally is just &#039;&gt;&#039; or &#039;&#039; then allow anything.
  if (!m[2]) {
    this.semver = ANY
  } else {
    this.semver = new SemVer(m[2], this.options.loose)
  }
}

Comparator.prototype.toString = function () {
  return this.value
}

Comparator.prototype.test = function (version) {
  debug(&#039;Comparator.test&#039;, version, this.options.loose)

  if (this.semver === ANY || version === ANY) {
    return true
  }

  if (typeof version === &#039;string&#039;) {
    try {
      version = new SemVer(version, this.options)
    } catch (er) {
      return false
    }
  }

  return cmp(version, this.operator, this.semver, this.options)
}

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError(&#039;a Comparator is required&#039;)
  }

  if (!options || typeof options !== &#039;object&#039;) {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  var rangeTmp

  if (this.operator === &#039;&#039;) {
    if (this.value === &#039;&#039;) {
      return true
    }
    rangeTmp = new Range(comp.value, options)
    return satisfies(this.value, rangeTmp, options)
  } else if (comp.operator === &#039;&#039;) {
    if (comp.value === &#039;&#039;) {
      return true
    }
    rangeTmp = new Range(this.value, options)
    return satisfies(comp.semver, rangeTmp, options)
  }

  var sameDirectionIncreasing =
    (this.operator === &#039;&gt;=&#039; || this.operator === &#039;&gt;&#039;) &amp;&amp;
    (comp.operator === &#039;&gt;=&#039; || comp.operator === &#039;&gt;&#039;)
  var sameDirectionDecreasing =
    (this.operator === &#039;&lt;=&#039; || this.operator === &#039;&lt;&#039;) &amp;&amp;
    (comp.operator === &#039;&lt;=&#039; || comp.operator === &#039;&lt;&#039;)
  var sameSemVer = this.semver.version === comp.semver.version
  var differentDirectionsInclusive =
    (this.operator === &#039;&gt;=&#039; || this.operator === &#039;&lt;=&#039;) &amp;&amp;
    (comp.operator === &#039;&gt;=&#039; || comp.operator === &#039;&lt;=&#039;)
  var oppositeDirectionsLessThan =
    cmp(this.semver, &#039;&lt;&#039;, comp.semver, options) &amp;&amp;
    ((this.operator === &#039;&gt;=&#039; || this.operator === &#039;&gt;&#039;) &amp;&amp;
    (comp.operator === &#039;&lt;=&#039; || comp.operator === &#039;&lt;&#039;))
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, &#039;&gt;&#039;, comp.semver, options) &amp;&amp;
    ((this.operator === &#039;&lt;=&#039; || this.operator === &#039;&lt;&#039;) &amp;&amp;
    (comp.operator === &#039;&gt;=&#039; || comp.operator === &#039;&gt;&#039;))

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer &amp;&amp; differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan
}

exports.Range = Range
function Range (range, options) {
  if (!options || typeof options !== &#039;object&#039;) {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose &amp;&amp;
        range.includePrerelease === !!options.includePrerelease) {
      return range
    } else {
      return new Range(range.raw, options)
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options)
  }

  if (!(this instanceof Range)) {
    return new Range(range, options)
  }

  this.options = options
  this.loose = !!options.loose
  this.includePrerelease = !!options.includePrerelease

  // First, split based on boolean or ||
  this.raw = range
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim())
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length
  })

  if (!this.set.length) {
    throw new TypeError(&#039;Invalid SemVer Range: &#039; + range)
  }

  this.format()
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(&#039; &#039;).trim()
  }).join(&#039;||&#039;).trim()
  return this.range
}

Range.prototype.toString = function () {
  return this.range
}

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose
  range = range.trim()
  // `1.2.3 - 1.2.4` =&gt; `&gt;=1.2.3 &lt;=1.2.4`
  var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
  range = range.replace(hr, hyphenReplace)
  debug(&#039;hyphen replace&#039;, range)
  // `&gt; 1.2.3 &lt; 1.2.5` =&gt; `&gt;1.2.3 &lt;1.2.5`
  range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
  debug(&#039;comparator trim&#039;, range, re[t.COMPARATORTRIM])

  // `~ 1.2.3` =&gt; `~1.2.3`
  range = range.replace(re[t.TILDETRIM], tildeTrimReplace)

  // `^ 1.2.3` =&gt; `^1.2.3`
  range = range.replace(re[t.CARETTRIM], caretTrimReplace)

  // normalize spaces
  range = range.split(/\s+/).join(&#039; &#039;)

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
  var set = range.split(&#039; &#039;).map(function (comp) {
    return parseComparator(comp, this.options)
  }, this).join(&#039; &#039;).split(/\s+/)
  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe)
    })
  }
  set = set.map(function (comp) {
    return new Comparator(comp, this.options)
  }, this)

  return set
}

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError(&#039;a Range is required&#039;)
  }

  return this.set.some(function (thisComparators) {
    return (
      isSatisfiable(thisComparators, options) &amp;&amp;
      range.set.some(function (rangeComparators) {
        return (
          isSatisfiable(rangeComparators, options) &amp;&amp;
          thisComparators.every(function (thisComparator) {
            return rangeComparators.every(function (rangeComparator) {
              return thisComparator.intersects(rangeComparator, options)
            })
          })
        )
      })
    )
  })
}

// take a set of comparators and determine whether there
// exists a version which can satisfy it
function isSatisfiable (comparators, options) {
  var result = true
  var remainingComparators = comparators.slice()
  var testComparator = remainingComparators.pop()

  while (result &amp;&amp; remainingComparators.length) {
    result = remainingComparators.every(function (otherComparator) {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators
function toComparators (range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value
    }).join(&#039; &#039;).trim().split(&#039; &#039;)
  })
}

// comprised of xranges, tildes, stars, and gtlt&#039;s at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator (comp, options) {
  debug(&#039;comp&#039;, comp, options)
  comp = replaceCarets(comp, options)
  debug(&#039;caret&#039;, comp)
  comp = replaceTildes(comp, options)
  debug(&#039;tildes&#039;, comp)
  comp = replaceXRanges(comp, options)
  debug(&#039;xrange&#039;, comp)
  comp = replaceStars(comp, options)
  debug(&#039;stars&#039;, comp)
  return comp
}

function isX (id) {
  return !id || id.toLowerCase() === &#039;x&#039; || id === &#039;*&#039;
}

// ~, ~&gt; --&gt; * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~&gt;2, ~&gt;2.x ~&gt;2.x.x --&gt; &gt;=2.0.0 &lt;3.0.0
// ~2.0, ~2.0.x, ~&gt;2.0, ~&gt;2.0.x --&gt; &gt;=2.0.0 &lt;2.1.0
// ~1.2, ~1.2.x, ~&gt;1.2, ~&gt;1.2.x --&gt; &gt;=1.2.0 &lt;1.3.0
// ~1.2.3, ~&gt;1.2.3 --&gt; &gt;=1.2.3 &lt;1.3.0
// ~1.2.0, ~&gt;1.2.0 --&gt; &gt;=1.2.0 &lt;1.3.0
function replaceTildes (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options)
  }).join(&#039; &#039;)
}

function replaceTilde (comp, options) {
  var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug(&#039;tilde&#039;, comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = &#039;&#039;
    } else if (isX(m)) {
      ret = &#039;&gt;=&#039; + M + &#039;.0.0 &lt;&#039; + (+M + 1) + &#039;.0.0&#039;
    } else if (isX(p)) {
      // ~1.2 == &gt;=1.2.0 &lt;1.3.0
      ret = &#039;&gt;=&#039; + M + &#039;.&#039; + m + &#039;.0 &lt;&#039; + M + &#039;.&#039; + (+m + 1) + &#039;.0&#039;
    } else if (pr) {
      debug(&#039;replaceTilde pr&#039;, pr)
      ret = &#039;&gt;=&#039; + M + &#039;.&#039; + m + &#039;.&#039; + p + &#039;-&#039; + pr +
            &#039; &lt;&#039; + M + &#039;.&#039; + (+m + 1) + &#039;.0&#039;
    } else {
      // ~1.2.3 == &gt;=1.2.3 &lt;1.3.0
      ret = &#039;&gt;=&#039; + M + &#039;.&#039; + m + &#039;.&#039; + p +
            &#039; &lt;&#039; + M + &#039;.&#039; + (+m + 1) + &#039;.0&#039;
    }

    debug(&#039;tilde return&#039;, ret)
    return ret
  })
}

// ^ --&gt; * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --&gt; &gt;=2.0.0 &lt;3.0.0
// ^2.0, ^2.0.x --&gt; &gt;=2.0.0 &lt;3.0.0
// ^1.2, ^1.2.x --&gt; &gt;=1.2.0 &lt;2.0.0
// ^1.2.3 --&gt; &gt;=1.2.3 &lt;2.0.0
// ^1.2.0 --&gt; &gt;=1.2.0 &lt;2.0.0
function replaceCarets (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options)
  }).join(&#039; &#039;)
}

function replaceCaret (comp, options) {
  debug(&#039;caret&#039;, comp, options)
  var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug(&#039;caret&#039;, comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = &#039;&#039;
    } else if (isX(m)) {
      ret = &#039;&gt;=&#039; + M + &#039;.0.0 &lt;&#039; + (+M + 1) + &#039;.0.0&#039;
    } else if (isX(p)) {
      if (M === &#039;0&#039;) {
        ret = &#039;&gt;=&#039; + M + &#039;.&#039; + m + &#039;.0 &lt;&#039; + M + &#039;.&#039; + (+m + 1) + &#039;.0&#039;
      } else {
        ret = &#039;&gt;=&#039; + M + &#039;.&#039; + m + &#039;.0 &lt;&#039; + (+M + 1) + &#039;.0.0&#039;
      }
    } else if (pr) {
      debug(&#039;replaceCaret pr&#039;, pr)
      if (M === &#039;0&#039;) {
        if (m === &#039;0&#039;) {
          ret = &#039;&gt;=&#039; + M + &#039;.&#039; + m + &#039;.&#039; + p + &#039;-&#039; + pr +
                &#039; &lt;&#039; + M + &#039;.&#039; + m + &#039;.&#039; + (+p + 1)
        } else {
          ret = &#039;&gt;=&#039; + M + &#039;.&#039; + m + &#039;.&#039; + p + &#039;-&#039; + pr +
                &#039; &lt;&#039; + M + &#039;.&#039; + (+m + 1) + &#039;.0&#039;
        }
      } else {
        ret = &#039;&gt;=&#039; + M + &#039;.&#039; + m + &#039;.&#039; + p + &#039;-&#039; + pr +
              &#039; &lt;&#039; + (+M + 1) + &#039;.0.0&#039;
      }
    } else {
      debug(&#039;no pr&#039;)
      if (M === &#039;0&#039;) {
        if (m === &#039;0&#039;) {
          ret = &#039;&gt;=&#039; + M + &#039;.&#039; + m + &#039;.&#039; + p +
                &#039; &lt;&#039; + M + &#039;.&#039; + m + &#039;.&#039; + (+p + 1)
        } else {
          ret = &#039;&gt;=&#039; + M + &#039;.&#039; + m + &#039;.&#039; + p +
                &#039; &lt;&#039; + M + &#039;.&#039; + (+m + 1) + &#039;.0&#039;
        }
      } else {
        ret = &#039;&gt;=&#039; + M + &#039;.&#039; + m + &#039;.&#039; + p +
              &#039; &lt;&#039; + (+M + 1) + &#039;.0.0&#039;
      }
    }

    debug(&#039;caret return&#039;, ret)
    return ret
  })
}

function replaceXRanges (comp, options) {
  debug(&#039;replaceXRanges&#039;, comp, options)
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options)
  }).join(&#039; &#039;)
}

function replaceXRange (comp, options) {
  comp = comp.trim()
  var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug(&#039;xRange&#039;, comp, ret, gtlt, M, m, p, pr)
    var xM = isX(M)
    var xm = xM || isX(m)
    var xp = xm || isX(p)
    var anyX = xp

    if (gtlt === &#039;=&#039; &amp;&amp; anyX) {
      gtlt = &#039;&#039;
    }

    // if we&#039;re including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? &#039;-0&#039; : &#039;&#039;

    if (xM) {
      if (gtlt === &#039;&gt;&#039; || gtlt === &#039;&lt;&#039;) {
        // nothing is allowed
        ret = &#039;&lt;0.0.0-0&#039;
      } else {
        // nothing is forbidden
        ret = &#039;*&#039;
      }
    } else if (gtlt &amp;&amp; anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === &#039;&gt;&#039;) {
        // &gt;1 =&gt; &gt;=2.0.0
        // &gt;1.2 =&gt; &gt;=1.3.0
        // &gt;1.2.3 =&gt; &gt;= 1.2.4
        gtlt = &#039;&gt;=&#039;
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === &#039;&lt;=&#039;) {
        // &lt;=0.7.x is actually &lt;0.8.0, since any 0.7.x should
        // pass.  Similarly, &lt;=7.x is actually &lt;8.0.0, etc.
        gtlt = &#039;&lt;&#039;
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      ret = gtlt + M + &#039;.&#039; + m + &#039;.&#039; + p + pr
    } else if (xm) {
      ret = &#039;&gt;=&#039; + M + &#039;.0.0&#039; + pr + &#039; &lt;&#039; + (+M + 1) + &#039;.0.0&#039; + pr
    } else if (xp) {
      ret = &#039;&gt;=&#039; + M + &#039;.&#039; + m + &#039;.0&#039; + pr +
        &#039; &lt;&#039; + M + &#039;.&#039; + (+m + 1) + &#039;.0&#039; + pr
    }

    debug(&#039;xRange return&#039;, ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and &#039;&#039; means &quot;any version&quot;, just remove the *s entirely.
function replaceStars (comp, options) {
  debug(&#039;replaceStars&#039;, comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[t.STAR], &#039;&#039;)
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 =&gt; &gt;=1.2.0 &lt;=3.4.5
// 1.2.3 - 3.4 =&gt; &gt;=1.2.0 &lt;3.5.0 Any 3.4.x will do
// 1.2 - 3.4 =&gt; &gt;=1.2.0 &lt;3.5.0
function hyphenReplace ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = &#039;&#039;
  } else if (isX(fm)) {
    from = &#039;&gt;=&#039; + fM + &#039;.0.0&#039;
  } else if (isX(fp)) {
    from = &#039;&gt;=&#039; + fM + &#039;.&#039; + fm + &#039;.0&#039;
  } else {
    from = &#039;&gt;=&#039; + from
  }

  if (isX(tM)) {
    to = &#039;&#039;
  } else if (isX(tm)) {
    to = &#039;&lt;&#039; + (+tM + 1) + &#039;.0.0&#039;
  } else if (isX(tp)) {
    to = &#039;&lt;&#039; + tM + &#039;.&#039; + (+tm + 1) + &#039;.0&#039;
  } else if (tpr) {
    to = &#039;&lt;=&#039; + tM + &#039;.&#039; + tm + &#039;.&#039; + tp + &#039;-&#039; + tpr
  } else {
    to = &#039;&lt;=&#039; + to
  }

  return (from + &#039; &#039; + to).trim()
}

// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function (version) {
  if (!version) {
    return false
  }

  if (typeof version === &#039;string&#039;) {
    try {
      version = new SemVer(version, this.options)
    } catch (er) {
      return false
    }
  }

  for (var i = 0; i &lt; this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true
    }
  }
  return false
}

function testSet (set, version, options) {
  for (var i = 0; i &lt; set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length &amp;&amp; !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to &gt;=1.2.3-pr.1 &lt;2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it&#039;s within the range set by the comparators.
    for (i = 0; i &lt; set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === ANY) {
        continue
      }

      if (set[i].semver.prerelease.length &gt; 0) {
        var allowed = set[i].semver
        if (allowed.major === version.major &amp;&amp;
            allowed.minor === version.minor &amp;&amp;
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it&#039;s not one of the ones we like.
    return false
  }

  return true
}

exports.satisfies = satisfies
function satisfies (version, range, options) {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}

exports.maxSatisfying = maxSatisfying
function maxSatisfying (versions, range, options) {
  var max = null
  var maxSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}

exports.minSatisfying = minSatisfying
function minSatisfying (versions, range, options) {
  var min = null
  var minSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}

exports.minVersion = minVersion
function minVersion (range, loose) {
  range = new Range(range, loose)

  var minver = new SemVer(&#039;0.0.0&#039;)
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer(&#039;0.0.0-0&#039;)
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (var i = 0; i &lt; range.set.length; ++i) {
    var comparators = range.set[i]

    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator&#039;s semver object.
      var compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case &#039;&gt;&#039;:
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case &#039;&#039;:
        case &#039;&gt;=&#039;:
          if (!minver || gt(minver, compver)) {
            minver = compver
          }
          break
        case &#039;&lt;&#039;:
        case &#039;&lt;=&#039;:
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error(&#039;Unexpected operation: &#039; + comparator.operator)
      }
    })
  }

  if (minver &amp;&amp; range.test(minver)) {
    return minver
  }

  return null
}

exports.validRange = validRange
function validRange (range, options) {
  try {
    // Return &#039;*&#039; instead of &#039;&#039; so that truthiness works.
    // This will throw if it&#039;s invalid anyway
    return new Range(range, options).range || &#039;*&#039;
  } catch (er) {
    return null
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr
function ltr (version, range, options) {
  return outside(version, range, &#039;&lt;&#039;, options)
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr
function gtr (version, range, options) {
  return outside(version, range, &#039;&gt;&#039;, options)
}

exports.outside = outside
function outside (version, range, hilo, options) {
  version = new SemVer(version, options)
  range = new Range(range, options)

  var gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case &#039;&gt;&#039;:
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = &#039;&gt;&#039;
      ecomp = &#039;&gt;=&#039;
      break
    case &#039;&lt;&#039;:
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = &#039;&lt;&#039;
      ecomp = &#039;&lt;=&#039;
      break
    default:
      throw new TypeError(&#039;Must provide a hilo val of &quot;&lt;&quot; or &quot;&gt;&quot;&#039;)
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we&#039;re in &quot;gtr&quot; mode.
  // but note that everything is flipped for the &quot;ltr&quot; function.

  for (var i = 0; i &lt; range.set.length; ++i) {
    var comparators = range.set[i]

    var high = null
    var low = null

    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator(&#039;&gt;=0.0.0&#039;)
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn&#039;t outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn&#039;t higher than the range
    if ((!low.operator || low.operator === comp) &amp;&amp;
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp &amp;&amp; ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

exports.prerelease = prerelease
function prerelease (version, options) {
  var parsed = parse(version, options)
  return (parsed &amp;&amp; parsed.prerelease.length) ? parsed.prerelease : null
}

exports.intersects = intersects
function intersects (r1, r2, options) {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}

exports.coerce = coerce
function coerce (version, options) {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version === &#039;number&#039;) {
    version = String(version)
  }

  if (typeof version !== &#039;string&#039;) {
    return null
  }

  options = options || {}

  var match = null
  if (!options.rtl) {
    match = version.match(re[t.COERCE])
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, &#039;1.2.3.4&#039; wants to coerce &#039;2.3.4&#039;, not &#039;3.4&#039; or &#039;4&#039;
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    var next
    while ((next = re[t.COERCERTL].exec(version)) &amp;&amp;
      (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
          next.index + next[0].length !== match.index + match[0].length) {
        match = next
      }
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length
    }
    // leave it in a clean state
    re[t.COERCERTL].lastIndex = -1
  }

  if (match === null) {
    return null
  }

  return parse(match[2] +
    &#039;.&#039; + (match[3] || &#039;0&#039;) +
    &#039;.&#039; + (match[4] || &#039;0&#039;), options)
}</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
