<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/ace-builds/src/mode-ejs.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/ace-builds/src/mode-ejs.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">54.43</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">3132</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">101.35</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">51.35</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">define(&quot;ace/mode/css_highlight_rules&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/lang&quot;,&quot;ace/mode/text_highlight_rules&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;../lib/oop&quot;);
var lang = require(&quot;../lib/lang&quot;);
var TextHighlightRules = require(&quot;./text_highlight_rules&quot;).TextHighlightRules;
var supportType = exports.supportType = &quot;align-content|align-items|align-self|all|animation|animation-delay|animation-direction|animation-duration|animation-fill-mode|animation-iteration-count|animation-name|animation-play-state|animation-timing-function|backface-visibility|background|background-attachment|background-blend-mode|background-clip|background-color|background-image|background-origin|background-position|background-repeat|background-size|border|border-bottom|border-bottom-color|border-bottom-left-radius|border-bottom-right-radius|border-bottom-style|border-bottom-width|border-collapse|border-color|border-image|border-image-outset|border-image-repeat|border-image-slice|border-image-source|border-image-width|border-left|border-left-color|border-left-style|border-left-width|border-radius|border-right|border-right-color|border-right-style|border-right-width|border-spacing|border-style|border-top|border-top-color|border-top-left-radius|border-top-right-radius|border-top-style|border-top-width|border-width|bottom|box-shadow|box-sizing|caption-side|clear|clip|color|column-count|column-fill|column-gap|column-rule|column-rule-color|column-rule-style|column-rule-width|column-span|column-width|columns|content|counter-increment|counter-reset|cursor|direction|display|empty-cells|filter|flex|flex-basis|flex-direction|flex-flow|flex-grow|flex-shrink|flex-wrap|float|font|font-family|font-size|font-size-adjust|font-stretch|font-style|font-variant|font-weight|hanging-punctuation|height|justify-content|left|letter-spacing|line-height|list-style|list-style-image|list-style-position|list-style-type|margin|margin-bottom|margin-left|margin-right|margin-top|max-height|max-width|max-zoom|min-height|min-width|min-zoom|nav-down|nav-index|nav-left|nav-right|nav-up|opacity|order|outline|outline-color|outline-offset|outline-style|outline-width|overflow|overflow-x|overflow-y|padding|padding-bottom|padding-left|padding-right|padding-top|page-break-after|page-break-before|page-break-inside|perspective|perspective-origin|position|quotes|resize|right|tab-size|table-layout|text-align|text-align-last|text-decoration|text-decoration-color|text-decoration-line|text-decoration-style|text-indent|text-justify|text-overflow|text-shadow|text-transform|top|transform|transform-origin|transform-style|transition|transition-delay|transition-duration|transition-property|transition-timing-function|unicode-bidi|user-select|user-zoom|vertical-align|visibility|white-space|width|word-break|word-spacing|word-wrap|z-index&quot;;
var supportFunction = exports.supportFunction = &quot;rgb|rgba|url|attr|counter|counters&quot;;
var supportConstant = exports.supportConstant = &quot;absolute|after-edge|after|all-scroll|all|alphabetic|always|antialiased|armenian|auto|avoid-column|avoid-page|avoid|balance|baseline|before-edge|before|below|bidi-override|block-line-height|block|bold|bolder|border-box|both|bottom|box|break-all|break-word|capitalize|caps-height|caption|center|central|char|circle|cjk-ideographic|clone|close-quote|col-resize|collapse|column|consider-shifts|contain|content-box|cover|crosshair|cubic-bezier|dashed|decimal-leading-zero|decimal|default|disabled|disc|disregard-shifts|distribute-all-lines|distribute-letter|distribute-space|distribute|dotted|double|e-resize|ease-in|ease-in-out|ease-out|ease|ellipsis|end|exclude-ruby|flex-end|flex-start|fill|fixed|georgian|glyphs|grid-height|groove|hand|hanging|hebrew|help|hidden|hiragana-iroha|hiragana|horizontal|icon|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space|ideographic|inactive|include-ruby|inherit|initial|inline-block|inline-box|inline-line-height|inline-table|inline|inset|inside|inter-ideograph|inter-word|invert|italic|justify|katakana-iroha|katakana|keep-all|last|left|lighter|line-edge|line-through|line|linear|list-item|local|loose|lower-alpha|lower-greek|lower-latin|lower-roman|lowercase|lr-tb|ltr|mathematical|max-height|max-size|medium|menu|message-box|middle|move|n-resize|ne-resize|newspaper|no-change|no-close-quote|no-drop|no-open-quote|no-repeat|none|normal|not-allowed|nowrap|nw-resize|oblique|open-quote|outset|outside|overline|padding-box|page|pointer|pre-line|pre-wrap|pre|preserve-3d|progress|relative|repeat-x|repeat-y|repeat|replaced|reset-size|ridge|right|round|row-resize|rtl|s-resize|scroll|se-resize|separate|slice|small-caps|small-caption|solid|space|square|start|static|status-bar|step-end|step-start|steps|stretch|strict|sub|super|sw-resize|table-caption|table-cell|table-column-group|table-column|table-footer-group|table-header-group|table-row-group|table-row|table|tb-rl|text-after-edge|text-before-edge|text-bottom|text-size|text-top|text|thick|thin|transparent|underline|upper-alpha|upper-latin|upper-roman|uppercase|use-script|vertical-ideographic|vertical-text|visible|w-resize|wait|whitespace|z-index|zero|zoom&quot;;
var supportConstantColor = exports.supportConstantColor = &quot;aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|green|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|rebeccapurple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silver|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|violet|wheat|white|whitesmoke|yellow|yellowgreen&quot;;
var supportConstantFonts = exports.supportConstantFonts = &quot;arial|century|comic|courier|cursive|fantasy|garamond|georgia|helvetica|impact|lucida|symbol|system|tahoma|times|trebuchet|utopia|verdana|webdings|sans-serif|serif|monospace&quot;;
var numRe = exports.numRe = &quot;\\-?(?:(?:[0-9]+(?:\\.[0-9]+)?)|(?:\\.[0-9]+))&quot;;
var pseudoElements = exports.pseudoElements = &quot;(\\:+)\\b(after|before|first-letter|first-line|moz-selection|selection)\\b&quot;;
var pseudoClasses = exports.pseudoClasses = &quot;(:)\\b(active|checked|disabled|empty|enabled|first-child|first-of-type|focus|hover|indeterminate|invalid|last-child|last-of-type|link|not|nth-child|nth-last-child|nth-last-of-type|nth-of-type|only-child|only-of-type|required|root|target|valid|visited)\\b&quot;;
var CssHighlightRules = function () {
    var keywordMapper = this.createKeywordMapper({
        &quot;support.function&quot;: supportFunction,
        &quot;support.constant&quot;: supportConstant,
        &quot;support.type&quot;: supportType,
        &quot;support.constant.color&quot;: supportConstantColor,
        &quot;support.constant.fonts&quot;: supportConstantFonts
    }, &quot;text&quot;, true);
    this.$rules = {
        &quot;start&quot;: [{
                include: [&quot;strings&quot;, &quot;url&quot;, &quot;comments&quot;]
            }, {
                token: &quot;paren.lparen&quot;,
                regex: &quot;\\{&quot;,
                next: &quot;ruleset&quot;
            }, {
                token: &quot;paren.rparen&quot;,
                regex: &quot;\\}&quot;
            }, {
                token: &quot;string&quot;,
                regex: &quot;@(?!viewport)&quot;,
                next: &quot;media&quot;
            }, {
                token: &quot;keyword&quot;,
                regex: &quot;#[a-z0-9-_]+&quot;
            }, {
                token: &quot;keyword&quot;,
                regex: &quot;%&quot;
            }, {
                token: &quot;variable&quot;,
                regex: &quot;\\.[a-z0-9-_]+&quot;
            }, {
                token: &quot;string&quot;,
                regex: &quot;:[a-z0-9-_]+&quot;
            }, {
                token: &quot;constant.numeric&quot;,
                regex: numRe
            }, {
                token: &quot;constant&quot;,
                regex: &quot;[a-z0-9-_]+&quot;
            }, {
                caseInsensitive: true
            }],
        &quot;media&quot;: [{
                include: [&quot;strings&quot;, &quot;url&quot;, &quot;comments&quot;]
            }, {
                token: &quot;paren.lparen&quot;,
                regex: &quot;\\{&quot;,
                next: &quot;start&quot;
            }, {
                token: &quot;paren.rparen&quot;,
                regex: &quot;\\}&quot;,
                next: &quot;start&quot;
            }, {
                token: &quot;string&quot;,
                regex: &quot;;&quot;,
                next: &quot;start&quot;
            }, {
                token: &quot;keyword&quot;,
                regex: &quot;(?:media|supports|document|charset|import|namespace|media|supports|document&quot;
                    + &quot;|page|font|keyframes|viewport|counter-style|font-feature-values&quot;
                    + &quot;|swash|ornaments|annotation|stylistic|styleset|character-variant)&quot;
            }],
        &quot;comments&quot;: [{
                token: &quot;comment&quot;,
                regex: &quot;\\/\\*&quot;,
                push: [{
                        token: &quot;comment&quot;,
                        regex: &quot;\\*\\/&quot;,
                        next: &quot;pop&quot;
                    }, {
                        defaultToken: &quot;comment&quot;
                    }]
            }],
        &quot;ruleset&quot;: [{
                regex: &quot;-(webkit|ms|moz|o)-&quot;,
                token: &quot;text&quot;
            }, {
                token: &quot;punctuation.operator&quot;,
                regex: &quot;[:;]&quot;
            }, {
                token: &quot;paren.rparen&quot;,
                regex: &quot;\\}&quot;,
                next: &quot;start&quot;
            }, {
                include: [&quot;strings&quot;, &quot;url&quot;, &quot;comments&quot;]
            }, {
                token: [&quot;constant.numeric&quot;, &quot;keyword&quot;],
                regex: &quot;(&quot; + numRe + &quot;)(ch|cm|deg|em|ex|fr|gd|grad|Hz|in|kHz|mm|ms|pc|pt|px|rad|rem|s|turn|vh|vmax|vmin|vm|vw|%)&quot;
            }, {
                token: &quot;constant.numeric&quot;,
                regex: numRe
            }, {
                token: &quot;constant.numeric&quot;,
                regex: &quot;#[a-f0-9]{6}&quot;
            }, {
                token: &quot;constant.numeric&quot;,
                regex: &quot;#[a-f0-9]{3}&quot;
            }, {
                token: [&quot;punctuation&quot;, &quot;entity.other.attribute-name.pseudo-element.css&quot;],
                regex: pseudoElements
            }, {
                token: [&quot;punctuation&quot;, &quot;entity.other.attribute-name.pseudo-class.css&quot;],
                regex: pseudoClasses
            }, {
                include: &quot;url&quot;
            }, {
                token: keywordMapper,
                regex: &quot;\\-?[a-zA-Z_][a-zA-Z0-9_\\-]*&quot;
            }, {
                caseInsensitive: true
            }],
        url: [{
                token: &quot;support.function&quot;,
                regex: &quot;(?:url(:?-prefix)?|domain|regexp)\\(&quot;,
                push: [{
                        token: &quot;support.function&quot;,
                        regex: &quot;\\)&quot;,
                        next: &quot;pop&quot;
                    }, {
                        defaultToken: &quot;string&quot;
                    }]
            }],
        strings: [{
                token: &quot;string.start&quot;,
                regex: &quot;&#039;&quot;,
                push: [{
                        token: &quot;string.end&quot;,
                        regex: &quot;&#039;|$&quot;,
                        next: &quot;pop&quot;
                    }, {
                        include: &quot;escapes&quot;
                    }, {
                        token: &quot;constant.language.escape&quot;,
                        regex: /\\$/,
                        consumeLineEnd: true
                    }, {
                        defaultToken: &quot;string&quot;
                    }]
            }, {
                token: &quot;string.start&quot;,
                regex: &#039;&quot;&#039;,
                push: [{
                        token: &quot;string.end&quot;,
                        regex: &#039;&quot;|$&#039;,
                        next: &quot;pop&quot;
                    }, {
                        include: &quot;escapes&quot;
                    }, {
                        token: &quot;constant.language.escape&quot;,
                        regex: /\\$/,
                        consumeLineEnd: true
                    }, {
                        defaultToken: &quot;string&quot;
                    }]
            }],
        escapes: [{
                token: &quot;constant.language.escape&quot;,
                regex: /\\([a-fA-F\d]{1,6}|[^a-fA-F\d])/
            }]
    };
    this.normalizeRules();
};
oop.inherits(CssHighlightRules, TextHighlightRules);
exports.CssHighlightRules = CssHighlightRules;

});

define(&quot;ace/mode/doc_comment_highlight_rules&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/mode/text_highlight_rules&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;../lib/oop&quot;);
var TextHighlightRules = require(&quot;./text_highlight_rules&quot;).TextHighlightRules;
var DocCommentHighlightRules = function () {
    this.$rules = {
        &quot;start&quot;: [{
                token: &quot;comment.doc.tag&quot;,
                regex: &quot;@[\\w\\d_]+&quot; // TODO: fix email addresses
            },
            DocCommentHighlightRules.getTagRule(),
            {
                defaultToken: &quot;comment.doc&quot;,
                caseInsensitive: true
            }]
    };
};
oop.inherits(DocCommentHighlightRules, TextHighlightRules);
DocCommentHighlightRules.getTagRule = function (start) {
    return {
        token: &quot;comment.doc.tag.storage.type&quot;,
        regex: &quot;\\b(?:TODO|FIXME|XXX|HACK)\\b&quot;
    };
};
DocCommentHighlightRules.getStartRule = function (start) {
    return {
        token: &quot;comment.doc&quot;,
        regex: &quot;\\/\\*(?=\\*)&quot;,
        next: start
    };
};
DocCommentHighlightRules.getEndRule = function (start) {
    return {
        token: &quot;comment.doc&quot;,
        regex: &quot;\\*\\/&quot;,
        next: start
    };
};
exports.DocCommentHighlightRules = DocCommentHighlightRules;

});

define(&quot;ace/mode/javascript_highlight_rules&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/mode/doc_comment_highlight_rules&quot;,&quot;ace/mode/text_highlight_rules&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;../lib/oop&quot;);
var DocCommentHighlightRules = require(&quot;./doc_comment_highlight_rules&quot;).DocCommentHighlightRules;
var TextHighlightRules = require(&quot;./text_highlight_rules&quot;).TextHighlightRules;
var identifierRe = &quot;[a-zA-Z\\$_\u00a1-\uffff][a-zA-Z\\d\\$_\u00a1-\uffff]*&quot;;
var JavaScriptHighlightRules = function (options) {
    var keywordMapper = this.createKeywordMapper({
        &quot;variable.language&quot;: &quot;Array|Boolean|Date|Function|Iterator|Number|Object|RegExp|String|Proxy|Symbol|&quot; + // Constructors
            &quot;Namespace|QName|XML|XMLList|&quot; + // E4X
            &quot;ArrayBuffer|Float32Array|Float64Array|Int16Array|Int32Array|Int8Array|&quot; +
            &quot;Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|&quot; +
            &quot;Error|EvalError|InternalError|RangeError|ReferenceError|StopIteration|&quot; + // Errors
            &quot;SyntaxError|TypeError|URIError|&quot; +
            &quot;decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|eval|isFinite|&quot; + // Non-constructor functions
            &quot;isNaN|parseFloat|parseInt|&quot; +
            &quot;JSON|Math|&quot; + // Other
            &quot;this|arguments|prototype|window|document&quot;,
        &quot;keyword&quot;: &quot;const|yield|import|get|set|async|await|&quot; +
            &quot;break|case|catch|continue|default|delete|do|else|finally|for|function|&quot; +
            &quot;if|in|of|instanceof|new|return|switch|throw|try|typeof|let|var|while|with|debugger|&quot; +
            &quot;__parent__|__count__|escape|unescape|with|__proto__|&quot; +
            &quot;class|enum|extends|super|export|implements|private|public|interface|package|protected|static|constructor&quot;,
        &quot;storage.type&quot;: &quot;const|let|var|function&quot;,
        &quot;constant.language&quot;: &quot;null|Infinity|NaN|undefined&quot;,
        &quot;support.function&quot;: &quot;alert&quot;,
        &quot;constant.language.boolean&quot;: &quot;true|false&quot;
    }, &quot;identifier&quot;);
    var kwBeforeRe = &quot;case|do|else|finally|in|instanceof|return|throw|try|typeof|yield|void&quot;;
    var escapedRe = &quot;\\\\(?:x[0-9a-fA-F]{2}|&quot; + // hex
        &quot;u[0-9a-fA-F]{4}|&quot; + // unicode
        &quot;u{[0-9a-fA-F]{1,6}}|&quot; + // es6 unicode
        &quot;[0-2][0-7]{0,2}|&quot; + // oct
        &quot;3[0-7][0-7]?|&quot; + // oct
        &quot;[4-7][0-7]?|&quot; + //oct
        &quot;.)&quot;;
    this.$rules = {
        &quot;no_regex&quot;: [
            DocCommentHighlightRules.getStartRule(&quot;doc-start&quot;),
            comments(&quot;no_regex&quot;),
            {
                token: &quot;string&quot;,
                regex: &quot;&#039;(?=.)&quot;,
                next: &quot;qstring&quot;
            }, {
                token: &quot;string&quot;,
                regex: &#039;&quot;(?=.)&#039;,
                next: &quot;qqstring&quot;
            }, {
                token: &quot;constant.numeric&quot;,
                regex: /0(?:[xX][0-9a-fA-F]+|[oO][0-7]+|[bB][01]+)\b/
            }, {
                token: &quot;constant.numeric&quot;,
                regex: /(?:\d\d*(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+\b)?/
            }, {
                token: [
                    &quot;storage.type&quot;, &quot;punctuation.operator&quot;, &quot;support.function&quot;,
                    &quot;punctuation.operator&quot;, &quot;entity.name.function&quot;, &quot;text&quot;, &quot;keyword.operator&quot;
                ],
                regex: &quot;(&quot; + identifierRe + &quot;)(\\.)(prototype)(\\.)(&quot; + identifierRe + &quot;)(\\s*)(=)&quot;,
                next: &quot;function_arguments&quot;
            }, {
                token: [
                    &quot;storage.type&quot;, &quot;punctuation.operator&quot;, &quot;entity.name.function&quot;, &quot;text&quot;,
                    &quot;keyword.operator&quot;, &quot;text&quot;, &quot;storage.type&quot;, &quot;text&quot;, &quot;paren.lparen&quot;
                ],
                regex: &quot;(&quot; + identifierRe + &quot;)(\\.)(&quot; + identifierRe + &quot;)(\\s*)(=)(\\s*)(function\\*?)(\\s*)(\\()&quot;,
                next: &quot;function_arguments&quot;
            }, {
                token: [
                    &quot;entity.name.function&quot;, &quot;text&quot;, &quot;keyword.operator&quot;, &quot;text&quot;, &quot;storage.type&quot;,
                    &quot;text&quot;, &quot;paren.lparen&quot;
                ],
                regex: &quot;(&quot; + identifierRe + &quot;)(\\s*)(=)(\\s*)(function\\*?)(\\s*)(\\()&quot;,
                next: &quot;function_arguments&quot;
            }, {
                token: [
                    &quot;storage.type&quot;, &quot;punctuation.operator&quot;, &quot;entity.name.function&quot;, &quot;text&quot;,
                    &quot;keyword.operator&quot;, &quot;text&quot;,
                    &quot;storage.type&quot;, &quot;text&quot;, &quot;entity.name.function&quot;, &quot;text&quot;, &quot;paren.lparen&quot;
                ],
                regex: &quot;(&quot; + identifierRe + &quot;)(\\.)(&quot; + identifierRe + &quot;)(\\s*)(=)(\\s*)(function\\*?)(\\s+)(\\w+)(\\s*)(\\()&quot;,
                next: &quot;function_arguments&quot;
            }, {
                token: [
                    &quot;storage.type&quot;, &quot;text&quot;, &quot;entity.name.function&quot;, &quot;text&quot;, &quot;paren.lparen&quot;
                ],
                regex: &quot;(function\\*?)(\\s+)(&quot; + identifierRe + &quot;)(\\s*)(\\()&quot;,
                next: &quot;function_arguments&quot;
            }, {
                token: [
                    &quot;entity.name.function&quot;, &quot;text&quot;, &quot;punctuation.operator&quot;,
                    &quot;text&quot;, &quot;storage.type&quot;, &quot;text&quot;, &quot;paren.lparen&quot;
                ],
                regex: &quot;(&quot; + identifierRe + &quot;)(\\s*)(:)(\\s*)(function\\*?)(\\s*)(\\()&quot;,
                next: &quot;function_arguments&quot;
            }, {
                token: [
                    &quot;text&quot;, &quot;text&quot;, &quot;storage.type&quot;, &quot;text&quot;, &quot;paren.lparen&quot;
                ],
                regex: &quot;(:)(\\s*)(function\\*?)(\\s*)(\\()&quot;,
                next: &quot;function_arguments&quot;
            }, {
                token: &quot;keyword&quot;,
                regex: &quot;from(?=\\s*(&#039;|\&quot;))&quot;
            }, {
                token: &quot;keyword&quot;,
                regex: &quot;(?:&quot; + kwBeforeRe + &quot;)\\b&quot;,
                next: &quot;start&quot;
            }, {
                token: &quot;support.constant&quot;,
                regex: /that\b/
            }, {
                token: [&quot;storage.type&quot;, &quot;punctuation.operator&quot;, &quot;support.function.firebug&quot;],
                regex: /(console)(\.)(warn|info|log|error|time|trace|timeEnd|assert)\b/
            }, {
                token: keywordMapper,
                regex: identifierRe
            }, {
                token: &quot;punctuation.operator&quot;,
                regex: /[.](?![.])/,
                next: &quot;property&quot;
            }, {
                token: &quot;storage.type&quot;,
                regex: /=&gt;/,
                next: &quot;start&quot;
            }, {
                token: &quot;keyword.operator&quot;,
                regex: /--|\+\+|\.{3}|===|==|=|!=|!==|&lt;+=?|&gt;+=?|!|&amp;&amp;|\|\||\?:|[!$%&amp;*+\-~\/^]=?/,
                next: &quot;start&quot;
            }, {
                token: &quot;punctuation.operator&quot;,
                regex: /[?:,;.]/,
                next: &quot;start&quot;
            }, {
                token: &quot;paren.lparen&quot;,
                regex: /[\[({]/,
                next: &quot;start&quot;
            }, {
                token: &quot;paren.rparen&quot;,
                regex: /[\])}]/
            }, {
                token: &quot;comment&quot;,
                regex: /^#!.*$/
            }
        ],
        property: [{
                token: &quot;text&quot;,
                regex: &quot;\\s+&quot;
            }, {
                token: [
                    &quot;storage.type&quot;, &quot;punctuation.operator&quot;, &quot;entity.name.function&quot;, &quot;text&quot;,
                    &quot;keyword.operator&quot;, &quot;text&quot;,
                    &quot;storage.type&quot;, &quot;text&quot;, &quot;entity.name.function&quot;, &quot;text&quot;, &quot;paren.lparen&quot;
                ],
                regex: &quot;(&quot; + identifierRe + &quot;)(\\.)(&quot; + identifierRe + &quot;)(\\s*)(=)(\\s*)(function\\*?)(?:(\\s+)(\\w+))?(\\s*)(\\()&quot;,
                next: &quot;function_arguments&quot;
            }, {
                token: &quot;punctuation.operator&quot;,
                regex: /[.](?![.])/
            }, {
                token: &quot;support.function&quot;,
                regex: /(s(?:h(?:ift|ow(?:Mod(?:elessDialog|alDialog)|Help))|croll(?:X|By(?:Pages|Lines)?|Y|To)?|t(?:op|rike)|i(?:n|zeToContent|debar|gnText)|ort|u(?:p|b(?:str(?:ing)?)?)|pli(?:ce|t)|e(?:nd|t(?:Re(?:sizable|questHeader)|M(?:i(?:nutes|lliseconds)|onth)|Seconds|Ho(?:tKeys|urs)|Year|Cursor|Time(?:out)?|Interval|ZOptions|Date|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Date|FullYear)|FullYear|Active)|arch)|qrt|lice|avePreferences|mall)|h(?:ome|andleEvent)|navigate|c(?:har(?:CodeAt|At)|o(?:s|n(?:cat|textual|firm)|mpile)|eil|lear(?:Timeout|Interval)?|a(?:ptureEvents|ll)|reate(?:StyleSheet|Popup|EventObject))|t(?:o(?:GMTString|S(?:tring|ource)|U(?:TCString|pperCase)|Lo(?:caleString|werCase))|est|a(?:n|int(?:Enabled)?))|i(?:s(?:NaN|Finite)|ndexOf|talics)|d(?:isableExternalCapture|ump|etachEvent)|u(?:n(?:shift|taint|escape|watch)|pdateCommands)|j(?:oin|avaEnabled)|p(?:o(?:p|w)|ush|lugins.refresh|a(?:ddings|rse(?:Int|Float)?)|r(?:int|ompt|eference))|e(?:scape|nableExternalCapture|val|lementFromPoint|x(?:p|ec(?:Script|Command)?))|valueOf|UTC|queryCommand(?:State|Indeterm|Enabled|Value)|f(?:i(?:nd|lter|le(?:ModifiedDate|Size|CreatedDate|UpdatedDate)|xed)|o(?:nt(?:size|color)|rward|rEach)|loor|romCharCode)|watch|l(?:ink|o(?:ad|g)|astIndexOf)|a(?:sin|nchor|cos|t(?:tachEvent|ob|an(?:2)?)|pply|lert|b(?:s|ort))|r(?:ou(?:nd|teEvents)|e(?:size(?:By|To)|calc|turnValue|place|verse|l(?:oad|ease(?:Capture|Events)))|andom)|g(?:o|et(?:ResponseHeader|M(?:i(?:nutes|lliseconds)|onth)|Se(?:conds|lection)|Hours|Year|Time(?:zoneOffset)?|Da(?:y|te)|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Da(?:y|te)|FullYear)|FullYear|A(?:ttention|llResponseHeaders)))|m(?:in|ove(?:B(?:y|elow)|To(?:Absolute)?|Above)|ergeAttributes|a(?:tch|rgins|x))|b(?:toa|ig|o(?:ld|rderWidths)|link|ack))\b(?=\()/
            }, {
                token: &quot;support.function.dom&quot;,
                regex: /(s(?:ub(?:stringData|mit)|plitText|e(?:t(?:NamedItem|Attribute(?:Node)?)|lect))|has(?:ChildNodes|Feature)|namedItem|c(?:l(?:ick|o(?:se|neNode))|reate(?:C(?:omment|DATASection|aption)|T(?:Head|extNode|Foot)|DocumentFragment|ProcessingInstruction|E(?:ntityReference|lement)|Attribute))|tabIndex|i(?:nsert(?:Row|Before|Cell|Data)|tem)|open|delete(?:Row|C(?:ell|aption)|T(?:Head|Foot)|Data)|focus|write(?:ln)?|a(?:dd|ppend(?:Child|Data))|re(?:set|place(?:Child|Data)|move(?:NamedItem|Child|Attribute(?:Node)?)?)|get(?:NamedItem|Element(?:sBy(?:Name|TagName|ClassName)|ById)|Attribute(?:Node)?)|blur)\b(?=\()/
            }, {
                token: &quot;support.constant&quot;,
                regex: /(s(?:ystemLanguage|cr(?:ipts|ollbars|een(?:X|Y|Top|Left))|t(?:yle(?:Sheets)?|atus(?:Text|bar)?)|ibling(?:Below|Above)|ource|uffixes|e(?:curity(?:Policy)?|l(?:ection|f)))|h(?:istory|ost(?:name)?|as(?:h|Focus))|y|X(?:MLDocument|SLDocument)|n(?:ext|ame(?:space(?:s|URI)|Prop))|M(?:IN_VALUE|AX_VALUE)|c(?:haracterSet|o(?:n(?:structor|trollers)|okieEnabled|lorDepth|mp(?:onents|lete))|urrent|puClass|l(?:i(?:p(?:boardData)?|entInformation)|osed|asses)|alle(?:e|r)|rypto)|t(?:o(?:olbar|p)|ext(?:Transform|Indent|Decoration|Align)|ags)|SQRT(?:1_2|2)|i(?:n(?:ner(?:Height|Width)|put)|ds|gnoreCase)|zIndex|o(?:scpu|n(?:readystatechange|Line)|uter(?:Height|Width)|p(?:sProfile|ener)|ffscreenBuffering)|NEGATIVE_INFINITY|d(?:i(?:splay|alog(?:Height|Top|Width|Left|Arguments)|rectories)|e(?:scription|fault(?:Status|Ch(?:ecked|arset)|View)))|u(?:ser(?:Profile|Language|Agent)|n(?:iqueID|defined)|pdateInterval)|_content|p(?:ixelDepth|ort|ersonalbar|kcs11|l(?:ugins|atform)|a(?:thname|dding(?:Right|Bottom|Top|Left)|rent(?:Window|Layer)?|ge(?:X(?:Offset)?|Y(?:Offset)?))|r(?:o(?:to(?:col|type)|duct(?:Sub)?|mpter)|e(?:vious|fix)))|e(?:n(?:coding|abledPlugin)|x(?:ternal|pando)|mbeds)|v(?:isibility|endor(?:Sub)?|Linkcolor)|URLUnencoded|P(?:I|OSITIVE_INFINITY)|f(?:ilename|o(?:nt(?:Size|Family|Weight)|rmName)|rame(?:s|Element)|gColor)|E|whiteSpace|l(?:i(?:stStyleType|n(?:eHeight|kColor))|o(?:ca(?:tion(?:bar)?|lName)|wsrc)|e(?:ngth|ft(?:Context)?)|a(?:st(?:M(?:odified|atch)|Index|Paren)|yer(?:s|X)|nguage))|a(?:pp(?:MinorVersion|Name|Co(?:deName|re)|Version)|vail(?:Height|Top|Width|Left)|ll|r(?:ity|guments)|Linkcolor|bove)|r(?:ight(?:Context)?|e(?:sponse(?:XML|Text)|adyState))|global|x|m(?:imeTypes|ultiline|enubar|argin(?:Right|Bottom|Top|Left))|L(?:N(?:10|2)|OG(?:10E|2E))|b(?:o(?:ttom|rder(?:Width|RightWidth|BottomWidth|Style|Color|TopWidth|LeftWidth))|ufferDepth|elow|ackground(?:Color|Image)))\b/
            }, {
                token: &quot;identifier&quot;,
                regex: identifierRe
            }, {
                regex: &quot;&quot;,
                token: &quot;empty&quot;,
                next: &quot;no_regex&quot;
            }
        ],
        &quot;start&quot;: [
            DocCommentHighlightRules.getStartRule(&quot;doc-start&quot;),
            comments(&quot;start&quot;),
            {
                token: &quot;string.regexp&quot;,
                regex: &quot;\\/&quot;,
                next: &quot;regex&quot;
            }, {
                token: &quot;text&quot;,
                regex: &quot;\\s+|^$&quot;,
                next: &quot;start&quot;
            }, {
                token: &quot;empty&quot;,
                regex: &quot;&quot;,
                next: &quot;no_regex&quot;
            }
        ],
        &quot;regex&quot;: [
            {
                token: &quot;regexp.keyword.operator&quot;,
                regex: &quot;\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)&quot;
            }, {
                token: &quot;string.regexp&quot;,
                regex: &quot;/[sxngimy]*&quot;,
                next: &quot;no_regex&quot;
            }, {
                token: &quot;invalid&quot;,
                regex: /\{\d+\b,?\d*\}[+*]|[+*$^?][+*]|[$^][?]|\?{3,}/
            }, {
                token: &quot;constant.language.escape&quot;,
                regex: /\(\?[:=!]|\)|\{\d+\b,?\d*\}|[+*]\?|[()$^+*?.]/
            }, {
                token: &quot;constant.language.delimiter&quot;,
                regex: /\|/
            }, {
                token: &quot;constant.language.escape&quot;,
                regex: /\[\^?/,
                next: &quot;regex_character_class&quot;
            }, {
                token: &quot;empty&quot;,
                regex: &quot;$&quot;,
                next: &quot;no_regex&quot;
            }, {
                defaultToken: &quot;string.regexp&quot;
            }
        ],
        &quot;regex_character_class&quot;: [
            {
                token: &quot;regexp.charclass.keyword.operator&quot;,
                regex: &quot;\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)&quot;
            }, {
                token: &quot;constant.language.escape&quot;,
                regex: &quot;]&quot;,
                next: &quot;regex&quot;
            }, {
                token: &quot;constant.language.escape&quot;,
                regex: &quot;-&quot;
            }, {
                token: &quot;empty&quot;,
                regex: &quot;$&quot;,
                next: &quot;no_regex&quot;
            }, {
                defaultToken: &quot;string.regexp.charachterclass&quot;
            }
        ],
        &quot;default_parameter&quot;: [
            {
                token: &quot;string&quot;,
                regex: &quot;&#039;(?=.)&quot;,
                push: [
                    {
                        token: &quot;string&quot;,
                        regex: &quot;&#039;|$&quot;,
                        next: &quot;pop&quot;
                    }, {
                        include: &quot;qstring&quot;
                    }
                ]
            }, {
                token: &quot;string&quot;,
                regex: &#039;&quot;(?=.)&#039;,
                push: [
                    {
                        token: &quot;string&quot;,
                        regex: &#039;&quot;|$&#039;,
                        next: &quot;pop&quot;
                    }, {
                        include: &quot;qqstring&quot;
                    }
                ]
            }, {
                token: &quot;constant.language&quot;,
                regex: &quot;null|Infinity|NaN|undefined&quot;
            }, {
                token: &quot;constant.numeric&quot;,
                regex: /0(?:[xX][0-9a-fA-F]+|[oO][0-7]+|[bB][01]+)\b/
            }, {
                token: &quot;constant.numeric&quot;,
                regex: /(?:\d\d*(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+\b)?/
            }, {
                token: &quot;punctuation.operator&quot;,
                regex: &quot;,&quot;,
                next: &quot;function_arguments&quot;
            }, {
                token: &quot;text&quot;,
                regex: &quot;\\s+&quot;
            }, {
                token: &quot;punctuation.operator&quot;,
                regex: &quot;$&quot;
            }, {
                token: &quot;empty&quot;,
                regex: &quot;&quot;,
                next: &quot;no_regex&quot;
            }
        ],
        &quot;function_arguments&quot;: [
            comments(&quot;function_arguments&quot;),
            {
                token: &quot;variable.parameter&quot;,
                regex: identifierRe
            }, {
                token: &quot;punctuation.operator&quot;,
                regex: &quot;,&quot;
            }, {
                token: &quot;text&quot;,
                regex: &quot;\\s+&quot;
            }, {
                token: &quot;punctuation.operator&quot;,
                regex: &quot;$&quot;
            }, {
                token: &quot;empty&quot;,
                regex: &quot;&quot;,
                next: &quot;no_regex&quot;
            }
        ],
        &quot;qqstring&quot;: [
            {
                token: &quot;constant.language.escape&quot;,
                regex: escapedRe
            }, {
                token: &quot;string&quot;,
                regex: &quot;\\\\$&quot;,
                consumeLineEnd: true
            }, {
                token: &quot;string&quot;,
                regex: &#039;&quot;|$&#039;,
                next: &quot;no_regex&quot;
            }, {
                defaultToken: &quot;string&quot;
            }
        ],
        &quot;qstring&quot;: [
            {
                token: &quot;constant.language.escape&quot;,
                regex: escapedRe
            }, {
                token: &quot;string&quot;,
                regex: &quot;\\\\$&quot;,
                consumeLineEnd: true
            }, {
                token: &quot;string&quot;,
                regex: &quot;&#039;|$&quot;,
                next: &quot;no_regex&quot;
            }, {
                defaultToken: &quot;string&quot;
            }
        ]
    };
    if (!options || !options.noES6) {
        this.$rules.no_regex.unshift({
            regex: &quot;[{}]&quot;, onMatch: function (val, state, stack) {
                this.next = val == &quot;{&quot; ? this.nextState : &quot;&quot;;
                if (val == &quot;{&quot; &amp;&amp; stack.length) {
                    stack.unshift(&quot;start&quot;, state);
                }
                else if (val == &quot;}&quot; &amp;&amp; stack.length) {
                    stack.shift();
                    this.next = stack.shift();
                    if (this.next.indexOf(&quot;string&quot;) != -1 || this.next.indexOf(&quot;jsx&quot;) != -1)
                        return &quot;paren.quasi.end&quot;;
                }
                return val == &quot;{&quot; ? &quot;paren.lparen&quot; : &quot;paren.rparen&quot;;
            },
            nextState: &quot;start&quot;
        }, {
            token: &quot;string.quasi.start&quot;,
            regex: /`/,
            push: [{
                    token: &quot;constant.language.escape&quot;,
                    regex: escapedRe
                }, {
                    token: &quot;paren.quasi.start&quot;,
                    regex: /\${/,
                    push: &quot;start&quot;
                }, {
                    token: &quot;string.quasi.end&quot;,
                    regex: /`/,
                    next: &quot;pop&quot;
                }, {
                    defaultToken: &quot;string.quasi&quot;
                }]
        }, {
            token: [&quot;variable.parameter&quot;, &quot;text&quot;],
            regex: &quot;(&quot; + identifierRe + &quot;)(\\s*)(?=\\=&gt;)&quot;
        }, {
            token: &quot;paren.lparen&quot;,
            regex: &quot;(\\()(?=.+\\s*=&gt;)&quot;,
            next: &quot;function_arguments&quot;
        }, {
            token: &quot;variable.language&quot;,
            regex: &quot;(?:(?:(?:Weak)?(?:Set|Map))|Promise)\\b&quot;
        });
        this.$rules[&quot;function_arguments&quot;].unshift({
            token: &quot;keyword.operator&quot;,
            regex: &quot;=&quot;,
            next: &quot;default_parameter&quot;
        }, {
            token: &quot;keyword.operator&quot;,
            regex: &quot;\\.{3}&quot;
        });
        this.$rules[&quot;property&quot;].unshift({
            token: &quot;support.function&quot;,
            regex: &quot;(findIndex|repeat|startsWith|endsWith|includes|isSafeInteger|trunc|cbrt|log2|log10|sign|then|catch|&quot;
                + &quot;finally|resolve|reject|race|any|all|allSettled|keys|entries|isInteger)\\b(?=\\()&quot;
        }, {
            token: &quot;constant.language&quot;,
            regex: &quot;(?:MAX_SAFE_INTEGER|MIN_SAFE_INTEGER|EPSILON)\\b&quot;
        });
        if (!options || options.jsx != false)
            JSX.call(this);
    }
    this.embedRules(DocCommentHighlightRules, &quot;doc-&quot;, [DocCommentHighlightRules.getEndRule(&quot;no_regex&quot;)]);
    this.normalizeRules();
};
oop.inherits(JavaScriptHighlightRules, TextHighlightRules);
function JSX() {
    var tagRegex = identifierRe.replace(&quot;\\d&quot;, &quot;\\d\\-&quot;);
    var jsxTag = {
        onMatch: function (val, state, stack) {
            var offset = val.charAt(1) == &quot;/&quot; ? 2 : 1;
            if (offset == 1) {
                if (state != this.nextState)
                    stack.unshift(this.next, this.nextState, 0);
                else
                    stack.unshift(this.next);
                stack[2]++;
            }
            else if (offset == 2) {
                if (state == this.nextState) {
                    stack[1]--;
                    if (!stack[1] || stack[1] &lt; 0) {
                        stack.shift();
                        stack.shift();
                    }
                }
            }
            return [{
                    type: &quot;meta.tag.punctuation.&quot; + (offset == 1 ? &quot;&quot; : &quot;end-&quot;) + &quot;tag-open.xml&quot;,
                    value: val.slice(0, offset)
                }, {
                    type: &quot;meta.tag.tag-name.xml&quot;,
                    value: val.substr(offset)
                }];
        },
        regex: &quot;&lt;/?&quot; + tagRegex + &quot;&quot;,
        next: &quot;jsxAttributes&quot;,
        nextState: &quot;jsx&quot;
    };
    this.$rules.start.unshift(jsxTag);
    var jsxJsRule = {
        regex: &quot;{&quot;,
        token: &quot;paren.quasi.start&quot;,
        push: &quot;start&quot;
    };
    this.$rules.jsx = [
        jsxJsRule,
        jsxTag,
        { include: &quot;reference&quot; },
        { defaultToken: &quot;string&quot; }
    ];
    this.$rules.jsxAttributes = [{
            token: &quot;meta.tag.punctuation.tag-close.xml&quot;,
            regex: &quot;/?&gt;&quot;,
            onMatch: function (value, currentState, stack) {
                if (currentState == stack[0])
                    stack.shift();
                if (value.length == 2) {
                    if (stack[0] == this.nextState)
                        stack[1]--;
                    if (!stack[1] || stack[1] &lt; 0) {
                        stack.splice(0, 2);
                    }
                }
                this.next = stack[0] || &quot;start&quot;;
                return [{ type: this.token, value: value }];
            },
            nextState: &quot;jsx&quot;
        },
        jsxJsRule,
        comments(&quot;jsxAttributes&quot;),
        {
            token: &quot;entity.other.attribute-name.xml&quot;,
            regex: tagRegex
        }, {
            token: &quot;keyword.operator.attribute-equals.xml&quot;,
            regex: &quot;=&quot;
        }, {
            token: &quot;text.tag-whitespace.xml&quot;,
            regex: &quot;\\s+&quot;
        }, {
            token: &quot;string.attribute-value.xml&quot;,
            regex: &quot;&#039;&quot;,
            stateName: &quot;jsx_attr_q&quot;,
            push: [
                { token: &quot;string.attribute-value.xml&quot;, regex: &quot;&#039;&quot;, next: &quot;pop&quot; },
                { include: &quot;reference&quot; },
                { defaultToken: &quot;string.attribute-value.xml&quot; }
            ]
        }, {
            token: &quot;string.attribute-value.xml&quot;,
            regex: &#039;&quot;&#039;,
            stateName: &quot;jsx_attr_qq&quot;,
            push: [
                { token: &quot;string.attribute-value.xml&quot;, regex: &#039;&quot;&#039;, next: &quot;pop&quot; },
                { include: &quot;reference&quot; },
                { defaultToken: &quot;string.attribute-value.xml&quot; }
            ]
        },
        jsxTag
    ];
    this.$rules.reference = [{
            token: &quot;constant.language.escape.reference.xml&quot;,
            regex: &quot;(?:&amp;#[0-9]+;)|(?:&amp;#x[0-9a-fA-F]+;)|(?:&amp;[a-zA-Z0-9_:\\.-]+;)&quot;
        }];
}
function comments(next) {
    return [
        {
            token: &quot;comment&quot;,
            regex: /\/\*/,
            next: [
                DocCommentHighlightRules.getTagRule(),
                { token: &quot;comment&quot;, regex: &quot;\\*\\/&quot;, next: next || &quot;pop&quot; },
                { defaultToken: &quot;comment&quot;, caseInsensitive: true }
            ]
        }, {
            token: &quot;comment&quot;,
            regex: &quot;\\/\\/&quot;,
            next: [
                DocCommentHighlightRules.getTagRule(),
                { token: &quot;comment&quot;, regex: &quot;$|^&quot;, next: next || &quot;pop&quot; },
                { defaultToken: &quot;comment&quot;, caseInsensitive: true }
            ]
        }
    ];
}
exports.JavaScriptHighlightRules = JavaScriptHighlightRules;

});

define(&quot;ace/mode/xml_highlight_rules&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/mode/text_highlight_rules&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;../lib/oop&quot;);
var TextHighlightRules = require(&quot;./text_highlight_rules&quot;).TextHighlightRules;
var XmlHighlightRules = function (normalize) {
    var tagRegex = &quot;[_:a-zA-Z\xc0-\uffff][-_:.a-zA-Z0-9\xc0-\uffff]*&quot;;
    this.$rules = {
        start: [
            { token: &quot;string.cdata.xml&quot;, regex: &quot;&lt;\\!\\[CDATA\\[&quot;, next: &quot;cdata&quot; },
            {
                token: [&quot;punctuation.instruction.xml&quot;, &quot;keyword.instruction.xml&quot;],
                regex: &quot;(&lt;\\?)(&quot; + tagRegex + &quot;)&quot;, next: &quot;processing_instruction&quot;
            },
            { token: &quot;comment.start.xml&quot;, regex: &quot;&lt;\\!--&quot;, next: &quot;comment&quot; },
            {
                token: [&quot;xml-pe.doctype.xml&quot;, &quot;xml-pe.doctype.xml&quot;],
                regex: &quot;(&lt;\\!)(DOCTYPE)(?=[\\s])&quot;, next: &quot;doctype&quot;, caseInsensitive: true
            },
            { include: &quot;tag&quot; },
            { token: &quot;text.end-tag-open.xml&quot;, regex: &quot;&lt;/&quot; },
            { token: &quot;text.tag-open.xml&quot;, regex: &quot;&lt;&quot; },
            { include: &quot;reference&quot; },
            { defaultToken: &quot;text.xml&quot; }
        ],
        processing_instruction: [{
                token: &quot;entity.other.attribute-name.decl-attribute-name.xml&quot;,
                regex: tagRegex
            }, {
                token: &quot;keyword.operator.decl-attribute-equals.xml&quot;,
                regex: &quot;=&quot;
            }, {
                include: &quot;whitespace&quot;
            }, {
                include: &quot;string&quot;
            }, {
                token: &quot;punctuation.xml-decl.xml&quot;,
                regex: &quot;\\?&gt;&quot;,
                next: &quot;start&quot;
            }],
        doctype: [
            { include: &quot;whitespace&quot; },
            { include: &quot;string&quot; },
            { token: &quot;xml-pe.doctype.xml&quot;, regex: &quot;&gt;&quot;, next: &quot;start&quot; },
            { token: &quot;xml-pe.xml&quot;, regex: &quot;[-_a-zA-Z0-9:]+&quot; },
            { token: &quot;punctuation.int-subset&quot;, regex: &quot;\\[&quot;, push: &quot;int_subset&quot; }
        ],
        int_subset: [{
                token: &quot;text.xml&quot;,
                regex: &quot;\\s+&quot;
            }, {
                token: &quot;punctuation.int-subset.xml&quot;,
                regex: &quot;]&quot;,
                next: &quot;pop&quot;
            }, {
                token: [&quot;punctuation.markup-decl.xml&quot;, &quot;keyword.markup-decl.xml&quot;],
                regex: &quot;(&lt;\\!)(&quot; + tagRegex + &quot;)&quot;,
                push: [{
                        token: &quot;text&quot;,
                        regex: &quot;\\s+&quot;
                    },
                    {
                        token: &quot;punctuation.markup-decl.xml&quot;,
                        regex: &quot;&gt;&quot;,
                        next: &quot;pop&quot;
                    },
                    { include: &quot;string&quot; }]
            }],
        cdata: [
            { token: &quot;string.cdata.xml&quot;, regex: &quot;\\]\\]&gt;&quot;, next: &quot;start&quot; },
            { token: &quot;text.xml&quot;, regex: &quot;\\s+&quot; },
            { token: &quot;text.xml&quot;, regex: &quot;(?:[^\\]]|\\](?!\\]&gt;))+&quot; }
        ],
        comment: [
            { token: &quot;comment.end.xml&quot;, regex: &quot;--&gt;&quot;, next: &quot;start&quot; },
            { defaultToken: &quot;comment.xml&quot; }
        ],
        reference: [{
                token: &quot;constant.language.escape.reference.xml&quot;,
                regex: &quot;(?:&amp;#[0-9]+;)|(?:&amp;#x[0-9a-fA-F]+;)|(?:&amp;[a-zA-Z0-9_:\\.-]+;)&quot;
            }],
        attr_reference: [{
                token: &quot;constant.language.escape.reference.attribute-value.xml&quot;,
                regex: &quot;(?:&amp;#[0-9]+;)|(?:&amp;#x[0-9a-fA-F]+;)|(?:&amp;[a-zA-Z0-9_:\\.-]+;)&quot;
            }],
        tag: [{
                token: [&quot;meta.tag.punctuation.tag-open.xml&quot;, &quot;meta.tag.punctuation.end-tag-open.xml&quot;, &quot;meta.tag.tag-name.xml&quot;],
                regex: &quot;(?:(&lt;)|(&lt;/))((?:&quot; + tagRegex + &quot;:)?&quot; + tagRegex + &quot;)&quot;,
                next: [
                    { include: &quot;attributes&quot; },
                    { token: &quot;meta.tag.punctuation.tag-close.xml&quot;, regex: &quot;/?&gt;&quot;, next: &quot;start&quot; }
                ]
            }],
        tag_whitespace: [
            { token: &quot;text.tag-whitespace.xml&quot;, regex: &quot;\\s+&quot; }
        ],
        whitespace: [
            { token: &quot;text.whitespace.xml&quot;, regex: &quot;\\s+&quot; }
        ],
        string: [{
                token: &quot;string.xml&quot;,
                regex: &quot;&#039;&quot;,
                push: [
                    { token: &quot;string.xml&quot;, regex: &quot;&#039;&quot;, next: &quot;pop&quot; },
                    { defaultToken: &quot;string.xml&quot; }
                ]
            }, {
                token: &quot;string.xml&quot;,
                regex: &#039;&quot;&#039;,
                push: [
                    { token: &quot;string.xml&quot;, regex: &#039;&quot;&#039;, next: &quot;pop&quot; },
                    { defaultToken: &quot;string.xml&quot; }
                ]
            }],
        attributes: [{
                token: &quot;entity.other.attribute-name.xml&quot;,
                regex: tagRegex
            }, {
                token: &quot;keyword.operator.attribute-equals.xml&quot;,
                regex: &quot;=&quot;
            }, {
                include: &quot;tag_whitespace&quot;
            }, {
                include: &quot;attribute_value&quot;
            }],
        attribute_value: [{
                token: &quot;string.attribute-value.xml&quot;,
                regex: &quot;&#039;&quot;,
                push: [
                    { token: &quot;string.attribute-value.xml&quot;, regex: &quot;&#039;&quot;, next: &quot;pop&quot; },
                    { include: &quot;attr_reference&quot; },
                    { defaultToken: &quot;string.attribute-value.xml&quot; }
                ]
            }, {
                token: &quot;string.attribute-value.xml&quot;,
                regex: &#039;&quot;&#039;,
                push: [
                    { token: &quot;string.attribute-value.xml&quot;, regex: &#039;&quot;&#039;, next: &quot;pop&quot; },
                    { include: &quot;attr_reference&quot; },
                    { defaultToken: &quot;string.attribute-value.xml&quot; }
                ]
            }]
    };
    if (this.constructor === XmlHighlightRules)
        this.normalizeRules();
};
(function () {
    this.embedTagRules = function (HighlightRules, prefix, tag) {
        this.$rules.tag.unshift({
            token: [&quot;meta.tag.punctuation.tag-open.xml&quot;, &quot;meta.tag.&quot; + tag + &quot;.tag-name.xml&quot;],
            regex: &quot;(&lt;)(&quot; + tag + &quot;(?=\\s|&gt;|$))&quot;,
            next: [
                { include: &quot;attributes&quot; },
                { token: &quot;meta.tag.punctuation.tag-close.xml&quot;, regex: &quot;/?&gt;&quot;, next: prefix + &quot;start&quot; }
            ]
        });
        this.$rules[tag + &quot;-end&quot;] = [
            { include: &quot;attributes&quot; },
            { token: &quot;meta.tag.punctuation.tag-close.xml&quot;, regex: &quot;/?&gt;&quot;, next: &quot;start&quot;,
                onMatch: function (value, currentState, stack) {
                    stack.splice(0);
                    return this.token;
                } }
        ];
        this.embedRules(HighlightRules, prefix, [{
                token: [&quot;meta.tag.punctuation.end-tag-open.xml&quot;, &quot;meta.tag.&quot; + tag + &quot;.tag-name.xml&quot;],
                regex: &quot;(&lt;/)(&quot; + tag + &quot;(?=\\s|&gt;|$))&quot;,
                next: tag + &quot;-end&quot;
            }, {
                token: &quot;string.cdata.xml&quot;,
                regex: &quot;&lt;\\!\\[CDATA\\[&quot;
            }, {
                token: &quot;string.cdata.xml&quot;,
                regex: &quot;\\]\\]&gt;&quot;
            }]);
    };
}).call(TextHighlightRules.prototype);
oop.inherits(XmlHighlightRules, TextHighlightRules);
exports.XmlHighlightRules = XmlHighlightRules;

});

define(&quot;ace/mode/html_highlight_rules&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/lang&quot;,&quot;ace/mode/css_highlight_rules&quot;,&quot;ace/mode/javascript_highlight_rules&quot;,&quot;ace/mode/xml_highlight_rules&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;../lib/oop&quot;);
var lang = require(&quot;../lib/lang&quot;);
var CssHighlightRules = require(&quot;./css_highlight_rules&quot;).CssHighlightRules;
var JavaScriptHighlightRules = require(&quot;./javascript_highlight_rules&quot;).JavaScriptHighlightRules;
var XmlHighlightRules = require(&quot;./xml_highlight_rules&quot;).XmlHighlightRules;
var tagMap = lang.createMap({
    a: &#039;anchor&#039;,
    button: &#039;form&#039;,
    form: &#039;form&#039;,
    img: &#039;image&#039;,
    input: &#039;form&#039;,
    label: &#039;form&#039;,
    option: &#039;form&#039;,
    script: &#039;script&#039;,
    select: &#039;form&#039;,
    textarea: &#039;form&#039;,
    style: &#039;style&#039;,
    table: &#039;table&#039;,
    tbody: &#039;table&#039;,
    td: &#039;table&#039;,
    tfoot: &#039;table&#039;,
    th: &#039;table&#039;,
    tr: &#039;table&#039;
});
var HtmlHighlightRules = function () {
    XmlHighlightRules.call(this);
    this.addRules({
        attributes: [{
                include: &quot;tag_whitespace&quot;
            }, {
                token: &quot;entity.other.attribute-name.xml&quot;,
                regex: &quot;[-_a-zA-Z0-9:.]+&quot;
            }, {
                token: &quot;keyword.operator.attribute-equals.xml&quot;,
                regex: &quot;=&quot;,
                push: [{
                        include: &quot;tag_whitespace&quot;
                    }, {
                        token: &quot;string.unquoted.attribute-value.html&quot;,
                        regex: &quot;[^&lt;&gt;=&#039;\&quot;`\\s]+&quot;,
                        next: &quot;pop&quot;
                    }, {
                        token: &quot;empty&quot;,
                        regex: &quot;&quot;,
                        next: &quot;pop&quot;
                    }]
            }, {
                include: &quot;attribute_value&quot;
            }],
        tag: [{
                token: function (start, tag) {
                    var group = tagMap[tag];
                    return [&quot;meta.tag.punctuation.&quot; + (start == &quot;&lt;&quot; ? &quot;&quot; : &quot;end-&quot;) + &quot;tag-open.xml&quot;,
                        &quot;meta.tag&quot; + (group ? &quot;.&quot; + group : &quot;&quot;) + &quot;.tag-name.xml&quot;];
                },
                regex: &quot;(&lt;/?)([-_a-zA-Z0-9:.]+)&quot;,
                next: &quot;tag_stuff&quot;
            }],
        tag_stuff: [
            { include: &quot;attributes&quot; },
            { token: &quot;meta.tag.punctuation.tag-close.xml&quot;, regex: &quot;/?&gt;&quot;, next: &quot;start&quot; }
        ]
    });
    this.embedTagRules(CssHighlightRules, &quot;css-&quot;, &quot;style&quot;);
    this.embedTagRules(new JavaScriptHighlightRules({ jsx: false }).getRules(), &quot;js-&quot;, &quot;script&quot;);
    if (this.constructor === HtmlHighlightRules)
        this.normalizeRules();
};
oop.inherits(HtmlHighlightRules, XmlHighlightRules);
exports.HtmlHighlightRules = HtmlHighlightRules;

});

define(&quot;ace/mode/matching_brace_outdent&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/range&quot;], function(require, exports, module){&quot;use strict&quot;;
var Range = require(&quot;../range&quot;).Range;
var MatchingBraceOutdent = function () { };
(function () {
    this.checkOutdent = function (line, input) {
        if (!/^\s+$/.test(line))
            return false;
        return /^\s*\}/.test(input);
    };
    this.autoOutdent = function (doc, row) {
        var line = doc.getLine(row);
        var match = line.match(/^(\s*\})/);
        if (!match)
            return 0;
        var column = match[1].length;
        var openBracePos = doc.findMatchingBracket({ row: row, column: column });
        if (!openBracePos || openBracePos.row == row)
            return 0;
        var indent = this.$getIndent(doc.getLine(openBracePos.row));
        doc.replace(new Range(row, 0, row, column - 1), indent);
    };
    this.$getIndent = function (line) {
        return line.match(/^\s*/)[0];
    };
}).call(MatchingBraceOutdent.prototype);
exports.MatchingBraceOutdent = MatchingBraceOutdent;

});

define(&quot;ace/mode/folding/cstyle&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/range&quot;,&quot;ace/mode/folding/fold_mode&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;../../lib/oop&quot;);
var Range = require(&quot;../../range&quot;).Range;
var BaseFoldMode = require(&quot;./fold_mode&quot;).FoldMode;
var FoldMode = exports.FoldMode = function (commentRegex) {
    if (commentRegex) {
        this.foldingStartMarker = new RegExp(this.foldingStartMarker.source.replace(/\|[^|]*?$/, &quot;|&quot; + commentRegex.start));
        this.foldingStopMarker = new RegExp(this.foldingStopMarker.source.replace(/\|[^|]*?$/, &quot;|&quot; + commentRegex.end));
    }
};
oop.inherits(FoldMode, BaseFoldMode);
(function () {
    this.foldingStartMarker = /([\{\[\(])[^\}\]\)]*$|^\s*(\/\*)/;
    this.foldingStopMarker = /^[^\[\{\(]*([\}\]\)])|^[\s\*]*(\*\/)/;
    this.singleLineBlockCommentRe = /^\s*(\/\*).*\*\/\s*$/;
    this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
    this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
    this._getFoldWidgetBase = this.getFoldWidget;
    this.getFoldWidget = function (session, foldStyle, row) {
        var line = session.getLine(row);
        if (this.singleLineBlockCommentRe.test(line)) {
            if (!this.startRegionRe.test(line) &amp;&amp; !this.tripleStarBlockCommentRe.test(line))
                return &quot;&quot;;
        }
        var fw = this._getFoldWidgetBase(session, foldStyle, row);
        if (!fw &amp;&amp; this.startRegionRe.test(line))
            return &quot;start&quot;; // lineCommentRegionStart
        return fw;
    };
    this.getFoldWidgetRange = function (session, foldStyle, row, forceMultiline) {
        var line = session.getLine(row);
        if (this.startRegionRe.test(line))
            return this.getCommentRegionBlock(session, line, row);
        var match = line.match(this.foldingStartMarker);
        if (match) {
            var i = match.index;
            if (match[1])
                return this.openingBracketBlock(session, match[1], row, i);
            var range = session.getCommentFoldRange(row, i + match[0].length, 1);
            if (range &amp;&amp; !range.isMultiLine()) {
                if (forceMultiline) {
                    range = this.getSectionRange(session, row);
                }
                else if (foldStyle != &quot;all&quot;)
                    range = null;
            }
            return range;
        }
        if (foldStyle === &quot;markbegin&quot;)
            return;
        var match = line.match(this.foldingStopMarker);
        if (match) {
            var i = match.index + match[0].length;
            if (match[1])
                return this.closingBracketBlock(session, match[1], row, i);
            return session.getCommentFoldRange(row, i, -1);
        }
    };
    this.getSectionRange = function (session, row) {
        var line = session.getLine(row);
        var startIndent = line.search(/\S/);
        var startRow = row;
        var startColumn = line.length;
        row = row + 1;
        var endRow = row;
        var maxRow = session.getLength();
        while (++row &lt; maxRow) {
            line = session.getLine(row);
            var indent = line.search(/\S/);
            if (indent === -1)
                continue;
            if (startIndent &gt; indent)
                break;
            var subRange = this.getFoldWidgetRange(session, &quot;all&quot;, row);
            if (subRange) {
                if (subRange.start.row &lt;= startRow) {
                    break;
                }
                else if (subRange.isMultiLine()) {
                    row = subRange.end.row;
                }
                else if (startIndent == indent) {
                    break;
                }
            }
            endRow = row;
        }
        return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
    };
    this.getCommentRegionBlock = function (session, line, row) {
        var startColumn = line.search(/\s*$/);
        var maxRow = session.getLength();
        var startRow = row;
        var re = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
        var depth = 1;
        while (++row &lt; maxRow) {
            line = session.getLine(row);
            var m = re.exec(line);
            if (!m)
                continue;
            if (m[1])
                depth--;
            else
                depth++;
            if (!depth)
                break;
        }
        var endRow = row;
        if (endRow &gt; startRow) {
            return new Range(startRow, startColumn, endRow, line.length);
        }
    };
}).call(FoldMode.prototype);

});

define(&quot;ace/mode/javascript&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/mode/text&quot;,&quot;ace/mode/javascript_highlight_rules&quot;,&quot;ace/mode/matching_brace_outdent&quot;,&quot;ace/worker/worker_client&quot;,&quot;ace/mode/behaviour/cstyle&quot;,&quot;ace/mode/folding/cstyle&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;../lib/oop&quot;);
var TextMode = require(&quot;./text&quot;).Mode;
var JavaScriptHighlightRules = require(&quot;./javascript_highlight_rules&quot;).JavaScriptHighlightRules;
var MatchingBraceOutdent = require(&quot;./matching_brace_outdent&quot;).MatchingBraceOutdent;
var WorkerClient = require(&quot;../worker/worker_client&quot;).WorkerClient;
var CstyleBehaviour = require(&quot;./behaviour/cstyle&quot;).CstyleBehaviour;
var CStyleFoldMode = require(&quot;./folding/cstyle&quot;).FoldMode;
var Mode = function () {
    this.HighlightRules = JavaScriptHighlightRules;
    this.$outdent = new MatchingBraceOutdent();
    this.$behaviour = new CstyleBehaviour();
    this.foldingRules = new CStyleFoldMode();
};
oop.inherits(Mode, TextMode);
(function () {
    this.lineCommentStart = &quot;//&quot;;
    this.blockComment = { start: &quot;/*&quot;, end: &quot;*/&quot; };
    this.$quotes = { &#039;&quot;&#039;: &#039;&quot;&#039;, &quot;&#039;&quot;: &quot;&#039;&quot;, &quot;`&quot;: &quot;`&quot; };
    this.getNextLineIndent = function (state, line, tab) {
        var indent = this.$getIndent(line);
        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
        var tokens = tokenizedLine.tokens;
        var endState = tokenizedLine.state;
        if (tokens.length &amp;&amp; tokens[tokens.length - 1].type == &quot;comment&quot;) {
            return indent;
        }
        if (state == &quot;start&quot; || state == &quot;no_regex&quot;) {
            var match = line.match(/^.*(?:\bcase\b.*:|[\{\(\[])\s*$/);
            if (match) {
                indent += tab;
            }
        }
        else if (state == &quot;doc-start&quot;) {
            if (endState == &quot;start&quot; || endState == &quot;no_regex&quot;) {
                return &quot;&quot;;
            }
            var match = line.match(/^\s*(\/?)\*/);
            if (match) {
                if (match[1]) {
                    indent += &quot; &quot;;
                }
                indent += &quot;* &quot;;
            }
        }
        return indent;
    };
    this.checkOutdent = function (state, line, input) {
        return this.$outdent.checkOutdent(line, input);
    };
    this.autoOutdent = function (state, doc, row) {
        this.$outdent.autoOutdent(doc, row);
    };
    this.createWorker = function (session) {
        var worker = new WorkerClient([&quot;ace&quot;], &quot;ace/mode/javascript_worker&quot;, &quot;JavaScriptWorker&quot;);
        worker.attachToDocument(session.getDocument());
        worker.on(&quot;annotate&quot;, function (results) {
            session.setAnnotations(results.data);
        });
        worker.on(&quot;terminate&quot;, function () {
            session.clearAnnotations();
        });
        return worker;
    };
    this.$id = &quot;ace/mode/javascript&quot;;
    this.snippetFileId = &quot;ace/snippets/javascript&quot;;
}).call(Mode.prototype);
exports.Mode = Mode;

});

define(&quot;ace/mode/css_completions&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;], function(require, exports, module){&quot;use strict&quot;;
var propertyMap = {
    &quot;background&quot;: { &quot;#$0&quot;: 1 },
    &quot;background-color&quot;: { &quot;#$0&quot;: 1, &quot;transparent&quot;: 1, &quot;fixed&quot;: 1 },
    &quot;background-image&quot;: { &quot;url(&#039;/$0&#039;)&quot;: 1 },
    &quot;background-repeat&quot;: { &quot;repeat&quot;: 1, &quot;repeat-x&quot;: 1, &quot;repeat-y&quot;: 1, &quot;no-repeat&quot;: 1, &quot;inherit&quot;: 1 },
    &quot;background-position&quot;: { &quot;bottom&quot;: 2, &quot;center&quot;: 2, &quot;left&quot;: 2, &quot;right&quot;: 2, &quot;top&quot;: 2, &quot;inherit&quot;: 2 },
    &quot;background-attachment&quot;: { &quot;scroll&quot;: 1, &quot;fixed&quot;: 1 },
    &quot;background-size&quot;: { &quot;cover&quot;: 1, &quot;contain&quot;: 1 },
    &quot;background-clip&quot;: { &quot;border-box&quot;: 1, &quot;padding-box&quot;: 1, &quot;content-box&quot;: 1 },
    &quot;background-origin&quot;: { &quot;border-box&quot;: 1, &quot;padding-box&quot;: 1, &quot;content-box&quot;: 1 },
    &quot;border&quot;: { &quot;solid $0&quot;: 1, &quot;dashed $0&quot;: 1, &quot;dotted $0&quot;: 1, &quot;#$0&quot;: 1 },
    &quot;border-color&quot;: { &quot;#$0&quot;: 1 },
    &quot;border-style&quot;: { &quot;solid&quot;: 2, &quot;dashed&quot;: 2, &quot;dotted&quot;: 2, &quot;double&quot;: 2, &quot;groove&quot;: 2, &quot;hidden&quot;: 2, &quot;inherit&quot;: 2, &quot;inset&quot;: 2, &quot;none&quot;: 2, &quot;outset&quot;: 2, &quot;ridged&quot;: 2 },
    &quot;border-collapse&quot;: { &quot;collapse&quot;: 1, &quot;separate&quot;: 1 },
    &quot;bottom&quot;: { &quot;px&quot;: 1, &quot;em&quot;: 1, &quot;%&quot;: 1 },
    &quot;clear&quot;: { &quot;left&quot;: 1, &quot;right&quot;: 1, &quot;both&quot;: 1, &quot;none&quot;: 1 },
    &quot;color&quot;: { &quot;#$0&quot;: 1, &quot;rgb(#$00,0,0)&quot;: 1 },
    &quot;cursor&quot;: { &quot;default&quot;: 1, &quot;pointer&quot;: 1, &quot;move&quot;: 1, &quot;text&quot;: 1, &quot;wait&quot;: 1, &quot;help&quot;: 1, &quot;progress&quot;: 1, &quot;n-resize&quot;: 1, &quot;ne-resize&quot;: 1, &quot;e-resize&quot;: 1, &quot;se-resize&quot;: 1, &quot;s-resize&quot;: 1, &quot;sw-resize&quot;: 1, &quot;w-resize&quot;: 1, &quot;nw-resize&quot;: 1 },
    &quot;display&quot;: { &quot;none&quot;: 1, &quot;block&quot;: 1, &quot;inline&quot;: 1, &quot;inline-block&quot;: 1, &quot;table-cell&quot;: 1 },
    &quot;empty-cells&quot;: { &quot;show&quot;: 1, &quot;hide&quot;: 1 },
    &quot;float&quot;: { &quot;left&quot;: 1, &quot;right&quot;: 1, &quot;none&quot;: 1 },
    &quot;font-family&quot;: { &quot;Arial&quot;: 2, &quot;Comic Sans MS&quot;: 2, &quot;Consolas&quot;: 2, &quot;Courier New&quot;: 2, &quot;Courier&quot;: 2, &quot;Georgia&quot;: 2, &quot;Monospace&quot;: 2, &quot;Sans-Serif&quot;: 2, &quot;Segoe UI&quot;: 2, &quot;Tahoma&quot;: 2, &quot;Times New Roman&quot;: 2, &quot;Trebuchet MS&quot;: 2, &quot;Verdana&quot;: 1 },
    &quot;font-size&quot;: { &quot;px&quot;: 1, &quot;em&quot;: 1, &quot;%&quot;: 1 },
    &quot;font-weight&quot;: { &quot;bold&quot;: 1, &quot;normal&quot;: 1 },
    &quot;font-style&quot;: { &quot;italic&quot;: 1, &quot;normal&quot;: 1 },
    &quot;font-variant&quot;: { &quot;normal&quot;: 1, &quot;small-caps&quot;: 1 },
    &quot;height&quot;: { &quot;px&quot;: 1, &quot;em&quot;: 1, &quot;%&quot;: 1 },
    &quot;left&quot;: { &quot;px&quot;: 1, &quot;em&quot;: 1, &quot;%&quot;: 1 },
    &quot;letter-spacing&quot;: { &quot;normal&quot;: 1 },
    &quot;line-height&quot;: { &quot;normal&quot;: 1 },
    &quot;list-style-type&quot;: { &quot;none&quot;: 1, &quot;disc&quot;: 1, &quot;circle&quot;: 1, &quot;square&quot;: 1, &quot;decimal&quot;: 1, &quot;decimal-leading-zero&quot;: 1, &quot;lower-roman&quot;: 1, &quot;upper-roman&quot;: 1, &quot;lower-greek&quot;: 1, &quot;lower-latin&quot;: 1, &quot;upper-latin&quot;: 1, &quot;georgian&quot;: 1, &quot;lower-alpha&quot;: 1, &quot;upper-alpha&quot;: 1 },
    &quot;margin&quot;: { &quot;px&quot;: 1, &quot;em&quot;: 1, &quot;%&quot;: 1 },
    &quot;margin-right&quot;: { &quot;px&quot;: 1, &quot;em&quot;: 1, &quot;%&quot;: 1 },
    &quot;margin-left&quot;: { &quot;px&quot;: 1, &quot;em&quot;: 1, &quot;%&quot;: 1 },
    &quot;margin-top&quot;: { &quot;px&quot;: 1, &quot;em&quot;: 1, &quot;%&quot;: 1 },
    &quot;margin-bottom&quot;: { &quot;px&quot;: 1, &quot;em&quot;: 1, &quot;%&quot;: 1 },
    &quot;max-height&quot;: { &quot;px&quot;: 1, &quot;em&quot;: 1, &quot;%&quot;: 1 },
    &quot;max-width&quot;: { &quot;px&quot;: 1, &quot;em&quot;: 1, &quot;%&quot;: 1 },
    &quot;min-height&quot;: { &quot;px&quot;: 1, &quot;em&quot;: 1, &quot;%&quot;: 1 },
    &quot;min-width&quot;: { &quot;px&quot;: 1, &quot;em&quot;: 1, &quot;%&quot;: 1 },
    &quot;overflow&quot;: { &quot;hidden&quot;: 1, &quot;visible&quot;: 1, &quot;auto&quot;: 1, &quot;scroll&quot;: 1 },
    &quot;overflow-x&quot;: { &quot;hidden&quot;: 1, &quot;visible&quot;: 1, &quot;auto&quot;: 1, &quot;scroll&quot;: 1 },
    &quot;overflow-y&quot;: { &quot;hidden&quot;: 1, &quot;visible&quot;: 1, &quot;auto&quot;: 1, &quot;scroll&quot;: 1 },
    &quot;padding&quot;: { &quot;px&quot;: 1, &quot;em&quot;: 1, &quot;%&quot;: 1 },
    &quot;padding-top&quot;: { &quot;px&quot;: 1, &quot;em&quot;: 1, &quot;%&quot;: 1 },
    &quot;padding-right&quot;: { &quot;px&quot;: 1, &quot;em&quot;: 1, &quot;%&quot;: 1 },
    &quot;padding-bottom&quot;: { &quot;px&quot;: 1, &quot;em&quot;: 1, &quot;%&quot;: 1 },
    &quot;padding-left&quot;: { &quot;px&quot;: 1, &quot;em&quot;: 1, &quot;%&quot;: 1 },
    &quot;page-break-after&quot;: { &quot;auto&quot;: 1, &quot;always&quot;: 1, &quot;avoid&quot;: 1, &quot;left&quot;: 1, &quot;right&quot;: 1 },
    &quot;page-break-before&quot;: { &quot;auto&quot;: 1, &quot;always&quot;: 1, &quot;avoid&quot;: 1, &quot;left&quot;: 1, &quot;right&quot;: 1 },
    &quot;position&quot;: { &quot;absolute&quot;: 1, &quot;relative&quot;: 1, &quot;fixed&quot;: 1, &quot;static&quot;: 1 },
    &quot;right&quot;: { &quot;px&quot;: 1, &quot;em&quot;: 1, &quot;%&quot;: 1 },
    &quot;table-layout&quot;: { &quot;fixed&quot;: 1, &quot;auto&quot;: 1 },
    &quot;text-decoration&quot;: { &quot;none&quot;: 1, &quot;underline&quot;: 1, &quot;line-through&quot;: 1, &quot;blink&quot;: 1 },
    &quot;text-align&quot;: { &quot;left&quot;: 1, &quot;right&quot;: 1, &quot;center&quot;: 1, &quot;justify&quot;: 1 },
    &quot;text-transform&quot;: { &quot;capitalize&quot;: 1, &quot;uppercase&quot;: 1, &quot;lowercase&quot;: 1, &quot;none&quot;: 1 },
    &quot;top&quot;: { &quot;px&quot;: 1, &quot;em&quot;: 1, &quot;%&quot;: 1 },
    &quot;vertical-align&quot;: { &quot;top&quot;: 1, &quot;bottom&quot;: 1 },
    &quot;visibility&quot;: { &quot;hidden&quot;: 1, &quot;visible&quot;: 1 },
    &quot;white-space&quot;: { &quot;nowrap&quot;: 1, &quot;normal&quot;: 1, &quot;pre&quot;: 1, &quot;pre-line&quot;: 1, &quot;pre-wrap&quot;: 1 },
    &quot;width&quot;: { &quot;px&quot;: 1, &quot;em&quot;: 1, &quot;%&quot;: 1 },
    &quot;word-spacing&quot;: { &quot;normal&quot;: 1 },
    &quot;filter&quot;: { &quot;alpha(opacity=$0100)&quot;: 1 },
    &quot;text-shadow&quot;: { &quot;$02px 2px 2px #777&quot;: 1 },
    &quot;text-overflow&quot;: { &quot;ellipsis-word&quot;: 1, &quot;clip&quot;: 1, &quot;ellipsis&quot;: 1 },
    &quot;-moz-border-radius&quot;: 1,
    &quot;-moz-border-radius-topright&quot;: 1,
    &quot;-moz-border-radius-bottomright&quot;: 1,
    &quot;-moz-border-radius-topleft&quot;: 1,
    &quot;-moz-border-radius-bottomleft&quot;: 1,
    &quot;-webkit-border-radius&quot;: 1,
    &quot;-webkit-border-top-right-radius&quot;: 1,
    &quot;-webkit-border-top-left-radius&quot;: 1,
    &quot;-webkit-border-bottom-right-radius&quot;: 1,
    &quot;-webkit-border-bottom-left-radius&quot;: 1,
    &quot;-moz-box-shadow&quot;: 1,
    &quot;-webkit-box-shadow&quot;: 1,
    &quot;transform&quot;: { &quot;rotate($00deg)&quot;: 1, &quot;skew($00deg)&quot;: 1 },
    &quot;-moz-transform&quot;: { &quot;rotate($00deg)&quot;: 1, &quot;skew($00deg)&quot;: 1 },
    &quot;-webkit-transform&quot;: { &quot;rotate($00deg)&quot;: 1, &quot;skew($00deg)&quot;: 1 }
};
var CssCompletions = function () {
};
(function () {
    this.completionsDefined = false;
    this.defineCompletions = function () {
        if (document) {
            var style = document.createElement(&#039;c&#039;).style;
            for (var i in style) {
                if (typeof style[i] !== &#039;string&#039;)
                    continue;
                var name = i.replace(/[A-Z]/g, function (x) {
                    return &#039;-&#039; + x.toLowerCase();
                });
                if (!propertyMap.hasOwnProperty(name))
                    propertyMap[name] = 1;
            }
        }
        this.completionsDefined = true;
    };
    this.getCompletions = function (state, session, pos, prefix) {
        if (!this.completionsDefined) {
            this.defineCompletions();
        }
        if (state === &#039;ruleset&#039; || session.$mode.$id == &quot;ace/mode/scss&quot;) {
            var line = session.getLine(pos.row).substr(0, pos.column);
            var inParens = /\([^)]*$/.test(line);
            if (inParens) {
                line = line.substr(line.lastIndexOf(&#039;(&#039;) + 1);
            }
            if (/:[^;]+$/.test(line)) {
                /([\w\-]+):[^:]*$/.test(line);
                return this.getPropertyValueCompletions(state, session, pos, prefix);
            }
            else {
                return this.getPropertyCompletions(state, session, pos, prefix, inParens);
            }
        }
        return [];
    };
    this.getPropertyCompletions = function (state, session, pos, prefix, skipSemicolon) {
        skipSemicolon = skipSemicolon || false;
        var properties = Object.keys(propertyMap);
        return properties.map(function (property) {
            return {
                caption: property,
                snippet: property + &#039;: $0&#039; + (skipSemicolon ? &#039;&#039; : &#039;;&#039;),
                meta: &quot;property&quot;,
                score: 1000000
            };
        });
    };
    this.getPropertyValueCompletions = function (state, session, pos, prefix) {
        var line = session.getLine(pos.row).substr(0, pos.column);
        var property = (/([\w\-]+):[^:]*$/.exec(line) || {})[1];
        if (!property)
            return [];
        var values = [];
        if (property in propertyMap &amp;&amp; typeof propertyMap[property] === &quot;object&quot;) {
            values = Object.keys(propertyMap[property]);
        }
        return values.map(function (value) {
            return {
                caption: value,
                snippet: value,
                meta: &quot;property value&quot;,
                score: 1000000
            };
        });
    };
}).call(CssCompletions.prototype);
exports.CssCompletions = CssCompletions;

});

define(&quot;ace/mode/behaviour/css&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/mode/behaviour&quot;,&quot;ace/mode/behaviour/cstyle&quot;,&quot;ace/token_iterator&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;../../lib/oop&quot;);
var Behaviour = require(&quot;../behaviour&quot;).Behaviour;
var CstyleBehaviour = require(&quot;./cstyle&quot;).CstyleBehaviour;
var TokenIterator = require(&quot;../../token_iterator&quot;).TokenIterator;
var CssBehaviour = function () {
    this.inherit(CstyleBehaviour);
    this.add(&quot;colon&quot;, &quot;insertion&quot;, function (state, action, editor, session, text) {
        if (text === &#039;:&#039; &amp;&amp; editor.selection.isEmpty()) {
            var cursor = editor.getCursorPosition();
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            if (token &amp;&amp; token.value.match(/\s+/)) {
                token = iterator.stepBackward();
            }
            if (token &amp;&amp; token.type === &#039;support.type&#039;) {
                var line = session.doc.getLine(cursor.row);
                var rightChar = line.substring(cursor.column, cursor.column + 1);
                if (rightChar === &#039;:&#039;) {
                    return {
                        text: &#039;&#039;,
                        selection: [1, 1]
                    };
                }
                if (/^(\s+[^;]|\s*$)/.test(line.substring(cursor.column))) {
                    return {
                        text: &#039;:;&#039;,
                        selection: [1, 1]
                    };
                }
            }
        }
    });
    this.add(&quot;colon&quot;, &quot;deletion&quot;, function (state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() &amp;&amp; selected === &#039;:&#039;) {
            var cursor = editor.getCursorPosition();
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            if (token &amp;&amp; token.value.match(/\s+/)) {
                token = iterator.stepBackward();
            }
            if (token &amp;&amp; token.type === &#039;support.type&#039;) {
                var line = session.doc.getLine(range.start.row);
                var rightChar = line.substring(range.end.column, range.end.column + 1);
                if (rightChar === &#039;;&#039;) {
                    range.end.column++;
                    return range;
                }
            }
        }
    });
    this.add(&quot;semicolon&quot;, &quot;insertion&quot;, function (state, action, editor, session, text) {
        if (text === &#039;;&#039; &amp;&amp; editor.selection.isEmpty()) {
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar === &#039;;&#039;) {
                return {
                    text: &#039;&#039;,
                    selection: [1, 1]
                };
            }
        }
    });
    this.add(&quot;!important&quot;, &quot;insertion&quot;, function (state, action, editor, session, text) {
        if (text === &#039;!&#039; &amp;&amp; editor.selection.isEmpty()) {
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            if (/^\s*(;|}|$)/.test(line.substring(cursor.column))) {
                return {
                    text: &#039;!important&#039;,
                    selection: [10, 10]
                };
            }
        }
    });
};
oop.inherits(CssBehaviour, CstyleBehaviour);
exports.CssBehaviour = CssBehaviour;

});

define(&quot;ace/mode/css&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/mode/text&quot;,&quot;ace/mode/css_highlight_rules&quot;,&quot;ace/mode/matching_brace_outdent&quot;,&quot;ace/worker/worker_client&quot;,&quot;ace/mode/css_completions&quot;,&quot;ace/mode/behaviour/css&quot;,&quot;ace/mode/folding/cstyle&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;../lib/oop&quot;);
var TextMode = require(&quot;./text&quot;).Mode;
var CssHighlightRules = require(&quot;./css_highlight_rules&quot;).CssHighlightRules;
var MatchingBraceOutdent = require(&quot;./matching_brace_outdent&quot;).MatchingBraceOutdent;
var WorkerClient = require(&quot;../worker/worker_client&quot;).WorkerClient;
var CssCompletions = require(&quot;./css_completions&quot;).CssCompletions;
var CssBehaviour = require(&quot;./behaviour/css&quot;).CssBehaviour;
var CStyleFoldMode = require(&quot;./folding/cstyle&quot;).FoldMode;
var Mode = function () {
    this.HighlightRules = CssHighlightRules;
    this.$outdent = new MatchingBraceOutdent();
    this.$behaviour = new CssBehaviour();
    this.$completer = new CssCompletions();
    this.foldingRules = new CStyleFoldMode();
};
oop.inherits(Mode, TextMode);
(function () {
    this.foldingRules = &quot;cStyle&quot;;
    this.blockComment = { start: &quot;/*&quot;, end: &quot;*/&quot; };
    this.getNextLineIndent = function (state, line, tab) {
        var indent = this.$getIndent(line);
        var tokens = this.getTokenizer().getLineTokens(line, state).tokens;
        if (tokens.length &amp;&amp; tokens[tokens.length - 1].type == &quot;comment&quot;) {
            return indent;
        }
        var match = line.match(/^.*\{\s*$/);
        if (match) {
            indent += tab;
        }
        return indent;
    };
    this.checkOutdent = function (state, line, input) {
        return this.$outdent.checkOutdent(line, input);
    };
    this.autoOutdent = function (state, doc, row) {
        this.$outdent.autoOutdent(doc, row);
    };
    this.getCompletions = function (state, session, pos, prefix) {
        return this.$completer.getCompletions(state, session, pos, prefix);
    };
    this.createWorker = function (session) {
        var worker = new WorkerClient([&quot;ace&quot;], &quot;ace/mode/css_worker&quot;, &quot;Worker&quot;);
        worker.attachToDocument(session.getDocument());
        worker.on(&quot;annotate&quot;, function (e) {
            session.setAnnotations(e.data);
        });
        worker.on(&quot;terminate&quot;, function () {
            session.clearAnnotations();
        });
        return worker;
    };
    this.$id = &quot;ace/mode/css&quot;;
    this.snippetFileId = &quot;ace/snippets/css&quot;;
}).call(Mode.prototype);
exports.Mode = Mode;

});

define(&quot;ace/mode/behaviour/xml&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/mode/behaviour&quot;,&quot;ace/token_iterator&quot;,&quot;ace/lib/lang&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;../../lib/oop&quot;);
var Behaviour = require(&quot;../behaviour&quot;).Behaviour;
var TokenIterator = require(&quot;../../token_iterator&quot;).TokenIterator;
var lang = require(&quot;../../lib/lang&quot;);
function is(token, type) {
    return token &amp;&amp; token.type.lastIndexOf(type + &quot;.xml&quot;) &gt; -1;
}
var XmlBehaviour = function () {
    this.add(&quot;string_dquotes&quot;, &quot;insertion&quot;, function (state, action, editor, session, text) {
        if (text == &#039;&quot;&#039; || text == &quot;&#039;&quot;) {
            var quote = text;
            var selected = session.doc.getTextRange(editor.getSelectionRange());
            if (selected !== &quot;&quot; &amp;&amp; selected !== &quot;&#039;&quot; &amp;&amp; selected != &#039;&quot;&#039; &amp;&amp; editor.getWrapBehavioursEnabled()) {
                return {
                    text: quote + selected + quote,
                    selection: false
                };
            }
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            if (rightChar == quote &amp;&amp; (is(token, &quot;attribute-value&quot;) || is(token, &quot;string&quot;))) {
                return {
                    text: &quot;&quot;,
                    selection: [1, 1]
                };
            }
            if (!token)
                token = iterator.stepBackward();
            if (!token)
                return;
            while (is(token, &quot;tag-whitespace&quot;) || is(token, &quot;whitespace&quot;)) {
                token = iterator.stepBackward();
            }
            var rightSpace = !rightChar || rightChar.match(/\s/);
            if (is(token, &quot;attribute-equals&quot;) &amp;&amp; (rightSpace || rightChar == &#039;&gt;&#039;) || (is(token, &quot;decl-attribute-equals&quot;) &amp;&amp; (rightSpace || rightChar == &#039;?&#039;))) {
                return {
                    text: quote + quote,
                    selection: [1, 1]
                };
            }
        }
    });
    this.add(&quot;string_dquotes&quot;, &quot;deletion&quot;, function (state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() &amp;&amp; (selected == &#039;&quot;&#039; || selected == &quot;&#039;&quot;)) {
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == selected) {
                range.end.column++;
                return range;
            }
        }
    });
    this.add(&quot;autoclosing&quot;, &quot;insertion&quot;, function (state, action, editor, session, text) {
        if (text == &#039;&gt;&#039;) {
            var position = editor.getSelectionRange().start;
            var iterator = new TokenIterator(session, position.row, position.column);
            var token = iterator.getCurrentToken() || iterator.stepBackward();
            if (!token || !(is(token, &quot;tag-name&quot;) || is(token, &quot;tag-whitespace&quot;) || is(token, &quot;attribute-name&quot;) || is(token, &quot;attribute-equals&quot;) || is(token, &quot;attribute-value&quot;)))
                return;
            if (is(token, &quot;reference.attribute-value&quot;))
                return;
            if (is(token, &quot;attribute-value&quot;)) {
                var tokenEndColumn = iterator.getCurrentTokenColumn() + token.value.length;
                if (position.column &lt; tokenEndColumn)
                    return;
                if (position.column == tokenEndColumn) {
                    var nextToken = iterator.stepForward();
                    if (nextToken &amp;&amp; is(nextToken, &quot;attribute-value&quot;))
                        return;
                    iterator.stepBackward();
                }
            }
            if (/^\s*&gt;/.test(session.getLine(position.row).slice(position.column)))
                return;
            while (!is(token, &quot;tag-name&quot;)) {
                token = iterator.stepBackward();
                if (token.value == &quot;&lt;&quot;) {
                    token = iterator.stepForward();
                    break;
                }
            }
            var tokenRow = iterator.getCurrentTokenRow();
            var tokenColumn = iterator.getCurrentTokenColumn();
            if (is(iterator.stepBackward(), &quot;end-tag-open&quot;))
                return;
            var element = token.value;
            if (tokenRow == position.row)
                element = element.substring(0, position.column - tokenColumn);
            if (this.voidElements.hasOwnProperty(element.toLowerCase()))
                return;
            return {
                text: &quot;&gt;&quot; + &quot;&lt;/&quot; + element + &quot;&gt;&quot;,
                selection: [1, 1]
            };
        }
    });
    this.add(&quot;autoindent&quot;, &quot;insertion&quot;, function (state, action, editor, session, text) {
        if (text == &quot;\n&quot;) {
            var cursor = editor.getCursorPosition();
            var line = session.getLine(cursor.row);
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            if (token &amp;&amp; token.type.indexOf(&quot;tag-close&quot;) !== -1) {
                if (token.value == &quot;/&gt;&quot;)
                    return;
                while (token &amp;&amp; token.type.indexOf(&quot;tag-name&quot;) === -1) {
                    token = iterator.stepBackward();
                }
                if (!token) {
                    return;
                }
                var tag = token.value;
                var row = iterator.getCurrentTokenRow();
                token = iterator.stepBackward();
                if (!token || token.type.indexOf(&quot;end-tag&quot;) !== -1) {
                    return;
                }
                if (this.voidElements &amp;&amp; !this.voidElements[tag]) {
                    var nextToken = session.getTokenAt(cursor.row, cursor.column + 1);
                    var line = session.getLine(row);
                    var nextIndent = this.$getIndent(line);
                    var indent = nextIndent + session.getTabString();
                    if (nextToken &amp;&amp; nextToken.value === &quot;&lt;/&quot;) {
                        return {
                            text: &quot;\n&quot; + indent + &quot;\n&quot; + nextIndent,
                            selection: [1, indent.length, 1, indent.length]
                        };
                    }
                    else {
                        return {
                            text: &quot;\n&quot; + indent
                        };
                    }
                }
            }
        }
    });
};
oop.inherits(XmlBehaviour, Behaviour);
exports.XmlBehaviour = XmlBehaviour;

});

define(&quot;ace/mode/folding/mixed&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/mode/folding/fold_mode&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;../../lib/oop&quot;);
var BaseFoldMode = require(&quot;./fold_mode&quot;).FoldMode;
var FoldMode = exports.FoldMode = function (defaultMode, subModes) {
    this.defaultMode = defaultMode;
    this.subModes = subModes;
};
oop.inherits(FoldMode, BaseFoldMode);
(function () {
    this.$getMode = function (state) {
        if (typeof state != &quot;string&quot;)
            state = state[0];
        for (var key in this.subModes) {
            if (state.indexOf(key) === 0)
                return this.subModes[key];
        }
        return null;
    };
    this.$tryMode = function (state, session, foldStyle, row) {
        var mode = this.$getMode(state);
        return (mode ? mode.getFoldWidget(session, foldStyle, row) : &quot;&quot;);
    };
    this.getFoldWidget = function (session, foldStyle, row) {
        return (this.$tryMode(session.getState(row - 1), session, foldStyle, row) ||
            this.$tryMode(session.getState(row), session, foldStyle, row) ||
            this.defaultMode.getFoldWidget(session, foldStyle, row));
    };
    this.getFoldWidgetRange = function (session, foldStyle, row) {
        var mode = this.$getMode(session.getState(row - 1));
        if (!mode || !mode.getFoldWidget(session, foldStyle, row))
            mode = this.$getMode(session.getState(row));
        if (!mode || !mode.getFoldWidget(session, foldStyle, row))
            mode = this.defaultMode;
        return mode.getFoldWidgetRange(session, foldStyle, row);
    };
}).call(FoldMode.prototype);

});

define(&quot;ace/mode/folding/xml&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/range&quot;,&quot;ace/mode/folding/fold_mode&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;../../lib/oop&quot;);
var Range = require(&quot;../../range&quot;).Range;
var BaseFoldMode = require(&quot;./fold_mode&quot;).FoldMode;
var FoldMode = exports.FoldMode = function (voidElements, optionalEndTags) {
    BaseFoldMode.call(this);
    this.voidElements = voidElements || {};
    this.optionalEndTags = oop.mixin({}, this.voidElements);
    if (optionalEndTags)
        oop.mixin(this.optionalEndTags, optionalEndTags);
};
oop.inherits(FoldMode, BaseFoldMode);
var Tag = function () {
    this.tagName = &quot;&quot;;
    this.closing = false;
    this.selfClosing = false;
    this.start = { row: 0, column: 0 };
    this.end = { row: 0, column: 0 };
};
function is(token, type) {
    return token.type.lastIndexOf(type + &quot;.xml&quot;) &gt; -1;
}
(function () {
    this.getFoldWidget = function (session, foldStyle, row) {
        var tag = this._getFirstTagInLine(session, row);
        if (!tag)
            return this.getCommentFoldWidget(session, row);
        if (tag.closing || (!tag.tagName &amp;&amp; tag.selfClosing))
            return foldStyle === &quot;markbeginend&quot; ? &quot;end&quot; : &quot;&quot;;
        if (!tag.tagName || tag.selfClosing || this.voidElements.hasOwnProperty(tag.tagName.toLowerCase()))
            return &quot;&quot;;
        if (this._findEndTagInLine(session, row, tag.tagName, tag.end.column))
            return &quot;&quot;;
        return &quot;start&quot;;
    };
    this.getCommentFoldWidget = function (session, row) {
        if (/comment/.test(session.getState(row)) &amp;&amp; /&lt;!-/.test(session.getLine(row)))
            return &quot;start&quot;;
        return &quot;&quot;;
    };
    this._getFirstTagInLine = function (session, row) {
        var tokens = session.getTokens(row);
        var tag = new Tag();
        for (var i = 0; i &lt; tokens.length; i++) {
            var token = tokens[i];
            if (is(token, &quot;tag-open&quot;)) {
                tag.end.column = tag.start.column + token.value.length;
                tag.closing = is(token, &quot;end-tag-open&quot;);
                token = tokens[++i];
                if (!token)
                    return null;
                tag.tagName = token.value;
                tag.end.column += token.value.length;
                for (i++; i &lt; tokens.length; i++) {
                    token = tokens[i];
                    tag.end.column += token.value.length;
                    if (is(token, &quot;tag-close&quot;)) {
                        tag.selfClosing = token.value == &#039;/&gt;&#039;;
                        break;
                    }
                }
                return tag;
            }
            else if (is(token, &quot;tag-close&quot;)) {
                tag.selfClosing = token.value == &#039;/&gt;&#039;;
                return tag;
            }
            tag.start.column += token.value.length;
        }
        return null;
    };
    this._findEndTagInLine = function (session, row, tagName, startColumn) {
        var tokens = session.getTokens(row);
        var column = 0;
        for (var i = 0; i &lt; tokens.length; i++) {
            var token = tokens[i];
            column += token.value.length;
            if (column &lt; startColumn)
                continue;
            if (is(token, &quot;end-tag-open&quot;)) {
                token = tokens[i + 1];
                if (token &amp;&amp; token.value == tagName)
                    return true;
            }
        }
        return false;
    };
    this.getFoldWidgetRange = function (session, foldStyle, row) {
        var tags = session.getMatchingTags({ row: row, column: 0 });
        if (tags) {
            return new Range(tags.openTag.end.row, tags.openTag.end.column, tags.closeTag.start.row, tags.closeTag.start.column);
        }
        else {
            return this.getCommentFoldWidget(session, row)
                &amp;&amp; session.getCommentFoldRange(row, session.getLine(row).length);
        }
    };
}).call(FoldMode.prototype);

});

define(&quot;ace/mode/folding/html&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/mode/folding/mixed&quot;,&quot;ace/mode/folding/xml&quot;,&quot;ace/mode/folding/cstyle&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;../../lib/oop&quot;);
var MixedFoldMode = require(&quot;./mixed&quot;).FoldMode;
var XmlFoldMode = require(&quot;./xml&quot;).FoldMode;
var CStyleFoldMode = require(&quot;./cstyle&quot;).FoldMode;
var FoldMode = exports.FoldMode = function (voidElements, optionalTags) {
    MixedFoldMode.call(this, new XmlFoldMode(voidElements, optionalTags), {
        &quot;js-&quot;: new CStyleFoldMode(),
        &quot;css-&quot;: new CStyleFoldMode()
    });
};
oop.inherits(FoldMode, MixedFoldMode);

});

define(&quot;ace/mode/html_completions&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/token_iterator&quot;], function(require, exports, module){&quot;use strict&quot;;
var TokenIterator = require(&quot;../token_iterator&quot;).TokenIterator;
var commonAttributes = [
    &quot;accesskey&quot;,
    &quot;class&quot;,
    &quot;contenteditable&quot;,
    &quot;contextmenu&quot;,
    &quot;dir&quot;,
    &quot;draggable&quot;,
    &quot;dropzone&quot;,
    &quot;hidden&quot;,
    &quot;id&quot;,
    &quot;inert&quot;,
    &quot;itemid&quot;,
    &quot;itemprop&quot;,
    &quot;itemref&quot;,
    &quot;itemscope&quot;,
    &quot;itemtype&quot;,
    &quot;lang&quot;,
    &quot;spellcheck&quot;,
    &quot;style&quot;,
    &quot;tabindex&quot;,
    &quot;title&quot;,
    &quot;translate&quot;
];
var eventAttributes = [
    &quot;onabort&quot;,
    &quot;onblur&quot;,
    &quot;oncancel&quot;,
    &quot;oncanplay&quot;,
    &quot;oncanplaythrough&quot;,
    &quot;onchange&quot;,
    &quot;onclick&quot;,
    &quot;onclose&quot;,
    &quot;oncontextmenu&quot;,
    &quot;oncuechange&quot;,
    &quot;ondblclick&quot;,
    &quot;ondrag&quot;,
    &quot;ondragend&quot;,
    &quot;ondragenter&quot;,
    &quot;ondragleave&quot;,
    &quot;ondragover&quot;,
    &quot;ondragstart&quot;,
    &quot;ondrop&quot;,
    &quot;ondurationchange&quot;,
    &quot;onemptied&quot;,
    &quot;onended&quot;,
    &quot;onerror&quot;,
    &quot;onfocus&quot;,
    &quot;oninput&quot;,
    &quot;oninvalid&quot;,
    &quot;onkeydown&quot;,
    &quot;onkeypress&quot;,
    &quot;onkeyup&quot;,
    &quot;onload&quot;,
    &quot;onloadeddata&quot;,
    &quot;onloadedmetadata&quot;,
    &quot;onloadstart&quot;,
    &quot;onmousedown&quot;,
    &quot;onmousemove&quot;,
    &quot;onmouseout&quot;,
    &quot;onmouseover&quot;,
    &quot;onmouseup&quot;,
    &quot;onmousewheel&quot;,
    &quot;onpause&quot;,
    &quot;onplay&quot;,
    &quot;onplaying&quot;,
    &quot;onprogress&quot;,
    &quot;onratechange&quot;,
    &quot;onreset&quot;,
    &quot;onscroll&quot;,
    &quot;onseeked&quot;,
    &quot;onseeking&quot;,
    &quot;onselect&quot;,
    &quot;onshow&quot;,
    &quot;onstalled&quot;,
    &quot;onsubmit&quot;,
    &quot;onsuspend&quot;,
    &quot;ontimeupdate&quot;,
    &quot;onvolumechange&quot;,
    &quot;onwaiting&quot;
];
var globalAttributes = commonAttributes.concat(eventAttributes);
var attributeMap = {
    &quot;a&quot;: { &quot;href&quot;: 1, &quot;target&quot;: { &quot;_blank&quot;: 1, &quot;top&quot;: 1 }, &quot;ping&quot;: 1, &quot;rel&quot;: { &quot;nofollow&quot;: 1, &quot;alternate&quot;: 1, &quot;author&quot;: 1, &quot;bookmark&quot;: 1, &quot;help&quot;: 1, &quot;license&quot;: 1, &quot;next&quot;: 1, &quot;noreferrer&quot;: 1, &quot;prefetch&quot;: 1, &quot;prev&quot;: 1, &quot;search&quot;: 1, &quot;tag&quot;: 1 }, &quot;media&quot;: 1, &quot;hreflang&quot;: 1, &quot;type&quot;: 1 },
    &quot;abbr&quot;: {},
    &quot;address&quot;: {},
    &quot;area&quot;: { &quot;shape&quot;: 1, &quot;coords&quot;: 1, &quot;href&quot;: 1, &quot;hreflang&quot;: 1, &quot;alt&quot;: 1, &quot;target&quot;: 1, &quot;media&quot;: 1, &quot;rel&quot;: 1, &quot;ping&quot;: 1, &quot;type&quot;: 1 },
    &quot;article&quot;: { &quot;pubdate&quot;: 1 },
    &quot;aside&quot;: {},
    &quot;audio&quot;: { &quot;src&quot;: 1, &quot;autobuffer&quot;: 1, &quot;autoplay&quot;: { &quot;autoplay&quot;: 1 }, &quot;loop&quot;: { &quot;loop&quot;: 1 }, &quot;controls&quot;: { &quot;controls&quot;: 1 }, &quot;muted&quot;: { &quot;muted&quot;: 1 }, &quot;preload&quot;: { &quot;auto&quot;: 1, &quot;metadata&quot;: 1, &quot;none&quot;: 1 } },
    &quot;b&quot;: {},
    &quot;base&quot;: { &quot;href&quot;: 1, &quot;target&quot;: 1 },
    &quot;bdi&quot;: {},
    &quot;bdo&quot;: {},
    &quot;blockquote&quot;: { &quot;cite&quot;: 1 },
    &quot;body&quot;: { &quot;onafterprint&quot;: 1, &quot;onbeforeprint&quot;: 1, &quot;onbeforeunload&quot;: 1, &quot;onhashchange&quot;: 1, &quot;onmessage&quot;: 1, &quot;onoffline&quot;: 1, &quot;onpopstate&quot;: 1, &quot;onredo&quot;: 1, &quot;onresize&quot;: 1, &quot;onstorage&quot;: 1, &quot;onundo&quot;: 1, &quot;onunload&quot;: 1 },
    &quot;br&quot;: {},
    &quot;button&quot;: { &quot;autofocus&quot;: 1, &quot;disabled&quot;: { &quot;disabled&quot;: 1 }, &quot;form&quot;: 1, &quot;formaction&quot;: 1, &quot;formenctype&quot;: 1, &quot;formmethod&quot;: 1, &quot;formnovalidate&quot;: 1, &quot;formtarget&quot;: 1, &quot;name&quot;: 1, &quot;value&quot;: 1, &quot;type&quot;: { &quot;button&quot;: 1, &quot;submit&quot;: 1 } },
    &quot;canvas&quot;: { &quot;width&quot;: 1, &quot;height&quot;: 1 },
    &quot;caption&quot;: {},
    &quot;cite&quot;: {},
    &quot;code&quot;: {},
    &quot;col&quot;: { &quot;span&quot;: 1 },
    &quot;colgroup&quot;: { &quot;span&quot;: 1 },
    &quot;command&quot;: { &quot;type&quot;: 1, &quot;label&quot;: 1, &quot;icon&quot;: 1, &quot;disabled&quot;: 1, &quot;checked&quot;: 1, &quot;radiogroup&quot;: 1, &quot;command&quot;: 1 },
    &quot;data&quot;: {},
    &quot;datalist&quot;: {},
    &quot;dd&quot;: {},
    &quot;del&quot;: { &quot;cite&quot;: 1, &quot;datetime&quot;: 1 },
    &quot;details&quot;: { &quot;open&quot;: 1 },
    &quot;dfn&quot;: {},
    &quot;dialog&quot;: { &quot;open&quot;: 1 },
    &quot;div&quot;: {},
    &quot;dl&quot;: {},
    &quot;dt&quot;: {},
    &quot;em&quot;: {},
    &quot;embed&quot;: { &quot;src&quot;: 1, &quot;height&quot;: 1, &quot;width&quot;: 1, &quot;type&quot;: 1 },
    &quot;fieldset&quot;: { &quot;disabled&quot;: 1, &quot;form&quot;: 1, &quot;name&quot;: 1 },
    &quot;figcaption&quot;: {},
    &quot;figure&quot;: {},
    &quot;footer&quot;: {},
    &quot;form&quot;: { &quot;accept-charset&quot;: 1, &quot;action&quot;: 1, &quot;autocomplete&quot;: 1, &quot;enctype&quot;: { &quot;multipart/form-data&quot;: 1, &quot;application/x-www-form-urlencoded&quot;: 1 }, &quot;method&quot;: { &quot;get&quot;: 1, &quot;post&quot;: 1 }, &quot;name&quot;: 1, &quot;novalidate&quot;: 1, &quot;target&quot;: { &quot;_blank&quot;: 1, &quot;top&quot;: 1 } },
    &quot;h1&quot;: {},
    &quot;h2&quot;: {},
    &quot;h3&quot;: {},
    &quot;h4&quot;: {},
    &quot;h5&quot;: {},
    &quot;h6&quot;: {},
    &quot;head&quot;: {},
    &quot;header&quot;: {},
    &quot;hr&quot;: {},
    &quot;html&quot;: { &quot;manifest&quot;: 1 },
    &quot;i&quot;: {},
    &quot;iframe&quot;: { &quot;name&quot;: 1, &quot;src&quot;: 1, &quot;height&quot;: 1, &quot;width&quot;: 1, &quot;sandbox&quot;: { &quot;allow-same-origin&quot;: 1, &quot;allow-top-navigation&quot;: 1, &quot;allow-forms&quot;: 1, &quot;allow-scripts&quot;: 1 }, &quot;seamless&quot;: { &quot;seamless&quot;: 1 } },
    &quot;img&quot;: { &quot;alt&quot;: 1, &quot;src&quot;: 1, &quot;height&quot;: 1, &quot;width&quot;: 1, &quot;usemap&quot;: 1, &quot;ismap&quot;: 1 },
    &quot;input&quot;: {
        &quot;type&quot;: { &quot;text&quot;: 1, &quot;password&quot;: 1, &quot;hidden&quot;: 1, &quot;checkbox&quot;: 1, &quot;submit&quot;: 1, &quot;radio&quot;: 1, &quot;file&quot;: 1, &quot;button&quot;: 1, &quot;reset&quot;: 1, &quot;image&quot;: 31, &quot;color&quot;: 1, &quot;date&quot;: 1, &quot;datetime&quot;: 1, &quot;datetime-local&quot;: 1, &quot;email&quot;: 1, &quot;month&quot;: 1, &quot;number&quot;: 1, &quot;range&quot;: 1, &quot;search&quot;: 1, &quot;tel&quot;: 1, &quot;time&quot;: 1, &quot;url&quot;: 1, &quot;week&quot;: 1 },
        &quot;accept&quot;: 1, &quot;alt&quot;: 1, &quot;autocomplete&quot;: { &quot;on&quot;: 1, &quot;off&quot;: 1 }, &quot;autofocus&quot;: { &quot;autofocus&quot;: 1 }, &quot;checked&quot;: { &quot;checked&quot;: 1 }, &quot;disabled&quot;: { &quot;disabled&quot;: 1 }, &quot;form&quot;: 1, &quot;formaction&quot;: 1, &quot;formenctype&quot;: { &quot;application/x-www-form-urlencoded&quot;: 1, &quot;multipart/form-data&quot;: 1, &quot;text/plain&quot;: 1 }, &quot;formmethod&quot;: { &quot;get&quot;: 1, &quot;post&quot;: 1 }, &quot;formnovalidate&quot;: { &quot;formnovalidate&quot;: 1 }, &quot;formtarget&quot;: { &quot;_blank&quot;: 1, &quot;_self&quot;: 1, &quot;_parent&quot;: 1, &quot;_top&quot;: 1 }, &quot;height&quot;: 1, &quot;list&quot;: 1, &quot;max&quot;: 1, &quot;maxlength&quot;: 1, &quot;min&quot;: 1, &quot;multiple&quot;: { &quot;multiple&quot;: 1 }, &quot;name&quot;: 1, &quot;pattern&quot;: 1, &quot;placeholder&quot;: 1, &quot;readonly&quot;: { &quot;readonly&quot;: 1 }, &quot;required&quot;: { &quot;required&quot;: 1 }, &quot;size&quot;: 1, &quot;src&quot;: 1, &quot;step&quot;: 1, &quot;width&quot;: 1, &quot;files&quot;: 1, &quot;value&quot;: 1
    },
    &quot;ins&quot;: { &quot;cite&quot;: 1, &quot;datetime&quot;: 1 },
    &quot;kbd&quot;: {},
    &quot;keygen&quot;: { &quot;autofocus&quot;: 1, &quot;challenge&quot;: { &quot;challenge&quot;: 1 }, &quot;disabled&quot;: { &quot;disabled&quot;: 1 }, &quot;form&quot;: 1, &quot;keytype&quot;: { &quot;rsa&quot;: 1, &quot;dsa&quot;: 1, &quot;ec&quot;: 1 }, &quot;name&quot;: 1 },
    &quot;label&quot;: { &quot;form&quot;: 1, &quot;for&quot;: 1 },
    &quot;legend&quot;: {},
    &quot;li&quot;: { &quot;value&quot;: 1 },
    &quot;link&quot;: { &quot;href&quot;: 1, &quot;hreflang&quot;: 1, &quot;rel&quot;: { &quot;stylesheet&quot;: 1, &quot;icon&quot;: 1 }, &quot;media&quot;: { &quot;all&quot;: 1, &quot;screen&quot;: 1, &quot;print&quot;: 1 }, &quot;type&quot;: { &quot;text/css&quot;: 1, &quot;image/png&quot;: 1, &quot;image/jpeg&quot;: 1, &quot;image/gif&quot;: 1 }, &quot;sizes&quot;: 1 },
    &quot;main&quot;: {},
    &quot;map&quot;: { &quot;name&quot;: 1 },
    &quot;mark&quot;: {},
    &quot;math&quot;: {},
    &quot;menu&quot;: { &quot;type&quot;: 1, &quot;label&quot;: 1 },
    &quot;meta&quot;: { &quot;http-equiv&quot;: { &quot;content-type&quot;: 1 }, &quot;name&quot;: { &quot;description&quot;: 1, &quot;keywords&quot;: 1 }, &quot;content&quot;: { &quot;text/html; charset=UTF-8&quot;: 1 }, &quot;charset&quot;: 1 },
    &quot;meter&quot;: { &quot;value&quot;: 1, &quot;min&quot;: 1, &quot;max&quot;: 1, &quot;low&quot;: 1, &quot;high&quot;: 1, &quot;optimum&quot;: 1 },
    &quot;nav&quot;: {},
    &quot;noscript&quot;: { &quot;href&quot;: 1 },
    &quot;object&quot;: { &quot;param&quot;: 1, &quot;data&quot;: 1, &quot;type&quot;: 1, &quot;height&quot;: 1, &quot;width&quot;: 1, &quot;usemap&quot;: 1, &quot;name&quot;: 1, &quot;form&quot;: 1, &quot;classid&quot;: 1 },
    &quot;ol&quot;: { &quot;start&quot;: 1, &quot;reversed&quot;: 1 },
    &quot;optgroup&quot;: { &quot;disabled&quot;: 1, &quot;label&quot;: 1 },
    &quot;option&quot;: { &quot;disabled&quot;: 1, &quot;selected&quot;: 1, &quot;label&quot;: 1, &quot;value&quot;: 1 },
    &quot;output&quot;: { &quot;for&quot;: 1, &quot;form&quot;: 1, &quot;name&quot;: 1 },
    &quot;p&quot;: {},
    &quot;param&quot;: { &quot;name&quot;: 1, &quot;value&quot;: 1 },
    &quot;pre&quot;: {},
    &quot;progress&quot;: { &quot;value&quot;: 1, &quot;max&quot;: 1 },
    &quot;q&quot;: { &quot;cite&quot;: 1 },
    &quot;rp&quot;: {},
    &quot;rt&quot;: {},
    &quot;ruby&quot;: {},
    &quot;s&quot;: {},
    &quot;samp&quot;: {},
    &quot;script&quot;: { &quot;charset&quot;: 1, &quot;type&quot;: { &quot;text/javascript&quot;: 1 }, &quot;src&quot;: 1, &quot;defer&quot;: 1, &quot;async&quot;: 1 },
    &quot;select&quot;: { &quot;autofocus&quot;: 1, &quot;disabled&quot;: 1, &quot;form&quot;: 1, &quot;multiple&quot;: { &quot;multiple&quot;: 1 }, &quot;name&quot;: 1, &quot;size&quot;: 1, &quot;readonly&quot;: { &quot;readonly&quot;: 1 } },
    &quot;small&quot;: {},
    &quot;source&quot;: { &quot;src&quot;: 1, &quot;type&quot;: 1, &quot;media&quot;: 1 },
    &quot;span&quot;: {},
    &quot;strong&quot;: {},
    &quot;style&quot;: { &quot;type&quot;: 1, &quot;media&quot;: { &quot;all&quot;: 1, &quot;screen&quot;: 1, &quot;print&quot;: 1 }, &quot;scoped&quot;: 1 },
    &quot;sub&quot;: {},
    &quot;sup&quot;: {},
    &quot;svg&quot;: {},
    &quot;table&quot;: { &quot;summary&quot;: 1 },
    &quot;tbody&quot;: {},
    &quot;td&quot;: { &quot;headers&quot;: 1, &quot;rowspan&quot;: 1, &quot;colspan&quot;: 1 },
    &quot;textarea&quot;: { &quot;autofocus&quot;: { &quot;autofocus&quot;: 1 }, &quot;disabled&quot;: { &quot;disabled&quot;: 1 }, &quot;form&quot;: 1, &quot;maxlength&quot;: 1, &quot;name&quot;: 1, &quot;placeholder&quot;: 1, &quot;readonly&quot;: { &quot;readonly&quot;: 1 }, &quot;required&quot;: { &quot;required&quot;: 1 }, &quot;rows&quot;: 1, &quot;cols&quot;: 1, &quot;wrap&quot;: { &quot;on&quot;: 1, &quot;off&quot;: 1, &quot;hard&quot;: 1, &quot;soft&quot;: 1 } },
    &quot;tfoot&quot;: {},
    &quot;th&quot;: { &quot;headers&quot;: 1, &quot;rowspan&quot;: 1, &quot;colspan&quot;: 1, &quot;scope&quot;: 1 },
    &quot;thead&quot;: {},
    &quot;time&quot;: { &quot;datetime&quot;: 1 },
    &quot;title&quot;: {},
    &quot;tr&quot;: {},
    &quot;track&quot;: { &quot;kind&quot;: 1, &quot;src&quot;: 1, &quot;srclang&quot;: 1, &quot;label&quot;: 1, &quot;default&quot;: 1 },
    &quot;section&quot;: {},
    &quot;summary&quot;: {},
    &quot;u&quot;: {},
    &quot;ul&quot;: {},
    &quot;var&quot;: {},
    &quot;video&quot;: { &quot;src&quot;: 1, &quot;autobuffer&quot;: 1, &quot;autoplay&quot;: { &quot;autoplay&quot;: 1 }, &quot;loop&quot;: { &quot;loop&quot;: 1 }, &quot;controls&quot;: { &quot;controls&quot;: 1 }, &quot;width&quot;: 1, &quot;height&quot;: 1, &quot;poster&quot;: 1, &quot;muted&quot;: { &quot;muted&quot;: 1 }, &quot;preload&quot;: { &quot;auto&quot;: 1, &quot;metadata&quot;: 1, &quot;none&quot;: 1 } },
    &quot;wbr&quot;: {}
};
var elements = Object.keys(attributeMap);
function is(token, type) {
    return token.type.lastIndexOf(type + &quot;.xml&quot;) &gt; -1;
}
function findTagName(session, pos) {
    var iterator = new TokenIterator(session, pos.row, pos.column);
    var token = iterator.getCurrentToken();
    while (token &amp;&amp; !is(token, &quot;tag-name&quot;)) {
        token = iterator.stepBackward();
    }
    if (token)
        return token.value;
}
function findAttributeName(session, pos) {
    var iterator = new TokenIterator(session, pos.row, pos.column);
    var token = iterator.getCurrentToken();
    while (token &amp;&amp; !is(token, &quot;attribute-name&quot;)) {
        token = iterator.stepBackward();
    }
    if (token)
        return token.value;
}
var HtmlCompletions = function () {
};
(function () {
    this.getCompletions = function (state, session, pos, prefix) {
        var token = session.getTokenAt(pos.row, pos.column);
        if (!token)
            return [];
        if (is(token, &quot;tag-name&quot;) || is(token, &quot;tag-open&quot;) || is(token, &quot;end-tag-open&quot;))
            return this.getTagCompletions(state, session, pos, prefix);
        if (is(token, &quot;tag-whitespace&quot;) || is(token, &quot;attribute-name&quot;))
            return this.getAttributeCompletions(state, session, pos, prefix);
        if (is(token, &quot;attribute-value&quot;))
            return this.getAttributeValueCompletions(state, session, pos, prefix);
        var line = session.getLine(pos.row).substr(0, pos.column);
        if (/&amp;[a-z]*$/i.test(line))
            return this.getHTMLEntityCompletions(state, session, pos, prefix);
        return [];
    };
    this.getTagCompletions = function (state, session, pos, prefix) {
        return elements.map(function (element) {
            return {
                value: element,
                meta: &quot;tag&quot;,
                score: 1000000
            };
        });
    };
    this.getAttributeCompletions = function (state, session, pos, prefix) {
        var tagName = findTagName(session, pos);
        if (!tagName)
            return [];
        var attributes = globalAttributes;
        if (tagName in attributeMap) {
            attributes = attributes.concat(Object.keys(attributeMap[tagName]));
        }
        return attributes.map(function (attribute) {
            return {
                caption: attribute,
                snippet: attribute + &#039;=&quot;$0&quot;&#039;,
                meta: &quot;attribute&quot;,
                score: 1000000
            };
        });
    };
    this.getAttributeValueCompletions = function (state, session, pos, prefix) {
        var tagName = findTagName(session, pos);
        var attributeName = findAttributeName(session, pos);
        if (!tagName)
            return [];
        var values = [];
        if (tagName in attributeMap &amp;&amp; attributeName in attributeMap[tagName] &amp;&amp; typeof attributeMap[tagName][attributeName] === &quot;object&quot;) {
            values = Object.keys(attributeMap[tagName][attributeName]);
        }
        return values.map(function (value) {
            return {
                caption: value,
                snippet: value,
                meta: &quot;attribute value&quot;,
                score: 1000000
            };
        });
    };
    this.getHTMLEntityCompletions = function (state, session, pos, prefix) {
        var values = [&#039;Aacute;&#039;, &#039;aacute;&#039;, &#039;Acirc;&#039;, &#039;acirc;&#039;, &#039;acute;&#039;, &#039;AElig;&#039;, &#039;aelig;&#039;, &#039;Agrave;&#039;, &#039;agrave;&#039;, &#039;alefsym;&#039;, &#039;Alpha;&#039;, &#039;alpha;&#039;, &#039;amp;&#039;, &#039;and;&#039;, &#039;ang;&#039;, &#039;Aring;&#039;, &#039;aring;&#039;, &#039;asymp;&#039;, &#039;Atilde;&#039;, &#039;atilde;&#039;, &#039;Auml;&#039;, &#039;auml;&#039;, &#039;bdquo;&#039;, &#039;Beta;&#039;, &#039;beta;&#039;, &#039;brvbar;&#039;, &#039;bull;&#039;, &#039;cap;&#039;, &#039;Ccedil;&#039;, &#039;ccedil;&#039;, &#039;cedil;&#039;, &#039;cent;&#039;, &#039;Chi;&#039;, &#039;chi;&#039;, &#039;circ;&#039;, &#039;clubs;&#039;, &#039;cong;&#039;, &#039;copy;&#039;, &#039;crarr;&#039;, &#039;cup;&#039;, &#039;curren;&#039;, &#039;Dagger;&#039;, &#039;dagger;&#039;, &#039;dArr;&#039;, &#039;darr;&#039;, &#039;deg;&#039;, &#039;Delta;&#039;, &#039;delta;&#039;, &#039;diams;&#039;, &#039;divide;&#039;, &#039;Eacute;&#039;, &#039;eacute;&#039;, &#039;Ecirc;&#039;, &#039;ecirc;&#039;, &#039;Egrave;&#039;, &#039;egrave;&#039;, &#039;empty;&#039;, &#039;emsp;&#039;, &#039;ensp;&#039;, &#039;Epsilon;&#039;, &#039;epsilon;&#039;, &#039;equiv;&#039;, &#039;Eta;&#039;, &#039;eta;&#039;, &#039;ETH;&#039;, &#039;eth;&#039;, &#039;Euml;&#039;, &#039;euml;&#039;, &#039;euro;&#039;, &#039;exist;&#039;, &#039;fnof;&#039;, &#039;forall;&#039;, &#039;frac12;&#039;, &#039;frac14;&#039;, &#039;frac34;&#039;, &#039;frasl;&#039;, &#039;Gamma;&#039;, &#039;gamma;&#039;, &#039;ge;&#039;, &#039;gt;&#039;, &#039;hArr;&#039;, &#039;harr;&#039;, &#039;hearts;&#039;, &#039;hellip;&#039;, &#039;Iacute;&#039;, &#039;iacute;&#039;, &#039;Icirc;&#039;, &#039;icirc;&#039;, &#039;iexcl;&#039;, &#039;Igrave;&#039;, &#039;igrave;&#039;, &#039;image;&#039;, &#039;infin;&#039;, &#039;int;&#039;, &#039;Iota;&#039;, &#039;iota;&#039;, &#039;iquest;&#039;, &#039;isin;&#039;, &#039;Iuml;&#039;, &#039;iuml;&#039;, &#039;Kappa;&#039;, &#039;kappa;&#039;, &#039;Lambda;&#039;, &#039;lambda;&#039;, &#039;lang;&#039;, &#039;laquo;&#039;, &#039;lArr;&#039;, &#039;larr;&#039;, &#039;lceil;&#039;, &#039;ldquo;&#039;, &#039;le;&#039;, &#039;lfloor;&#039;, &#039;lowast;&#039;, &#039;loz;&#039;, &#039;lrm;&#039;, &#039;lsaquo;&#039;, &#039;lsquo;&#039;, &#039;lt;&#039;, &#039;macr;&#039;, &#039;mdash;&#039;, &#039;micro;&#039;, &#039;middot;&#039;, &#039;minus;&#039;, &#039;Mu;&#039;, &#039;mu;&#039;, &#039;nabla;&#039;, &#039;nbsp;&#039;, &#039;ndash;&#039;, &#039;ne;&#039;, &#039;ni;&#039;, &#039;not;&#039;, &#039;notin;&#039;, &#039;nsub;&#039;, &#039;Ntilde;&#039;, &#039;ntilde;&#039;, &#039;Nu;&#039;, &#039;nu;&#039;, &#039;Oacute;&#039;, &#039;oacute;&#039;, &#039;Ocirc;&#039;, &#039;ocirc;&#039;, &#039;OElig;&#039;, &#039;oelig;&#039;, &#039;Ograve;&#039;, &#039;ograve;&#039;, &#039;oline;&#039;, &#039;Omega;&#039;, &#039;omega;&#039;, &#039;Omicron;&#039;, &#039;omicron;&#039;, &#039;oplus;&#039;, &#039;or;&#039;, &#039;ordf;&#039;, &#039;ordm;&#039;, &#039;Oslash;&#039;, &#039;oslash;&#039;, &#039;Otilde;&#039;, &#039;otilde;&#039;, &#039;otimes;&#039;, &#039;Ouml;&#039;, &#039;ouml;&#039;, &#039;para;&#039;, &#039;part;&#039;, &#039;permil;&#039;, &#039;perp;&#039;, &#039;Phi;&#039;, &#039;phi;&#039;, &#039;Pi;&#039;, &#039;pi;&#039;, &#039;piv;&#039;, &#039;plusmn;&#039;, &#039;pound;&#039;, &#039;Prime;&#039;, &#039;prime;&#039;, &#039;prod;&#039;, &#039;prop;&#039;, &#039;Psi;&#039;, &#039;psi;&#039;, &#039;quot;&#039;, &#039;radic;&#039;, &#039;rang;&#039;, &#039;raquo;&#039;, &#039;rArr;&#039;, &#039;rarr;&#039;, &#039;rceil;&#039;, &#039;rdquo;&#039;, &#039;real;&#039;, &#039;reg;&#039;, &#039;rfloor;&#039;, &#039;Rho;&#039;, &#039;rho;&#039;, &#039;rlm;&#039;, &#039;rsaquo;&#039;, &#039;rsquo;&#039;, &#039;sbquo;&#039;, &#039;Scaron;&#039;, &#039;scaron;&#039;, &#039;sdot;&#039;, &#039;sect;&#039;, &#039;shy;&#039;, &#039;Sigma;&#039;, &#039;sigma;&#039;, &#039;sigmaf;&#039;, &#039;sim;&#039;, &#039;spades;&#039;, &#039;sub;&#039;, &#039;sube;&#039;, &#039;sum;&#039;, &#039;sup;&#039;, &#039;sup1;&#039;, &#039;sup2;&#039;, &#039;sup3;&#039;, &#039;supe;&#039;, &#039;szlig;&#039;, &#039;Tau;&#039;, &#039;tau;&#039;, &#039;there4;&#039;, &#039;Theta;&#039;, &#039;theta;&#039;, &#039;thetasym;&#039;, &#039;thinsp;&#039;, &#039;THORN;&#039;, &#039;thorn;&#039;, &#039;tilde;&#039;, &#039;times;&#039;, &#039;trade;&#039;, &#039;Uacute;&#039;, &#039;uacute;&#039;, &#039;uArr;&#039;, &#039;uarr;&#039;, &#039;Ucirc;&#039;, &#039;ucirc;&#039;, &#039;Ugrave;&#039;, &#039;ugrave;&#039;, &#039;uml;&#039;, &#039;upsih;&#039;, &#039;Upsilon;&#039;, &#039;upsilon;&#039;, &#039;Uuml;&#039;, &#039;uuml;&#039;, &#039;weierp;&#039;, &#039;Xi;&#039;, &#039;xi;&#039;, &#039;Yacute;&#039;, &#039;yacute;&#039;, &#039;yen;&#039;, &#039;Yuml;&#039;, &#039;yuml;&#039;, &#039;Zeta;&#039;, &#039;zeta;&#039;, &#039;zwj;&#039;, &#039;zwnj;&#039;];
        return values.map(function (value) {
            return {
                caption: value,
                snippet: value,
                meta: &quot;html entity&quot;,
                score: 1000000
            };
        });
    };
}).call(HtmlCompletions.prototype);
exports.HtmlCompletions = HtmlCompletions;

});

define(&quot;ace/mode/html&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/lang&quot;,&quot;ace/mode/text&quot;,&quot;ace/mode/javascript&quot;,&quot;ace/mode/css&quot;,&quot;ace/mode/html_highlight_rules&quot;,&quot;ace/mode/behaviour/xml&quot;,&quot;ace/mode/folding/html&quot;,&quot;ace/mode/html_completions&quot;,&quot;ace/worker/worker_client&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;../lib/oop&quot;);
var lang = require(&quot;../lib/lang&quot;);
var TextMode = require(&quot;./text&quot;).Mode;
var JavaScriptMode = require(&quot;./javascript&quot;).Mode;
var CssMode = require(&quot;./css&quot;).Mode;
var HtmlHighlightRules = require(&quot;./html_highlight_rules&quot;).HtmlHighlightRules;
var XmlBehaviour = require(&quot;./behaviour/xml&quot;).XmlBehaviour;
var HtmlFoldMode = require(&quot;./folding/html&quot;).FoldMode;
var HtmlCompletions = require(&quot;./html_completions&quot;).HtmlCompletions;
var WorkerClient = require(&quot;../worker/worker_client&quot;).WorkerClient;
var voidElements = [&quot;area&quot;, &quot;base&quot;, &quot;br&quot;, &quot;col&quot;, &quot;embed&quot;, &quot;hr&quot;, &quot;img&quot;, &quot;input&quot;, &quot;keygen&quot;, &quot;link&quot;, &quot;meta&quot;, &quot;menuitem&quot;, &quot;param&quot;, &quot;source&quot;, &quot;track&quot;, &quot;wbr&quot;];
var optionalEndTags = [&quot;li&quot;, &quot;dt&quot;, &quot;dd&quot;, &quot;p&quot;, &quot;rt&quot;, &quot;rp&quot;, &quot;optgroup&quot;, &quot;option&quot;, &quot;colgroup&quot;, &quot;td&quot;, &quot;th&quot;];
var Mode = function (options) {
    this.fragmentContext = options &amp;&amp; options.fragmentContext;
    this.HighlightRules = HtmlHighlightRules;
    this.$behaviour = new XmlBehaviour();
    this.$completer = new HtmlCompletions();
    this.createModeDelegates({
        &quot;js-&quot;: JavaScriptMode,
        &quot;css-&quot;: CssMode
    });
    this.foldingRules = new HtmlFoldMode(this.voidElements, lang.arrayToMap(optionalEndTags));
};
oop.inherits(Mode, TextMode);
(function () {
    this.blockComment = { start: &quot;&lt;!--&quot;, end: &quot;--&gt;&quot; };
    this.voidElements = lang.arrayToMap(voidElements);
    this.getNextLineIndent = function (state, line, tab) {
        return this.$getIndent(line);
    };
    this.checkOutdent = function (state, line, input) {
        return false;
    };
    this.getCompletions = function (state, session, pos, prefix) {
        return this.$completer.getCompletions(state, session, pos, prefix);
    };
    this.createWorker = function (session) {
        if (this.constructor != Mode)
            return;
        var worker = new WorkerClient([&quot;ace&quot;], &quot;ace/mode/html_worker&quot;, &quot;Worker&quot;);
        worker.attachToDocument(session.getDocument());
        if (this.fragmentContext)
            worker.call(&quot;setOptions&quot;, [{ context: this.fragmentContext }]);
        worker.on(&quot;error&quot;, function (e) {
            session.setAnnotations(e.data);
        });
        worker.on(&quot;terminate&quot;, function () {
            session.clearAnnotations();
        });
        return worker;
    };
    this.$id = &quot;ace/mode/html&quot;;
    this.snippetFileId = &quot;ace/snippets/html&quot;;
}).call(Mode.prototype);
exports.Mode = Mode;

});

define(&quot;ace/mode/ruby_highlight_rules&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/mode/text_highlight_rules&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;../lib/oop&quot;);
var TextHighlightRules = require(&quot;./text_highlight_rules&quot;).TextHighlightRules;
var constantOtherSymbol = exports.constantOtherSymbol = {
    token: &quot;constant.other.symbol.ruby&quot;,
    regex: &quot;[:](?:[A-Za-z_]|[@$](?=[a-zA-Z0-9_]))[a-zA-Z0-9_]*[!=?]?&quot;
};
exports.qString = {
    token: &quot;string&quot;,
    regex: &quot;[&#039;](?:(?:\\\\.)|(?:[^&#039;\\\\]))*?[&#039;]&quot;
};
exports.qqString = {
    token: &quot;string&quot;,
    regex: &#039;[&quot;](?:(?:\\\\.)|(?:[^&quot;\\\\]))*?[&quot;]&#039;
};
exports.tString = {
    token: &quot;string&quot;,
    regex: &quot;[`](?:(?:\\\\.)|(?:[^&#039;\\\\]))*?[`]&quot;
};
var constantNumericHex = exports.constantNumericHex = {
    token: &quot;constant.numeric&quot;,
    regex: &quot;0[xX][0-9a-fA-F](?:[0-9a-fA-F]|_(?=[0-9a-fA-F]))*\\b&quot;
};
var constantNumericBinary = exports.constantNumericBinary = {
    token: &quot;constant.numeric&quot;,
    regex: /\b(0[bB][01](?:[01]|_(?=[01]))*)\b/
};
var constantNumericDecimal = exports.constantNumericDecimal = {
    token: &quot;constant.numeric&quot;,
    regex: /\b(0[dD](?:[1-9](?:[\d]|_(?=[\d]))*|0))\b/
};
var constantNumericOctal = exports.constantNumericDecimal = {
    token: &quot;constant.numeric&quot;,
    regex: /\b(0[oO]?(?:[1-7](?:[0-7]|_(?=[0-7]))*|0))\b/
};
var constantNumericRational = exports.constantNumericRational = {
    token: &quot;constant.numeric&quot;,
    regex: /\b([\d]+(?:[./][\d]+)?ri?)\b/
};
var constantNumericComplex = exports.constantNumericComplex = {
    token: &quot;constant.numeric&quot;,
    regex: /\b([\d]i)\b/
};
var constantNumericFloat = exports.constantNumericFloat = {
    token: &quot;constant.numeric&quot;,
    regex: &quot;[+-]?\\d(?:\\d|_(?=\\d))*(?:(?:\\.\\d(?:\\d|_(?=\\d))*)?(?:[eE][+-]?\\d+)?)?i?\\b&quot;
};
var instanceVariable = exports.instanceVariable = {
    token: &quot;variable.instance&quot;,
    regex: &quot;@{1,2}[a-zA-Z_\\d]+&quot;
};
var RubyHighlightRules = function () {
    var builtinFunctions = (&quot;abort|Array|assert|assert_equal|assert_not_equal|assert_same|assert_not_same|&quot; +
        &quot;assert_nil|assert_not_nil|assert_match|assert_no_match|assert_in_delta|assert_throws|&quot; +
        &quot;assert_raise|assert_nothing_raised|assert_instance_of|assert_kind_of|assert_respond_to|&quot; +
        &quot;assert_operator|assert_send|assert_difference|assert_no_difference|assert_recognizes|&quot; +
        &quot;assert_generates|assert_response|assert_redirected_to|assert_template|assert_select|&quot; +
        &quot;assert_select_email|assert_select_rjs|assert_select_encoded|css_select|at_exit|&quot; +
        &quot;attr|attr_writer|attr_reader|attr_accessor|attr_accessible|autoload|binding|block_given?|callcc|&quot; +
        &quot;caller|catch|chomp|chomp!|chop|chop!|defined?|delete_via_redirect|eval|exec|exit|&quot; +
        &quot;exit!|fail|Float|flunk|follow_redirect!|fork|form_for|form_tag|format|gets|global_variables|gsub|&quot; +
        &quot;gsub!|get_via_redirect|host!|https?|https!|include|Integer|lambda|link_to|&quot; +
        &quot;link_to_unless_current|link_to_function|link_to_remote|load|local_variables|loop|open|open_session|&quot; +
        &quot;p|print|printf|proc|putc|puts|post_via_redirect|put_via_redirect|raise|rand|&quot; +
        &quot;raw|readline|readlines|redirect?|request_via_redirect|require|scan|select|&quot; +
        &quot;set_trace_func|sleep|split|sprintf|srand|String|stylesheet_link_tag|syscall|system|sub|sub!|test|&quot; +
        &quot;throw|trace_var|trap|untrace_var|atan2|cos|exp|frexp|ldexp|log|log10|sin|sqrt|tan|&quot; +
        &quot;render|javascript_include_tag|csrf_meta_tag|label_tag|text_field_tag|submit_tag|check_box_tag|&quot; +
        &quot;content_tag|radio_button_tag|text_area_tag|password_field_tag|hidden_field_tag|&quot; +
        &quot;fields_for|select_tag|options_for_select|options_from_collection_for_select|collection_select|&quot; +
        &quot;time_zone_select|select_date|select_time|select_datetime|date_select|time_select|datetime_select|&quot; +
        &quot;select_year|select_month|select_day|select_hour|select_minute|select_second|file_field_tag|&quot; +
        &quot;file_field|respond_to|skip_before_filter|around_filter|after_filter|verify|&quot; +
        &quot;protect_from_forgery|rescue_from|helper_method|redirect_to|before_filter|&quot; +
        &quot;send_data|send_file|validates_presence_of|validates_uniqueness_of|validates_length_of|&quot; +
        &quot;validates_format_of|validates_acceptance_of|validates_associated|validates_exclusion_of|&quot; +
        &quot;validates_inclusion_of|validates_numericality_of|validates_with|validates_each|&quot; +
        &quot;authenticate_or_request_with_http_basic|authenticate_or_request_with_http_digest|&quot; +
        &quot;filter_parameter_logging|match|get|post|resources|redirect|scope|assert_routing|&quot; +
        &quot;translate|localize|extract_locale_from_tld|caches_page|expire_page|caches_action|expire_action|&quot; +
        &quot;cache|expire_fragment|expire_cache_for|observe|cache_sweeper|&quot; +
        &quot;has_many|has_one|belongs_to|has_and_belongs_to_many|p|warn|refine|using|module_function|extend|alias_method|&quot; +
        &quot;private_class_method|remove_method|undef_method&quot;);
    var keywords = (&quot;alias|and|BEGIN|begin|break|case|class|def|defined|do|else|elsif|END|end|ensure|&quot; +
        &quot;__FILE__|finally|for|gem|if|in|__LINE__|module|next|not|or|private|protected|public|&quot; +
        &quot;redo|rescue|retry|return|super|then|undef|unless|until|when|while|yield|__ENCODING__|prepend&quot;);
    var buildinConstants = (&quot;true|TRUE|false|FALSE|nil|NIL|ARGF|ARGV|DATA|ENV|RUBY_PLATFORM|RUBY_RELEASE_DATE|&quot; +
        &quot;RUBY_VERSION|STDERR|STDIN|STDOUT|TOPLEVEL_BINDING|RUBY_PATCHLEVEL|RUBY_REVISION|RUBY_COPYRIGHT|RUBY_ENGINE|RUBY_ENGINE_VERSION|RUBY_DESCRIPTION&quot;);
    var builtinVariables = (&quot;$DEBUG|$defout|$FILENAME|$LOAD_PATH|$SAFE|$stdin|$stdout|$stderr|$VERBOSE|&quot; +
        &quot;$!|root_url|flash|session|cookies|params|request|response|logger|self&quot;);
    var keywordMapper = this.$keywords = this.createKeywordMapper({
        &quot;keyword&quot;: keywords,
        &quot;constant.language&quot;: buildinConstants,
        &quot;variable.language&quot;: builtinVariables,
        &quot;support.function&quot;: builtinFunctions,
        &quot;invalid.deprecated&quot;: &quot;debugger&quot; // TODO is this a remnant from js mode?
    }, &quot;identifier&quot;);
    var escapedChars = &quot;\\\\(?:n(?:[1-7][0-7]{0,2}|0)|[nsrtvfbae&#039;\&quot;\\\\]|c(?:\\\\M-)?.|M-(?:\\\\C-|\\\\c)?.|C-(?:\\\\M-)?.|[0-7]{3}|x[\\da-fA-F]{2}|u[\\da-fA-F]{4}|u{[\\da-fA-F]{1,6}(?:\\s[\\da-fA-F]{1,6})*})&quot;;
    var closeParen = {
        &quot;(&quot;: &quot;)&quot;,
        &quot;[&quot;: &quot;]&quot;,
        &quot;{&quot;: &quot;}&quot;,
        &quot;&lt;&quot;: &quot;&gt;&quot;,
        &quot;^&quot;: &quot;^&quot;,
        &quot;|&quot;: &quot;|&quot;,
        &quot;%&quot;: &quot;%&quot;
    };
    this.$rules = {
        &quot;start&quot;: [
            {
                token: &quot;comment&quot;,
                regex: &quot;#.*$&quot;
            }, {
                token: &quot;comment.multiline&quot;,
                regex: &quot;^=begin(?=$|\\s.*$)&quot;,
                next: &quot;comment&quot;
            }, {
                token: &quot;string.regexp&quot;,
                regex: /[/](?=.*\/)/,
                next: &quot;regex&quot;
            },
            [{
                    token: [&quot;constant.other.symbol.ruby&quot;, &quot;string.start&quot;],
                    regex: /(:)?(&quot;)/,
                    push: [{
                            token: &quot;constant.language.escape&quot;,
                            regex: escapedChars
                        }, {
                            token: &quot;paren.start&quot;,
                            regex: /#{/,
                            push: &quot;start&quot;
                        }, {
                            token: &quot;string.end&quot;,
                            regex: /&quot;/,
                            next: &quot;pop&quot;
                        }, {
                            defaultToken: &quot;string&quot;
                        }]
                }, {
                    token: &quot;string.start&quot;,
                    regex: /`/,
                    push: [{
                            token: &quot;constant.language.escape&quot;,
                            regex: escapedChars
                        }, {
                            token: &quot;paren.start&quot;,
                            regex: /#{/,
                            push: &quot;start&quot;
                        }, {
                            token: &quot;string.end&quot;,
                            regex: /`/,
                            next: &quot;pop&quot;
                        }, {
                            defaultToken: &quot;string&quot;
                        }]
                }, {
                    token: [&quot;constant.other.symbol.ruby&quot;, &quot;string.start&quot;],
                    regex: /(:)?(&#039;)/,
                    push: [{
                            token: &quot;constant.language.escape&quot;,
                            regex: /\\[&#039;\\]/
                        }, {
                            token: &quot;string.end&quot;,
                            regex: /&#039;/,
                            next: &quot;pop&quot;
                        }, {
                            defaultToken: &quot;string&quot;
                        }]
                }, {
                    token: &quot;string.start&quot;,
                    regex: /%[qwx]([(\[&lt;{^|%])/, onMatch: function (val, state, stack) {
                        if (stack.length)
                            stack = [];
                        var paren = val[val.length - 1];
                        stack.unshift(paren, state);
                        this.next = &quot;qStateWithoutInterpolation&quot;;
                        return this.token;
                    }
                }, {
                    token: &quot;string.start&quot;,
                    regex: /%[QWX]?([(\[&lt;{^|%])/, onMatch: function (val, state, stack) {
                        if (stack.length)
                            stack = [];
                        var paren = val[val.length - 1];
                        stack.unshift(paren, state);
                        this.next = &quot;qStateWithInterpolation&quot;;
                        return this.token;
                    }
                }, {
                    token: &quot;constant.other.symbol.ruby&quot;,
                    regex: /%[si]([(\[&lt;{^|%])/, onMatch: function (val, state, stack) {
                        if (stack.length)
                            stack = [];
                        var paren = val[val.length - 1];
                        stack.unshift(paren, state);
                        this.next = &quot;sStateWithoutInterpolation&quot;;
                        return this.token;
                    }
                }, {
                    token: &quot;constant.other.symbol.ruby&quot;,
                    regex: /%[SI]([(\[&lt;{^|%])/, onMatch: function (val, state, stack) {
                        if (stack.length)
                            stack = [];
                        var paren = val[val.length - 1];
                        stack.unshift(paren, state);
                        this.next = &quot;sStateWithInterpolation&quot;;
                        return this.token;
                    }
                }, {
                    token: &quot;string.regexp&quot;,
                    regex: /%[r]([(\[&lt;{^|%])/, onMatch: function (val, state, stack) {
                        if (stack.length)
                            stack = [];
                        var paren = val[val.length - 1];
                        stack.unshift(paren, state);
                        this.next = &quot;rState&quot;;
                        return this.token;
                    }
                }],
            {
                token: &quot;punctuation&quot;,
                regex: &quot;::&quot;
            },
            instanceVariable,
            {
                token: &quot;variable.global&quot;,
                regex: &quot;[$][a-zA-Z_\\d]+&quot;
            }, {
                token: &quot;support.class&quot;,
                regex: &quot;[A-Z][a-zA-Z_\\d]*&quot;
            }, {
                token: [&quot;punctuation.operator&quot;, &quot;support.function&quot;],
                regex: /(\.)([a-zA-Z_\d]+)(?=\()/
            }, {
                token: [&quot;punctuation.operator&quot;, &quot;identifier&quot;],
                regex: /(\.)([a-zA-Z_][a-zA-Z_\d]*)/
            }, {
                token: &quot;string.character&quot;,
                regex: &quot;\\B\\?(?:&quot; + escapedChars + &quot;|\\S)&quot;
            }, {
                token: &quot;punctuation.operator&quot;,
                regex: /\?(?=.+:)/
            },
            constantNumericRational,
            constantNumericComplex,
            constantOtherSymbol,
            constantNumericHex,
            constantNumericFloat,
            constantNumericBinary,
            constantNumericDecimal,
            constantNumericOctal,
            {
                token: &quot;constant.language.boolean&quot;,
                regex: &quot;(?:true|false)\\b&quot;
            }, {
                token: keywordMapper,
                regex: &quot;[a-zA-Z_$][a-zA-Z0-9_$]*\\b&quot;
            }, {
                token: &quot;punctuation.separator.key-value&quot;,
                regex: &quot;=&gt;&quot;
            }, {
                stateName: &quot;heredoc&quot;,
                onMatch: function (value, currentState, stack) {
                    var next = (value[2] == &#039;-&#039; || value[2] == &#039;~&#039;) ? &quot;indentedHeredoc&quot; : &quot;heredoc&quot;;
                    var tokens = value.split(this.splitRegex);
                    stack.push(next, tokens[3]);
                    return [
                        { type: &quot;constant&quot;, value: tokens[1] },
                        { type: &quot;string&quot;, value: tokens[2] },
                        { type: &quot;support.class&quot;, value: tokens[3] },
                        { type: &quot;string&quot;, value: tokens[4] }
                    ];
                },
                regex: &quot;(&lt;&lt;[-~]?)([&#039;\&quot;`]?)([\\w]+)([&#039;\&quot;`]?)&quot;,
                rules: {
                    heredoc: [{
                            onMatch: function (value, currentState, stack) {
                                if (value === stack[1]) {
                                    stack.shift();
                                    stack.shift();
                                    this.next = stack[0] || &quot;start&quot;;
                                    return &quot;support.class&quot;;
                                }
                                this.next = &quot;&quot;;
                                return &quot;string&quot;;
                            },
                            regex: &quot;.*$&quot;,
                            next: &quot;start&quot;
                        }],
                    indentedHeredoc: [{
                            token: &quot;string&quot;,
                            regex: &quot;^ +&quot;
                        }, {
                            onMatch: function (value, currentState, stack) {
                                if (value === stack[1]) {
                                    stack.shift();
                                    stack.shift();
                                    this.next = stack[0] || &quot;start&quot;;
                                    return &quot;support.class&quot;;
                                }
                                this.next = &quot;&quot;;
                                return &quot;string&quot;;
                            },
                            regex: &quot;.*$&quot;,
                            next: &quot;start&quot;
                        }]
                }
            }, {
                regex: &quot;$&quot;,
                token: &quot;empty&quot;,
                next: function (currentState, stack) {
                    if (stack[0] === &quot;heredoc&quot; || stack[0] === &quot;indentedHeredoc&quot;)
                        return stack[0];
                    return currentState;
                }
            }, {
                token: &quot;keyword.operator&quot;,
                regex: &quot;!|\\$|%|&amp;|\\*|/|\\-\\-|\\-|\\+\\+|\\+|~|===|==|=|!=|!==|&lt;=|&gt;=|&lt;&lt;=|&gt;&gt;=|&gt;&gt;&gt;=|&lt;&gt;|&lt;|&gt;|!|&amp;&amp;|\\|\\||\\?\\:|\\*=|%=|\\+=|\\-=|&amp;=|\\^=|\\||\\b(?:in|instanceof|new|delete|typeof|void)&quot;
            }, {
                token: &quot;paren.lparen&quot;,
                regex: &quot;[[({]&quot;
            }, {
                token: &quot;paren.rparen&quot;,
                regex: &quot;[\\])}]&quot;,
                onMatch: function (value, currentState, stack) {
                    this.next = &#039;&#039;;
                    if (value == &quot;}&quot; &amp;&amp; stack.length &gt; 1 &amp;&amp; stack[1] != &quot;start&quot;) {
                        stack.shift();
                        this.next = stack.shift();
                    }
                    return this.token;
                }
            }, {
                token: &quot;text&quot;,
                regex: &quot;\\s+&quot;
            }, {
                token: &quot;punctuation.operator&quot;,
                regex: /[?:,;.]/
            }
        ],
        &quot;comment&quot;: [
            {
                token: &quot;comment.multiline&quot;,
                regex: &quot;^=end(?=$|\\s.*$)&quot;,
                next: &quot;start&quot;
            }, {
                token: &quot;comment&quot;,
                regex: &quot;.+&quot;
            }
        ],
        &quot;qStateWithInterpolation&quot;: [{
                token: &quot;string.start&quot;,
                regex: /[(\[&lt;{]/, onMatch: function (val, state, stack) {
                    if (stack.length &amp;&amp; val === stack[0]) {
                        stack.unshift(val, state);
                        return this.token;
                    }
                    return &quot;string&quot;;
                }
            }, {
                token: &quot;constant.language.escape&quot;,
                regex: escapedChars
            }, {
                token: &quot;constant.language.escape&quot;,
                regex: /\\./
            }, {
                token: &quot;paren.start&quot;,
                regex: /#{/,
                push: &quot;start&quot;
            }, {
                token: &quot;string.end&quot;,
                regex: /[)\]&gt;}^|%]/, onMatch: function (val, state, stack) {
                    if (stack.length &amp;&amp; val === closeParen[stack[0]]) {
                        stack.shift();
                        this.next = stack.shift();
                        return this.token;
                    }
                    this.next = &#039;&#039;;
                    return &quot;string&quot;;
                }
            }, {
                defaultToken: &quot;string&quot;
            }],
        &quot;qStateWithoutInterpolation&quot;: [{
                token: &quot;string.start&quot;,
                regex: /[(\[&lt;{]/, onMatch: function (val, state, stack) {
                    if (stack.length &amp;&amp; val === stack[0]) {
                        stack.unshift(val, state);
                        return this.token;
                    }
                    return &quot;string&quot;;
                }
            }, {
                token: &quot;constant.language.escape&quot;,
                regex: /\\[&#039;\\]/
            }, {
                token: &quot;constant.language.escape&quot;,
                regex: /\\./
            }, {
                token: &quot;string.end&quot;,
                regex: /[)\]&gt;}^|%]/, onMatch: function (val, state, stack) {
                    if (stack.length &amp;&amp; val === closeParen[stack[0]]) {
                        stack.shift();
                        this.next = stack.shift();
                        return this.token;
                    }
                    this.next = &#039;&#039;;
                    return &quot;string&quot;;
                }
            }, {
                defaultToken: &quot;string&quot;
            }],
        &quot;sStateWithoutInterpolation&quot;: [{
                token: &quot;constant.other.symbol.ruby&quot;,
                regex: /[(\[&lt;{]/, onMatch: function (val, state, stack) {
                    if (stack.length &amp;&amp; val === stack[0]) {
                        stack.unshift(val, state);
                        return this.token;
                    }
                    return &quot;constant.other.symbol.ruby&quot;;
                }
            }, {
                token: &quot;constant.other.symbol.ruby&quot;,
                regex: /[)\]&gt;}^|%]/, onMatch: function (val, state, stack) {
                    if (stack.length &amp;&amp; val === closeParen[stack[0]]) {
                        stack.shift();
                        this.next = stack.shift();
                        return this.token;
                    }
                    this.next = &#039;&#039;;
                    return &quot;constant.other.symbol.ruby&quot;;
                }
            }, {
                defaultToken: &quot;constant.other.symbol.ruby&quot;
            }],
        &quot;sStateWithInterpolation&quot;: [{
                token: &quot;constant.other.symbol.ruby&quot;,
                regex: /[(\[&lt;{]/, onMatch: function (val, state, stack) {
                    if (stack.length &amp;&amp; val === stack[0]) {
                        stack.unshift(val, state);
                        return this.token;
                    }
                    return &quot;constant.other.symbol.ruby&quot;;
                }
            }, {
                token: &quot;constant.language.escape&quot;,
                regex: escapedChars
            }, {
                token: &quot;constant.language.escape&quot;,
                regex: /\\./
            }, {
                token: &quot;paren.start&quot;,
                regex: /#{/,
                push: &quot;start&quot;
            }, {
                token: &quot;constant.other.symbol.ruby&quot;,
                regex: /[)\]&gt;}^|%]/, onMatch: function (val, state, stack) {
                    if (stack.length &amp;&amp; val === closeParen[stack[0]]) {
                        stack.shift();
                        this.next = stack.shift();
                        return this.token;
                    }
                    this.next = &#039;&#039;;
                    return &quot;constant.other.symbol.ruby&quot;;
                }
            }, {
                defaultToken: &quot;constant.other.symbol.ruby&quot;
            }],
        &quot;rState&quot;: [{
                token: &quot;string.regexp&quot;,
                regex: /[(\[&lt;{]/, onMatch: function (val, state, stack) {
                    if (stack.length &amp;&amp; val === stack[0]) {
                        stack.unshift(val, state);
                        return this.token;
                    }
                    return &quot;constant.language.escape&quot;;
                }
            }, {
                token: &quot;paren.start&quot;,
                regex: /#{/,
                push: &quot;start&quot;
            }, {
                token: &quot;string.regexp&quot;,
                regex: /\//
            }, {
                token: &quot;string.regexp&quot;,
                regex: /[)\]&gt;}^|%][imxouesn]*/, onMatch: function (val, state, stack) {
                    if (stack.length &amp;&amp; val[0] === closeParen[stack[0]]) {
                        stack.shift();
                        this.next = stack.shift();
                        return this.token;
                    }
                    this.next = &#039;&#039;;
                    return &quot;constant.language.escape&quot;;
                }
            },
            { include: &quot;regex&quot; },
            {
                defaultToken: &quot;string.regexp&quot;
            }],
        &quot;regex&quot;: [
            {
                token: &quot;regexp.keyword&quot;,
                regex: /\\[wWdDhHsS]/
            }, {
                token: &quot;constant.language.escape&quot;,
                regex: /\\[AGbBzZ]/
            }, {
                token: &quot;constant.language.escape&quot;,
                regex: /\\g&lt;[a-zA-Z0-9]*&gt;/
            }, {
                token: [&quot;constant.language.escape&quot;, &quot;regexp.keyword&quot;, &quot;constant.language.escape&quot;],
                regex: /(\\p{\^?)(Alnum|Alpha|Blank|Cntrl|Digit|Graph|Lower|Print|Punct|Space|Upper|XDigit|Word|ASCII|Any|Assigned|Arabic|Armenian|Balinese|Bengali|Bopomofo|Braille|Buginese|Buhid|Canadian_Aboriginal|Carian|Cham|Cherokee|Common|Coptic|Cuneiform|Cypriot|Cyrillic|Deseret|Devanagari|Ethiopic|Georgian|Glagolitic|Gothic|Greek|Gujarati|Gurmukhi|Han|Hangul|Hanunoo|Hebrew|Hiragana|Inherited|Kannada|Katakana|Kayah_Li|Kharoshthi|Khmer|Lao|Latin|Lepcha|Limbu|Linear_B|Lycian|Lydian|Malayalam|Mongolian|Myanmar|New_Tai_Lue|Nko|Ogham|Ol_Chiki|Old_Italic|Old_Persian|Oriya|Osmanya|Phags_Pa|Phoenician|Rejang|Runic|Saurashtra|Shavian|Sinhala|Sundanese|Syloti_Nagri|Syriac|Tagalog|Tagbanwa|Tai_Le|Tamil|Telugu|Thaana|Thai|Tibetan|Tifinagh|Ugaritic|Vai|Yi|Ll|Lm|Lt|Lu|Lo|Mn|Mc|Me|Nd|Nl|Pc|Pd|Ps|Pe|Pi|Pf|Po|No|Sm|Sc|Sk|So|Zs|Zl|Zp|Cc|Cf|Cn|Co|Cs|N|L|M|P|S|Z|C)(})/
            }, {
                token: [&quot;constant.language.escape&quot;, &quot;invalid&quot;, &quot;constant.language.escape&quot;],
                regex: /(\\p{\^?)([^/]*)(})/
            }, {
                token: &quot;regexp.keyword.operator&quot;,
                regex: &quot;\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)&quot;
            }, {
                token: &quot;string.regexp&quot;,
                regex: /[/][imxouesn]*/,
                next: &quot;start&quot;
            }, {
                token: &quot;invalid&quot;,
                regex: /\{\d+\b,?\d*\}[+*]|[+*$^?][+*]|[$^][?]|\?{3,}/
            }, {
                token: &quot;constant.language.escape&quot;,
                regex: /\(\?(?:[:=!&gt;]|&lt;&#039;?[a-zA-Z]*&#039;?&gt;|&lt;[=!])|\)|\{\d+\b,?\d*\}|[+*]\?|[()$^+*?.]/
            }, {
                token: &quot;constant.language.delimiter&quot;,
                regex: /\|/
            }, {
                token: &quot;regexp.keyword&quot;,
                regex: /\[\[:(?:alnum|alpha|blank|cntrl|digit|graph|lower|print|punct|space|upper|xdigit|word|ascii):\]\]/
            }, {
                token: &quot;constant.language.escape&quot;,
                regex: /\[\^?/,
                push: &quot;regex_character_class&quot;
            }, {
                defaultToken: &quot;string.regexp&quot;
            }
        ],
        &quot;regex_character_class&quot;: [
            {
                token: &quot;regexp.keyword&quot;,
                regex: /\\[wWdDhHsS]/
            }, {
                token: &quot;regexp.charclass.keyword.operator&quot;,
                regex: &quot;\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)&quot;
            }, {
                token: &quot;constant.language.escape&quot;,
                regex: /&amp;?&amp;?\[\^?/,
                push: &quot;regex_character_class&quot;
            }, {
                token: &quot;constant.language.escape&quot;,
                regex: &quot;]&quot;,
                next: &quot;pop&quot;
            }, {
                token: &quot;constant.language.escape&quot;,
                regex: &quot;-&quot;
            }, {
                defaultToken: &quot;string.regexp.characterclass&quot;
            }
        ]
    };
    this.normalizeRules();
};
oop.inherits(RubyHighlightRules, TextHighlightRules);
exports.RubyHighlightRules = RubyHighlightRules;

});

define(&quot;ace/mode/folding/ruby&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/mode/folding/fold_mode&quot;,&quot;ace/range&quot;,&quot;ace/token_iterator&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;../../lib/oop&quot;);
var BaseFoldMode = require(&quot;./fold_mode&quot;).FoldMode;
var Range = require(&quot;../../range&quot;).Range;
var TokenIterator = require(&quot;../../token_iterator&quot;).TokenIterator;
var FoldMode = exports.FoldMode = function () {
};
oop.inherits(FoldMode, BaseFoldMode);
(function () {
    this.indentKeywords = {
        &quot;class&quot;: 1,
        &quot;def&quot;: 1,
        &quot;module&quot;: 1,
        &quot;do&quot;: 1,
        &quot;unless&quot;: 1,
        &quot;if&quot;: 1,
        &quot;while&quot;: 1,
        &quot;for&quot;: 1,
        &quot;until&quot;: 1,
        &quot;begin&quot;: 1,
        &quot;else&quot;: 0,
        &quot;elsif&quot;: 0,
        &quot;rescue&quot;: 0,
        &quot;ensure&quot;: 0,
        &quot;when&quot;: 0,
        &quot;end&quot;: -1,
        &quot;case&quot;: 1,
        &quot;=begin&quot;: 1,
        &quot;=end&quot;: -1
    };
    this.foldingStartMarker = /(?:\s|^)(def|do|while|class|unless|module|if|for|until|begin|else|elsif|case|rescue|ensure|when)\b|({\s*$)|(=begin)/;
    this.foldingStopMarker = /(=end(?=$|\s.*$))|(^\s*})|\b(end)\b/;
    this.getFoldWidget = function (session, foldStyle, row) {
        var line = session.getLine(row);
        var isStart = this.foldingStartMarker.test(line);
        var isEnd = this.foldingStopMarker.test(line);
        if (isStart &amp;&amp; !isEnd) {
            var match = line.match(this.foldingStartMarker);
            if (match[1]) {
                if (match[1] == &quot;if&quot; || match[1] == &quot;else&quot; || match[1] == &quot;while&quot; || match[1] == &quot;until&quot; || match[1] == &quot;unless&quot;) {
                    if (match[1] == &quot;else&quot; &amp;&amp; /^\s*else\s*$/.test(line) === false) {
                        return;
                    }
                    if (/^\s*(?:if|else|while|until|unless)\s*/.test(line) === false) {
                        return;
                    }
                }
                if (match[1] == &quot;when&quot;) {
                    if (/\sthen\s/.test(line) === true) {
                        return;
                    }
                }
                if (session.getTokenAt(row, match.index + 2).type === &quot;keyword&quot;)
                    return &quot;start&quot;;
            }
            else if (match[3]) {
                if (session.getTokenAt(row, match.index + 1).type === &quot;comment.multiline&quot;)
                    return &quot;start&quot;;
            }
            else {
                return &quot;start&quot;;
            }
        }
        if (foldStyle != &quot;markbeginend&quot; || !isEnd || isStart &amp;&amp; isEnd)
            return &quot;&quot;;
        var match = line.match(this.foldingStopMarker);
        if (match[3] === &quot;end&quot;) {
            if (session.getTokenAt(row, match.index + 1).type === &quot;keyword&quot;)
                return &quot;end&quot;;
        }
        else if (match[1]) {
            if (session.getTokenAt(row, match.index + 1).type === &quot;comment.multiline&quot;)
                return &quot;end&quot;;
        }
        else
            return &quot;end&quot;;
    };
    this.getFoldWidgetRange = function (session, foldStyle, row) {
        var line = session.doc.getLine(row);
        var match = this.foldingStartMarker.exec(line);
        if (match) {
            if (match[1] || match[3])
                return this.rubyBlock(session, row, match.index + 2);
            return this.openingBracketBlock(session, &quot;{&quot;, row, match.index);
        }
        var match = this.foldingStopMarker.exec(line);
        if (match) {
            if (match[3] === &quot;end&quot;) {
                if (session.getTokenAt(row, match.index + 1).type === &quot;keyword&quot;)
                    return this.rubyBlock(session, row, match.index + 1);
            }
            if (match[1] === &quot;=end&quot;) {
                if (session.getTokenAt(row, match.index + 1).type === &quot;comment.multiline&quot;)
                    return this.rubyBlock(session, row, match.index + 1);
            }
            return this.closingBracketBlock(session, &quot;}&quot;, row, match.index + match[0].length);
        }
    };
    this.rubyBlock = function (session, row, column, tokenRange) {
        var stream = new TokenIterator(session, row, column);
        var token = stream.getCurrentToken();
        if (!token || (token.type != &quot;keyword&quot; &amp;&amp; token.type != &quot;comment.multiline&quot;))
            return;
        var val = token.value;
        var line = session.getLine(row);
        switch (token.value) {
            case &quot;if&quot;:
            case &quot;unless&quot;:
            case &quot;while&quot;:
            case &quot;until&quot;:
                var checkToken = new RegExp(&quot;^\\s*&quot; + token.value);
                if (!checkToken.test(line)) {
                    return;
                }
                var dir = this.indentKeywords[val];
                break;
            case &quot;when&quot;:
                if (/\sthen\s/.test(line)) {
                    return;
                }
            case &quot;elsif&quot;:
            case &quot;rescue&quot;:
            case &quot;ensure&quot;:
                var dir = 1;
                break;
            case &quot;else&quot;:
                var checkToken = new RegExp(&quot;^\\s*&quot; + token.value + &quot;\\s*$&quot;);
                if (!checkToken.test(line)) {
                    return;
                }
                var dir = 1;
                break;
            default:
                var dir = this.indentKeywords[val];
                break;
        }
        var stack = [val];
        if (!dir)
            return;
        var startColumn = dir === -1 ? session.getLine(row - 1).length : session.getLine(row).length;
        var startRow = row;
        var ranges = [];
        ranges.push(stream.getCurrentTokenRange());
        stream.step = dir === -1 ? stream.stepBackward : stream.stepForward;
        if (token.type == &quot;comment.multiline&quot;) {
            while (token = stream.step()) {
                if (token.type !== &quot;comment.multiline&quot;)
                    continue;
                if (dir == 1) {
                    startColumn = 6;
                    if (token.value == &quot;=end&quot;) {
                        break;
                    }
                }
                else {
                    if (token.value == &quot;=begin&quot;) {
                        break;
                    }
                }
            }
        }
        else {
            while (token = stream.step()) {
                var ignore = false;
                if (token.type !== &quot;keyword&quot;)
                    continue;
                var level = dir * this.indentKeywords[token.value];
                line = session.getLine(stream.getCurrentTokenRow());
                switch (token.value) {
                    case &quot;do&quot;:
                        for (var i = stream.$tokenIndex - 1; i &gt;= 0; i--) {
                            var prevToken = stream.$rowTokens[i];
                            if (prevToken &amp;&amp; (prevToken.value == &quot;while&quot; || prevToken.value == &quot;until&quot; || prevToken.value == &quot;for&quot;)) {
                                level = 0;
                                break;
                            }
                        }
                        break;
                    case &quot;else&quot;:
                        var checkToken = new RegExp(&quot;^\\s*&quot; + token.value + &quot;\\s*$&quot;);
                        if (!checkToken.test(line) || val == &quot;case&quot;) {
                            level = 0;
                            ignore = true;
                        }
                        break;
                    case &quot;if&quot;:
                    case &quot;unless&quot;:
                    case &quot;while&quot;:
                    case &quot;until&quot;:
                        var checkToken = new RegExp(&quot;^\\s*&quot; + token.value);
                        if (!checkToken.test(line)) {
                            level = 0;
                            ignore = true;
                        }
                        break;
                    case &quot;when&quot;:
                        if (/\sthen\s/.test(line) || val == &quot;case&quot;) {
                            level = 0;
                            ignore = true;
                        }
                        break;
                }
                if (level &gt; 0) {
                    stack.unshift(token.value);
                }
                else if (level &lt;= 0 &amp;&amp; ignore === false) {
                    stack.shift();
                    if (!stack.length) {
                        if ((val == &quot;while&quot; || val == &quot;until&quot; || val == &quot;for&quot;) &amp;&amp; token.value != &quot;do&quot;) {
                            break;
                        }
                        if (token.value == &quot;do&quot; &amp;&amp; dir == -1 &amp;&amp; level != 0)
                            break;
                        if (token.value != &quot;do&quot;)
                            break;
                    }
                    if (level === 0) {
                        stack.unshift(token.value);
                    }
                }
            }
        }
        if (!token)
            return null;
        if (tokenRange) {
            ranges.push(stream.getCurrentTokenRange());
            return ranges;
        }
        var row = stream.getCurrentTokenRow();
        if (dir === -1) {
            if (token.type === &quot;comment.multiline&quot;) {
                var endColumn = 6;
            }
            else {
                var endColumn = session.getLine(row).length;
            }
            return new Range(row, endColumn, startRow - 1, startColumn);
        }
        else
            return new Range(startRow, startColumn, row - 1, session.getLine(row - 1).length);
    };
}).call(FoldMode.prototype);

});

define(&quot;ace/mode/ruby&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/mode/text&quot;,&quot;ace/mode/ruby_highlight_rules&quot;,&quot;ace/mode/matching_brace_outdent&quot;,&quot;ace/range&quot;,&quot;ace/mode/behaviour/cstyle&quot;,&quot;ace/mode/folding/ruby&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;../lib/oop&quot;);
var TextMode = require(&quot;./text&quot;).Mode;
var RubyHighlightRules = require(&quot;./ruby_highlight_rules&quot;).RubyHighlightRules;
var MatchingBraceOutdent = require(&quot;./matching_brace_outdent&quot;).MatchingBraceOutdent;
var Range = require(&quot;../range&quot;).Range;
var CstyleBehaviour = require(&quot;./behaviour/cstyle&quot;).CstyleBehaviour;
var FoldMode = require(&quot;./folding/ruby&quot;).FoldMode;
var Mode = function () {
    this.HighlightRules = RubyHighlightRules;
    this.$outdent = new MatchingBraceOutdent();
    this.$behaviour = new CstyleBehaviour();
    this.foldingRules = new FoldMode();
    this.indentKeywords = this.foldingRules.indentKeywords;
};
oop.inherits(Mode, TextMode);
(function () {
    this.lineCommentStart = &quot;#&quot;;
    this.getNextLineIndent = function (state, line, tab) {
        var indent = this.$getIndent(line);
        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
        var tokens = tokenizedLine.tokens;
        if (tokens.length &amp;&amp; tokens[tokens.length - 1].type == &quot;comment&quot;) {
            return indent;
        }
        if (state == &quot;start&quot;) {
            var match = line.match(/^.*[\{\(\[]\s*$/);
            var startingClassOrMethod = line.match(/^\s*(class|def|module)\s.*$/);
            var startingDoBlock = line.match(/.*do(\s*|\s+\|.*\|\s*)$/);
            var startingConditional = line.match(/^\s*(if|else|when|elsif|unless|while|for|begin|rescue|ensure)\s*/);
            if (match || startingClassOrMethod || startingDoBlock || startingConditional) {
                indent += tab;
            }
        }
        return indent;
    };
    this.checkOutdent = function (state, line, input) {
        return /^\s+(end|else|rescue|ensure)$/.test(line + input) || this.$outdent.checkOutdent(line, input);
    };
    this.autoOutdent = function (state, session, row) {
        var line = session.getLine(row);
        if (/}/.test(line))
            return this.$outdent.autoOutdent(session, row);
        var indent = this.$getIndent(line);
        var prevLine = session.getLine(row - 1);
        var prevIndent = this.$getIndent(prevLine);
        var tab = session.getTabString();
        if (prevIndent.length &lt;= indent.length) {
            if (indent.slice(-tab.length) == tab)
                session.remove(new Range(row, indent.length - tab.length, row, indent.length));
        }
    };
    this.getMatching = function (session, row, column) {
        if (row == undefined) {
            var pos = session.selection.lead;
            column = pos.column;
            row = pos.row;
        }
        var startToken = session.getTokenAt(row, column);
        if (startToken &amp;&amp; startToken.value in this.indentKeywords)
            return this.foldingRules.rubyBlock(session, row, column, true);
    };
    this.$id = &quot;ace/mode/ruby&quot;;
    this.snippetFileId = &quot;ace/snippets/ruby&quot;;
}).call(Mode.prototype);
exports.Mode = Mode;

});

define(&quot;ace/mode/ejs&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/mode/html_highlight_rules&quot;,&quot;ace/mode/javascript_highlight_rules&quot;,&quot;ace/lib/oop&quot;,&quot;ace/mode/html&quot;,&quot;ace/mode/javascript&quot;,&quot;ace/mode/css&quot;,&quot;ace/mode/ruby&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;../lib/oop&quot;);
var HtmlHighlightRules = require(&quot;./html_highlight_rules&quot;).HtmlHighlightRules;
var JavaScriptHighlightRules = require(&quot;./javascript_highlight_rules&quot;).JavaScriptHighlightRules;
var EjsHighlightRules = function (start, end) {
    HtmlHighlightRules.call(this);
    if (!start)
        start = &quot;(?:&lt;%|&lt;\\?|{{)&quot;;
    if (!end)
        end = &quot;(?:%&gt;|\\?&gt;|}})&quot;;
    for (var i in this.$rules) {
        this.$rules[i].unshift({
            token: &quot;markup.list.meta.tag&quot;,
            regex: start + &quot;(?![&gt;}])[-=]?&quot;,
            push: &quot;ejs-start&quot;
        });
    }
    this.embedRules(new JavaScriptHighlightRules({ jsx: false }).getRules(), &quot;ejs-&quot;, [{
            token: &quot;markup.list.meta.tag&quot;,
            regex: &quot;-?&quot; + end,
            next: &quot;pop&quot;
        }, {
            token: &quot;comment&quot;,
            regex: &quot;//.*?&quot; + end,
            next: &quot;pop&quot;
        }]);
    this.normalizeRules();
};
oop.inherits(EjsHighlightRules, HtmlHighlightRules);
exports.EjsHighlightRules = EjsHighlightRules;
var oop = require(&quot;../lib/oop&quot;);
var HtmlMode = require(&quot;./html&quot;).Mode;
var JavaScriptMode = require(&quot;./javascript&quot;).Mode;
var CssMode = require(&quot;./css&quot;).Mode;
var RubyMode = require(&quot;./ruby&quot;).Mode;
var Mode = function () {
    HtmlMode.call(this);
    this.HighlightRules = EjsHighlightRules;
    this.createModeDelegates({
        &quot;js-&quot;: JavaScriptMode,
        &quot;css-&quot;: CssMode,
        &quot;ejs-&quot;: JavaScriptMode
    });
};
oop.inherits(Mode, HtmlMode);
(function () {
    this.$id = &quot;ace/mode/ejs&quot;;
}).call(Mode.prototype);
exports.Mode = Mode;

});                (function() {
                    window.require([&quot;ace/mode/ejs&quot;], function(m) {
                        if (typeof module == &quot;object&quot; &amp;&amp; typeof exports == &quot;object&quot; &amp;&amp; module) {
                            module.exports = m;
                        }
                    });
                })();</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
