<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@istanbuljs/schema/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@istanbuljs/schema/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">77.12</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">466</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">25.18</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.97</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

const defaultExclude = require(&#039;./default-exclude.js&#039;);
const defaultExtension = require(&#039;./default-extension.js&#039;);

const nycCommands = {
	all: [null, &#039;check-coverage&#039;, &#039;instrument&#039;, &#039;merge&#039;, &#039;report&#039;],
	testExclude: [null, &#039;instrument&#039;, &#039;report&#039;, &#039;check-coverage&#039;],
	instrument: [null, &#039;instrument&#039;],
	checkCoverage: [null, &#039;report&#039;, &#039;check-coverage&#039;],
	report: [null, &#039;report&#039;],
	main: [null],
	instrumentOnly: [&#039;instrument&#039;]
};

const cwd = {
	description: &#039;working directory used when resolving paths&#039;,
	type: &#039;string&#039;,
	get default() {
		return process.cwd();
	},
	nycCommands: nycCommands.all
};

const nycrcPath = {
	description: &#039;specify an explicit path to find nyc configuration&#039;,
	nycCommands: nycCommands.all
};

const tempDir = {
	description: &#039;directory to output raw coverage information to&#039;,
	type: &#039;string&#039;,
	default: &#039;./.nyc_output&#039;,
	nycAlias: &#039;t&#039;,
	nycHiddenAlias: &#039;temp-directory&#039;,
	nycCommands: [null, &#039;check-coverage&#039;, &#039;merge&#039;, &#039;report&#039;]
};

const testExclude = {
	exclude: {
		description: &#039;a list of specific files and directories that should be excluded from coverage, glob patterns are supported&#039;,
		type: &#039;array&#039;,
		items: {
			type: &#039;string&#039;
		},
		default: defaultExclude,
		nycCommands: nycCommands.testExclude,
		nycAlias: &#039;x&#039;
	},
	excludeNodeModules: {
		description: &#039;whether or not to exclude all node_module folders (i.e. **/node_modules/**) by default&#039;,
		type: &#039;boolean&#039;,
		default: true,
		nycCommands: nycCommands.testExclude
	},
	include: {
		description: &#039;a list of specific files that should be covered, glob patterns are supported&#039;,
		type: &#039;array&#039;,
		items: {
			type: &#039;string&#039;
		},
		default: [],
		nycCommands: nycCommands.testExclude,
		nycAlias: &#039;n&#039;
	},
	extension: {
		description: &#039;a list of extensions that nyc should handle in addition to .js&#039;,
		type: &#039;array&#039;,
		items: {
			type: &#039;string&#039;
		},
		default: defaultExtension,
		nycCommands: nycCommands.testExclude,
		nycAlias: &#039;e&#039;
	}
};

const instrumentVisitor = {
	coverageVariable: {
		description: &#039;variable to store coverage&#039;,
		type: &#039;string&#039;,
		default: &#039;__coverage__&#039;,
		nycCommands: nycCommands.instrument
	},
	coverageGlobalScope: {
		description: &#039;scope to store the coverage variable&#039;,
		type: &#039;string&#039;,
		default: &#039;this&#039;,
		nycCommands: nycCommands.instrument
	},
	coverageGlobalScopeFunc: {
		description: &#039;avoid potentially replaced `Function` when finding global scope&#039;,
		type: &#039;boolean&#039;,
		default: true,
		nycCommands: nycCommands.instrument
	},
	ignoreClassMethods: {
		description: &#039;class method names to ignore for coverage&#039;,
		type: &#039;array&#039;,
		items: {
			type: &#039;string&#039;
		},
		default: [],
		nycCommands: nycCommands.instrument
	}
};

const instrumentParseGen = {
	autoWrap: {
		description: &#039;allow `return` statements outside of functions&#039;,
		type: &#039;boolean&#039;,
		default: true,
		nycCommands: nycCommands.instrument
	},
	esModules: {
		description: &#039;should files be treated as ES Modules&#039;,
		type: &#039;boolean&#039;,
		default: true,
		nycCommands: nycCommands.instrument
	},
	parserPlugins: {
		description: &#039;babel parser plugins to use when parsing the source&#039;,
		type: &#039;array&#039;,
		items: {
			type: &#039;string&#039;
		},
		/* Babel parser plugins are to be enabled when the feature is stage 3 and
		 * implemented in a released version of node.js. */
		default: [
			&#039;asyncGenerators&#039;,
			&#039;bigInt&#039;,
			&#039;classProperties&#039;,
			&#039;classPrivateProperties&#039;,
			&#039;classPrivateMethods&#039;,
			&#039;dynamicImport&#039;,
			&#039;importMeta&#039;,
			&#039;numericSeparator&#039;,
			&#039;objectRestSpread&#039;,
			&#039;optionalCatchBinding&#039;,
			&#039;topLevelAwait&#039;
		],
		nycCommands: nycCommands.instrument
	},
	compact: {
		description: &#039;should the output be compacted?&#039;,
		type: &#039;boolean&#039;,
		default: true,
		nycCommands: nycCommands.instrument
	},
	preserveComments: {
		description: &#039;should comments be preserved in the output?&#039;,
		type: &#039;boolean&#039;,
		default: true,
		nycCommands: nycCommands.instrument
	},
	produceSourceMap: {
		description: &#039;should source maps be produced?&#039;,
		type: &#039;boolean&#039;,
		default: true,
		nycCommands: nycCommands.instrument
	}
};

const checkCoverage = {
	excludeAfterRemap: {
		description: &#039;should exclude logic be performed after the source-map remaps filenames?&#039;,
		type: &#039;boolean&#039;,
		default: true,
		nycCommands: nycCommands.checkCoverage
	},
	branches: {
		description: &#039;what % of branches must be covered?&#039;,
		type: &#039;number&#039;,
		default: 0,
		minimum: 0,
		maximum: 100,
		nycCommands: nycCommands.checkCoverage
	},
	functions: {
		description: &#039;what % of functions must be covered?&#039;,
		type: &#039;number&#039;,
		default: 0,
		minimum: 0,
		maximum: 100,
		nycCommands: nycCommands.checkCoverage
	},
	lines: {
		description: &#039;what % of lines must be covered?&#039;,
		type: &#039;number&#039;,
		default: 90,
		minimum: 0,
		maximum: 100,
		nycCommands: nycCommands.checkCoverage
	},
	statements: {
		description: &#039;what % of statements must be covered?&#039;,
		type: &#039;number&#039;,
		default: 0,
		minimum: 0,
		maximum: 100,
		nycCommands: nycCommands.checkCoverage
	},
	perFile: {
		description: &#039;check thresholds per file&#039;,
		type: &#039;boolean&#039;,
		default: false,
		nycCommands: nycCommands.checkCoverage
	}
};

const report = {
	checkCoverage: {
		description: &#039;check whether coverage is within thresholds provided&#039;,
		type: &#039;boolean&#039;,
		default: false,
		nycCommands: nycCommands.report
	},
	reporter: {
		description: &#039;coverage reporter(s) to use&#039;,
		type: &#039;array&#039;,
		items: {
			type: &#039;string&#039;
		},
		default: [&#039;text&#039;],
		nycCommands: nycCommands.report,
		nycAlias: &#039;r&#039;
	},
	reportDir: {
		description: &#039;directory to output coverage reports in&#039;,
		type: &#039;string&#039;,
		default: &#039;coverage&#039;,
		nycCommands: nycCommands.report
	},
	showProcessTree: {
		description: &#039;display the tree of spawned processes&#039;,
		type: &#039;boolean&#039;,
		default: false,
		nycCommands: nycCommands.report
	},
	skipEmpty: {
		description: &#039;don\&#039;t show empty files (no lines of code) in report&#039;,
		type: &#039;boolean&#039;,
		default: false,
		nycCommands: nycCommands.report
	},
	skipFull: {
		description: &#039;don\&#039;t show files with 100% statement, branch, and function coverage&#039;,
		type: &#039;boolean&#039;,
		default: false,
		nycCommands: nycCommands.report
	}
};

const nycMain = {
	silent: {
		description: &#039;don\&#039;t output a report after tests finish running&#039;,
		type: &#039;boolean&#039;,
		default: false,
		nycCommands: nycCommands.main,
		nycAlias: &#039;s&#039;
	},
	all: {
		description: &#039;whether or not to instrument all files of the project (not just the ones touched by your test suite)&#039;,
		type: &#039;boolean&#039;,
		default: false,
		nycCommands: nycCommands.main,
		nycAlias: &#039;a&#039;
	},
	eager: {
		description: &#039;instantiate the instrumenter at startup (see https://git.io/vMKZ9)&#039;,
		type: &#039;boolean&#039;,
		default: false,
		nycCommands: nycCommands.main
	},
	cache: {
		description: &#039;cache instrumentation results for improved performance&#039;,
		type: &#039;boolean&#039;,
		default: true,
		nycCommands: nycCommands.main,
		nycAlias: &#039;c&#039;
	},
	cacheDir: {
		description: &#039;explicitly set location for instrumentation cache&#039;,
		type: &#039;string&#039;,
		nycCommands: nycCommands.main
	},
	babelCache: {
		description: &#039;cache babel transpilation results for improved performance&#039;,
		type: &#039;boolean&#039;,
		default: false,
		nycCommands: nycCommands.main
	},
	useSpawnWrap: {
		description: &#039;use spawn-wrap instead of setting process.env.NODE_OPTIONS&#039;,
		type: &#039;boolean&#039;,
		default: false,
		nycCommands: nycCommands.main
	},
	hookRequire: {
		description: &#039;should nyc wrap require?&#039;,
		type: &#039;boolean&#039;,
		default: true,
		nycCommands: nycCommands.main
	},
	hookRunInContext: {
		description: &#039;should nyc wrap vm.runInContext?&#039;,
		type: &#039;boolean&#039;,
		default: false,
		nycCommands: nycCommands.main
	},
	hookRunInThisContext: {
		description: &#039;should nyc wrap vm.runInThisContext?&#039;,
		type: &#039;boolean&#039;,
		default: false,
		nycCommands: nycCommands.main
	},
	clean: {
		description: &#039;should the .nyc_output folder be cleaned before executing tests&#039;,
		type: &#039;boolean&#039;,
		default: true,
		nycCommands: nycCommands.main
	}
};

const instrumentOnly = {
	inPlace: {
		description: &#039;should nyc run the instrumentation in place?&#039;,
		type: &#039;boolean&#039;,
		default: false,
		nycCommands: nycCommands.instrumentOnly
	},
	exitOnError: {
		description: &#039;should nyc exit when an instrumentation failure occurs?&#039;,
		type: &#039;boolean&#039;,
		default: false,
		nycCommands: nycCommands.instrumentOnly
	},
	delete: {
		description: &#039;should the output folder be deleted before instrumenting files?&#039;,
		type: &#039;boolean&#039;,
		default: false,
		nycCommands: nycCommands.instrumentOnly
	},
	completeCopy: {
		description: &#039;should nyc copy all files from input to output as well as instrumented files?&#039;,
		type: &#039;boolean&#039;,
		default: false,
		nycCommands: nycCommands.instrumentOnly
	}
};

const nyc = {
	description: &#039;nyc configuration options&#039;,
	type: &#039;object&#039;,
	properties: {
		cwd,
		nycrcPath,
		tempDir,

		/* Test Exclude */
		...testExclude,

		/* Instrumentation settings */
		...instrumentVisitor,

		/* Instrumentation parser/generator settings */
		...instrumentParseGen,
		sourceMap: {
			description: &#039;should nyc detect and handle source maps?&#039;,
			type: &#039;boolean&#039;,
			default: true,
			nycCommands: nycCommands.instrument
		},
		require: {
			description: &#039;a list of additional modules that nyc should attempt to require in its subprocess, e.g., @babel/register, @babel/polyfill&#039;,
			type: &#039;array&#039;,
			items: {
				type: &#039;string&#039;
			},
			default: [],
			nycCommands: nycCommands.instrument,
			nycAlias: &#039;i&#039;
		},
		instrument: {
			description: &#039;should nyc handle instrumentation?&#039;,
			type: &#039;boolean&#039;,
			default: true,
			nycCommands: nycCommands.instrument
		},

		/* Check coverage */
		...checkCoverage,

		/* Report options */
		...report,

		/* Main command options */
		...nycMain,

		/* Instrument command options */
		...instrumentOnly
	}
};

const configs = {
	nyc,
	testExclude: {
		description: &#039;test-exclude options&#039;,
		type: &#039;object&#039;,
		properties: {
			cwd,
			...testExclude
		}
	},
	babelPluginIstanbul: {
		description: &#039;babel-plugin-istanbul options&#039;,
		type: &#039;object&#039;,
		properties: {
			cwd,
			...testExclude,
			...instrumentVisitor
		}
	},
	instrumentVisitor: {
		description: &#039;instrument visitor options&#039;,
		type: &#039;object&#039;,
		properties: instrumentVisitor
	},
	instrumenter: {
		description: &#039;stand-alone instrumenter options&#039;,
		type: &#039;object&#039;,
		properties: {
			...instrumentVisitor,
			...instrumentParseGen
		}
	}
};

function defaultsReducer(defaults, [name, {default: value}]) {
	/* Modifying arrays in defaults is safe, does not change schema. */
	if (Array.isArray(value)) {
		value = [...value];
	}

	return Object.assign(defaults, {[name]: value});
}

module.exports = {
	...configs,
	defaults: Object.keys(configs).reduce(
		(defaults, id) =&gt; {
			Object.defineProperty(defaults, id, {
				enumerable: true,
				get() {
					/* This defers `process.cwd()` until defaults are requested. */
					return Object.entries(configs[id].properties)
						.filter(([, info]) =&gt; &#039;default&#039; in info)
						.reduce(defaultsReducer, {});
				}
			});

			return defaults;
		},
		{}
	)
};</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
