<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@babel/traverse/lib/path/evaluation.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@babel/traverse/lib/path/evaluation.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">44.45</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">340</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">99.15</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.96</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

Object.defineProperty(exports, &quot;__esModule&quot;, {
  value: true
});
exports.evaluate = evaluate;
exports.evaluateTruthy = evaluateTruthy;
const VALID_CALLEES = [&quot;String&quot;, &quot;Number&quot;, &quot;Math&quot;];
const INVALID_METHODS = [&quot;random&quot;];
function isValidCallee(val) {
  return VALID_CALLEES.includes(val);
}
function isInvalidMethod(val) {
  return INVALID_METHODS.includes(val);
}
function evaluateTruthy() {
  const res = this.evaluate();
  if (res.confident) return !!res.value;
}
function deopt(path, state) {
  if (!state.confident) return;
  state.deoptPath = path;
  state.confident = false;
}
const Globals = new Map([[&quot;undefined&quot;, undefined], [&quot;Infinity&quot;, Infinity], [&quot;NaN&quot;, NaN]]);
function evaluateCached(path, state) {
  const {
    node
  } = path;
  const {
    seen
  } = state;
  if (seen.has(node)) {
    const existing = seen.get(node);
    if (existing.resolved) {
      return existing.value;
    } else {
      deopt(path, state);
      return;
    }
  } else {
    const item = {
      resolved: false
    };
    seen.set(node, item);
    const val = _evaluate(path, state);
    if (state.confident) {
      item.resolved = true;
      item.value = val;
    }
    return val;
  }
}
function _evaluate(path, state) {
  if (!state.confident) return;
  if (path.isSequenceExpression()) {
    const exprs = path.get(&quot;expressions&quot;);
    return evaluateCached(exprs[exprs.length - 1], state);
  }
  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {
    return path.node.value;
  }
  if (path.isNullLiteral()) {
    return null;
  }
  if (path.isTemplateLiteral()) {
    return evaluateQuasis(path, path.node.quasis, state);
  }
  if (path.isTaggedTemplateExpression() &amp;&amp; path.get(&quot;tag&quot;).isMemberExpression()) {
    const object = path.get(&quot;tag.object&quot;);
    const {
      node: {
        name
      }
    } = object;
    const property = path.get(&quot;tag.property&quot;);
    if (object.isIdentifier() &amp;&amp; name === &quot;String&quot; &amp;&amp; !path.scope.getBinding(name) &amp;&amp; property.isIdentifier() &amp;&amp; property.node.name === &quot;raw&quot;) {
      return evaluateQuasis(path, path.node.quasi.quasis, state, true);
    }
  }
  if (path.isConditionalExpression()) {
    const testResult = evaluateCached(path.get(&quot;test&quot;), state);
    if (!state.confident) return;
    if (testResult) {
      return evaluateCached(path.get(&quot;consequent&quot;), state);
    } else {
      return evaluateCached(path.get(&quot;alternate&quot;), state);
    }
  }
  if (path.isExpressionWrapper()) {
    return evaluateCached(path.get(&quot;expression&quot;), state);
  }
  if (path.isMemberExpression() &amp;&amp; !path.parentPath.isCallExpression({
    callee: path.node
  })) {
    const property = path.get(&quot;property&quot;);
    const object = path.get(&quot;object&quot;);
    if (object.isLiteral()) {
      const value = object.node.value;
      const type = typeof value;
      let key = null;
      if (path.node.computed) {
        key = evaluateCached(property, state);
        if (!state.confident) return;
      } else if (property.isIdentifier()) {
        key = property.node.name;
      }
      if ((type === &quot;number&quot; || type === &quot;string&quot;) &amp;&amp; key != null &amp;&amp; (typeof key === &quot;number&quot; || typeof key === &quot;string&quot;)) {
        return value[key];
      }
    }
  }
  if (path.isReferencedIdentifier()) {
    const binding = path.scope.getBinding(path.node.name);
    if (binding) {
      if (binding.constantViolations.length &gt; 0 || path.node.start &lt; binding.path.node.end) {
        deopt(binding.path, state);
        return;
      }
      if (binding.hasValue) {
        return binding.value;
      }
    }
    const name = path.node.name;
    if (Globals.has(name)) {
      if (!binding) {
        return Globals.get(name);
      }
      deopt(binding.path, state);
      return;
    }
    const resolved = path.resolve();
    if (resolved === path) {
      deopt(path, state);
      return;
    } else {
      return evaluateCached(resolved, state);
    }
  }
  if (path.isUnaryExpression({
    prefix: true
  })) {
    if (path.node.operator === &quot;void&quot;) {
      return undefined;
    }
    const argument = path.get(&quot;argument&quot;);
    if (path.node.operator === &quot;typeof&quot; &amp;&amp; (argument.isFunction() || argument.isClass())) {
      return &quot;function&quot;;
    }
    const arg = evaluateCached(argument, state);
    if (!state.confident) return;
    switch (path.node.operator) {
      case &quot;!&quot;:
        return !arg;
      case &quot;+&quot;:
        return +arg;
      case &quot;-&quot;:
        return -arg;
      case &quot;~&quot;:
        return ~arg;
      case &quot;typeof&quot;:
        return typeof arg;
    }
  }
  if (path.isArrayExpression()) {
    const arr = [];
    const elems = path.get(&quot;elements&quot;);
    for (const elem of elems) {
      const elemValue = elem.evaluate();
      if (elemValue.confident) {
        arr.push(elemValue.value);
      } else {
        deopt(elemValue.deopt, state);
        return;
      }
    }
    return arr;
  }
  if (path.isObjectExpression()) {
    const obj = {};
    const props = path.get(&quot;properties&quot;);
    for (const prop of props) {
      if (prop.isObjectMethod() || prop.isSpreadElement()) {
        deopt(prop, state);
        return;
      }
      const keyPath = prop.get(&quot;key&quot;);
      let key;
      if (prop.node.computed) {
        key = keyPath.evaluate();
        if (!key.confident) {
          deopt(key.deopt, state);
          return;
        }
        key = key.value;
      } else if (keyPath.isIdentifier()) {
        key = keyPath.node.name;
      } else {
        key = keyPath.node.value;
      }
      const valuePath = prop.get(&quot;value&quot;);
      let value = valuePath.evaluate();
      if (!value.confident) {
        deopt(value.deopt, state);
        return;
      }
      value = value.value;
      obj[key] = value;
    }
    return obj;
  }
  if (path.isLogicalExpression()) {
    const wasConfident = state.confident;
    const left = evaluateCached(path.get(&quot;left&quot;), state);
    const leftConfident = state.confident;
    state.confident = wasConfident;
    const right = evaluateCached(path.get(&quot;right&quot;), state);
    const rightConfident = state.confident;
    switch (path.node.operator) {
      case &quot;||&quot;:
        state.confident = leftConfident &amp;&amp; (!!left || rightConfident);
        if (!state.confident) return;
        return left || right;
      case &quot;&amp;&amp;&quot;:
        state.confident = leftConfident &amp;&amp; (!left || rightConfident);
        if (!state.confident) return;
        return left &amp;&amp; right;
      case &quot;??&quot;:
        state.confident = leftConfident &amp;&amp; (left != null || rightConfident);
        if (!state.confident) return;
        return left != null ? left : right;
    }
  }
  if (path.isBinaryExpression()) {
    const left = evaluateCached(path.get(&quot;left&quot;), state);
    if (!state.confident) return;
    const right = evaluateCached(path.get(&quot;right&quot;), state);
    if (!state.confident) return;
    switch (path.node.operator) {
      case &quot;-&quot;:
        return left - right;
      case &quot;+&quot;:
        return left + right;
      case &quot;/&quot;:
        return left / right;
      case &quot;*&quot;:
        return left * right;
      case &quot;%&quot;:
        return left % right;
      case &quot;**&quot;:
        return Math.pow(left, right);
      case &quot;&lt;&quot;:
        return left &lt; right;
      case &quot;&gt;&quot;:
        return left &gt; right;
      case &quot;&lt;=&quot;:
        return left &lt;= right;
      case &quot;&gt;=&quot;:
        return left &gt;= right;
      case &quot;==&quot;:
        return left == right;
      case &quot;!=&quot;:
        return left != right;
      case &quot;===&quot;:
        return left === right;
      case &quot;!==&quot;:
        return left !== right;
      case &quot;|&quot;:
        return left | right;
      case &quot;&amp;&quot;:
        return left &amp; right;
      case &quot;^&quot;:
        return left ^ right;
      case &quot;&lt;&lt;&quot;:
        return left &lt;&lt; right;
      case &quot;&gt;&gt;&quot;:
        return left &gt;&gt; right;
      case &quot;&gt;&gt;&gt;&quot;:
        return left &gt;&gt;&gt; right;
    }
  }
  if (path.isCallExpression()) {
    const callee = path.get(&quot;callee&quot;);
    let context;
    let func;
    if (callee.isIdentifier() &amp;&amp; !path.scope.getBinding(callee.node.name) &amp;&amp; isValidCallee(callee.node.name)) {
      func = global[callee.node.name];
    }
    if (callee.isMemberExpression()) {
      const object = callee.get(&quot;object&quot;);
      const property = callee.get(&quot;property&quot;);
      if (object.isIdentifier() &amp;&amp; property.isIdentifier() &amp;&amp; isValidCallee(object.node.name) &amp;&amp; !isInvalidMethod(property.node.name)) {
        context = global[object.node.name];
        func = context[property.node.name];
      }
      if (object.isLiteral() &amp;&amp; property.isIdentifier()) {
        const type = typeof object.node.value;
        if (type === &quot;string&quot; || type === &quot;number&quot;) {
          context = object.node.value;
          func = context[property.node.name];
        }
      }
    }
    if (func) {
      const args = path.get(&quot;arguments&quot;).map(arg =&gt; evaluateCached(arg, state));
      if (!state.confident) return;
      return func.apply(context, args);
    }
  }
  deopt(path, state);
}
function evaluateQuasis(path, quasis, state, raw = false) {
  let str = &quot;&quot;;
  let i = 0;
  const exprs = path.isTemplateLiteral() ? path.get(&quot;expressions&quot;) : path.get(&quot;quasi.expressions&quot;);
  for (const elem of quasis) {
    if (!state.confident) break;
    str += raw ? elem.value.raw : elem.value.cooked;
    const expr = exprs[i++];
    if (expr) str += String(evaluateCached(expr, state));
  }
  if (!state.confident) return;
  return str;
}
function evaluate() {
  const state = {
    confident: true,
    deoptPath: null,
    seen: new Map()
  };
  let value = evaluateCached(this, state);
  if (!state.confident) value = undefined;
  return {
    confident: state.confident,
    deopt: state.deoptPath,
    value: value
  };
}

//# sourceMappingURL=evaluation.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
