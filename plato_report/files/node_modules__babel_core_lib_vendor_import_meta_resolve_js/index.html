<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@babel/core/lib/vendor/import-meta-resolve.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@babel/core/lib/vendor/import-meta-resolve.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">62.30</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">2866</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">208.28</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">50.33</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

Object.defineProperty(exports, &quot;__esModule&quot;, {
  value: true
});
exports.moduleResolve = moduleResolve;
exports.resolve = resolve;
function _url() {
  const data = require(&quot;url&quot;);
  _url = function () {
    return data;
  };
  return data;
}
function _fs() {
  const data = _interopRequireWildcard(require(&quot;fs&quot;), true);
  _fs = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = require(&quot;path&quot;);
  _path = function () {
    return data;
  };
  return data;
}
function _assert() {
  const data = require(&quot;assert&quot;);
  _assert = function () {
    return data;
  };
  return data;
}
function _util() {
  const data = require(&quot;util&quot;);
  _util = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== &quot;function&quot;) return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop &amp;&amp; obj &amp;&amp; obj.__esModule) { return obj; } if (obj === null || typeof obj !== &quot;object&quot; &amp;&amp; typeof obj !== &quot;function&quot;) { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache &amp;&amp; cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== &quot;default&quot; &amp;&amp; Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc &amp;&amp; (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, &quot;next&quot;, value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, &quot;throw&quot;, err); } _next(undefined); }); }; }
var re$3 = {
  exports: {}
};
const SEMVER_SPEC_VERSION = &#039;2.0.0&#039;;
const MAX_LENGTH$2 = 256;
const MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || 9007199254740991;
const MAX_SAFE_COMPONENT_LENGTH = 16;
var constants = {
  SEMVER_SPEC_VERSION,
  MAX_LENGTH: MAX_LENGTH$2,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  MAX_SAFE_COMPONENT_LENGTH
};
const debug$1 = typeof process === &#039;object&#039; &amp;&amp; process.env &amp;&amp; process.env.NODE_DEBUG &amp;&amp; /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) =&gt; console.error(&#039;SEMVER&#039;, ...args) : () =&gt; {};
var debug_1 = debug$1;
(function (module, exports) {
  const {
    MAX_SAFE_COMPONENT_LENGTH
  } = constants;
  const debug = debug_1;
  exports = module.exports = {};
  const re = exports.re = [];
  const src = exports.src = [];
  const t = exports.t = {};
  let R = 0;
  const createToken = (name, value, isGlobal) =&gt; {
    const index = R++;
    debug(name, index, value);
    t[name] = index;
    src[index] = value;
    re[index] = new RegExp(value, isGlobal ? &#039;g&#039; : undefined);
  };
  createToken(&#039;NUMERICIDENTIFIER&#039;, &#039;0|[1-9]\\d*&#039;);
  createToken(&#039;NUMERICIDENTIFIERLOOSE&#039;, &#039;[0-9]+&#039;);
  createToken(&#039;NONNUMERICIDENTIFIER&#039;, &#039;\\d*[a-zA-Z-][a-zA-Z0-9-]*&#039;);
  createToken(&#039;MAINVERSION&#039;, `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})`);
  createToken(&#039;MAINVERSIONLOOSE&#039;, `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})`);
  createToken(&#039;PRERELEASEIDENTIFIER&#039;, `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
  createToken(&#039;PRERELEASEIDENTIFIERLOOSE&#039;, `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
  createToken(&#039;PRERELEASE&#039;, `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
  createToken(&#039;PRERELEASELOOSE&#039;, `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken(&#039;BUILDIDENTIFIER&#039;, &#039;[0-9A-Za-z-]+&#039;);
  createToken(&#039;BUILD&#039;, `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
  createToken(&#039;FULLPLAIN&#039;, `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
  createToken(&#039;FULL&#039;, `^${src[t.FULLPLAIN]}$`);
  createToken(&#039;LOOSEPLAIN&#039;, `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
  createToken(&#039;LOOSE&#039;, `^${src[t.LOOSEPLAIN]}$`);
  createToken(&#039;GTLT&#039;, &#039;((?:&lt;|&gt;)?=?)&#039;);
  createToken(&#039;XRANGEIDENTIFIERLOOSE&#039;, `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken(&#039;XRANGEIDENTIFIER&#039;, `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken(&#039;XRANGEPLAIN&#039;, `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` + `)?)?`);
  createToken(&#039;XRANGEPLAINLOOSE&#039;, `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` + `)?)?`);
  createToken(&#039;XRANGE&#039;, `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
  createToken(&#039;XRANGELOOSE&#039;, `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
  createToken(&#039;COERCE&#039;, `${&#039;(^|[^\\d])&#039; + &#039;(\\d{1,&#039;}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:$|[^\\d])`);
  createToken(&#039;COERCERTL&#039;, src[t.COERCE], true);
  createToken(&#039;LONETILDE&#039;, &#039;(?:~&gt;?)&#039;);
  createToken(&#039;TILDETRIM&#039;, `(\\s*)${src[t.LONETILDE]}\\s+`, true);
  exports.tildeTrimReplace = &#039;$1~&#039;;
  createToken(&#039;TILDE&#039;, `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
  createToken(&#039;TILDELOOSE&#039;, `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
  createToken(&#039;LONECARET&#039;, &#039;(?:\\^)&#039;);
  createToken(&#039;CARETTRIM&#039;, `(\\s*)${src[t.LONECARET]}\\s+`, true);
  exports.caretTrimReplace = &#039;$1^&#039;;
  createToken(&#039;CARET&#039;, `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
  createToken(&#039;CARETLOOSE&#039;, `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
  createToken(&#039;COMPARATORLOOSE&#039;, `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
  createToken(&#039;COMPARATOR&#039;, `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
  createToken(&#039;COMPARATORTRIM&#039;, `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
  exports.comparatorTrimReplace = &#039;$1$2$3&#039;;
  createToken(&#039;HYPHENRANGE&#039;, `^\\s*(${src[t.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAIN]})` + `\\s*$`);
  createToken(&#039;HYPHENRANGELOOSE&#039;, `^\\s*(${src[t.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAINLOOSE]})` + `\\s*$`);
  createToken(&#039;STAR&#039;, &#039;(&lt;|&gt;)?=?\\s*\\*&#039;);
  createToken(&#039;GTE0&#039;, &#039;^\\s*&gt;=\\s*0\\.0\\.0\\s*$&#039;);
  createToken(&#039;GTE0PRE&#039;, &#039;^\\s*&gt;=\\s*0\\.0\\.0-0\\s*$&#039;);
})(re$3, re$3.exports);
const opts = [&#039;includePrerelease&#039;, &#039;loose&#039;, &#039;rtl&#039;];
const parseOptions$2 = options =&gt; !options ? {} : typeof options !== &#039;object&#039; ? {
  loose: true
} : opts.filter(k =&gt; options[k]).reduce((o, k) =&gt; {
  o[k] = true;
  return o;
}, {});
var parseOptions_1 = parseOptions$2;
const numeric = /^[0-9]+$/;
const compareIdentifiers$1 = (a, b) =&gt; {
  const anum = numeric.test(a);
  const bnum = numeric.test(b);
  if (anum &amp;&amp; bnum) {
    a = +a;
    b = +b;
  }
  return a === b ? 0 : anum &amp;&amp; !bnum ? -1 : bnum &amp;&amp; !anum ? 1 : a &lt; b ? -1 : 1;
};
const rcompareIdentifiers = (a, b) =&gt; compareIdentifiers$1(b, a);
var identifiers = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers
};
const debug = debug_1;
const {
  MAX_LENGTH: MAX_LENGTH$1,
  MAX_SAFE_INTEGER
} = constants;
const {
  re: re$2,
  t: t$2
} = re$3.exports;
const parseOptions$1 = parseOptions_1;
const {
  compareIdentifiers
} = identifiers;
class SemVer$c {
  constructor(version, options) {
    options = parseOptions$1(options);
    if (version instanceof SemVer$c) {
      if (version.loose === !!options.loose &amp;&amp; version.includePrerelease === !!options.includePrerelease) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== &#039;string&#039;) {
      throw new TypeError(`Invalid Version: ${version}`);
    }
    if (version.length &gt; MAX_LENGTH$1) {
      throw new TypeError(`version is longer than ${MAX_LENGTH$1} characters`);
    }
    debug(&#039;SemVer&#039;, version, options);
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    const m = version.trim().match(options.loose ? re$2[t$2.LOOSE] : re$2[t$2.FULL]);
    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`);
    }
    this.raw = version;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major &gt; MAX_SAFE_INTEGER || this.major &lt; 0) {
      throw new TypeError(&#039;Invalid major version&#039;);
    }
    if (this.minor &gt; MAX_SAFE_INTEGER || this.minor &lt; 0) {
      throw new TypeError(&#039;Invalid minor version&#039;);
    }
    if (this.patch &gt; MAX_SAFE_INTEGER || this.patch &lt; 0) {
      throw new TypeError(&#039;Invalid patch version&#039;);
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(&#039;.&#039;).map(id =&gt; {
        if (/^[0-9]+$/.test(id)) {
          const num = +id;
          if (num &gt;= 0 &amp;&amp; num &lt; MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m[5] ? m[5].split(&#039;.&#039;) : [];
    this.format();
  }
  format() {
    this.version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join(&#039;.&#039;)}`;
    }
    return this.version;
  }
  toString() {
    return this.version;
  }
  compare(other) {
    debug(&#039;SemVer.compare&#039;, this.version, this.options, other);
    if (!(other instanceof SemVer$c)) {
      if (typeof other === &#039;string&#039; &amp;&amp; other === this.version) {
        return 0;
      }
      other = new SemVer$c(other, this.options);
    }
    if (other.version === this.version) {
      return 0;
    }
    return this.compareMain(other) || this.comparePre(other);
  }
  compareMain(other) {
    if (!(other instanceof SemVer$c)) {
      other = new SemVer$c(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  }
  comparePre(other) {
    if (!(other instanceof SemVer$c)) {
      other = new SemVer$c(other, this.options);
    }
    if (this.prerelease.length &amp;&amp; !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length &amp;&amp; other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length &amp;&amp; !other.prerelease.length) {
      return 0;
    }
    let i = 0;
    do {
      const a = this.prerelease[i];
      const b = other.prerelease[i];
      debug(&#039;prerelease compare&#039;, i, a, b);
      if (a === undefined &amp;&amp; b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a === undefined) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  }
  compareBuild(other) {
    if (!(other instanceof SemVer$c)) {
      other = new SemVer$c(other, this.options);
    }
    let i = 0;
    do {
      const a = this.build[i];
      const b = other.build[i];
      debug(&#039;prerelease compare&#039;, i, a, b);
      if (a === undefined &amp;&amp; b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a === undefined) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  }
  inc(release, identifier) {
    switch (release) {
      case &#039;premajor&#039;:
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc(&#039;pre&#039;, identifier);
        break;
      case &#039;preminor&#039;:
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc(&#039;pre&#039;, identifier);
        break;
      case &#039;prepatch&#039;:
        this.prerelease.length = 0;
        this.inc(&#039;patch&#039;, identifier);
        this.inc(&#039;pre&#039;, identifier);
        break;
      case &#039;prerelease&#039;:
        if (this.prerelease.length === 0) {
          this.inc(&#039;patch&#039;, identifier);
        }
        this.inc(&#039;pre&#039;, identifier);
        break;
      case &#039;major&#039;:
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case &#039;minor&#039;:
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case &#039;patch&#039;:
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case &#039;pre&#039;:
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          let i = this.prerelease.length;
          while (--i &gt;= 0) {
            if (typeof this.prerelease[i] === &#039;number&#039;) {
              this.prerelease[i]++;
              i = -2;
            }
          }
          if (i === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error(`invalid increment argument: ${release}`);
    }
    this.format();
    this.raw = this.version;
    return this;
  }
}
var semver$2 = SemVer$c;
const {
  MAX_LENGTH
} = constants;
const {
  re: re$1,
  t: t$1
} = re$3.exports;
const SemVer$b = semver$2;
const parseOptions = parseOptions_1;
const parse$5 = (version, options) =&gt; {
  options = parseOptions(options);
  if (version instanceof SemVer$b) {
    return version;
  }
  if (typeof version !== &#039;string&#039;) {
    return null;
  }
  if (version.length &gt; MAX_LENGTH) {
    return null;
  }
  const r = options.loose ? re$1[t$1.LOOSE] : re$1[t$1.FULL];
  if (!r.test(version)) {
    return null;
  }
  try {
    return new SemVer$b(version, options);
  } catch (er) {
    return null;
  }
};
var parse_1 = parse$5;
const parse$4 = parse_1;
const valid$1 = (version, options) =&gt; {
  const v = parse$4(version, options);
  return v ? v.version : null;
};
var valid_1 = valid$1;
const parse$3 = parse_1;
const clean = (version, options) =&gt; {
  const s = parse$3(version.trim().replace(/^[=v]+/, &#039;&#039;), options);
  return s ? s.version : null;
};
var clean_1 = clean;
const SemVer$a = semver$2;
const inc = (version, release, options, identifier) =&gt; {
  if (typeof options === &#039;string&#039;) {
    identifier = options;
    options = undefined;
  }
  try {
    return new SemVer$a(version instanceof SemVer$a ? version.version : version, options).inc(release, identifier).version;
  } catch (er) {
    return null;
  }
};
var inc_1 = inc;
const SemVer$9 = semver$2;
const compare$a = (a, b, loose) =&gt; new SemVer$9(a, loose).compare(new SemVer$9(b, loose));
var compare_1 = compare$a;
const compare$9 = compare_1;
const eq$2 = (a, b, loose) =&gt; compare$9(a, b, loose) === 0;
var eq_1 = eq$2;
const parse$2 = parse_1;
const eq$1 = eq_1;
const diff = (version1, version2) =&gt; {
  if (eq$1(version1, version2)) {
    return null;
  } else {
    const v1 = parse$2(version1);
    const v2 = parse$2(version2);
    const hasPre = v1.prerelease.length || v2.prerelease.length;
    const prefix = hasPre ? &#039;pre&#039; : &#039;&#039;;
    const defaultResult = hasPre ? &#039;prerelease&#039; : &#039;&#039;;
    for (const key in v1) {
      if (key === &#039;major&#039; || key === &#039;minor&#039; || key === &#039;patch&#039;) {
        if (v1[key] !== v2[key]) {
          return prefix + key;
        }
      }
    }
    return defaultResult;
  }
};
var diff_1 = diff;
const SemVer$8 = semver$2;
const major = (a, loose) =&gt; new SemVer$8(a, loose).major;
var major_1 = major;
const SemVer$7 = semver$2;
const minor = (a, loose) =&gt; new SemVer$7(a, loose).minor;
var minor_1 = minor;
const SemVer$6 = semver$2;
const patch = (a, loose) =&gt; new SemVer$6(a, loose).patch;
var patch_1 = patch;
const parse$1 = parse_1;
const prerelease = (version, options) =&gt; {
  const parsed = parse$1(version, options);
  return parsed &amp;&amp; parsed.prerelease.length ? parsed.prerelease : null;
};
var prerelease_1 = prerelease;
const compare$8 = compare_1;
const rcompare = (a, b, loose) =&gt; compare$8(b, a, loose);
var rcompare_1 = rcompare;
const compare$7 = compare_1;
const compareLoose = (a, b) =&gt; compare$7(a, b, true);
var compareLoose_1 = compareLoose;
const SemVer$5 = semver$2;
const compareBuild$2 = (a, b, loose) =&gt; {
  const versionA = new SemVer$5(a, loose);
  const versionB = new SemVer$5(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
var compareBuild_1 = compareBuild$2;
const compareBuild$1 = compareBuild_1;
const sort = (list, loose) =&gt; list.sort((a, b) =&gt; compareBuild$1(a, b, loose));
var sort_1 = sort;
const compareBuild = compareBuild_1;
const rsort = (list, loose) =&gt; list.sort((a, b) =&gt; compareBuild(b, a, loose));
var rsort_1 = rsort;
const compare$6 = compare_1;
const gt$3 = (a, b, loose) =&gt; compare$6(a, b, loose) &gt; 0;
var gt_1 = gt$3;
const compare$5 = compare_1;
const lt$2 = (a, b, loose) =&gt; compare$5(a, b, loose) &lt; 0;
var lt_1 = lt$2;
const compare$4 = compare_1;
const neq$1 = (a, b, loose) =&gt; compare$4(a, b, loose) !== 0;
var neq_1 = neq$1;
const compare$3 = compare_1;
const gte$2 = (a, b, loose) =&gt; compare$3(a, b, loose) &gt;= 0;
var gte_1 = gte$2;
const compare$2 = compare_1;
const lte$2 = (a, b, loose) =&gt; compare$2(a, b, loose) &lt;= 0;
var lte_1 = lte$2;
const eq = eq_1;
const neq = neq_1;
const gt$2 = gt_1;
const gte$1 = gte_1;
const lt$1 = lt_1;
const lte$1 = lte_1;
const cmp = (a, op, b, loose) =&gt; {
  switch (op) {
    case &#039;===&#039;:
      if (typeof a === &#039;object&#039;) {
        a = a.version;
      }
      if (typeof b === &#039;object&#039;) {
        b = b.version;
      }
      return a === b;
    case &#039;!==&#039;:
      if (typeof a === &#039;object&#039;) {
        a = a.version;
      }
      if (typeof b === &#039;object&#039;) {
        b = b.version;
      }
      return a !== b;
    case &#039;&#039;:
    case &#039;=&#039;:
    case &#039;==&#039;:
      return eq(a, b, loose);
    case &#039;!=&#039;:
      return neq(a, b, loose);
    case &#039;&gt;&#039;:
      return gt$2(a, b, loose);
    case &#039;&gt;=&#039;:
      return gte$1(a, b, loose);
    case &#039;&lt;&#039;:
      return lt$1(a, b, loose);
    case &#039;&lt;=&#039;:
      return lte$1(a, b, loose);
    default:
      throw new TypeError(`Invalid operator: ${op}`);
  }
};
var cmp_1 = cmp;
const SemVer$4 = semver$2;
const parse = parse_1;
const {
  re,
  t
} = re$3.exports;
const coerce = (version, options) =&gt; {
  if (version instanceof SemVer$4) {
    return version;
  }
  if (typeof version === &#039;number&#039;) {
    version = String(version);
  }
  if (typeof version !== &#039;string&#039;) {
    return null;
  }
  options = options || {};
  let match = null;
  if (!options.rtl) {
    match = version.match(re[t.COERCE]);
  } else {
    let next;
    while ((next = re[t.COERCERTL].exec(version)) &amp;&amp; (!match || match.index + match[0].length !== version.length)) {
      if (!match || next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
    }
    re[t.COERCERTL].lastIndex = -1;
  }
  if (match === null) {
    return null;
  }
  return parse(`${match[2]}.${match[3] || &#039;0&#039;}.${match[4] || &#039;0&#039;}`, options);
};
var coerce_1 = coerce;
var iterator;
var hasRequiredIterator;
function requireIterator() {
  if (hasRequiredIterator) return iterator;
  hasRequiredIterator = 1;
  iterator = function (Yallist) {
    Yallist.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head; walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
  return iterator;
}
var yallist;
var hasRequiredYallist;
function requireYallist() {
  if (hasRequiredYallist) return yallist;
  hasRequiredYallist = 1;
  yallist = Yallist;
  Yallist.Node = Node;
  Yallist.create = Yallist;
  function Yallist(list) {
    var self = this;
    if (!(self instanceof Yallist)) {
      self = new Yallist();
    }
    self.tail = null;
    self.head = null;
    self.length = 0;
    if (list &amp;&amp; typeof list.forEach === &#039;function&#039;) {
      list.forEach(function (item) {
        self.push(item);
      });
    } else if (arguments.length &gt; 0) {
      for (var i = 0, l = arguments.length; i &lt; l; i++) {
        self.push(arguments[i]);
      }
    }
    return self;
  }
  Yallist.prototype.removeNode = function (node) {
    if (node.list !== this) {
      throw new Error(&#039;removing node which does not belong to this list&#039;);
    }
    var next = node.next;
    var prev = node.prev;
    if (next) {
      next.prev = prev;
    }
    if (prev) {
      prev.next = next;
    }
    if (node === this.head) {
      this.head = next;
    }
    if (node === this.tail) {
      this.tail = prev;
    }
    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next;
  };
  Yallist.prototype.unshiftNode = function (node) {
    if (node === this.head) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var head = this.head;
    node.list = this;
    node.next = head;
    if (head) {
      head.prev = node;
    }
    this.head = node;
    if (!this.tail) {
      this.tail = node;
    }
    this.length++;
  };
  Yallist.prototype.pushNode = function (node) {
    if (node === this.tail) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var tail = this.tail;
    node.list = this;
    node.prev = tail;
    if (tail) {
      tail.next = node;
    }
    this.tail = node;
    if (!this.head) {
      this.head = node;
    }
    this.length++;
  };
  Yallist.prototype.push = function () {
    for (var i = 0, l = arguments.length; i &lt; l; i++) {
      push(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.unshift = function () {
    for (var i = 0, l = arguments.length; i &lt; l; i++) {
      unshift(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.pop = function () {
    if (!this.tail) {
      return undefined;
    }
    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) {
      this.tail.next = null;
    } else {
      this.head = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.shift = function () {
    if (!this.head) {
      return undefined;
    }
    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) {
      this.head.prev = null;
    } else {
      this.tail = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.forEach = function (fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.head, i = 0; walker !== null; i++) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.next;
    }
  };
  Yallist.prototype.forEachReverse = function (fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.prev;
    }
  };
  Yallist.prototype.get = function (n) {
    for (var i = 0, walker = this.head; walker !== null &amp;&amp; i &lt; n; i++) {
      walker = walker.next;
    }
    if (i === n &amp;&amp; walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.getReverse = function (n) {
    for (var i = 0, walker = this.tail; walker !== null &amp;&amp; i &lt; n; i++) {
      walker = walker.prev;
    }
    if (i === n &amp;&amp; walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.map = function (fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for (var walker = this.head; walker !== null;) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.next;
    }
    return res;
  };
  Yallist.prototype.mapReverse = function (fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for (var walker = this.tail; walker !== null;) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.prev;
    }
    return res;
  };
  Yallist.prototype.reduce = function (fn, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length &gt; 1) {
      acc = initial;
    } else if (this.head) {
      walker = this.head.next;
      acc = this.head.value;
    } else {
      throw new TypeError(&#039;Reduce of empty list with no initial value&#039;);
    }
    for (var i = 0; walker !== null; i++) {
      acc = fn(acc, walker.value, i);
      walker = walker.next;
    }
    return acc;
  };
  Yallist.prototype.reduceReverse = function (fn, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length &gt; 1) {
      acc = initial;
    } else if (this.tail) {
      walker = this.tail.prev;
      acc = this.tail.value;
    } else {
      throw new TypeError(&#039;Reduce of empty list with no initial value&#039;);
    }
    for (var i = this.length - 1; walker !== null; i--) {
      acc = fn(acc, walker.value, i);
      walker = walker.prev;
    }
    return acc;
  };
  Yallist.prototype.toArray = function () {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.head; walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.next;
    }
    return arr;
  };
  Yallist.prototype.toArrayReverse = function () {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.tail; walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.prev;
    }
    return arr;
  };
  Yallist.prototype.slice = function (from, to) {
    to = to || this.length;
    if (to &lt; 0) {
      to += this.length;
    }
    from = from || 0;
    if (from &lt; 0) {
      from += this.length;
    }
    var ret = new Yallist();
    if (to &lt; from || to &lt; 0) {
      return ret;
    }
    if (from &lt; 0) {
      from = 0;
    }
    if (to &gt; this.length) {
      to = this.length;
    }
    for (var i = 0, walker = this.head; walker !== null &amp;&amp; i &lt; from; i++) {
      walker = walker.next;
    }
    for (; walker !== null &amp;&amp; i &lt; to; i++, walker = walker.next) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.sliceReverse = function (from, to) {
    to = to || this.length;
    if (to &lt; 0) {
      to += this.length;
    }
    from = from || 0;
    if (from &lt; 0) {
      from += this.length;
    }
    var ret = new Yallist();
    if (to &lt; from || to &lt; 0) {
      return ret;
    }
    if (from &lt; 0) {
      from = 0;
    }
    if (to &gt; this.length) {
      to = this.length;
    }
    for (var i = this.length, walker = this.tail; walker !== null &amp;&amp; i &gt; to; i--) {
      walker = walker.prev;
    }
    for (; walker !== null &amp;&amp; i &gt; from; i--, walker = walker.prev) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.splice = function (start, deleteCount, ...nodes) {
    if (start &gt; this.length) {
      start = this.length - 1;
    }
    if (start &lt; 0) {
      start = this.length + start;
    }
    for (var i = 0, walker = this.head; walker !== null &amp;&amp; i &lt; start; i++) {
      walker = walker.next;
    }
    var ret = [];
    for (var i = 0; walker &amp;&amp; i &lt; deleteCount; i++) {
      ret.push(walker.value);
      walker = this.removeNode(walker);
    }
    if (walker === null) {
      walker = this.tail;
    }
    if (walker !== this.head &amp;&amp; walker !== this.tail) {
      walker = walker.prev;
    }
    for (var i = 0; i &lt; nodes.length; i++) {
      walker = insert(this, walker, nodes[i]);
    }
    return ret;
  };
  Yallist.prototype.reverse = function () {
    var head = this.head;
    var tail = this.tail;
    for (var walker = head; walker !== null; walker = walker.prev) {
      var p = walker.prev;
      walker.prev = walker.next;
      walker.next = p;
    }
    this.head = tail;
    this.tail = head;
    return this;
  };
  function insert(self, node, value) {
    var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);
    if (inserted.next === null) {
      self.tail = inserted;
    }
    if (inserted.prev === null) {
      self.head = inserted;
    }
    self.length++;
    return inserted;
  }
  function push(self, item) {
    self.tail = new Node(item, self.tail, null, self);
    if (!self.head) {
      self.head = self.tail;
    }
    self.length++;
  }
  function unshift(self, item) {
    self.head = new Node(item, null, self.head, self);
    if (!self.tail) {
      self.tail = self.head;
    }
    self.length++;
  }
  function Node(value, prev, next, list) {
    if (!(this instanceof Node)) {
      return new Node(value, prev, next, list);
    }
    this.list = list;
    this.value = value;
    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = null;
    }
    if (next) {
      next.prev = this;
      this.next = next;
    } else {
      this.next = null;
    }
  }
  try {
    requireIterator()(Yallist);
  } catch (er) {}
  return yallist;
}
var lruCache;
var hasRequiredLruCache;
function requireLruCache() {
  if (hasRequiredLruCache) return lruCache;
  hasRequiredLruCache = 1;
  const Yallist = requireYallist();
  const MAX = Symbol(&#039;max&#039;);
  const LENGTH = Symbol(&#039;length&#039;);
  const LENGTH_CALCULATOR = Symbol(&#039;lengthCalculator&#039;);
  const ALLOW_STALE = Symbol(&#039;allowStale&#039;);
  const MAX_AGE = Symbol(&#039;maxAge&#039;);
  const DISPOSE = Symbol(&#039;dispose&#039;);
  const NO_DISPOSE_ON_SET = Symbol(&#039;noDisposeOnSet&#039;);
  const LRU_LIST = Symbol(&#039;lruList&#039;);
  const CACHE = Symbol(&#039;cache&#039;);
  const UPDATE_AGE_ON_GET = Symbol(&#039;updateAgeOnGet&#039;);
  const naiveLength = () =&gt; 1;
  class LRUCache {
    constructor(options) {
      if (typeof options === &#039;number&#039;) options = {
        max: options
      };
      if (!options) options = {};
      if (options.max &amp;&amp; (typeof options.max !== &#039;number&#039; || options.max &lt; 0)) throw new TypeError(&#039;max must be a non-negative number&#039;);
      this[MAX] = options.max || Infinity;
      const lc = options.length || naiveLength;
      this[LENGTH_CALCULATOR] = typeof lc !== &#039;function&#039; ? naiveLength : lc;
      this[ALLOW_STALE] = options.stale || false;
      if (options.maxAge &amp;&amp; typeof options.maxAge !== &#039;number&#039;) throw new TypeError(&#039;maxAge must be a number&#039;);
      this[MAX_AGE] = options.maxAge || 0;
      this[DISPOSE] = options.dispose;
      this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
      this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
      this.reset();
    }
    set max(mL) {
      if (typeof mL !== &#039;number&#039; || mL &lt; 0) throw new TypeError(&#039;max must be a non-negative number&#039;);
      this[MAX] = mL || Infinity;
      trim(this);
    }
    get max() {
      return this[MAX];
    }
    set allowStale(allowStale) {
      this[ALLOW_STALE] = !!allowStale;
    }
    get allowStale() {
      return this[ALLOW_STALE];
    }
    set maxAge(mA) {
      if (typeof mA !== &#039;number&#039;) throw new TypeError(&#039;maxAge must be a non-negative number&#039;);
      this[MAX_AGE] = mA;
      trim(this);
    }
    get maxAge() {
      return this[MAX_AGE];
    }
    set lengthCalculator(lC) {
      if (typeof lC !== &#039;function&#039;) lC = naiveLength;
      if (lC !== this[LENGTH_CALCULATOR]) {
        this[LENGTH_CALCULATOR] = lC;
        this[LENGTH] = 0;
        this[LRU_LIST].forEach(hit =&gt; {
          hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
          this[LENGTH] += hit.length;
        });
      }
      trim(this);
    }
    get lengthCalculator() {
      return this[LENGTH_CALCULATOR];
    }
    get length() {
      return this[LENGTH];
    }
    get itemCount() {
      return this[LRU_LIST].length;
    }
    rforEach(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].tail; walker !== null;) {
        const prev = walker.prev;
        forEachStep(this, fn, walker, thisp);
        walker = prev;
      }
    }
    forEach(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].head; walker !== null;) {
        const next = walker.next;
        forEachStep(this, fn, walker, thisp);
        walker = next;
      }
    }
    keys() {
      return this[LRU_LIST].toArray().map(k =&gt; k.key);
    }
    values() {
      return this[LRU_LIST].toArray().map(k =&gt; k.value);
    }
    reset() {
      if (this[DISPOSE] &amp;&amp; this[LRU_LIST] &amp;&amp; this[LRU_LIST].length) {
        this[LRU_LIST].forEach(hit =&gt; this[DISPOSE](hit.key, hit.value));
      }
      this[CACHE] = new Map();
      this[LRU_LIST] = new Yallist();
      this[LENGTH] = 0;
    }
    dump() {
      return this[LRU_LIST].map(hit =&gt; isStale(this, hit) ? false : {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }).toArray().filter(h =&gt; h);
    }
    dumpLru() {
      return this[LRU_LIST];
    }
    set(key, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      if (maxAge &amp;&amp; typeof maxAge !== &#039;number&#039;) throw new TypeError(&#039;maxAge must be a number&#039;);
      const now = maxAge ? Date.now() : 0;
      const len = this[LENGTH_CALCULATOR](value, key);
      if (this[CACHE].has(key)) {
        if (len &gt; this[MAX]) {
          del(this, this[CACHE].get(key));
          return false;
        }
        const node = this[CACHE].get(key);
        const item = node.value;
        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET]) this[DISPOSE](key, item.value);
        }
        item.now = now;
        item.maxAge = maxAge;
        item.value = value;
        this[LENGTH] += len - item.length;
        item.length = len;
        this.get(key);
        trim(this);
        return true;
      }
      const hit = new Entry(key, value, len, now, maxAge);
      if (hit.length &gt; this[MAX]) {
        if (this[DISPOSE]) this[DISPOSE](key, value);
        return false;
      }
      this[LENGTH] += hit.length;
      this[LRU_LIST].unshift(hit);
      this[CACHE].set(key, this[LRU_LIST].head);
      trim(this);
      return true;
    }
    has(key) {
      if (!this[CACHE].has(key)) return false;
      const hit = this[CACHE].get(key).value;
      return !isStale(this, hit);
    }
    get(key) {
      return get(this, key, true);
    }
    peek(key) {
      return get(this, key, false);
    }
    pop() {
      const node = this[LRU_LIST].tail;
      if (!node) return null;
      del(this, node);
      return node.value;
    }
    del(key) {
      del(this, this[CACHE].get(key));
    }
    load(arr) {
      this.reset();
      const now = Date.now();
      for (let l = arr.length - 1; l &gt;= 0; l--) {
        const hit = arr[l];
        const expiresAt = hit.e || 0;
        if (expiresAt === 0) this.set(hit.k, hit.v);else {
          const maxAge = expiresAt - now;
          if (maxAge &gt; 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    }
    prune() {
      this[CACHE].forEach((value, key) =&gt; get(this, key, false));
    }
  }
  const get = (self, key, doUse) =&gt; {
    const node = self[CACHE].get(key);
    if (node) {
      const hit = node.value;
      if (isStale(self, hit)) {
        del(self, node);
        if (!self[ALLOW_STALE]) return undefined;
      } else {
        if (doUse) {
          if (self[UPDATE_AGE_ON_GET]) node.value.now = Date.now();
          self[LRU_LIST].unshiftNode(node);
        }
      }
      return hit.value;
    }
  };
  const isStale = (self, hit) =&gt; {
    if (!hit || !hit.maxAge &amp;&amp; !self[MAX_AGE]) return false;
    const diff = Date.now() - hit.now;
    return hit.maxAge ? diff &gt; hit.maxAge : self[MAX_AGE] &amp;&amp; diff &gt; self[MAX_AGE];
  };
  const trim = self =&gt; {
    if (self[LENGTH] &gt; self[MAX]) {
      for (let walker = self[LRU_LIST].tail; self[LENGTH] &gt; self[MAX] &amp;&amp; walker !== null;) {
        const prev = walker.prev;
        del(self, walker);
        walker = prev;
      }
    }
  };
  const del = (self, node) =&gt; {
    if (node) {
      const hit = node.value;
      if (self[DISPOSE]) self[DISPOSE](hit.key, hit.value);
      self[LENGTH] -= hit.length;
      self[CACHE].delete(hit.key);
      self[LRU_LIST].removeNode(node);
    }
  };
  class Entry {
    constructor(key, value, length, now, maxAge) {
      this.key = key;
      this.value = value;
      this.length = length;
      this.now = now;
      this.maxAge = maxAge || 0;
    }
  }
  const forEachStep = (self, fn, node, thisp) =&gt; {
    let hit = node.value;
    if (isStale(self, hit)) {
      del(self, node);
      if (!self[ALLOW_STALE]) hit = undefined;
    }
    if (hit) fn.call(thisp, hit.value, hit.key, self);
  };
  lruCache = LRUCache;
  return lruCache;
}
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  class Range {
    constructor(range, options) {
      options = parseOptions(options);
      if (range instanceof Range) {
        if (range.loose === !!options.loose &amp;&amp; range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        this.raw = range.value;
        this.set = [[range]];
        this.format();
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range;
      this.set = range.split(&#039;||&#039;).map(r =&gt; this.parseRange(r.trim())).filter(c =&gt; c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${range}`);
      }
      if (this.set.length &gt; 1) {
        const first = this.set[0];
        this.set = this.set.filter(c =&gt; !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length &gt; 1) {
          for (const c of this.set) {
            if (c.length === 1 &amp;&amp; isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.format();
    }
    format() {
      this.range = this.set.map(comps =&gt; {
        return comps.join(&#039; &#039;).trim();
      }).join(&#039;||&#039;).trim();
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range) {
      range = range.trim();
      const memoOpts = Object.keys(this.options).join(&#039;,&#039;);
      const memoKey = `parseRange:${memoOpts}:${range}`;
      const cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug(&#039;hyphen replace&#039;, range);
      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
      debug(&#039;comparator trim&#039;, range);
      range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
      range = range.replace(re[t.CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(&#039; &#039;);
      let rangeList = range.split(&#039; &#039;).map(comp =&gt; parseComparator(comp, this.options)).join(&#039; &#039;).split(/\s+/).map(comp =&gt; replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter(comp =&gt; {
          debug(&#039;loose invalid filter&#039;, comp, this.options);
          return !!comp.match(re[t.COMPARATORLOOSE]);
        });
      }
      debug(&#039;range list&#039;, rangeList);
      const rangeMap = new Map();
      const comparators = rangeList.map(comp =&gt; new Comparator(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size &gt; 1 &amp;&amp; rangeMap.has(&#039;&#039;)) {
        rangeMap.delete(&#039;&#039;);
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError(&#039;a Range is required&#039;);
      }
      return this.set.some(thisComparators =&gt; {
        return isSatisfiable(thisComparators, options) &amp;&amp; range.set.some(rangeComparators =&gt; {
          return isSatisfiable(rangeComparators, options) &amp;&amp; thisComparators.every(thisComparator =&gt; {
            return rangeComparators.every(rangeComparator =&gt; {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    test(version) {
      if (!version) {
        return false;
      }
      if (typeof version === &#039;string&#039;) {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0; i &lt; this.set.length; i++) {
        if (testSet(this.set[i], version, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  range = Range;
  const LRU = requireLruCache();
  const cache = new LRU({
    max: 1000
  });
  const parseOptions = parseOptions_1;
  const Comparator = requireComparator();
  const debug = debug_1;
  const SemVer = semver$2;
  const {
    re,
    t,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = re$3.exports;
  const isNullSet = c =&gt; c.value === &#039;&lt;0.0.0-0&#039;;
  const isAny = c =&gt; c.value === &#039;&#039;;
  const isSatisfiable = (comparators, options) =&gt; {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result &amp;&amp; remainingComparators.length) {
      result = remainingComparators.every(otherComparator =&gt; {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  const parseComparator = (comp, options) =&gt; {
    debug(&#039;comp&#039;, comp, options);
    comp = replaceCarets(comp, options);
    debug(&#039;caret&#039;, comp);
    comp = replaceTildes(comp, options);
    debug(&#039;tildes&#039;, comp);
    comp = replaceXRanges(comp, options);
    debug(&#039;xrange&#039;, comp);
    comp = replaceStars(comp, options);
    debug(&#039;stars&#039;, comp);
    return comp;
  };
  const isX = id =&gt; !id || id.toLowerCase() === &#039;x&#039; || id === &#039;*&#039;;
  const replaceTildes = (comp, options) =&gt; comp.trim().split(/\s+/).map(c =&gt; {
    return replaceTilde(c, options);
  }).join(&#039; &#039;);
  const replaceTilde = (comp, options) =&gt; {
    const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, (_, M, m, p, pr) =&gt; {
      debug(&#039;tilde&#039;, comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = &#039;&#039;;
      } else if (isX(m)) {
        ret = `&gt;=${M}.0.0 &lt;${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `&gt;=${M}.${m}.0 &lt;${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug(&#039;replaceTilde pr&#039;, pr);
        ret = `&gt;=${M}.${m}.${p}-${pr} &lt;${M}.${+m + 1}.0-0`;
      } else {
        ret = `&gt;=${M}.${m}.${p} &lt;${M}.${+m + 1}.0-0`;
      }
      debug(&#039;tilde return&#039;, ret);
      return ret;
    });
  };
  const replaceCarets = (comp, options) =&gt; comp.trim().split(/\s+/).map(c =&gt; {
    return replaceCaret(c, options);
  }).join(&#039; &#039;);
  const replaceCaret = (comp, options) =&gt; {
    debug(&#039;caret&#039;, comp, options);
    const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    const z = options.includePrerelease ? &#039;-0&#039; : &#039;&#039;;
    return comp.replace(r, (_, M, m, p, pr) =&gt; {
      debug(&#039;caret&#039;, comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = &#039;&#039;;
      } else if (isX(m)) {
        ret = `&gt;=${M}.0.0${z} &lt;${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === &#039;0&#039;) {
          ret = `&gt;=${M}.${m}.0${z} &lt;${M}.${+m + 1}.0-0`;
        } else {
          ret = `&gt;=${M}.${m}.0${z} &lt;${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug(&#039;replaceCaret pr&#039;, pr);
        if (M === &#039;0&#039;) {
          if (m === &#039;0&#039;) {
            ret = `&gt;=${M}.${m}.${p}-${pr} &lt;${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `&gt;=${M}.${m}.${p}-${pr} &lt;${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `&gt;=${M}.${m}.${p}-${pr} &lt;${+M + 1}.0.0-0`;
        }
      } else {
        debug(&#039;no pr&#039;);
        if (M === &#039;0&#039;) {
          if (m === &#039;0&#039;) {
            ret = `&gt;=${M}.${m}.${p}${z} &lt;${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `&gt;=${M}.${m}.${p}${z} &lt;${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `&gt;=${M}.${m}.${p} &lt;${+M + 1}.0.0-0`;
        }
      }
      debug(&#039;caret return&#039;, ret);
      return ret;
    });
  };
  const replaceXRanges = (comp, options) =&gt; {
    debug(&#039;replaceXRanges&#039;, comp, options);
    return comp.split(/\s+/).map(c =&gt; {
      return replaceXRange(c, options);
    }).join(&#039; &#039;);
  };
  const replaceXRange = (comp, options) =&gt; {
    comp = comp.trim();
    const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) =&gt; {
      debug(&#039;xRange&#039;, comp, ret, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === &#039;=&#039; &amp;&amp; anyX) {
        gtlt = &#039;&#039;;
      }
      pr = options.includePrerelease ? &#039;-0&#039; : &#039;&#039;;
      if (xM) {
        if (gtlt === &#039;&gt;&#039; || gtlt === &#039;&lt;&#039;) {
          ret = &#039;&lt;0.0.0-0&#039;;
        } else {
          ret = &#039;*&#039;;
        }
      } else if (gtlt &amp;&amp; anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === &#039;&gt;&#039;) {
          gtlt = &#039;&gt;=&#039;;
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === &#039;&lt;=&#039;) {
          gtlt = &#039;&lt;&#039;;
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === &#039;&lt;&#039;) {
          pr = &#039;-0&#039;;
        }
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `&gt;=${M}.0.0${pr} &lt;${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `&gt;=${M}.${m}.0${pr} &lt;${M}.${+m + 1}.0-0`;
      }
      debug(&#039;xRange return&#039;, ret);
      return ret;
    });
  };
  const replaceStars = (comp, options) =&gt; {
    debug(&#039;replaceStars&#039;, comp, options);
    return comp.trim().replace(re[t.STAR], &#039;&#039;);
  };
  const replaceGTE0 = (comp, options) =&gt; {
    debug(&#039;replaceGTE0&#039;, comp, options);
    return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], &#039;&#039;);
  };
  const hyphenReplace = incPr =&gt; ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) =&gt; {
    if (isX(fM)) {
      from = &#039;&#039;;
    } else if (isX(fm)) {
      from = `&gt;=${fM}.0.0${incPr ? &#039;-0&#039; : &#039;&#039;}`;
    } else if (isX(fp)) {
      from = `&gt;=${fM}.${fm}.0${incPr ? &#039;-0&#039; : &#039;&#039;}`;
    } else if (fpr) {
      from = `&gt;=${from}`;
    } else {
      from = `&gt;=${from}${incPr ? &#039;-0&#039; : &#039;&#039;}`;
    }
    if (isX(tM)) {
      to = &#039;&#039;;
    } else if (isX(tm)) {
      to = `&lt;${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `&lt;${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `&lt;=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `&lt;${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `&lt;=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  const testSet = (set, version, options) =&gt; {
    for (let i = 0; i &lt; set.length; i++) {
      if (!set[i].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length &amp;&amp; !options.includePrerelease) {
      for (let i = 0; i &lt; set.length; i++) {
        debug(set[i].semver);
        if (set[i].semver === Comparator.ANY) {
          continue;
        }
        if (set[i].semver.prerelease.length &gt; 0) {
          const allowed = set[i].semver;
          if (allowed.major === version.major &amp;&amp; allowed.minor === version.minor &amp;&amp; allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
  return range;
}
var comparator;
var hasRequiredComparator;
function requireComparator() {
  if (hasRequiredComparator) return comparator;
  hasRequiredComparator = 1;
  const ANY = Symbol(&#039;SemVer ANY&#039;);
  class Comparator {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      options = parseOptions(options);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      debug(&#039;comparator&#039;, comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = &#039;&#039;;
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug(&#039;comp&#039;, this);
    }
    parse(comp) {
      const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== undefined ? m[1] : &#039;&#039;;
      if (this.operator === &#039;=&#039;) {
        this.operator = &#039;&#039;;
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version) {
      debug(&#039;Comparator.test&#039;, version, this.options.loose);
      if (this.semver === ANY || version === ANY) {
        return true;
      }
      if (typeof version === &#039;string&#039;) {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError(&#039;a Comparator is required&#039;);
      }
      if (!options || typeof options !== &#039;object&#039;) {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (this.operator === &#039;&#039;) {
        if (this.value === &#039;&#039;) {
          return true;
        }
        return new Range(comp.value, options).test(this.value);
      } else if (comp.operator === &#039;&#039;) {
        if (comp.value === &#039;&#039;) {
          return true;
        }
        return new Range(this.value, options).test(comp.semver);
      }
      const sameDirectionIncreasing = (this.operator === &#039;&gt;=&#039; || this.operator === &#039;&gt;&#039;) &amp;&amp; (comp.operator === &#039;&gt;=&#039; || comp.operator === &#039;&gt;&#039;);
      const sameDirectionDecreasing = (this.operator === &#039;&lt;=&#039; || this.operator === &#039;&lt;&#039;) &amp;&amp; (comp.operator === &#039;&lt;=&#039; || comp.operator === &#039;&lt;&#039;);
      const sameSemVer = this.semver.version === comp.semver.version;
      const differentDirectionsInclusive = (this.operator === &#039;&gt;=&#039; || this.operator === &#039;&lt;=&#039;) &amp;&amp; (comp.operator === &#039;&gt;=&#039; || comp.operator === &#039;&lt;=&#039;);
      const oppositeDirectionsLessThan = cmp(this.semver, &#039;&lt;&#039;, comp.semver, options) &amp;&amp; (this.operator === &#039;&gt;=&#039; || this.operator === &#039;&gt;&#039;) &amp;&amp; (comp.operator === &#039;&lt;=&#039; || comp.operator === &#039;&lt;&#039;);
      const oppositeDirectionsGreaterThan = cmp(this.semver, &#039;&gt;&#039;, comp.semver, options) &amp;&amp; (this.operator === &#039;&lt;=&#039; || this.operator === &#039;&lt;&#039;) &amp;&amp; (comp.operator === &#039;&gt;=&#039; || comp.operator === &#039;&gt;&#039;);
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer &amp;&amp; differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    }
  }
  comparator = Comparator;
  const parseOptions = parseOptions_1;
  const {
    re,
    t
  } = re$3.exports;
  const cmp = cmp_1;
  const debug = debug_1;
  const SemVer = semver$2;
  const Range = requireRange();
  return comparator;
}
const Range$8 = requireRange();
const satisfies$3 = (version, range, options) =&gt; {
  try {
    range = new Range$8(range, options);
  } catch (er) {
    return false;
  }
  return range.test(version);
};
var satisfies_1 = satisfies$3;
const Range$7 = requireRange();
const toComparators = (range, options) =&gt; new Range$7(range, options).set.map(comp =&gt; comp.map(c =&gt; c.value).join(&#039; &#039;).trim().split(&#039; &#039;));
var toComparators_1 = toComparators;
const SemVer$3 = semver$2;
const Range$6 = requireRange();
const maxSatisfying = (versions, range, options) =&gt; {
  let max = null;
  let maxSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$6(range, options);
  } catch (er) {
    return null;
  }
  versions.forEach(v =&gt; {
    if (rangeObj.test(v)) {
      if (!max || maxSV.compare(v) === -1) {
        max = v;
        maxSV = new SemVer$3(max, options);
      }
    }
  });
  return max;
};
var maxSatisfying_1 = maxSatisfying;
const SemVer$2 = semver$2;
const Range$5 = requireRange();
const minSatisfying = (versions, range, options) =&gt; {
  let min = null;
  let minSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$5(range, options);
  } catch (er) {
    return null;
  }
  versions.forEach(v =&gt; {
    if (rangeObj.test(v)) {
      if (!min || minSV.compare(v) === 1) {
        min = v;
        minSV = new SemVer$2(min, options);
      }
    }
  });
  return min;
};
var minSatisfying_1 = minSatisfying;
const SemVer$1 = semver$2;
const Range$4 = requireRange();
const gt$1 = gt_1;
const minVersion = (range, loose) =&gt; {
  range = new Range$4(range, loose);
  let minver = new SemVer$1(&#039;0.0.0&#039;);
  if (range.test(minver)) {
    return minver;
  }
  minver = new SemVer$1(&#039;0.0.0-0&#039;);
  if (range.test(minver)) {
    return minver;
  }
  minver = null;
  for (let i = 0; i &lt; range.set.length; ++i) {
    const comparators = range.set[i];
    let setMin = null;
    comparators.forEach(comparator =&gt; {
      const compver = new SemVer$1(comparator.semver.version);
      switch (comparator.operator) {
        case &#039;&gt;&#039;:
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }
          compver.raw = compver.format();
        case &#039;&#039;:
        case &#039;&gt;=&#039;:
          if (!setMin || gt$1(compver, setMin)) {
            setMin = compver;
          }
          break;
        case &#039;&lt;&#039;:
        case &#039;&lt;=&#039;:
          break;
        default:
          throw new Error(`Unexpected operation: ${comparator.operator}`);
      }
    });
    if (setMin &amp;&amp; (!minver || gt$1(minver, setMin))) {
      minver = setMin;
    }
  }
  if (minver &amp;&amp; range.test(minver)) {
    return minver;
  }
  return null;
};
var minVersion_1 = minVersion;
const Range$3 = requireRange();
const validRange = (range, options) =&gt; {
  try {
    return new Range$3(range, options).range || &#039;*&#039;;
  } catch (er) {
    return null;
  }
};
var valid = validRange;
const SemVer = semver$2;
const Comparator$1 = requireComparator();
const {
  ANY: ANY$1
} = Comparator$1;
const Range$2 = requireRange();
const satisfies$2 = satisfies_1;
const gt = gt_1;
const lt = lt_1;
const lte = lte_1;
const gte = gte_1;
const outside$2 = (version, range, hilo, options) =&gt; {
  version = new SemVer(version, options);
  range = new Range$2(range, options);
  let gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case &#039;&gt;&#039;:
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = &#039;&gt;&#039;;
      ecomp = &#039;&gt;=&#039;;
      break;
    case &#039;&lt;&#039;:
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = &#039;&lt;&#039;;
      ecomp = &#039;&lt;=&#039;;
      break;
    default:
      throw new TypeError(&#039;Must provide a hilo val of &quot;&lt;&quot; or &quot;&gt;&quot;&#039;);
  }
  if (satisfies$2(version, range, options)) {
    return false;
  }
  for (let i = 0; i &lt; range.set.length; ++i) {
    const comparators = range.set[i];
    let high = null;
    let low = null;
    comparators.forEach(comparator =&gt; {
      if (comparator.semver === ANY$1) {
        comparator = new Comparator$1(&#039;&gt;=0.0.0&#039;);
      }
      high = high || comparator;
      low = low || comparator;
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator;
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator;
      }
    });
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }
    if ((!low.operator || low.operator === comp) &amp;&amp; ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp &amp;&amp; ltfn(version, low.semver)) {
      return false;
    }
  }
  return true;
};
var outside_1 = outside$2;
const outside$1 = outside_1;
const gtr = (version, range, options) =&gt; outside$1(version, range, &#039;&gt;&#039;, options);
var gtr_1 = gtr;
const outside = outside_1;
const ltr = (version, range, options) =&gt; outside(version, range, &#039;&lt;&#039;, options);
var ltr_1 = ltr;
const Range$1 = requireRange();
const intersects = (r1, r2, options) =&gt; {
  r1 = new Range$1(r1, options);
  r2 = new Range$1(r2, options);
  return r1.intersects(r2);
};
var intersects_1 = intersects;
const satisfies$1 = satisfies_1;
const compare$1 = compare_1;
var simplify = (versions, range, options) =&gt; {
  const set = [];
  let first = null;
  let prev = null;
  const v = versions.sort((a, b) =&gt; compare$1(a, b, options));
  for (const version of v) {
    const included = satisfies$1(version, range, options);
    if (included) {
      prev = version;
      if (!first) {
        first = version;
      }
    } else {
      if (prev) {
        set.push([first, prev]);
      }
      prev = null;
      first = null;
    }
  }
  if (first) {
    set.push([first, null]);
  }
  const ranges = [];
  for (const [min, max] of set) {
    if (min === max) {
      ranges.push(min);
    } else if (!max &amp;&amp; min === v[0]) {
      ranges.push(&#039;*&#039;);
    } else if (!max) {
      ranges.push(`&gt;=${min}`);
    } else if (min === v[0]) {
      ranges.push(`&lt;=${max}`);
    } else {
      ranges.push(`${min} - ${max}`);
    }
  }
  const simplified = ranges.join(&#039; || &#039;);
  const original = typeof range.raw === &#039;string&#039; ? range.raw : String(range);
  return simplified.length &lt; original.length ? simplified : range;
};
const Range = requireRange();
const Comparator = requireComparator();
const {
  ANY
} = Comparator;
const satisfies = satisfies_1;
const compare = compare_1;
const subset = (sub, dom, options = {}) =&gt; {
  if (sub === dom) {
    return true;
  }
  sub = new Range(sub, options);
  dom = new Range(dom, options);
  let sawNonNull = false;
  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options);
      sawNonNull = sawNonNull || isSub !== null;
      if (isSub) {
        continue OUTER;
      }
    }
    if (sawNonNull) {
      return false;
    }
  }
  return true;
};
const simpleSubset = (sub, dom, options) =&gt; {
  if (sub === dom) {
    return true;
  }
  if (sub.length === 1 &amp;&amp; sub[0].semver === ANY) {
    if (dom.length === 1 &amp;&amp; dom[0].semver === ANY) {
      return true;
    } else if (options.includePrerelease) {
      sub = [new Comparator(&#039;&gt;=0.0.0-0&#039;)];
    } else {
      sub = [new Comparator(&#039;&gt;=0.0.0&#039;)];
    }
  }
  if (dom.length === 1 &amp;&amp; dom[0].semver === ANY) {
    if (options.includePrerelease) {
      return true;
    } else {
      dom = [new Comparator(&#039;&gt;=0.0.0&#039;)];
    }
  }
  const eqSet = new Set();
  let gt, lt;
  for (const c of sub) {
    if (c.operator === &#039;&gt;&#039; || c.operator === &#039;&gt;=&#039;) {
      gt = higherGT(gt, c, options);
    } else if (c.operator === &#039;&lt;&#039; || c.operator === &#039;&lt;=&#039;) {
      lt = lowerLT(lt, c, options);
    } else {
      eqSet.add(c.semver);
    }
  }
  if (eqSet.size &gt; 1) {
    return null;
  }
  let gtltComp;
  if (gt &amp;&amp; lt) {
    gtltComp = compare(gt.semver, lt.semver, options);
    if (gtltComp &gt; 0) {
      return null;
    } else if (gtltComp === 0 &amp;&amp; (gt.operator !== &#039;&gt;=&#039; || lt.operator !== &#039;&lt;=&#039;)) {
      return null;
    }
  }
  for (const eq of eqSet) {
    if (gt &amp;&amp; !satisfies(eq, String(gt), options)) {
      return null;
    }
    if (lt &amp;&amp; !satisfies(eq, String(lt), options)) {
      return null;
    }
    for (const c of dom) {
      if (!satisfies(eq, String(c), options)) {
        return false;
      }
    }
    return true;
  }
  let higher, lower;
  let hasDomLT, hasDomGT;
  let needDomLTPre = lt &amp;&amp; !options.includePrerelease &amp;&amp; lt.semver.prerelease.length ? lt.semver : false;
  let needDomGTPre = gt &amp;&amp; !options.includePrerelease &amp;&amp; gt.semver.prerelease.length ? gt.semver : false;
  if (needDomLTPre &amp;&amp; needDomLTPre.prerelease.length === 1 &amp;&amp; lt.operator === &#039;&lt;&#039; &amp;&amp; needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false;
  }
  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === &#039;&gt;&#039; || c.operator === &#039;&gt;=&#039;;
    hasDomLT = hasDomLT || c.operator === &#039;&lt;&#039; || c.operator === &#039;&lt;=&#039;;
    if (gt) {
      if (needDomGTPre) {
        if (c.semver.prerelease &amp;&amp; c.semver.prerelease.length &amp;&amp; c.semver.major === needDomGTPre.major &amp;&amp; c.semver.minor === needDomGTPre.minor &amp;&amp; c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false;
        }
      }
      if (c.operator === &#039;&gt;&#039; || c.operator === &#039;&gt;=&#039;) {
        higher = higherGT(gt, c, options);
        if (higher === c &amp;&amp; higher !== gt) {
          return false;
        }
      } else if (gt.operator === &#039;&gt;=&#039; &amp;&amp; !satisfies(gt.semver, String(c), options)) {
        return false;
      }
    }
    if (lt) {
      if (needDomLTPre) {
        if (c.semver.prerelease &amp;&amp; c.semver.prerelease.length &amp;&amp; c.semver.major === needDomLTPre.major &amp;&amp; c.semver.minor === needDomLTPre.minor &amp;&amp; c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false;
        }
      }
      if (c.operator === &#039;&lt;&#039; || c.operator === &#039;&lt;=&#039;) {
        lower = lowerLT(lt, c, options);
        if (lower === c &amp;&amp; lower !== lt) {
          return false;
        }
      } else if (lt.operator === &#039;&lt;=&#039; &amp;&amp; !satisfies(lt.semver, String(c), options)) {
        return false;
      }
    }
    if (!c.operator &amp;&amp; (lt || gt) &amp;&amp; gtltComp !== 0) {
      return false;
    }
  }
  if (gt &amp;&amp; hasDomLT &amp;&amp; !lt &amp;&amp; gtltComp !== 0) {
    return false;
  }
  if (lt &amp;&amp; hasDomGT &amp;&amp; !gt &amp;&amp; gtltComp !== 0) {
    return false;
  }
  if (needDomGTPre || needDomLTPre) {
    return false;
  }
  return true;
};
const higherGT = (a, b, options) =&gt; {
  if (!a) {
    return b;
  }
  const comp = compare(a.semver, b.semver, options);
  return comp &gt; 0 ? a : comp &lt; 0 ? b : b.operator === &#039;&gt;&#039; &amp;&amp; a.operator === &#039;&gt;=&#039; ? b : a;
};
const lowerLT = (a, b, options) =&gt; {
  if (!a) {
    return b;
  }
  const comp = compare(a.semver, b.semver, options);
  return comp &lt; 0 ? a : comp &gt; 0 ? b : b.operator === &#039;&lt;&#039; &amp;&amp; a.operator === &#039;&lt;=&#039; ? b : a;
};
var subset_1 = subset;
const internalRe = re$3.exports;
var semver$1 = {
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  SemVer: semver$2,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers,
  parse: parse_1,
  valid: valid_1,
  clean: clean_1,
  inc: inc_1,
  diff: diff_1,
  major: major_1,
  minor: minor_1,
  patch: patch_1,
  prerelease: prerelease_1,
  compare: compare_1,
  rcompare: rcompare_1,
  compareLoose: compareLoose_1,
  compareBuild: compareBuild_1,
  sort: sort_1,
  rsort: rsort_1,
  gt: gt_1,
  lt: lt_1,
  eq: eq_1,
  neq: neq_1,
  gte: gte_1,
  lte: lte_1,
  cmp: cmp_1,
  coerce: coerce_1,
  Comparator: requireComparator(),
  Range: requireRange(),
  satisfies: satisfies_1,
  toComparators: toComparators_1,
  maxSatisfying: maxSatisfying_1,
  minSatisfying: minSatisfying_1,
  minVersion: minVersion_1,
  validRange: valid,
  outside: outside_1,
  gtr: gtr_1,
  ltr: ltr_1,
  intersects: intersects_1,
  simplifyRange: simplify,
  subset: subset_1
};
var semver = semver$1;
var builtins = function ({
  version = process.version,
  experimental = false
} = {}) {
  var coreModules = [&#039;assert&#039;, &#039;buffer&#039;, &#039;child_process&#039;, &#039;cluster&#039;, &#039;console&#039;, &#039;constants&#039;, &#039;crypto&#039;, &#039;dgram&#039;, &#039;dns&#039;, &#039;domain&#039;, &#039;events&#039;, &#039;fs&#039;, &#039;http&#039;, &#039;https&#039;, &#039;module&#039;, &#039;net&#039;, &#039;os&#039;, &#039;path&#039;, &#039;punycode&#039;, &#039;querystring&#039;, &#039;readline&#039;, &#039;repl&#039;, &#039;stream&#039;, &#039;string_decoder&#039;, &#039;sys&#039;, &#039;timers&#039;, &#039;tls&#039;, &#039;tty&#039;, &#039;url&#039;, &#039;util&#039;, &#039;vm&#039;, &#039;zlib&#039;];
  if (semver.lt(version, &#039;6.0.0&#039;)) coreModules.push(&#039;freelist&#039;);
  if (semver.gte(version, &#039;1.0.0&#039;)) coreModules.push(&#039;v8&#039;);
  if (semver.gte(version, &#039;1.1.0&#039;)) coreModules.push(&#039;process&#039;);
  if (semver.gte(version, &#039;8.0.0&#039;)) coreModules.push(&#039;inspector&#039;);
  if (semver.gte(version, &#039;8.1.0&#039;)) coreModules.push(&#039;async_hooks&#039;);
  if (semver.gte(version, &#039;8.4.0&#039;)) coreModules.push(&#039;http2&#039;);
  if (semver.gte(version, &#039;8.5.0&#039;)) coreModules.push(&#039;perf_hooks&#039;);
  if (semver.gte(version, &#039;10.0.0&#039;)) coreModules.push(&#039;trace_events&#039;);
  if (semver.gte(version, &#039;10.5.0&#039;) &amp;&amp; (experimental || semver.gte(version, &#039;12.0.0&#039;))) {
    coreModules.push(&#039;worker_threads&#039;);
  }
  if (semver.gte(version, &#039;12.16.0&#039;) &amp;&amp; experimental) {
    coreModules.push(&#039;wasi&#039;);
  }
  return coreModules;
};
const reader = {
  read
};
function read(jsonPath) {
  return find(_path().dirname(jsonPath));
}
function find(dir) {
  try {
    const string = _fs().default.readFileSync(_path().toNamespacedPath(_path().join(dir, &#039;package.json&#039;)), &#039;utf8&#039;);
    return {
      string
    };
  } catch (error) {
    if (error.code === &#039;ENOENT&#039;) {
      const parent = _path().dirname(dir);
      if (dir !== parent) return find(parent);
      return {
        string: undefined
      };
    }
    throw error;
  }
}
const isWindows = process.platform === &#039;win32&#039;;
const own$1 = {}.hasOwnProperty;
const codes = {};
const messages = new Map();
const nodeInternalPrefix = &#039;__node_internal_&#039;;
let userStackTraceLimit;
codes.ERR_INVALID_MODULE_SPECIFIER = createError(&#039;ERR_INVALID_MODULE_SPECIFIER&#039;, (request, reason, base = undefined) =&gt; {
  return `Invalid module &quot;${request}&quot; ${reason}${base ? ` imported from ${base}` : &#039;&#039;}`;
}, TypeError);
codes.ERR_INVALID_PACKAGE_CONFIG = createError(&#039;ERR_INVALID_PACKAGE_CONFIG&#039;, (path, base, message) =&gt; {
  return `Invalid package config ${path}${base ? ` while importing ${base}` : &#039;&#039;}${message ? `. ${message}` : &#039;&#039;}`;
}, Error);
codes.ERR_INVALID_PACKAGE_TARGET = createError(&#039;ERR_INVALID_PACKAGE_TARGET&#039;, (pkgPath, key, target, isImport = false, base = undefined) =&gt; {
  const relError = typeof target === &#039;string&#039; &amp;&amp; !isImport &amp;&amp; target.length &gt; 0 &amp;&amp; !target.startsWith(&#039;./&#039;);
  if (key === &#039;.&#039;) {
    _assert()(isImport === false);
    return `Invalid &quot;exports&quot; main target ${JSON.stringify(target)} defined ` + `in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : &#039;&#039;}${relError ? &#039;; targets must start with &quot;./&quot;&#039; : &#039;&#039;}`;
  }
  return `Invalid &quot;${isImport ? &#039;imports&#039; : &#039;exports&#039;}&quot; target ${JSON.stringify(target)} defined for &#039;${key}&#039; in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : &#039;&#039;}${relError ? &#039;; targets must start with &quot;./&quot;&#039; : &#039;&#039;}`;
}, Error);
codes.ERR_MODULE_NOT_FOUND = createError(&#039;ERR_MODULE_NOT_FOUND&#039;, (path, base, type = &#039;package&#039;) =&gt; {
  return `Cannot find ${type} &#039;${path}&#039; imported from ${base}`;
}, Error);
codes.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError(&#039;ERR_PACKAGE_IMPORT_NOT_DEFINED&#039;, (specifier, packagePath, base) =&gt; {
  return `Package import specifier &quot;${specifier}&quot; is not defined${packagePath ? ` in package ${packagePath}package.json` : &#039;&#039;} imported from ${base}`;
}, TypeError);
codes.ERR_PACKAGE_PATH_NOT_EXPORTED = createError(&#039;ERR_PACKAGE_PATH_NOT_EXPORTED&#039;, (pkgPath, subpath, base = undefined) =&gt; {
  if (subpath === &#039;.&#039;) return `No &quot;exports&quot; main defined in ${pkgPath}package.json${base ? ` imported from ${base}` : &#039;&#039;}`;
  return `Package subpath &#039;${subpath}&#039; is not defined by &quot;exports&quot; in ${pkgPath}package.json${base ? ` imported from ${base}` : &#039;&#039;}`;
}, Error);
codes.ERR_UNSUPPORTED_DIR_IMPORT = createError(&#039;ERR_UNSUPPORTED_DIR_IMPORT&#039;, &quot;Directory import &#039;%s&#039; is not supported &quot; + &#039;resolving ES modules imported from %s&#039;, Error);
codes.ERR_UNKNOWN_FILE_EXTENSION = createError(&#039;ERR_UNKNOWN_FILE_EXTENSION&#039;, &#039;Unknown file extension &quot;%s&quot; for %s&#039;, TypeError);
codes.ERR_INVALID_ARG_VALUE = createError(&#039;ERR_INVALID_ARG_VALUE&#039;, (name, value, reason = &#039;is invalid&#039;) =&gt; {
  let inspected = (0, _util().inspect)(value);
  if (inspected.length &gt; 128) {
    inspected = `${inspected.slice(0, 128)}...`;
  }
  const type = name.includes(&#039;.&#039;) ? &#039;property&#039; : &#039;argument&#039;;
  return `The ${type} &#039;${name}&#039; ${reason}. Received ${inspected}`;
}, TypeError);
codes.ERR_UNSUPPORTED_ESM_URL_SCHEME = createError(&#039;ERR_UNSUPPORTED_ESM_URL_SCHEME&#039;, url =&gt; {
  let message = &#039;Only file and data URLs are supported by the default ESM loader&#039;;
  if (isWindows &amp;&amp; url.protocol.length === 2) {
    message += &#039;. On Windows, absolute paths must be valid file:// URLs&#039;;
  }
  message += `. Received protocol &#039;${url.protocol}&#039;`;
  return message;
}, Error);
function createError(sym, value, def) {
  messages.set(sym, value);
  return makeNodeErrorWithCode(def, sym);
}
function makeNodeErrorWithCode(Base, key) {
  return NodeError;
  function NodeError(...args) {
    const limit = Error.stackTraceLimit;
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;
    const error = new Base();
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;
    const message = getMessage(key, args, error);
    Object.defineProperty(error, &#039;message&#039;, {
      value: message,
      enumerable: false,
      writable: true,
      configurable: true
    });
    Object.defineProperty(error, &#039;toString&#039;, {
      value() {
        return `${this.name} [${key}]: ${this.message}`;
      },
      enumerable: false,
      writable: true,
      configurable: true
    });
    addCodeToName(error, Base.name, key);
    error.code = key;
    return error;
  }
}
const addCodeToName = hideStackFrames(function (error, name, code) {
  error = captureLargerStackTrace(error);
  error.name = `${name} [${code}]`;
  error.stack;
  if (name === &#039;SystemError&#039;) {
    Object.defineProperty(error, &#039;name&#039;, {
      value: name,
      enumerable: false,
      writable: true,
      configurable: true
    });
  } else {
    delete error.name;
  }
});
function isErrorStackTraceLimitWritable() {
  const desc = Object.getOwnPropertyDescriptor(Error, &#039;stackTraceLimit&#039;);
  if (desc === undefined) {
    return Object.isExtensible(Error);
  }
  return own$1.call(desc, &#039;writable&#039;) ? desc.writable : desc.set !== undefined;
}
function hideStackFrames(fn) {
  const hidden = nodeInternalPrefix + fn.name;
  Object.defineProperty(fn, &#039;name&#039;, {
    value: hidden
  });
  return fn;
}
const captureLargerStackTrace = hideStackFrames(function (error) {
  const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
  if (stackTraceLimitIsWritable) {
    userStackTraceLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = Number.POSITIVE_INFINITY;
  }
  Error.captureStackTrace(error);
  if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;
  return error;
});
function getMessage(key, args, self) {
  const message = messages.get(key);
  if (typeof message === &#039;function&#039;) {
    _assert()(message.length &lt;= args.length, `Code: ${key}; The provided arguments length (${args.length}) does not ` + `match the required ones (${message.length}).`);
    return Reflect.apply(message, self, args);
  }
  const expectedLength = (message.match(/%[dfijoOs]/g) || []).length;
  _assert()(expectedLength === args.length, `Code: ${key}; The provided arguments length (${args.length}) does not ` + `match the required ones (${expectedLength}).`);
  if (args.length === 0) return message;
  args.unshift(message);
  return Reflect.apply(_util().format, null, args);
}
const {
  ERR_UNKNOWN_FILE_EXTENSION
} = codes;
const extensionFormatMap = {
  __proto__: null,
  &#039;.cjs&#039;: &#039;commonjs&#039;,
  &#039;.js&#039;: &#039;module&#039;,
  &#039;.mjs&#039;: &#039;module&#039;
};
function defaultGetFormat(url) {
  if (url.startsWith(&#039;node:&#039;)) {
    return {
      format: &#039;builtin&#039;
    };
  }
  const parsed = new (_url().URL)(url);
  if (parsed.protocol === &#039;data:&#039;) {
    const {
      1: mime
    } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(parsed.pathname) || [null, null];
    const format = mime === &#039;text/javascript&#039; ? &#039;module&#039; : null;
    return {
      format
    };
  }
  if (parsed.protocol === &#039;file:&#039;) {
    const ext = _path().extname(parsed.pathname);
    let format;
    if (ext === &#039;.js&#039;) {
      format = getPackageType(parsed.href) === &#039;module&#039; ? &#039;module&#039; : &#039;commonjs&#039;;
    } else {
      format = extensionFormatMap[ext];
    }
    if (!format) {
      throw new ERR_UNKNOWN_FILE_EXTENSION(ext, (0, _url().fileURLToPath)(url));
    }
    return {
      format: format || null
    };
  }
  return {
    format: null
  };
}
const listOfBuiltins = builtins();
const {
  ERR_INVALID_MODULE_SPECIFIER,
  ERR_INVALID_PACKAGE_CONFIG,
  ERR_INVALID_PACKAGE_TARGET,
  ERR_MODULE_NOT_FOUND,
  ERR_PACKAGE_IMPORT_NOT_DEFINED,
  ERR_PACKAGE_PATH_NOT_EXPORTED,
  ERR_UNSUPPORTED_DIR_IMPORT,
  ERR_UNSUPPORTED_ESM_URL_SCHEME,
  ERR_INVALID_ARG_VALUE
} = codes;
const own = {}.hasOwnProperty;
const DEFAULT_CONDITIONS = Object.freeze([&#039;node&#039;, &#039;import&#039;]);
const DEFAULT_CONDITIONS_SET = new Set(DEFAULT_CONDITIONS);
const invalidSegmentRegEx = /(^|\\|\/)(\.\.?|node_modules)(\\|\/|$)/;
const patternRegEx = /\*/g;
const encodedSepRegEx = /%2f|%2c/i;
const emittedPackageWarnings = new Set();
const packageJsonCache = new Map();
function emitFolderMapDeprecation(match, pjsonUrl, isExports, base) {
  const pjsonPath = (0, _url().fileURLToPath)(pjsonUrl);
  if (emittedPackageWarnings.has(pjsonPath + &#039;|&#039; + match)) return;
  emittedPackageWarnings.add(pjsonPath + &#039;|&#039; + match);
  process.emitWarning(`Use of deprecated folder mapping &quot;${match}&quot; in the ${isExports ? &#039;&quot;exports&quot;&#039; : &#039;&quot;imports&quot;&#039;} field module resolution of the package at ${pjsonPath}${base ? ` imported from ${(0, _url().fileURLToPath)(base)}` : &#039;&#039;}.\n` + `Update this package.json to use a subpath pattern like &quot;${match}*&quot;.`, &#039;DeprecationWarning&#039;, &#039;DEP0148&#039;);
}
function emitLegacyIndexDeprecation(url, packageJsonUrl, base, main) {
  const {
    format
  } = defaultGetFormat(url.href);
  if (format !== &#039;module&#039;) return;
  const path = (0, _url().fileURLToPath)(url.href);
  const pkgPath = (0, _url().fileURLToPath)(new (_url().URL)(&#039;.&#039;, packageJsonUrl));
  const basePath = (0, _url().fileURLToPath)(base);
  if (main) process.emitWarning(`Package ${pkgPath} has a &quot;main&quot; field set to ${JSON.stringify(main)}, ` + `excluding the full filename and extension to the resolved file at &quot;${path.slice(pkgPath.length)}&quot;, imported from ${basePath}.\n Automatic extension resolution of the &quot;main&quot; field is` + &#039;deprecated for ES modules.&#039;, &#039;DeprecationWarning&#039;, &#039;DEP0151&#039;);else process.emitWarning(`No &quot;main&quot; or &quot;exports&quot; field defined in the package.json for ${pkgPath} resolving the main entry point &quot;${path.slice(pkgPath.length)}&quot;, imported from ${basePath}.\nDefault &quot;index&quot; lookups for the main are deprecated for ES modules.`, &#039;DeprecationWarning&#039;, &#039;DEP0151&#039;);
}
function getConditionsSet(conditions) {
  if (conditions !== undefined &amp;&amp; conditions !== DEFAULT_CONDITIONS) {
    if (!Array.isArray(conditions)) {
      throw new ERR_INVALID_ARG_VALUE(&#039;conditions&#039;, conditions, &#039;expected an array&#039;);
    }
    return new Set(conditions);
  }
  return DEFAULT_CONDITIONS_SET;
}
function tryStatSync(path) {
  try {
    return (0, _fs().statSync)(path);
  } catch (_unused) {
    return new (_fs().Stats)();
  }
}
function getPackageConfig(path, specifier, base) {
  const existing = packageJsonCache.get(path);
  if (existing !== undefined) {
    return existing;
  }
  const source = reader.read(path).string;
  if (source === undefined) {
    const packageConfig = {
      pjsonPath: path,
      exists: false,
      main: undefined,
      name: undefined,
      type: &#039;none&#039;,
      exports: undefined,
      imports: undefined
    };
    packageJsonCache.set(path, packageConfig);
    return packageConfig;
  }
  let packageJson;
  try {
    packageJson = JSON.parse(source);
  } catch (error) {
    throw new ERR_INVALID_PACKAGE_CONFIG(path, (base ? `&quot;${specifier}&quot; from ` : &#039;&#039;) + (0, _url().fileURLToPath)(base || specifier), error.message);
  }
  const {
    exports,
    imports,
    main,
    name,
    type
  } = packageJson;
  const packageConfig = {
    pjsonPath: path,
    exists: true,
    main: typeof main === &#039;string&#039; ? main : undefined,
    name: typeof name === &#039;string&#039; ? name : undefined,
    type: type === &#039;module&#039; || type === &#039;commonjs&#039; ? type : &#039;none&#039;,
    exports,
    imports: imports &amp;&amp; typeof imports === &#039;object&#039; ? imports : undefined
  };
  packageJsonCache.set(path, packageConfig);
  return packageConfig;
}
function getPackageScopeConfig(resolved) {
  let packageJsonUrl = new (_url().URL)(&#039;./package.json&#039;, resolved);
  while (true) {
    const packageJsonPath = packageJsonUrl.pathname;
    if (packageJsonPath.endsWith(&#039;node_modules/package.json&#039;)) break;
    const packageConfig = getPackageConfig((0, _url().fileURLToPath)(packageJsonUrl), resolved);
    if (packageConfig.exists) return packageConfig;
    const lastPackageJsonUrl = packageJsonUrl;
    packageJsonUrl = new (_url().URL)(&#039;../package.json&#039;, packageJsonUrl);
    if (packageJsonUrl.pathname === lastPackageJsonUrl.pathname) break;
  }
  const packageJsonPath = (0, _url().fileURLToPath)(packageJsonUrl);
  const packageConfig = {
    pjsonPath: packageJsonPath,
    exists: false,
    main: undefined,
    name: undefined,
    type: &#039;none&#039;,
    exports: undefined,
    imports: undefined
  };
  packageJsonCache.set(packageJsonPath, packageConfig);
  return packageConfig;
}
function fileExists(url) {
  return tryStatSync((0, _url().fileURLToPath)(url)).isFile();
}
function legacyMainResolve(packageJsonUrl, packageConfig, base) {
  let guess;
  if (packageConfig.main !== undefined) {
    guess = new (_url().URL)(`./${packageConfig.main}`, packageJsonUrl);
    if (fileExists(guess)) return guess;
    const tries = [`./${packageConfig.main}.js`, `./${packageConfig.main}.json`, `./${packageConfig.main}.node`, `./${packageConfig.main}/index.js`, `./${packageConfig.main}/index.json`, `./${packageConfig.main}/index.node`];
    let i = -1;
    while (++i &lt; tries.length) {
      guess = new (_url().URL)(tries[i], packageJsonUrl);
      if (fileExists(guess)) break;
      guess = undefined;
    }
    if (guess) {
      emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
      return guess;
    }
  }
  const tries = [&#039;./index.js&#039;, &#039;./index.json&#039;, &#039;./index.node&#039;];
  let i = -1;
  while (++i &lt; tries.length) {
    guess = new (_url().URL)(tries[i], packageJsonUrl);
    if (fileExists(guess)) break;
    guess = undefined;
  }
  if (guess) {
    emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
    return guess;
  }
  throw new ERR_MODULE_NOT_FOUND((0, _url().fileURLToPath)(new (_url().URL)(&#039;.&#039;, packageJsonUrl)), (0, _url().fileURLToPath)(base));
}
function finalizeResolution(resolved, base) {
  if (encodedSepRegEx.test(resolved.pathname)) throw new ERR_INVALID_MODULE_SPECIFIER(resolved.pathname, &#039;must not include encoded &quot;/&quot; or &quot;\\&quot; characters&#039;, (0, _url().fileURLToPath)(base));
  const path = (0, _url().fileURLToPath)(resolved);
  const stats = tryStatSync(path.endsWith(&#039;/&#039;) ? path.slice(-1) : path);
  if (stats.isDirectory()) {
    const error = new ERR_UNSUPPORTED_DIR_IMPORT(path, (0, _url().fileURLToPath)(base));
    error.url = String(resolved);
    throw error;
  }
  if (!stats.isFile()) {
    throw new ERR_MODULE_NOT_FOUND(path || resolved.pathname, base &amp;&amp; (0, _url().fileURLToPath)(base), &#039;module&#039;);
  }
  return resolved;
}
function throwImportNotDefined(specifier, packageJsonUrl, base) {
  throw new ERR_PACKAGE_IMPORT_NOT_DEFINED(specifier, packageJsonUrl &amp;&amp; (0, _url().fileURLToPath)(new (_url().URL)(&#039;.&#039;, packageJsonUrl)), (0, _url().fileURLToPath)(base));
}
function throwExportsNotFound(subpath, packageJsonUrl, base) {
  throw new ERR_PACKAGE_PATH_NOT_EXPORTED((0, _url().fileURLToPath)(new (_url().URL)(&#039;.&#039;, packageJsonUrl)), subpath, base &amp;&amp; (0, _url().fileURLToPath)(base));
}
function throwInvalidSubpath(subpath, packageJsonUrl, internal, base) {
  const reason = `request is not a valid subpath for the &quot;${internal ? &#039;imports&#039; : &#039;exports&#039;}&quot; resolution of ${(0, _url().fileURLToPath)(packageJsonUrl)}`;
  throw new ERR_INVALID_MODULE_SPECIFIER(subpath, reason, base &amp;&amp; (0, _url().fileURLToPath)(base));
}
function throwInvalidPackageTarget(subpath, target, packageJsonUrl, internal, base) {
  target = typeof target === &#039;object&#039; &amp;&amp; target !== null ? JSON.stringify(target, null, &#039;&#039;) : `${target}`;
  throw new ERR_INVALID_PACKAGE_TARGET((0, _url().fileURLToPath)(new (_url().URL)(&#039;.&#039;, packageJsonUrl)), subpath, target, internal, base &amp;&amp; (0, _url().fileURLToPath)(base));
}
function resolvePackageTargetString(target, subpath, match, packageJsonUrl, base, pattern, internal, conditions) {
  if (subpath !== &#039;&#039; &amp;&amp; !pattern &amp;&amp; target[target.length - 1] !== &#039;/&#039;) throwInvalidPackageTarget(match, target, packageJsonUrl, internal, base);
  if (!target.startsWith(&#039;./&#039;)) {
    if (internal &amp;&amp; !target.startsWith(&#039;../&#039;) &amp;&amp; !target.startsWith(&#039;/&#039;)) {
      let isURL = false;
      try {
        new (_url().URL)(target);
        isURL = true;
      } catch (_unused2) {}
      if (!isURL) {
        const exportTarget = pattern ? target.replace(patternRegEx, subpath) : target + subpath;
        return packageResolve(exportTarget, packageJsonUrl, conditions);
      }
    }
    throwInvalidPackageTarget(match, target, packageJsonUrl, internal, base);
  }
  if (invalidSegmentRegEx.test(target.slice(2))) throwInvalidPackageTarget(match, target, packageJsonUrl, internal, base);
  const resolved = new (_url().URL)(target, packageJsonUrl);
  const resolvedPath = resolved.pathname;
  const packagePath = new (_url().URL)(&#039;.&#039;, packageJsonUrl).pathname;
  if (!resolvedPath.startsWith(packagePath)) throwInvalidPackageTarget(match, target, packageJsonUrl, internal, base);
  if (subpath === &#039;&#039;) return resolved;
  if (invalidSegmentRegEx.test(subpath)) throwInvalidSubpath(match + subpath, packageJsonUrl, internal, base);
  if (pattern) return new (_url().URL)(resolved.href.replace(patternRegEx, subpath));
  return new (_url().URL)(subpath, resolved);
}
function isArrayIndex(key) {
  const keyNumber = Number(key);
  if (`${keyNumber}` !== key) return false;
  return keyNumber &gt;= 0 &amp;&amp; keyNumber &lt; 0xffffffff;
}
function resolvePackageTarget(packageJsonUrl, target, subpath, packageSubpath, base, pattern, internal, conditions) {
  if (typeof target === &#039;string&#039;) {
    return resolvePackageTargetString(target, subpath, packageSubpath, packageJsonUrl, base, pattern, internal, conditions);
  }
  if (Array.isArray(target)) {
    const targetList = target;
    if (targetList.length === 0) return null;
    let lastException;
    let i = -1;
    while (++i &lt; targetList.length) {
      const targetItem = targetList[i];
      let resolved;
      try {
        resolved = resolvePackageTarget(packageJsonUrl, targetItem, subpath, packageSubpath, base, pattern, internal, conditions);
      } catch (error) {
        lastException = error;
        if (error.code === &#039;ERR_INVALID_PACKAGE_TARGET&#039;) continue;
        throw error;
      }
      if (resolved === undefined) continue;
      if (resolved === null) {
        lastException = null;
        continue;
      }
      return resolved;
    }
    if (lastException === undefined || lastException === null) {
      return lastException;
    }
    throw lastException;
  }
  if (typeof target === &#039;object&#039; &amp;&amp; target !== null) {
    const keys = Object.getOwnPropertyNames(target);
    let i = -1;
    while (++i &lt; keys.length) {
      const key = keys[i];
      if (isArrayIndex(key)) {
        throw new ERR_INVALID_PACKAGE_CONFIG((0, _url().fileURLToPath)(packageJsonUrl), base, &#039;&quot;exports&quot; cannot contain numeric property keys.&#039;);
      }
    }
    i = -1;
    while (++i &lt; keys.length) {
      const key = keys[i];
      if (key === &#039;default&#039; || conditions &amp;&amp; conditions.has(key)) {
        const conditionalTarget = target[key];
        const resolved = resolvePackageTarget(packageJsonUrl, conditionalTarget, subpath, packageSubpath, base, pattern, internal, conditions);
        if (resolved === undefined) continue;
        return resolved;
      }
    }
    return undefined;
  }
  if (target === null) {
    return null;
  }
  throwInvalidPackageTarget(packageSubpath, target, packageJsonUrl, internal, base);
}
function isConditionalExportsMainSugar(exports, packageJsonUrl, base) {
  if (typeof exports === &#039;string&#039; || Array.isArray(exports)) return true;
  if (typeof exports !== &#039;object&#039; || exports === null) return false;
  const keys = Object.getOwnPropertyNames(exports);
  let isConditionalSugar = false;
  let i = 0;
  let j = -1;
  while (++j &lt; keys.length) {
    const key = keys[j];
    const curIsConditionalSugar = key === &#039;&#039; || key[0] !== &#039;.&#039;;
    if (i++ === 0) {
      isConditionalSugar = curIsConditionalSugar;
    } else if (isConditionalSugar !== curIsConditionalSugar) {
      throw new ERR_INVALID_PACKAGE_CONFIG((0, _url().fileURLToPath)(packageJsonUrl), base, &#039;&quot;exports&quot; cannot contain some keys starting with \&#039;.\&#039; and some not.&#039; + &#039; The exports object must either be an object of package subpath keys&#039; + &#039; or an object of main entry condition name keys only.&#039;);
    }
  }
  return isConditionalSugar;
}
function packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions) {
  let exports = packageConfig.exports;
  if (isConditionalExportsMainSugar(exports, packageJsonUrl, base)) exports = {
    &#039;.&#039;: exports
  };
  if (own.call(exports, packageSubpath)) {
    const target = exports[packageSubpath];
    const resolved = resolvePackageTarget(packageJsonUrl, target, &#039;&#039;, packageSubpath, base, false, false, conditions);
    if (resolved === null || resolved === undefined) throwExportsNotFound(packageSubpath, packageJsonUrl, base);
    return {
      resolved,
      exact: true
    };
  }
  let bestMatch = &#039;&#039;;
  const keys = Object.getOwnPropertyNames(exports);
  let i = -1;
  while (++i &lt; keys.length) {
    const key = keys[i];
    if (key[key.length - 1] === &#039;*&#039; &amp;&amp; packageSubpath.startsWith(key.slice(0, -1)) &amp;&amp; packageSubpath.length &gt;= key.length &amp;&amp; key.length &gt; bestMatch.length) {
      bestMatch = key;
    } else if (key[key.length - 1] === &#039;/&#039; &amp;&amp; packageSubpath.startsWith(key) &amp;&amp; key.length &gt; bestMatch.length) {
      bestMatch = key;
    }
  }
  if (bestMatch) {
    const target = exports[bestMatch];
    const pattern = bestMatch[bestMatch.length - 1] === &#039;*&#039;;
    const subpath = packageSubpath.slice(bestMatch.length - (pattern ? 1 : 0));
    const resolved = resolvePackageTarget(packageJsonUrl, target, subpath, bestMatch, base, pattern, false, conditions);
    if (resolved === null || resolved === undefined) throwExportsNotFound(packageSubpath, packageJsonUrl, base);
    if (!pattern) emitFolderMapDeprecation(bestMatch, packageJsonUrl, true, base);
    return {
      resolved,
      exact: pattern
    };
  }
  throwExportsNotFound(packageSubpath, packageJsonUrl, base);
}
function packageImportsResolve(name, base, conditions) {
  if (name === &#039;#&#039; || name.startsWith(&#039;#/&#039;)) {
    const reason = &#039;is not a valid internal imports specifier name&#039;;
    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, (0, _url().fileURLToPath)(base));
  }
  let packageJsonUrl;
  const packageConfig = getPackageScopeConfig(base);
  if (packageConfig.exists) {
    packageJsonUrl = (0, _url().pathToFileURL)(packageConfig.pjsonPath);
    const imports = packageConfig.imports;
    if (imports) {
      if (own.call(imports, name)) {
        const resolved = resolvePackageTarget(packageJsonUrl, imports[name], &#039;&#039;, name, base, false, true, conditions);
        if (resolved !== null) return {
          resolved,
          exact: true
        };
      } else {
        let bestMatch = &#039;&#039;;
        const keys = Object.getOwnPropertyNames(imports);
        let i = -1;
        while (++i &lt; keys.length) {
          const key = keys[i];
          if (key[key.length - 1] === &#039;*&#039; &amp;&amp; name.startsWith(key.slice(0, -1)) &amp;&amp; name.length &gt;= key.length &amp;&amp; key.length &gt; bestMatch.length) {
            bestMatch = key;
          } else if (key[key.length - 1] === &#039;/&#039; &amp;&amp; name.startsWith(key) &amp;&amp; key.length &gt; bestMatch.length) {
            bestMatch = key;
          }
        }
        if (bestMatch) {
          const target = imports[bestMatch];
          const pattern = bestMatch[bestMatch.length - 1] === &#039;*&#039;;
          const subpath = name.slice(bestMatch.length - (pattern ? 1 : 0));
          const resolved = resolvePackageTarget(packageJsonUrl, target, subpath, bestMatch, base, pattern, true, conditions);
          if (resolved !== null) {
            if (!pattern) emitFolderMapDeprecation(bestMatch, packageJsonUrl, false, base);
            return {
              resolved,
              exact: pattern
            };
          }
        }
      }
    }
  }
  throwImportNotDefined(name, packageJsonUrl, base);
}
function getPackageType(url) {
  const packageConfig = getPackageScopeConfig(url);
  return packageConfig.type;
}
function parsePackageName(specifier, base) {
  let separatorIndex = specifier.indexOf(&#039;/&#039;);
  let validPackageName = true;
  let isScoped = false;
  if (specifier[0] === &#039;@&#039;) {
    isScoped = true;
    if (separatorIndex === -1 || specifier.length === 0) {
      validPackageName = false;
    } else {
      separatorIndex = specifier.indexOf(&#039;/&#039;, separatorIndex + 1);
    }
  }
  const packageName = separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex);
  let i = -1;
  while (++i &lt; packageName.length) {
    if (packageName[i] === &#039;%&#039; || packageName[i] === &#039;\\&#039;) {
      validPackageName = false;
      break;
    }
  }
  if (!validPackageName) {
    throw new ERR_INVALID_MODULE_SPECIFIER(specifier, &#039;is not a valid package name&#039;, (0, _url().fileURLToPath)(base));
  }
  const packageSubpath = &#039;.&#039; + (separatorIndex === -1 ? &#039;&#039; : specifier.slice(separatorIndex));
  return {
    packageName,
    packageSubpath,
    isScoped
  };
}
function packageResolve(specifier, base, conditions) {
  const {
    packageName,
    packageSubpath,
    isScoped
  } = parsePackageName(specifier, base);
  const packageConfig = getPackageScopeConfig(base);
  if (packageConfig.exists) {
    const packageJsonUrl = (0, _url().pathToFileURL)(packageConfig.pjsonPath);
    if (packageConfig.name === packageName &amp;&amp; packageConfig.exports !== undefined &amp;&amp; packageConfig.exports !== null) {
      return packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions).resolved;
    }
  }
  let packageJsonUrl = new (_url().URL)(&#039;./node_modules/&#039; + packageName + &#039;/package.json&#039;, base);
  let packageJsonPath = (0, _url().fileURLToPath)(packageJsonUrl);
  let lastPath;
  do {
    const stat = tryStatSync(packageJsonPath.slice(0, -13));
    if (!stat.isDirectory()) {
      lastPath = packageJsonPath;
      packageJsonUrl = new (_url().URL)((isScoped ? &#039;../../../../node_modules/&#039; : &#039;../../../node_modules/&#039;) + packageName + &#039;/package.json&#039;, packageJsonUrl);
      packageJsonPath = (0, _url().fileURLToPath)(packageJsonUrl);
      continue;
    }
    const packageConfig = getPackageConfig(packageJsonPath, specifier, base);
    if (packageConfig.exports !== undefined &amp;&amp; packageConfig.exports !== null) return packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions).resolved;
    if (packageSubpath === &#039;.&#039;) return legacyMainResolve(packageJsonUrl, packageConfig, base);
    return new (_url().URL)(packageSubpath, packageJsonUrl);
  } while (packageJsonPath.length !== lastPath.length);
  throw new ERR_MODULE_NOT_FOUND(packageName, (0, _url().fileURLToPath)(base));
}
function isRelativeSpecifier(specifier) {
  if (specifier[0] === &#039;.&#039;) {
    if (specifier.length === 1 || specifier[1] === &#039;/&#039;) return true;
    if (specifier[1] === &#039;.&#039; &amp;&amp; (specifier.length === 2 || specifier[2] === &#039;/&#039;)) {
      return true;
    }
  }
  return false;
}
function shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {
  if (specifier === &#039;&#039;) return false;
  if (specifier[0] === &#039;/&#039;) return true;
  return isRelativeSpecifier(specifier);
}
function moduleResolve(specifier, base, conditions) {
  let resolved;
  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
    resolved = new (_url().URL)(specifier, base);
  } else if (specifier[0] === &#039;#&#039;) {
    ({
      resolved
    } = packageImportsResolve(specifier, base, conditions));
  } else {
    try {
      resolved = new (_url().URL)(specifier);
    } catch (_unused3) {
      resolved = packageResolve(specifier, base, conditions);
    }
  }
  return finalizeResolution(resolved, base);
}
function defaultResolve(specifier, context = {}) {
  const {
    parentURL
  } = context;
  let parsed;
  try {
    parsed = new (_url().URL)(specifier);
    if (parsed.protocol === &#039;data:&#039;) {
      return {
        url: specifier
      };
    }
  } catch (_unused4) {}
  if (parsed &amp;&amp; parsed.protocol === &#039;node:&#039;) return {
    url: specifier
  };
  if (parsed &amp;&amp; parsed.protocol !== &#039;file:&#039; &amp;&amp; parsed.protocol !== &#039;data:&#039;) throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(parsed);
  if (listOfBuiltins.includes(specifier)) {
    return {
      url: &#039;node:&#039; + specifier
    };
  }
  if (parentURL.startsWith(&#039;data:&#039;)) {
    new (_url().URL)(specifier, parentURL);
  }
  const conditions = getConditionsSet(context.conditions);
  let url = moduleResolve(specifier, new (_url().URL)(parentURL), conditions);
  const urlPath = (0, _url().fileURLToPath)(url);
  const real = (0, _fs().realpathSync)(urlPath);
  const old = url;
  url = (0, _url().pathToFileURL)(real + (urlPath.endsWith(_path().sep) ? &#039;/&#039; : &#039;&#039;));
  url.search = old.search;
  url.hash = old.hash;
  return {
    url: `${url}`
  };
}
function resolve(_x, _x2) {
  return _resolve.apply(this, arguments);
}
function _resolve() {
  _resolve = _asyncToGenerator(function* (specifier, parent) {
    if (!parent) {
      throw new Error(&#039;Please pass `parent`: `import-meta-resolve` cannot ponyfill that&#039;);
    }
    try {
      return defaultResolve(specifier, {
        parentURL: parent
      }).url;
    } catch (error) {
      return error.code === &#039;ERR_UNSUPPORTED_DIR_IMPORT&#039; ? error.url : Promise.reject(error);
    }
  });
  return _resolve.apply(this, arguments);
}
0 &amp;&amp; 0;

//# sourceMappingURL=import-meta-resolve.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
