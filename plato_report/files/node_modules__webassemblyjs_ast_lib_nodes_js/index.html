<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@webassemblyjs/ast/lib/nodes.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@webassemblyjs/ast/lib/nodes.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">64.91</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1144</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">74.25</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">14.88</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

Object.defineProperty(exports, &quot;__esModule&quot;, {
  value: true
});
exports.module = _module;
exports.moduleMetadata = moduleMetadata;
exports.moduleNameMetadata = moduleNameMetadata;
exports.functionNameMetadata = functionNameMetadata;
exports.localNameMetadata = localNameMetadata;
exports.binaryModule = binaryModule;
exports.quoteModule = quoteModule;
exports.sectionMetadata = sectionMetadata;
exports.producersSectionMetadata = producersSectionMetadata;
exports.producerMetadata = producerMetadata;
exports.producerMetadataVersionedName = producerMetadataVersionedName;
exports.loopInstruction = loopInstruction;
exports.instr = instr;
exports.ifInstruction = ifInstruction;
exports.stringLiteral = stringLiteral;
exports.numberLiteral = numberLiteral;
exports.longNumberLiteral = longNumberLiteral;
exports.floatLiteral = floatLiteral;
exports.elem = elem;
exports.indexInFuncSection = indexInFuncSection;
exports.valtypeLiteral = valtypeLiteral;
exports.typeInstruction = typeInstruction;
exports.start = start;
exports.globalType = globalType;
exports.leadingComment = leadingComment;
exports.blockComment = blockComment;
exports.data = data;
exports.global = global;
exports.table = table;
exports.memory = memory;
exports.funcImportDescr = funcImportDescr;
exports.moduleImport = moduleImport;
exports.moduleExportDescr = moduleExportDescr;
exports.moduleExport = moduleExport;
exports.limit = limit;
exports.signature = signature;
exports.program = program;
exports.identifier = identifier;
exports.blockInstruction = blockInstruction;
exports.callInstruction = callInstruction;
exports.callIndirectInstruction = callIndirectInstruction;
exports.byteArray = byteArray;
exports.func = func;
exports.internalBrUnless = internalBrUnless;
exports.internalGoto = internalGoto;
exports.internalCallExtern = internalCallExtern;
exports.internalEndAndReturn = internalEndAndReturn;
exports.assertInternalCallExtern = exports.assertInternalGoto = exports.assertInternalBrUnless = exports.assertFunc = exports.assertByteArray = exports.assertCallIndirectInstruction = exports.assertCallInstruction = exports.assertBlockInstruction = exports.assertIdentifier = exports.assertProgram = exports.assertSignature = exports.assertLimit = exports.assertModuleExport = exports.assertModuleExportDescr = exports.assertModuleImport = exports.assertFuncImportDescr = exports.assertMemory = exports.assertTable = exports.assertGlobal = exports.assertData = exports.assertBlockComment = exports.assertLeadingComment = exports.assertGlobalType = exports.assertStart = exports.assertTypeInstruction = exports.assertValtypeLiteral = exports.assertIndexInFuncSection = exports.assertElem = exports.assertFloatLiteral = exports.assertLongNumberLiteral = exports.assertNumberLiteral = exports.assertStringLiteral = exports.assertIfInstruction = exports.assertInstr = exports.assertLoopInstruction = exports.assertProducerMetadataVersionedName = exports.assertProducerMetadata = exports.assertProducersSectionMetadata = exports.assertSectionMetadata = exports.assertQuoteModule = exports.assertBinaryModule = exports.assertLocalNameMetadata = exports.assertFunctionNameMetadata = exports.assertModuleNameMetadata = exports.assertModuleMetadata = exports.assertModule = exports.isIntrinsic = exports.isImportDescr = exports.isNumericLiteral = exports.isExpression = exports.isInstruction = exports.isBlock = exports.isNode = exports.isInternalEndAndReturn = exports.isInternalCallExtern = exports.isInternalGoto = exports.isInternalBrUnless = exports.isFunc = exports.isByteArray = exports.isCallIndirectInstruction = exports.isCallInstruction = exports.isBlockInstruction = exports.isIdentifier = exports.isProgram = exports.isSignature = exports.isLimit = exports.isModuleExport = exports.isModuleExportDescr = exports.isModuleImport = exports.isFuncImportDescr = exports.isMemory = exports.isTable = exports.isGlobal = exports.isData = exports.isBlockComment = exports.isLeadingComment = exports.isGlobalType = exports.isStart = exports.isTypeInstruction = exports.isValtypeLiteral = exports.isIndexInFuncSection = exports.isElem = exports.isFloatLiteral = exports.isLongNumberLiteral = exports.isNumberLiteral = exports.isStringLiteral = exports.isIfInstruction = exports.isInstr = exports.isLoopInstruction = exports.isProducerMetadataVersionedName = exports.isProducerMetadata = exports.isProducersSectionMetadata = exports.isSectionMetadata = exports.isQuoteModule = exports.isBinaryModule = exports.isLocalNameMetadata = exports.isFunctionNameMetadata = exports.isModuleNameMetadata = exports.isModuleMetadata = exports.isModule = void 0;
exports.nodeAndUnionTypes = exports.unionTypesMap = exports.assertInternalEndAndReturn = void 0;

function _typeof(obj) { if (typeof Symbol === &quot;function&quot; &amp;&amp; typeof Symbol.iterator === &quot;symbol&quot;) { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj &amp;&amp; typeof Symbol === &quot;function&quot; &amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? &quot;symbol&quot; : typeof obj; }; } return _typeof(obj); }

// THIS FILE IS AUTOGENERATED
// see scripts/generateNodeUtils.js
function isTypeOf(t) {
  return function (n) {
    return n.type === t;
  };
}

function assertTypeOf(t) {
  return function (n) {
    return function () {
      if (!(n.type === t)) {
        throw new Error(&#039;n.type === t&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
      }
    }();
  };
}

function _module(id, fields, metadata) {
  if (id !== null &amp;&amp; id !== undefined) {
    if (!(typeof id === &quot;string&quot;)) {
      throw new Error(&#039;typeof id === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument id must be of type string, given: &quot; + _typeof(id) || &quot;unknown&quot;));
    }
  }

  if (!(_typeof(fields) === &quot;object&quot; &amp;&amp; typeof fields.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof fields === &quot;object&quot; &amp;&amp; typeof fields.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;Module&quot;,
    id: id,
    fields: fields
  };

  if (typeof metadata !== &quot;undefined&quot;) {
    node.metadata = metadata;
  }

  return node;
}

function moduleMetadata(sections, functionNames, localNames, producers) {
  if (!(_typeof(sections) === &quot;object&quot; &amp;&amp; typeof sections.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof sections === &quot;object&quot; &amp;&amp; typeof sections.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  if (functionNames !== null &amp;&amp; functionNames !== undefined) {
    if (!(_typeof(functionNames) === &quot;object&quot; &amp;&amp; typeof functionNames.length !== &quot;undefined&quot;)) {
      throw new Error(&#039;typeof functionNames === &quot;object&quot; &amp;&amp; typeof functionNames.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
    }
  }

  if (localNames !== null &amp;&amp; localNames !== undefined) {
    if (!(_typeof(localNames) === &quot;object&quot; &amp;&amp; typeof localNames.length !== &quot;undefined&quot;)) {
      throw new Error(&#039;typeof localNames === &quot;object&quot; &amp;&amp; typeof localNames.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
    }
  }

  if (producers !== null &amp;&amp; producers !== undefined) {
    if (!(_typeof(producers) === &quot;object&quot; &amp;&amp; typeof producers.length !== &quot;undefined&quot;)) {
      throw new Error(&#039;typeof producers === &quot;object&quot; &amp;&amp; typeof producers.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
    }
  }

  var node = {
    type: &quot;ModuleMetadata&quot;,
    sections: sections
  };

  if (typeof functionNames !== &quot;undefined&quot; &amp;&amp; functionNames.length &gt; 0) {
    node.functionNames = functionNames;
  }

  if (typeof localNames !== &quot;undefined&quot; &amp;&amp; localNames.length &gt; 0) {
    node.localNames = localNames;
  }

  if (typeof producers !== &quot;undefined&quot; &amp;&amp; producers.length &gt; 0) {
    node.producers = producers;
  }

  return node;
}

function moduleNameMetadata(value) {
  if (!(typeof value === &quot;string&quot;)) {
    throw new Error(&#039;typeof value === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument value must be of type string, given: &quot; + _typeof(value) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;ModuleNameMetadata&quot;,
    value: value
  };
  return node;
}

function functionNameMetadata(value, index) {
  if (!(typeof value === &quot;string&quot;)) {
    throw new Error(&#039;typeof value === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument value must be of type string, given: &quot; + _typeof(value) || &quot;unknown&quot;));
  }

  if (!(typeof index === &quot;number&quot;)) {
    throw new Error(&#039;typeof index === &quot;number&quot;&#039; + &quot; error: &quot; + (&quot;Argument index must be of type number, given: &quot; + _typeof(index) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;FunctionNameMetadata&quot;,
    value: value,
    index: index
  };
  return node;
}

function localNameMetadata(value, localIndex, functionIndex) {
  if (!(typeof value === &quot;string&quot;)) {
    throw new Error(&#039;typeof value === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument value must be of type string, given: &quot; + _typeof(value) || &quot;unknown&quot;));
  }

  if (!(typeof localIndex === &quot;number&quot;)) {
    throw new Error(&#039;typeof localIndex === &quot;number&quot;&#039; + &quot; error: &quot; + (&quot;Argument localIndex must be of type number, given: &quot; + _typeof(localIndex) || &quot;unknown&quot;));
  }

  if (!(typeof functionIndex === &quot;number&quot;)) {
    throw new Error(&#039;typeof functionIndex === &quot;number&quot;&#039; + &quot; error: &quot; + (&quot;Argument functionIndex must be of type number, given: &quot; + _typeof(functionIndex) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;LocalNameMetadata&quot;,
    value: value,
    localIndex: localIndex,
    functionIndex: functionIndex
  };
  return node;
}

function binaryModule(id, blob) {
  if (id !== null &amp;&amp; id !== undefined) {
    if (!(typeof id === &quot;string&quot;)) {
      throw new Error(&#039;typeof id === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument id must be of type string, given: &quot; + _typeof(id) || &quot;unknown&quot;));
    }
  }

  if (!(_typeof(blob) === &quot;object&quot; &amp;&amp; typeof blob.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof blob === &quot;object&quot; &amp;&amp; typeof blob.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;BinaryModule&quot;,
    id: id,
    blob: blob
  };
  return node;
}

function quoteModule(id, string) {
  if (id !== null &amp;&amp; id !== undefined) {
    if (!(typeof id === &quot;string&quot;)) {
      throw new Error(&#039;typeof id === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument id must be of type string, given: &quot; + _typeof(id) || &quot;unknown&quot;));
    }
  }

  if (!(_typeof(string) === &quot;object&quot; &amp;&amp; typeof string.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof string === &quot;object&quot; &amp;&amp; typeof string.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;QuoteModule&quot;,
    id: id,
    string: string
  };
  return node;
}

function sectionMetadata(section, startOffset, size, vectorOfSize) {
  if (!(typeof startOffset === &quot;number&quot;)) {
    throw new Error(&#039;typeof startOffset === &quot;number&quot;&#039; + &quot; error: &quot; + (&quot;Argument startOffset must be of type number, given: &quot; + _typeof(startOffset) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;SectionMetadata&quot;,
    section: section,
    startOffset: startOffset,
    size: size,
    vectorOfSize: vectorOfSize
  };
  return node;
}

function producersSectionMetadata(producers) {
  if (!(_typeof(producers) === &quot;object&quot; &amp;&amp; typeof producers.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof producers === &quot;object&quot; &amp;&amp; typeof producers.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;ProducersSectionMetadata&quot;,
    producers: producers
  };
  return node;
}

function producerMetadata(language, processedBy, sdk) {
  if (!(_typeof(language) === &quot;object&quot; &amp;&amp; typeof language.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof language === &quot;object&quot; &amp;&amp; typeof language.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  if (!(_typeof(processedBy) === &quot;object&quot; &amp;&amp; typeof processedBy.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof processedBy === &quot;object&quot; &amp;&amp; typeof processedBy.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  if (!(_typeof(sdk) === &quot;object&quot; &amp;&amp; typeof sdk.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof sdk === &quot;object&quot; &amp;&amp; typeof sdk.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;ProducerMetadata&quot;,
    language: language,
    processedBy: processedBy,
    sdk: sdk
  };
  return node;
}

function producerMetadataVersionedName(name, version) {
  if (!(typeof name === &quot;string&quot;)) {
    throw new Error(&#039;typeof name === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument name must be of type string, given: &quot; + _typeof(name) || &quot;unknown&quot;));
  }

  if (!(typeof version === &quot;string&quot;)) {
    throw new Error(&#039;typeof version === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument version must be of type string, given: &quot; + _typeof(version) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;ProducerMetadataVersionedName&quot;,
    name: name,
    version: version
  };
  return node;
}

function loopInstruction(label, resulttype, instr) {
  if (!(_typeof(instr) === &quot;object&quot; &amp;&amp; typeof instr.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof instr === &quot;object&quot; &amp;&amp; typeof instr.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;LoopInstruction&quot;,
    id: &quot;loop&quot;,
    label: label,
    resulttype: resulttype,
    instr: instr
  };
  return node;
}

function instr(id, object, args, namedArgs) {
  if (!(typeof id === &quot;string&quot;)) {
    throw new Error(&#039;typeof id === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument id must be of type string, given: &quot; + _typeof(id) || &quot;unknown&quot;));
  }

  if (!(_typeof(args) === &quot;object&quot; &amp;&amp; typeof args.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof args === &quot;object&quot; &amp;&amp; typeof args.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;Instr&quot;,
    id: id,
    args: args
  };

  if (typeof object !== &quot;undefined&quot;) {
    node.object = object;
  }

  if (typeof namedArgs !== &quot;undefined&quot; &amp;&amp; Object.keys(namedArgs).length !== 0) {
    node.namedArgs = namedArgs;
  }

  return node;
}

function ifInstruction(testLabel, test, result, consequent, alternate) {
  if (!(_typeof(test) === &quot;object&quot; &amp;&amp; typeof test.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof test === &quot;object&quot; &amp;&amp; typeof test.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  if (!(_typeof(consequent) === &quot;object&quot; &amp;&amp; typeof consequent.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof consequent === &quot;object&quot; &amp;&amp; typeof consequent.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  if (!(_typeof(alternate) === &quot;object&quot; &amp;&amp; typeof alternate.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof alternate === &quot;object&quot; &amp;&amp; typeof alternate.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;IfInstruction&quot;,
    id: &quot;if&quot;,
    testLabel: testLabel,
    test: test,
    result: result,
    consequent: consequent,
    alternate: alternate
  };
  return node;
}

function stringLiteral(value) {
  if (!(typeof value === &quot;string&quot;)) {
    throw new Error(&#039;typeof value === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument value must be of type string, given: &quot; + _typeof(value) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;StringLiteral&quot;,
    value: value
  };
  return node;
}

function numberLiteral(value, raw) {
  if (!(typeof value === &quot;number&quot;)) {
    throw new Error(&#039;typeof value === &quot;number&quot;&#039; + &quot; error: &quot; + (&quot;Argument value must be of type number, given: &quot; + _typeof(value) || &quot;unknown&quot;));
  }

  if (!(typeof raw === &quot;string&quot;)) {
    throw new Error(&#039;typeof raw === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument raw must be of type string, given: &quot; + _typeof(raw) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;NumberLiteral&quot;,
    value: value,
    raw: raw
  };
  return node;
}

function longNumberLiteral(value, raw) {
  if (!(typeof raw === &quot;string&quot;)) {
    throw new Error(&#039;typeof raw === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument raw must be of type string, given: &quot; + _typeof(raw) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;LongNumberLiteral&quot;,
    value: value,
    raw: raw
  };
  return node;
}

function floatLiteral(value, nan, inf, raw) {
  if (!(typeof value === &quot;number&quot;)) {
    throw new Error(&#039;typeof value === &quot;number&quot;&#039; + &quot; error: &quot; + (&quot;Argument value must be of type number, given: &quot; + _typeof(value) || &quot;unknown&quot;));
  }

  if (nan !== null &amp;&amp; nan !== undefined) {
    if (!(typeof nan === &quot;boolean&quot;)) {
      throw new Error(&#039;typeof nan === &quot;boolean&quot;&#039; + &quot; error: &quot; + (&quot;Argument nan must be of type boolean, given: &quot; + _typeof(nan) || &quot;unknown&quot;));
    }
  }

  if (inf !== null &amp;&amp; inf !== undefined) {
    if (!(typeof inf === &quot;boolean&quot;)) {
      throw new Error(&#039;typeof inf === &quot;boolean&quot;&#039; + &quot; error: &quot; + (&quot;Argument inf must be of type boolean, given: &quot; + _typeof(inf) || &quot;unknown&quot;));
    }
  }

  if (!(typeof raw === &quot;string&quot;)) {
    throw new Error(&#039;typeof raw === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument raw must be of type string, given: &quot; + _typeof(raw) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;FloatLiteral&quot;,
    value: value,
    raw: raw
  };

  if (nan === true) {
    node.nan = true;
  }

  if (inf === true) {
    node.inf = true;
  }

  return node;
}

function elem(table, offset, funcs) {
  if (!(_typeof(offset) === &quot;object&quot; &amp;&amp; typeof offset.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof offset === &quot;object&quot; &amp;&amp; typeof offset.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  if (!(_typeof(funcs) === &quot;object&quot; &amp;&amp; typeof funcs.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof funcs === &quot;object&quot; &amp;&amp; typeof funcs.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;Elem&quot;,
    table: table,
    offset: offset,
    funcs: funcs
  };
  return node;
}

function indexInFuncSection(index) {
  var node = {
    type: &quot;IndexInFuncSection&quot;,
    index: index
  };
  return node;
}

function valtypeLiteral(name) {
  var node = {
    type: &quot;ValtypeLiteral&quot;,
    name: name
  };
  return node;
}

function typeInstruction(id, functype) {
  var node = {
    type: &quot;TypeInstruction&quot;,
    id: id,
    functype: functype
  };
  return node;
}

function start(index) {
  var node = {
    type: &quot;Start&quot;,
    index: index
  };
  return node;
}

function globalType(valtype, mutability) {
  var node = {
    type: &quot;GlobalType&quot;,
    valtype: valtype,
    mutability: mutability
  };
  return node;
}

function leadingComment(value) {
  if (!(typeof value === &quot;string&quot;)) {
    throw new Error(&#039;typeof value === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument value must be of type string, given: &quot; + _typeof(value) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;LeadingComment&quot;,
    value: value
  };
  return node;
}

function blockComment(value) {
  if (!(typeof value === &quot;string&quot;)) {
    throw new Error(&#039;typeof value === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument value must be of type string, given: &quot; + _typeof(value) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;BlockComment&quot;,
    value: value
  };
  return node;
}

function data(memoryIndex, offset, init) {
  var node = {
    type: &quot;Data&quot;,
    memoryIndex: memoryIndex,
    offset: offset,
    init: init
  };
  return node;
}

function global(globalType, init, name) {
  if (!(_typeof(init) === &quot;object&quot; &amp;&amp; typeof init.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof init === &quot;object&quot; &amp;&amp; typeof init.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;Global&quot;,
    globalType: globalType,
    init: init,
    name: name
  };
  return node;
}

function table(elementType, limits, name, elements) {
  if (!(limits.type === &quot;Limit&quot;)) {
    throw new Error(&#039;limits.type === &quot;Limit&quot;&#039; + &quot; error: &quot; + (&quot;Argument limits must be of type Limit, given: &quot; + limits.type || &quot;unknown&quot;));
  }

  if (elements !== null &amp;&amp; elements !== undefined) {
    if (!(_typeof(elements) === &quot;object&quot; &amp;&amp; typeof elements.length !== &quot;undefined&quot;)) {
      throw new Error(&#039;typeof elements === &quot;object&quot; &amp;&amp; typeof elements.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
    }
  }

  var node = {
    type: &quot;Table&quot;,
    elementType: elementType,
    limits: limits,
    name: name
  };

  if (typeof elements !== &quot;undefined&quot; &amp;&amp; elements.length &gt; 0) {
    node.elements = elements;
  }

  return node;
}

function memory(limits, id) {
  var node = {
    type: &quot;Memory&quot;,
    limits: limits,
    id: id
  };
  return node;
}

function funcImportDescr(id, signature) {
  var node = {
    type: &quot;FuncImportDescr&quot;,
    id: id,
    signature: signature
  };
  return node;
}

function moduleImport(module, name, descr) {
  if (!(typeof module === &quot;string&quot;)) {
    throw new Error(&#039;typeof module === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument module must be of type string, given: &quot; + _typeof(module) || &quot;unknown&quot;));
  }

  if (!(typeof name === &quot;string&quot;)) {
    throw new Error(&#039;typeof name === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument name must be of type string, given: &quot; + _typeof(name) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;ModuleImport&quot;,
    module: module,
    name: name,
    descr: descr
  };
  return node;
}

function moduleExportDescr(exportType, id) {
  var node = {
    type: &quot;ModuleExportDescr&quot;,
    exportType: exportType,
    id: id
  };
  return node;
}

function moduleExport(name, descr) {
  if (!(typeof name === &quot;string&quot;)) {
    throw new Error(&#039;typeof name === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument name must be of type string, given: &quot; + _typeof(name) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;ModuleExport&quot;,
    name: name,
    descr: descr
  };
  return node;
}

function limit(min, max, shared) {
  if (!(typeof min === &quot;number&quot;)) {
    throw new Error(&#039;typeof min === &quot;number&quot;&#039; + &quot; error: &quot; + (&quot;Argument min must be of type number, given: &quot; + _typeof(min) || &quot;unknown&quot;));
  }

  if (max !== null &amp;&amp; max !== undefined) {
    if (!(typeof max === &quot;number&quot;)) {
      throw new Error(&#039;typeof max === &quot;number&quot;&#039; + &quot; error: &quot; + (&quot;Argument max must be of type number, given: &quot; + _typeof(max) || &quot;unknown&quot;));
    }
  }

  if (shared !== null &amp;&amp; shared !== undefined) {
    if (!(typeof shared === &quot;boolean&quot;)) {
      throw new Error(&#039;typeof shared === &quot;boolean&quot;&#039; + &quot; error: &quot; + (&quot;Argument shared must be of type boolean, given: &quot; + _typeof(shared) || &quot;unknown&quot;));
    }
  }

  var node = {
    type: &quot;Limit&quot;,
    min: min
  };

  if (typeof max !== &quot;undefined&quot;) {
    node.max = max;
  }

  if (shared === true) {
    node.shared = true;
  }

  return node;
}

function signature(params, results) {
  if (!(_typeof(params) === &quot;object&quot; &amp;&amp; typeof params.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof params === &quot;object&quot; &amp;&amp; typeof params.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  if (!(_typeof(results) === &quot;object&quot; &amp;&amp; typeof results.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof results === &quot;object&quot; &amp;&amp; typeof results.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;Signature&quot;,
    params: params,
    results: results
  };
  return node;
}

function program(body) {
  if (!(_typeof(body) === &quot;object&quot; &amp;&amp; typeof body.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof body === &quot;object&quot; &amp;&amp; typeof body.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;Program&quot;,
    body: body
  };
  return node;
}

function identifier(value, raw) {
  if (!(typeof value === &quot;string&quot;)) {
    throw new Error(&#039;typeof value === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument value must be of type string, given: &quot; + _typeof(value) || &quot;unknown&quot;));
  }

  if (raw !== null &amp;&amp; raw !== undefined) {
    if (!(typeof raw === &quot;string&quot;)) {
      throw new Error(&#039;typeof raw === &quot;string&quot;&#039; + &quot; error: &quot; + (&quot;Argument raw must be of type string, given: &quot; + _typeof(raw) || &quot;unknown&quot;));
    }
  }

  var node = {
    type: &quot;Identifier&quot;,
    value: value
  };

  if (typeof raw !== &quot;undefined&quot;) {
    node.raw = raw;
  }

  return node;
}

function blockInstruction(label, instr, result) {
  if (!(_typeof(instr) === &quot;object&quot; &amp;&amp; typeof instr.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof instr === &quot;object&quot; &amp;&amp; typeof instr.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;BlockInstruction&quot;,
    id: &quot;block&quot;,
    label: label,
    instr: instr,
    result: result
  };
  return node;
}

function callInstruction(index, instrArgs, numeric) {
  if (instrArgs !== null &amp;&amp; instrArgs !== undefined) {
    if (!(_typeof(instrArgs) === &quot;object&quot; &amp;&amp; typeof instrArgs.length !== &quot;undefined&quot;)) {
      throw new Error(&#039;typeof instrArgs === &quot;object&quot; &amp;&amp; typeof instrArgs.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
    }
  }

  var node = {
    type: &quot;CallInstruction&quot;,
    id: &quot;call&quot;,
    index: index
  };

  if (typeof instrArgs !== &quot;undefined&quot; &amp;&amp; instrArgs.length &gt; 0) {
    node.instrArgs = instrArgs;
  }

  if (typeof numeric !== &quot;undefined&quot;) {
    node.numeric = numeric;
  }

  return node;
}

function callIndirectInstruction(signature, intrs) {
  if (intrs !== null &amp;&amp; intrs !== undefined) {
    if (!(_typeof(intrs) === &quot;object&quot; &amp;&amp; typeof intrs.length !== &quot;undefined&quot;)) {
      throw new Error(&#039;typeof intrs === &quot;object&quot; &amp;&amp; typeof intrs.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
    }
  }

  var node = {
    type: &quot;CallIndirectInstruction&quot;,
    id: &quot;call_indirect&quot;,
    signature: signature
  };

  if (typeof intrs !== &quot;undefined&quot; &amp;&amp; intrs.length &gt; 0) {
    node.intrs = intrs;
  }

  return node;
}

function byteArray(values) {
  if (!(_typeof(values) === &quot;object&quot; &amp;&amp; typeof values.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof values === &quot;object&quot; &amp;&amp; typeof values.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;ByteArray&quot;,
    values: values
  };
  return node;
}

function func(name, signature, body, isExternal, metadata) {
  if (!(_typeof(body) === &quot;object&quot; &amp;&amp; typeof body.length !== &quot;undefined&quot;)) {
    throw new Error(&#039;typeof body === &quot;object&quot; &amp;&amp; typeof body.length !== &quot;undefined&quot;&#039; + &quot; error: &quot; + (undefined || &quot;unknown&quot;));
  }

  if (isExternal !== null &amp;&amp; isExternal !== undefined) {
    if (!(typeof isExternal === &quot;boolean&quot;)) {
      throw new Error(&#039;typeof isExternal === &quot;boolean&quot;&#039; + &quot; error: &quot; + (&quot;Argument isExternal must be of type boolean, given: &quot; + _typeof(isExternal) || &quot;unknown&quot;));
    }
  }

  var node = {
    type: &quot;Func&quot;,
    name: name,
    signature: signature,
    body: body
  };

  if (isExternal === true) {
    node.isExternal = true;
  }

  if (typeof metadata !== &quot;undefined&quot;) {
    node.metadata = metadata;
  }

  return node;
}

function internalBrUnless(target) {
  if (!(typeof target === &quot;number&quot;)) {
    throw new Error(&#039;typeof target === &quot;number&quot;&#039; + &quot; error: &quot; + (&quot;Argument target must be of type number, given: &quot; + _typeof(target) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;InternalBrUnless&quot;,
    target: target
  };
  return node;
}

function internalGoto(target) {
  if (!(typeof target === &quot;number&quot;)) {
    throw new Error(&#039;typeof target === &quot;number&quot;&#039; + &quot; error: &quot; + (&quot;Argument target must be of type number, given: &quot; + _typeof(target) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;InternalGoto&quot;,
    target: target
  };
  return node;
}

function internalCallExtern(target) {
  if (!(typeof target === &quot;number&quot;)) {
    throw new Error(&#039;typeof target === &quot;number&quot;&#039; + &quot; error: &quot; + (&quot;Argument target must be of type number, given: &quot; + _typeof(target) || &quot;unknown&quot;));
  }

  var node = {
    type: &quot;InternalCallExtern&quot;,
    target: target
  };
  return node;
}

function internalEndAndReturn() {
  var node = {
    type: &quot;InternalEndAndReturn&quot;
  };
  return node;
}

var isModule = isTypeOf(&quot;Module&quot;);
exports.isModule = isModule;
var isModuleMetadata = isTypeOf(&quot;ModuleMetadata&quot;);
exports.isModuleMetadata = isModuleMetadata;
var isModuleNameMetadata = isTypeOf(&quot;ModuleNameMetadata&quot;);
exports.isModuleNameMetadata = isModuleNameMetadata;
var isFunctionNameMetadata = isTypeOf(&quot;FunctionNameMetadata&quot;);
exports.isFunctionNameMetadata = isFunctionNameMetadata;
var isLocalNameMetadata = isTypeOf(&quot;LocalNameMetadata&quot;);
exports.isLocalNameMetadata = isLocalNameMetadata;
var isBinaryModule = isTypeOf(&quot;BinaryModule&quot;);
exports.isBinaryModule = isBinaryModule;
var isQuoteModule = isTypeOf(&quot;QuoteModule&quot;);
exports.isQuoteModule = isQuoteModule;
var isSectionMetadata = isTypeOf(&quot;SectionMetadata&quot;);
exports.isSectionMetadata = isSectionMetadata;
var isProducersSectionMetadata = isTypeOf(&quot;ProducersSectionMetadata&quot;);
exports.isProducersSectionMetadata = isProducersSectionMetadata;
var isProducerMetadata = isTypeOf(&quot;ProducerMetadata&quot;);
exports.isProducerMetadata = isProducerMetadata;
var isProducerMetadataVersionedName = isTypeOf(&quot;ProducerMetadataVersionedName&quot;);
exports.isProducerMetadataVersionedName = isProducerMetadataVersionedName;
var isLoopInstruction = isTypeOf(&quot;LoopInstruction&quot;);
exports.isLoopInstruction = isLoopInstruction;
var isInstr = isTypeOf(&quot;Instr&quot;);
exports.isInstr = isInstr;
var isIfInstruction = isTypeOf(&quot;IfInstruction&quot;);
exports.isIfInstruction = isIfInstruction;
var isStringLiteral = isTypeOf(&quot;StringLiteral&quot;);
exports.isStringLiteral = isStringLiteral;
var isNumberLiteral = isTypeOf(&quot;NumberLiteral&quot;);
exports.isNumberLiteral = isNumberLiteral;
var isLongNumberLiteral = isTypeOf(&quot;LongNumberLiteral&quot;);
exports.isLongNumberLiteral = isLongNumberLiteral;
var isFloatLiteral = isTypeOf(&quot;FloatLiteral&quot;);
exports.isFloatLiteral = isFloatLiteral;
var isElem = isTypeOf(&quot;Elem&quot;);
exports.isElem = isElem;
var isIndexInFuncSection = isTypeOf(&quot;IndexInFuncSection&quot;);
exports.isIndexInFuncSection = isIndexInFuncSection;
var isValtypeLiteral = isTypeOf(&quot;ValtypeLiteral&quot;);
exports.isValtypeLiteral = isValtypeLiteral;
var isTypeInstruction = isTypeOf(&quot;TypeInstruction&quot;);
exports.isTypeInstruction = isTypeInstruction;
var isStart = isTypeOf(&quot;Start&quot;);
exports.isStart = isStart;
var isGlobalType = isTypeOf(&quot;GlobalType&quot;);
exports.isGlobalType = isGlobalType;
var isLeadingComment = isTypeOf(&quot;LeadingComment&quot;);
exports.isLeadingComment = isLeadingComment;
var isBlockComment = isTypeOf(&quot;BlockComment&quot;);
exports.isBlockComment = isBlockComment;
var isData = isTypeOf(&quot;Data&quot;);
exports.isData = isData;
var isGlobal = isTypeOf(&quot;Global&quot;);
exports.isGlobal = isGlobal;
var isTable = isTypeOf(&quot;Table&quot;);
exports.isTable = isTable;
var isMemory = isTypeOf(&quot;Memory&quot;);
exports.isMemory = isMemory;
var isFuncImportDescr = isTypeOf(&quot;FuncImportDescr&quot;);
exports.isFuncImportDescr = isFuncImportDescr;
var isModuleImport = isTypeOf(&quot;ModuleImport&quot;);
exports.isModuleImport = isModuleImport;
var isModuleExportDescr = isTypeOf(&quot;ModuleExportDescr&quot;);
exports.isModuleExportDescr = isModuleExportDescr;
var isModuleExport = isTypeOf(&quot;ModuleExport&quot;);
exports.isModuleExport = isModuleExport;
var isLimit = isTypeOf(&quot;Limit&quot;);
exports.isLimit = isLimit;
var isSignature = isTypeOf(&quot;Signature&quot;);
exports.isSignature = isSignature;
var isProgram = isTypeOf(&quot;Program&quot;);
exports.isProgram = isProgram;
var isIdentifier = isTypeOf(&quot;Identifier&quot;);
exports.isIdentifier = isIdentifier;
var isBlockInstruction = isTypeOf(&quot;BlockInstruction&quot;);
exports.isBlockInstruction = isBlockInstruction;
var isCallInstruction = isTypeOf(&quot;CallInstruction&quot;);
exports.isCallInstruction = isCallInstruction;
var isCallIndirectInstruction = isTypeOf(&quot;CallIndirectInstruction&quot;);
exports.isCallIndirectInstruction = isCallIndirectInstruction;
var isByteArray = isTypeOf(&quot;ByteArray&quot;);
exports.isByteArray = isByteArray;
var isFunc = isTypeOf(&quot;Func&quot;);
exports.isFunc = isFunc;
var isInternalBrUnless = isTypeOf(&quot;InternalBrUnless&quot;);
exports.isInternalBrUnless = isInternalBrUnless;
var isInternalGoto = isTypeOf(&quot;InternalGoto&quot;);
exports.isInternalGoto = isInternalGoto;
var isInternalCallExtern = isTypeOf(&quot;InternalCallExtern&quot;);
exports.isInternalCallExtern = isInternalCallExtern;
var isInternalEndAndReturn = isTypeOf(&quot;InternalEndAndReturn&quot;);
exports.isInternalEndAndReturn = isInternalEndAndReturn;

var isNode = function isNode(node) {
  return isModule(node) || isModuleMetadata(node) || isModuleNameMetadata(node) || isFunctionNameMetadata(node) || isLocalNameMetadata(node) || isBinaryModule(node) || isQuoteModule(node) || isSectionMetadata(node) || isProducersSectionMetadata(node) || isProducerMetadata(node) || isProducerMetadataVersionedName(node) || isLoopInstruction(node) || isInstr(node) || isIfInstruction(node) || isStringLiteral(node) || isNumberLiteral(node) || isLongNumberLiteral(node) || isFloatLiteral(node) || isElem(node) || isIndexInFuncSection(node) || isValtypeLiteral(node) || isTypeInstruction(node) || isStart(node) || isGlobalType(node) || isLeadingComment(node) || isBlockComment(node) || isData(node) || isGlobal(node) || isTable(node) || isMemory(node) || isFuncImportDescr(node) || isModuleImport(node) || isModuleExportDescr(node) || isModuleExport(node) || isLimit(node) || isSignature(node) || isProgram(node) || isIdentifier(node) || isBlockInstruction(node) || isCallInstruction(node) || isCallIndirectInstruction(node) || isByteArray(node) || isFunc(node) || isInternalBrUnless(node) || isInternalGoto(node) || isInternalCallExtern(node) || isInternalEndAndReturn(node);
};

exports.isNode = isNode;

var isBlock = function isBlock(node) {
  return isLoopInstruction(node) || isBlockInstruction(node) || isFunc(node);
};

exports.isBlock = isBlock;

var isInstruction = function isInstruction(node) {
  return isLoopInstruction(node) || isInstr(node) || isIfInstruction(node) || isTypeInstruction(node) || isBlockInstruction(node) || isCallInstruction(node) || isCallIndirectInstruction(node);
};

exports.isInstruction = isInstruction;

var isExpression = function isExpression(node) {
  return isInstr(node) || isStringLiteral(node) || isNumberLiteral(node) || isLongNumberLiteral(node) || isFloatLiteral(node) || isValtypeLiteral(node) || isIdentifier(node);
};

exports.isExpression = isExpression;

var isNumericLiteral = function isNumericLiteral(node) {
  return isNumberLiteral(node) || isLongNumberLiteral(node) || isFloatLiteral(node);
};

exports.isNumericLiteral = isNumericLiteral;

var isImportDescr = function isImportDescr(node) {
  return isGlobalType(node) || isTable(node) || isMemory(node) || isFuncImportDescr(node);
};

exports.isImportDescr = isImportDescr;

var isIntrinsic = function isIntrinsic(node) {
  return isInternalBrUnless(node) || isInternalGoto(node) || isInternalCallExtern(node) || isInternalEndAndReturn(node);
};

exports.isIntrinsic = isIntrinsic;
var assertModule = assertTypeOf(&quot;Module&quot;);
exports.assertModule = assertModule;
var assertModuleMetadata = assertTypeOf(&quot;ModuleMetadata&quot;);
exports.assertModuleMetadata = assertModuleMetadata;
var assertModuleNameMetadata = assertTypeOf(&quot;ModuleNameMetadata&quot;);
exports.assertModuleNameMetadata = assertModuleNameMetadata;
var assertFunctionNameMetadata = assertTypeOf(&quot;FunctionNameMetadata&quot;);
exports.assertFunctionNameMetadata = assertFunctionNameMetadata;
var assertLocalNameMetadata = assertTypeOf(&quot;LocalNameMetadata&quot;);
exports.assertLocalNameMetadata = assertLocalNameMetadata;
var assertBinaryModule = assertTypeOf(&quot;BinaryModule&quot;);
exports.assertBinaryModule = assertBinaryModule;
var assertQuoteModule = assertTypeOf(&quot;QuoteModule&quot;);
exports.assertQuoteModule = assertQuoteModule;
var assertSectionMetadata = assertTypeOf(&quot;SectionMetadata&quot;);
exports.assertSectionMetadata = assertSectionMetadata;
var assertProducersSectionMetadata = assertTypeOf(&quot;ProducersSectionMetadata&quot;);
exports.assertProducersSectionMetadata = assertProducersSectionMetadata;
var assertProducerMetadata = assertTypeOf(&quot;ProducerMetadata&quot;);
exports.assertProducerMetadata = assertProducerMetadata;
var assertProducerMetadataVersionedName = assertTypeOf(&quot;ProducerMetadataVersionedName&quot;);
exports.assertProducerMetadataVersionedName = assertProducerMetadataVersionedName;
var assertLoopInstruction = assertTypeOf(&quot;LoopInstruction&quot;);
exports.assertLoopInstruction = assertLoopInstruction;
var assertInstr = assertTypeOf(&quot;Instr&quot;);
exports.assertInstr = assertInstr;
var assertIfInstruction = assertTypeOf(&quot;IfInstruction&quot;);
exports.assertIfInstruction = assertIfInstruction;
var assertStringLiteral = assertTypeOf(&quot;StringLiteral&quot;);
exports.assertStringLiteral = assertStringLiteral;
var assertNumberLiteral = assertTypeOf(&quot;NumberLiteral&quot;);
exports.assertNumberLiteral = assertNumberLiteral;
var assertLongNumberLiteral = assertTypeOf(&quot;LongNumberLiteral&quot;);
exports.assertLongNumberLiteral = assertLongNumberLiteral;
var assertFloatLiteral = assertTypeOf(&quot;FloatLiteral&quot;);
exports.assertFloatLiteral = assertFloatLiteral;
var assertElem = assertTypeOf(&quot;Elem&quot;);
exports.assertElem = assertElem;
var assertIndexInFuncSection = assertTypeOf(&quot;IndexInFuncSection&quot;);
exports.assertIndexInFuncSection = assertIndexInFuncSection;
var assertValtypeLiteral = assertTypeOf(&quot;ValtypeLiteral&quot;);
exports.assertValtypeLiteral = assertValtypeLiteral;
var assertTypeInstruction = assertTypeOf(&quot;TypeInstruction&quot;);
exports.assertTypeInstruction = assertTypeInstruction;
var assertStart = assertTypeOf(&quot;Start&quot;);
exports.assertStart = assertStart;
var assertGlobalType = assertTypeOf(&quot;GlobalType&quot;);
exports.assertGlobalType = assertGlobalType;
var assertLeadingComment = assertTypeOf(&quot;LeadingComment&quot;);
exports.assertLeadingComment = assertLeadingComment;
var assertBlockComment = assertTypeOf(&quot;BlockComment&quot;);
exports.assertBlockComment = assertBlockComment;
var assertData = assertTypeOf(&quot;Data&quot;);
exports.assertData = assertData;
var assertGlobal = assertTypeOf(&quot;Global&quot;);
exports.assertGlobal = assertGlobal;
var assertTable = assertTypeOf(&quot;Table&quot;);
exports.assertTable = assertTable;
var assertMemory = assertTypeOf(&quot;Memory&quot;);
exports.assertMemory = assertMemory;
var assertFuncImportDescr = assertTypeOf(&quot;FuncImportDescr&quot;);
exports.assertFuncImportDescr = assertFuncImportDescr;
var assertModuleImport = assertTypeOf(&quot;ModuleImport&quot;);
exports.assertModuleImport = assertModuleImport;
var assertModuleExportDescr = assertTypeOf(&quot;ModuleExportDescr&quot;);
exports.assertModuleExportDescr = assertModuleExportDescr;
var assertModuleExport = assertTypeOf(&quot;ModuleExport&quot;);
exports.assertModuleExport = assertModuleExport;
var assertLimit = assertTypeOf(&quot;Limit&quot;);
exports.assertLimit = assertLimit;
var assertSignature = assertTypeOf(&quot;Signature&quot;);
exports.assertSignature = assertSignature;
var assertProgram = assertTypeOf(&quot;Program&quot;);
exports.assertProgram = assertProgram;
var assertIdentifier = assertTypeOf(&quot;Identifier&quot;);
exports.assertIdentifier = assertIdentifier;
var assertBlockInstruction = assertTypeOf(&quot;BlockInstruction&quot;);
exports.assertBlockInstruction = assertBlockInstruction;
var assertCallInstruction = assertTypeOf(&quot;CallInstruction&quot;);
exports.assertCallInstruction = assertCallInstruction;
var assertCallIndirectInstruction = assertTypeOf(&quot;CallIndirectInstruction&quot;);
exports.assertCallIndirectInstruction = assertCallIndirectInstruction;
var assertByteArray = assertTypeOf(&quot;ByteArray&quot;);
exports.assertByteArray = assertByteArray;
var assertFunc = assertTypeOf(&quot;Func&quot;);
exports.assertFunc = assertFunc;
var assertInternalBrUnless = assertTypeOf(&quot;InternalBrUnless&quot;);
exports.assertInternalBrUnless = assertInternalBrUnless;
var assertInternalGoto = assertTypeOf(&quot;InternalGoto&quot;);
exports.assertInternalGoto = assertInternalGoto;
var assertInternalCallExtern = assertTypeOf(&quot;InternalCallExtern&quot;);
exports.assertInternalCallExtern = assertInternalCallExtern;
var assertInternalEndAndReturn = assertTypeOf(&quot;InternalEndAndReturn&quot;);
exports.assertInternalEndAndReturn = assertInternalEndAndReturn;
var unionTypesMap = {
  Module: [&quot;Node&quot;],
  ModuleMetadata: [&quot;Node&quot;],
  ModuleNameMetadata: [&quot;Node&quot;],
  FunctionNameMetadata: [&quot;Node&quot;],
  LocalNameMetadata: [&quot;Node&quot;],
  BinaryModule: [&quot;Node&quot;],
  QuoteModule: [&quot;Node&quot;],
  SectionMetadata: [&quot;Node&quot;],
  ProducersSectionMetadata: [&quot;Node&quot;],
  ProducerMetadata: [&quot;Node&quot;],
  ProducerMetadataVersionedName: [&quot;Node&quot;],
  LoopInstruction: [&quot;Node&quot;, &quot;Block&quot;, &quot;Instruction&quot;],
  Instr: [&quot;Node&quot;, &quot;Expression&quot;, &quot;Instruction&quot;],
  IfInstruction: [&quot;Node&quot;, &quot;Instruction&quot;],
  StringLiteral: [&quot;Node&quot;, &quot;Expression&quot;],
  NumberLiteral: [&quot;Node&quot;, &quot;NumericLiteral&quot;, &quot;Expression&quot;],
  LongNumberLiteral: [&quot;Node&quot;, &quot;NumericLiteral&quot;, &quot;Expression&quot;],
  FloatLiteral: [&quot;Node&quot;, &quot;NumericLiteral&quot;, &quot;Expression&quot;],
  Elem: [&quot;Node&quot;],
  IndexInFuncSection: [&quot;Node&quot;],
  ValtypeLiteral: [&quot;Node&quot;, &quot;Expression&quot;],
  TypeInstruction: [&quot;Node&quot;, &quot;Instruction&quot;],
  Start: [&quot;Node&quot;],
  GlobalType: [&quot;Node&quot;, &quot;ImportDescr&quot;],
  LeadingComment: [&quot;Node&quot;],
  BlockComment: [&quot;Node&quot;],
  Data: [&quot;Node&quot;],
  Global: [&quot;Node&quot;],
  Table: [&quot;Node&quot;, &quot;ImportDescr&quot;],
  Memory: [&quot;Node&quot;, &quot;ImportDescr&quot;],
  FuncImportDescr: [&quot;Node&quot;, &quot;ImportDescr&quot;],
  ModuleImport: [&quot;Node&quot;],
  ModuleExportDescr: [&quot;Node&quot;],
  ModuleExport: [&quot;Node&quot;],
  Limit: [&quot;Node&quot;],
  Signature: [&quot;Node&quot;],
  Program: [&quot;Node&quot;],
  Identifier: [&quot;Node&quot;, &quot;Expression&quot;],
  BlockInstruction: [&quot;Node&quot;, &quot;Block&quot;, &quot;Instruction&quot;],
  CallInstruction: [&quot;Node&quot;, &quot;Instruction&quot;],
  CallIndirectInstruction: [&quot;Node&quot;, &quot;Instruction&quot;],
  ByteArray: [&quot;Node&quot;],
  Func: [&quot;Node&quot;, &quot;Block&quot;],
  InternalBrUnless: [&quot;Node&quot;, &quot;Intrinsic&quot;],
  InternalGoto: [&quot;Node&quot;, &quot;Intrinsic&quot;],
  InternalCallExtern: [&quot;Node&quot;, &quot;Intrinsic&quot;],
  InternalEndAndReturn: [&quot;Node&quot;, &quot;Intrinsic&quot;]
};
exports.unionTypesMap = unionTypesMap;
var nodeAndUnionTypes = [&quot;Module&quot;, &quot;ModuleMetadata&quot;, &quot;ModuleNameMetadata&quot;, &quot;FunctionNameMetadata&quot;, &quot;LocalNameMetadata&quot;, &quot;BinaryModule&quot;, &quot;QuoteModule&quot;, &quot;SectionMetadata&quot;, &quot;ProducersSectionMetadata&quot;, &quot;ProducerMetadata&quot;, &quot;ProducerMetadataVersionedName&quot;, &quot;LoopInstruction&quot;, &quot;Instr&quot;, &quot;IfInstruction&quot;, &quot;StringLiteral&quot;, &quot;NumberLiteral&quot;, &quot;LongNumberLiteral&quot;, &quot;FloatLiteral&quot;, &quot;Elem&quot;, &quot;IndexInFuncSection&quot;, &quot;ValtypeLiteral&quot;, &quot;TypeInstruction&quot;, &quot;Start&quot;, &quot;GlobalType&quot;, &quot;LeadingComment&quot;, &quot;BlockComment&quot;, &quot;Data&quot;, &quot;Global&quot;, &quot;Table&quot;, &quot;Memory&quot;, &quot;FuncImportDescr&quot;, &quot;ModuleImport&quot;, &quot;ModuleExportDescr&quot;, &quot;ModuleExport&quot;, &quot;Limit&quot;, &quot;Signature&quot;, &quot;Program&quot;, &quot;Identifier&quot;, &quot;BlockInstruction&quot;, &quot;CallInstruction&quot;, &quot;CallIndirectInstruction&quot;, &quot;ByteArray&quot;, &quot;Func&quot;, &quot;InternalBrUnless&quot;, &quot;InternalGoto&quot;, &quot;InternalCallExtern&quot;, &quot;InternalEndAndReturn&quot;, &quot;Node&quot;, &quot;Block&quot;, &quot;Instruction&quot;, &quot;Expression&quot;, &quot;NumericLiteral&quot;, &quot;ImportDescr&quot;, &quot;Intrinsic&quot;];
exports.nodeAndUnionTypes = nodeAndUnionTypes;</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
