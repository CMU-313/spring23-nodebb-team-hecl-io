<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/ace-builds/src/ace.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/ace-builds/src/ace.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">61.81</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">19629</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">410.38</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">434.13</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

/**
 * Define a module along with a payload
 * @param module a name for the payload
 * @param payload a function to call with (require, exports, module) params
 */

(function() {

var ACE_NAMESPACE = &quot;&quot;;

var global = (function() { return this; })();
if (!global &amp;&amp; typeof window != &quot;undefined&quot;) global = window; // strict mode


if (!ACE_NAMESPACE &amp;&amp; typeof requirejs !== &quot;undefined&quot;)
    return;


var define = function(module, deps, payload) {
    if (typeof module !== &quot;string&quot;) {
        if (define.original)
            define.original.apply(this, arguments);
        else {
            console.error(&quot;dropping module because define wasn\&#039;t a string.&quot;);
            console.trace();
        }
        return;
    }
    if (arguments.length == 2)
        payload = deps;
    if (!define.modules[module]) {
        define.payloads[module] = payload;
        define.modules[module] = null;
    }
};

define.modules = {};
define.payloads = {};

/**
 * Get at functionality define()ed using the function above
 */
var _require = function(parentId, module, callback) {
    if (typeof module === &quot;string&quot;) {
        var payload = lookup(parentId, module);
        if (payload != undefined) {
            callback &amp;&amp; callback();
            return payload;
        }
    } else if (Object.prototype.toString.call(module) === &quot;[object Array]&quot;) {
        var params = [];
        for (var i = 0, l = module.length; i &lt; l; ++i) {
            var dep = lookup(parentId, module[i]);
            if (dep == undefined &amp;&amp; require.original)
                return;
            params.push(dep);
        }
        return callback &amp;&amp; callback.apply(null, params) || true;
    }
};

var require = function(module, callback) {
    var packagedModule = _require(&quot;&quot;, module, callback);
    if (packagedModule == undefined &amp;&amp; require.original)
        return require.original.apply(this, arguments);
    return packagedModule;
};

var normalizeModule = function(parentId, moduleName) {
    // normalize plugin requires
    if (moduleName.indexOf(&quot;!&quot;) !== -1) {
        var chunks = moduleName.split(&quot;!&quot;);
        return normalizeModule(parentId, chunks[0]) + &quot;!&quot; + normalizeModule(parentId, chunks[1]);
    }
    // normalize relative requires
    if (moduleName.charAt(0) == &quot;.&quot;) {
        var base = parentId.split(&quot;/&quot;).slice(0, -1).join(&quot;/&quot;);
        moduleName = base + &quot;/&quot; + moduleName;

        while(moduleName.indexOf(&quot;.&quot;) !== -1 &amp;&amp; previous != moduleName) {
            var previous = moduleName;
            moduleName = moduleName.replace(/\/\.\//, &quot;/&quot;).replace(/[^\/]+\/\.\.\//, &quot;&quot;);
        }
    }
    return moduleName;
};

/**
 * Internal function to lookup moduleNames and resolve them by calling the
 * definition function if needed.
 */
var lookup = function(parentId, moduleName) {
    moduleName = normalizeModule(parentId, moduleName);

    var module = define.modules[moduleName];
    if (!module) {
        module = define.payloads[moduleName];
        if (typeof module === &#039;function&#039;) {
            var exports = {};
            var mod = {
                id: moduleName,
                uri: &#039;&#039;,
                exports: exports,
                packaged: true
            };

            var req = function(module, callback) {
                return _require(moduleName, module, callback);
            };

            var returnValue = module(req, exports, mod);
            exports = returnValue || mod.exports;
            define.modules[moduleName] = exports;
            delete define.payloads[moduleName];
        }
        module = define.modules[moduleName] = exports || module;
    }
    return module;
};

function exportAce(ns) {
    var root = global;
    if (ns) {
        if (!global[ns])
            global[ns] = {};
        root = global[ns];
    }

    if (!root.define || !root.define.packaged) {
        define.original = root.define;
        root.define = define;
        root.define.packaged = true;
    }

    if (!root.require || !root.require.packaged) {
        require.original = root.require;
        root.require = require;
        root.require.packaged = true;
    }
}

exportAce(ACE_NAMESPACE);

})();

define(&quot;ace/lib/es6-shim&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;], function(require, exports, module){function defineProp(obj, name, val) {
    Object.defineProperty(obj, name, {
        value: val,
        enumerable: false,
        writable: true,
        configurable: true
    });
}
if (!String.prototype.startsWith) {
    defineProp(String.prototype, &quot;startsWith&quot;, function (searchString, position) {
        position = position || 0;
        return this.lastIndexOf(searchString, position) === position;
    });
}
if (!String.prototype.endsWith) {
    defineProp(String.prototype, &quot;endsWith&quot;, function (searchString, position) {
        var subjectString = this;
        if (position === undefined || position &gt; subjectString.length) {
            position = subjectString.length;
        }
        position -= searchString.length;
        var lastIndex = subjectString.indexOf(searchString, position);
        return lastIndex !== -1 &amp;&amp; lastIndex === position;
    });
}
if (!String.prototype.repeat) {
    defineProp(String.prototype, &quot;repeat&quot;, function (count) {
        var result = &quot;&quot;;
        var string = this;
        while (count &gt; 0) {
            if (count &amp; 1)
                result += string;
            if ((count &gt;&gt;= 1))
                string += string;
        }
        return result;
    });
}
if (!String.prototype.includes) {
    defineProp(String.prototype, &quot;includes&quot;, function (str, position) {
        return this.indexOf(str, position) != -1;
    });
}
if (!Object.assign) {
    Object.assign = function (target) {
        if (target === undefined || target === null) {
            throw new TypeError(&quot;Cannot convert undefined or null to object&quot;);
        }
        var output = Object(target);
        for (var index = 1; index &lt; arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined &amp;&amp; source !== null) {
                Object.keys(source).forEach(function (key) {
                    output[key] = source[key];
                });
            }
        }
        return output;
    };
}
if (!Object.values) {
    Object.values = function (o) {
        return Object.keys(o).map(function (k) {
            return o[k];
        });
    };
}
if (!Array.prototype.find) {
    defineProp(Array.prototype, &quot;find&quot;, function (predicate) {
        var len = this.length;
        var thisArg = arguments[1];
        for (var k = 0; k &lt; len; k++) {
            var kValue = this[k];
            if (predicate.call(thisArg, kValue, k, this)) {
                return kValue;
            }
        }
    });
}
if (!Array.prototype.findIndex) {
    defineProp(Array.prototype, &quot;findIndex&quot;, function (predicate) {
        var len = this.length;
        var thisArg = arguments[1];
        for (var k = 0; k &lt; len; k++) {
            var kValue = this[k];
            if (predicate.call(thisArg, kValue, k, this)) {
                return k;
            }
        }
    });
}
if (!Array.prototype.includes) {
    defineProp(Array.prototype, &quot;includes&quot;, function (item, position) {
        return this.indexOf(item, position) != -1;
    });
}
if (!Array.prototype.fill) {
    defineProp(Array.prototype, &quot;fill&quot;, function (value) {
        var O = this;
        var len = O.length &gt;&gt;&gt; 0;
        var start = arguments[1];
        var relativeStart = start &gt;&gt; 0;
        var k = relativeStart &lt; 0
            ? Math.max(len + relativeStart, 0)
            : Math.min(relativeStart, len);
        var end = arguments[2];
        var relativeEnd = end === undefined ? len : end &gt;&gt; 0;
        var final = relativeEnd &lt; 0
            ? Math.max(len + relativeEnd, 0)
            : Math.min(relativeEnd, len);
        while (k &lt; final) {
            O[k] = value;
            k++;
        }
        return O;
    });
}
if (!Array.of) {
    defineProp(Array, &quot;of&quot;, function () {
        return Array.prototype.slice.call(arguments);
    });
}

});

define(&quot;ace/lib/fixoldbrowsers&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/es6-shim&quot;], function(require, exports, module){// vim:set ts=4 sts=4 sw=4 st:
&quot;use strict&quot;;
require(&quot;./es6-shim&quot;);

});

define(&quot;ace/lib/lang&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;], function(require, exports, module){&quot;use strict&quot;;
exports.last = function (a) {
    return a[a.length - 1];
};
exports.stringReverse = function (string) {
    return string.split(&quot;&quot;).reverse().join(&quot;&quot;);
};
exports.stringRepeat = function (string, count) {
    var result = &#039;&#039;;
    while (count &gt; 0) {
        if (count &amp; 1)
            result += string;
        if (count &gt;&gt;= 1)
            string += string;
    }
    return result;
};
var trimBeginRegexp = /^\s\s*/;
var trimEndRegexp = /\s\s*$/;
exports.stringTrimLeft = function (string) {
    return string.replace(trimBeginRegexp, &#039;&#039;);
};
exports.stringTrimRight = function (string) {
    return string.replace(trimEndRegexp, &#039;&#039;);
};
exports.copyObject = function (obj) {
    var copy = {};
    for (var key in obj) {
        copy[key] = obj[key];
    }
    return copy;
};
exports.copyArray = function (array) {
    var copy = [];
    for (var i = 0, l = array.length; i &lt; l; i++) {
        if (array[i] &amp;&amp; typeof array[i] == &quot;object&quot;)
            copy[i] = this.copyObject(array[i]);
        else
            copy[i] = array[i];
    }
    return copy;
};
exports.deepCopy = function deepCopy(obj) {
    if (typeof obj !== &quot;object&quot; || !obj)
        return obj;
    var copy;
    if (Array.isArray(obj)) {
        copy = [];
        for (var key = 0; key &lt; obj.length; key++) {
            copy[key] = deepCopy(obj[key]);
        }
        return copy;
    }
    if (Object.prototype.toString.call(obj) !== &quot;[object Object]&quot;)
        return obj;
    copy = {};
    for (var key in obj)
        copy[key] = deepCopy(obj[key]);
    return copy;
};
exports.arrayToMap = function (arr) {
    var map = {};
    for (var i = 0; i &lt; arr.length; i++) {
        map[arr[i]] = 1;
    }
    return map;
};
exports.createMap = function (props) {
    var map = Object.create(null);
    for (var i in props) {
        map[i] = props[i];
    }
    return map;
};
exports.arrayRemove = function (array, value) {
    for (var i = 0; i &lt;= array.length; i++) {
        if (value === array[i]) {
            array.splice(i, 1);
        }
    }
};
exports.escapeRegExp = function (str) {
    return str.replace(/([.*+?^${}()|[\]\/\\])/g, &#039;\\$1&#039;);
};
exports.escapeHTML = function (str) {
    return (&quot;&quot; + str).replace(/&amp;/g, &quot;&amp;#38;&quot;).replace(/&quot;/g, &quot;&amp;#34;&quot;).replace(/&#039;/g, &quot;&amp;#39;&quot;).replace(/&lt;/g, &quot;&amp;#60;&quot;);
};
exports.getMatchOffsets = function (string, regExp) {
    var matches = [];
    string.replace(regExp, function (str) {
        matches.push({
            offset: arguments[arguments.length - 2],
            length: str.length
        });
    });
    return matches;
};
exports.deferredCall = function (fcn) {
    var timer = null;
    var callback = function () {
        timer = null;
        fcn();
    };
    var deferred = function (timeout) {
        deferred.cancel();
        timer = setTimeout(callback, timeout || 0);
        return deferred;
    };
    deferred.schedule = deferred;
    deferred.call = function () {
        this.cancel();
        fcn();
        return deferred;
    };
    deferred.cancel = function () {
        clearTimeout(timer);
        timer = null;
        return deferred;
    };
    deferred.isPending = function () {
        return timer;
    };
    return deferred;
};
exports.delayedCall = function (fcn, defaultTimeout) {
    var timer = null;
    var callback = function () {
        timer = null;
        fcn();
    };
    var _self = function (timeout) {
        if (timer == null)
            timer = setTimeout(callback, timeout || defaultTimeout);
    };
    _self.delay = function (timeout) {
        timer &amp;&amp; clearTimeout(timer);
        timer = setTimeout(callback, timeout || defaultTimeout);
    };
    _self.schedule = _self;
    _self.call = function () {
        this.cancel();
        fcn();
    };
    _self.cancel = function () {
        timer &amp;&amp; clearTimeout(timer);
        timer = null;
    };
    _self.isPending = function () {
        return timer;
    };
    return _self;
};

});

define(&quot;ace/lib/oop&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;], function(require, exports, module){&quot;use strict&quot;;
exports.inherits = function (ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
};
exports.mixin = function (obj, mixin) {
    for (var key in mixin) {
        obj[key] = mixin[key];
    }
    return obj;
};
exports.implement = function (proto, mixin) {
    exports.mixin(proto, mixin);
};

});

define(&quot;ace/lib/useragent&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;], function(require, exports, module){&quot;use strict&quot;;
exports.OS = {
    LINUX: &quot;LINUX&quot;,
    MAC: &quot;MAC&quot;,
    WINDOWS: &quot;WINDOWS&quot;
};
exports.getOS = function () {
    if (exports.isMac) {
        return exports.OS.MAC;
    }
    else if (exports.isLinux) {
        return exports.OS.LINUX;
    }
    else {
        return exports.OS.WINDOWS;
    }
};
var _navigator = typeof navigator == &quot;object&quot; ? navigator : {};
var os = (/mac|win|linux/i.exec(_navigator.platform) || [&quot;other&quot;])[0].toLowerCase();
var ua = _navigator.userAgent || &quot;&quot;;
var appName = _navigator.appName || &quot;&quot;;
exports.isWin = (os == &quot;win&quot;);
exports.isMac = (os == &quot;mac&quot;);
exports.isLinux = (os == &quot;linux&quot;);
exports.isIE =
    (appName == &quot;Microsoft Internet Explorer&quot; || appName.indexOf(&quot;MSAppHost&quot;) &gt;= 0)
        ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1])
        : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]); // for ie
exports.isOldIE = exports.isIE &amp;&amp; exports.isIE &lt; 9;
exports.isGecko = exports.isMozilla = ua.match(/ Gecko\/\d+/);
exports.isOpera = typeof opera == &quot;object&quot; &amp;&amp; Object.prototype.toString.call(window.opera) == &quot;[object Opera]&quot;;
exports.isWebKit = parseFloat(ua.split(&quot;WebKit/&quot;)[1]) || undefined;
exports.isChrome = parseFloat(ua.split(&quot; Chrome/&quot;)[1]) || undefined;
exports.isEdge = parseFloat(ua.split(&quot; Edge/&quot;)[1]) || undefined;
exports.isAIR = ua.indexOf(&quot;AdobeAIR&quot;) &gt;= 0;
exports.isAndroid = ua.indexOf(&quot;Android&quot;) &gt;= 0;
exports.isChromeOS = ua.indexOf(&quot; CrOS &quot;) &gt;= 0;
exports.isIOS = /iPad|iPhone|iPod/.test(ua) &amp;&amp; !window.MSStream;
if (exports.isIOS)
    exports.isMac = true;
exports.isMobile = exports.isIOS || exports.isAndroid;

});

define(&quot;ace/lib/dom&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/useragent&quot;], function(require, exports, module){&quot;use strict&quot;;
var useragent = require(&quot;./useragent&quot;);
var XHTML_NS = &quot;http://www.w3.org/1999/xhtml&quot;;
exports.buildDom = function buildDom(arr, parent, refs) {
    if (typeof arr == &quot;string&quot; &amp;&amp; arr) {
        var txt = document.createTextNode(arr);
        if (parent)
            parent.appendChild(txt);
        return txt;
    }
    if (!Array.isArray(arr)) {
        if (arr &amp;&amp; arr.appendChild &amp;&amp; parent)
            parent.appendChild(arr);
        return arr;
    }
    if (typeof arr[0] != &quot;string&quot; || !arr[0]) {
        var els = [];
        for (var i = 0; i &lt; arr.length; i++) {
            var ch = buildDom(arr[i], parent, refs);
            ch &amp;&amp; els.push(ch);
        }
        return els;
    }
    var el = document.createElement(arr[0]);
    var options = arr[1];
    var childIndex = 1;
    if (options &amp;&amp; typeof options == &quot;object&quot; &amp;&amp; !Array.isArray(options))
        childIndex = 2;
    for (var i = childIndex; i &lt; arr.length; i++)
        buildDom(arr[i], el, refs);
    if (childIndex == 2) {
        Object.keys(options).forEach(function (n) {
            var val = options[n];
            if (n === &quot;class&quot;) {
                el.className = Array.isArray(val) ? val.join(&quot; &quot;) : val;
            }
            else if (typeof val == &quot;function&quot; || n == &quot;value&quot; || n[0] == &quot;$&quot;) {
                el[n] = val;
            }
            else if (n === &quot;ref&quot;) {
                if (refs)
                    refs[val] = el;
            }
            else if (n === &quot;style&quot;) {
                if (typeof val == &quot;string&quot;)
                    el.style.cssText = val;
            }
            else if (val != null) {
                el.setAttribute(n, val);
            }
        });
    }
    if (parent)
        parent.appendChild(el);
    return el;
};
exports.getDocumentHead = function (doc) {
    if (!doc)
        doc = document;
    return doc.head || doc.getElementsByTagName(&quot;head&quot;)[0] || doc.documentElement;
};
exports.createElement = function (tag, ns) {
    return document.createElementNS ?
        document.createElementNS(ns || XHTML_NS, tag) :
        document.createElement(tag);
};
exports.removeChildren = function (element) {
    element.innerHTML = &quot;&quot;;
};
exports.createTextNode = function (textContent, element) {
    var doc = element ? element.ownerDocument : document;
    return doc.createTextNode(textContent);
};
exports.createFragment = function (element) {
    var doc = element ? element.ownerDocument : document;
    return doc.createDocumentFragment();
};
exports.hasCssClass = function (el, name) {
    var classes = (el.className + &quot;&quot;).split(/\s+/g);
    return classes.indexOf(name) !== -1;
};
exports.addCssClass = function (el, name) {
    if (!exports.hasCssClass(el, name)) {
        el.className += &quot; &quot; + name;
    }
};
exports.removeCssClass = function (el, name) {
    var classes = el.className.split(/\s+/g);
    while (true) {
        var index = classes.indexOf(name);
        if (index == -1) {
            break;
        }
        classes.splice(index, 1);
    }
    el.className = classes.join(&quot; &quot;);
};
exports.toggleCssClass = function (el, name) {
    var classes = el.className.split(/\s+/g), add = true;
    while (true) {
        var index = classes.indexOf(name);
        if (index == -1) {
            break;
        }
        add = false;
        classes.splice(index, 1);
    }
    if (add)
        classes.push(name);
    el.className = classes.join(&quot; &quot;);
    return add;
};
exports.setCssClass = function (node, className, include) {
    if (include) {
        exports.addCssClass(node, className);
    }
    else {
        exports.removeCssClass(node, className);
    }
};
exports.hasCssString = function (id, doc) {
    var index = 0, sheets;
    doc = doc || document;
    if ((sheets = doc.querySelectorAll(&quot;style&quot;))) {
        while (index &lt; sheets.length) {
            if (sheets[index++].id === id) {
                return true;
            }
        }
    }
};
exports.removeElementById = function (id, doc) {
    doc = doc || document;
    if (doc.getElementById(id)) {
        doc.getElementById(id).remove();
    }
};
var strictCSP;
var cssCache = [];
exports.useStrictCSP = function (value) {
    strictCSP = value;
    if (value == false)
        insertPendingStyles();
    else if (!cssCache)
        cssCache = [];
};
function insertPendingStyles() {
    var cache = cssCache;
    cssCache = null;
    cache &amp;&amp; cache.forEach(function (item) {
        importCssString(item[0], item[1]);
    });
}
function importCssString(cssText, id, target) {
    if (typeof document == &quot;undefined&quot;)
        return;
    if (cssCache) {
        if (target) {
            insertPendingStyles();
        }
        else if (target === false) {
            return cssCache.push([cssText, id]);
        }
    }
    if (strictCSP)
        return;
    var container = target;
    if (!target || !target.getRootNode) {
        container = document;
    }
    else {
        container = target.getRootNode();
        if (!container || container == target)
            container = document;
    }
    var doc = container.ownerDocument || container;
    if (id &amp;&amp; exports.hasCssString(id, container))
        return null;
    if (id)
        cssText += &quot;\n/*# sourceURL=ace/css/&quot; + id + &quot; */&quot;;
    var style = exports.createElement(&quot;style&quot;);
    style.appendChild(doc.createTextNode(cssText));
    if (id)
        style.id = id;
    if (container == doc)
        container = exports.getDocumentHead(doc);
    container.insertBefore(style, container.firstChild);
}
exports.importCssString = importCssString;
exports.importCssStylsheet = function (uri, doc) {
    exports.buildDom([&quot;link&quot;, { rel: &quot;stylesheet&quot;, href: uri }], exports.getDocumentHead(doc));
};
exports.scrollbarWidth = function (doc) {
    var inner = exports.createElement(&quot;ace_inner&quot;);
    inner.style.width = &quot;100%&quot;;
    inner.style.minWidth = &quot;0px&quot;;
    inner.style.height = &quot;200px&quot;;
    inner.style.display = &quot;block&quot;;
    var outer = exports.createElement(&quot;ace_outer&quot;);
    var style = outer.style;
    style.position = &quot;absolute&quot;;
    style.left = &quot;-10000px&quot;;
    style.overflow = &quot;hidden&quot;;
    style.width = &quot;200px&quot;;
    style.minWidth = &quot;0px&quot;;
    style.height = &quot;150px&quot;;
    style.display = &quot;block&quot;;
    outer.appendChild(inner);
    var body = (doc &amp;&amp; doc.documentElement) || (document &amp;&amp; document.documentElement);
    if (!body)
        return 0;
    body.appendChild(outer);
    var noScrollbar = inner.offsetWidth;
    style.overflow = &quot;scroll&quot;;
    var withScrollbar = inner.offsetWidth;
    if (noScrollbar === withScrollbar) {
        withScrollbar = outer.clientWidth;
    }
    body.removeChild(outer);
    return noScrollbar - withScrollbar;
};
exports.computedStyle = function (element, style) {
    return window.getComputedStyle(element, &quot;&quot;) || {};
};
exports.setStyle = function (styles, property, value) {
    if (styles[property] !== value) {
        styles[property] = value;
    }
};
exports.HAS_CSS_ANIMATION = false;
exports.HAS_CSS_TRANSFORMS = false;
exports.HI_DPI = useragent.isWin
    ? typeof window !== &quot;undefined&quot; &amp;&amp; window.devicePixelRatio &gt;= 1.5
    : true;
if (useragent.isChromeOS)
    exports.HI_DPI = false;
if (typeof document !== &quot;undefined&quot;) {
    var div = document.createElement(&quot;div&quot;);
    if (exports.HI_DPI &amp;&amp; div.style.transform !== undefined)
        exports.HAS_CSS_TRANSFORMS = true;
    if (!useragent.isEdge &amp;&amp; typeof div.style.animationName !== &quot;undefined&quot;)
        exports.HAS_CSS_ANIMATION = true;
    div = null;
}
if (exports.HAS_CSS_TRANSFORMS) {
    exports.translate = function (element, tx, ty) {
        element.style.transform = &quot;translate(&quot; + Math.round(tx) + &quot;px, &quot; + Math.round(ty) + &quot;px)&quot;;
    };
}
else {
    exports.translate = function (element, tx, ty) {
        element.style.top = Math.round(ty) + &quot;px&quot;;
        element.style.left = Math.round(tx) + &quot;px&quot;;
    };
}

});

define(&quot;ace/lib/net&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/dom&quot;], function(require, exports, module){/*
 * based on code from:
 *
 * @license RequireJS text 0.25.0 Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/requirejs for details
 */
&quot;use strict&quot;;
var dom = require(&quot;./dom&quot;);
exports.get = function (url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open(&#039;GET&#039;, url, true);
    xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
            callback(xhr.responseText);
        }
    };
    xhr.send(null);
};
exports.loadScript = function (path, callback) {
    var head = dom.getDocumentHead();
    var s = document.createElement(&#039;script&#039;);
    s.src = path;
    head.appendChild(s);
    s.onload = s.onreadystatechange = function (_, isAbort) {
        if (isAbort || !s.readyState || s.readyState == &quot;loaded&quot; || s.readyState == &quot;complete&quot;) {
            s = s.onload = s.onreadystatechange = null;
            if (!isAbort)
                callback();
        }
    };
};
exports.qualifyURL = function (url) {
    var a = document.createElement(&#039;a&#039;);
    a.href = url;
    return a.href;
};

});

define(&quot;ace/lib/event_emitter&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;], function(require, exports, module){&quot;use strict&quot;;
var EventEmitter = {};
var stopPropagation = function () { this.propagationStopped = true; };
var preventDefault = function () { this.defaultPrevented = true; };
EventEmitter._emit =
    EventEmitter._dispatchEvent = function (eventName, e) {
        this._eventRegistry || (this._eventRegistry = {});
        this._defaultHandlers || (this._defaultHandlers = {});
        var listeners = this._eventRegistry[eventName] || [];
        var defaultHandler = this._defaultHandlers[eventName];
        if (!listeners.length &amp;&amp; !defaultHandler)
            return;
        if (typeof e != &quot;object&quot; || !e)
            e = {};
        if (!e.type)
            e.type = eventName;
        if (!e.stopPropagation)
            e.stopPropagation = stopPropagation;
        if (!e.preventDefault)
            e.preventDefault = preventDefault;
        listeners = listeners.slice();
        for (var i = 0; i &lt; listeners.length; i++) {
            listeners[i](e, this);
            if (e.propagationStopped)
                break;
        }
        if (defaultHandler &amp;&amp; !e.defaultPrevented)
            return defaultHandler(e, this);
    };
EventEmitter._signal = function (eventName, e) {
    var listeners = (this._eventRegistry || {})[eventName];
    if (!listeners)
        return;
    listeners = listeners.slice();
    for (var i = 0; i &lt; listeners.length; i++)
        listeners[i](e, this);
};
EventEmitter.once = function (eventName, callback) {
    var _self = this;
    this.on(eventName, function newCallback() {
        _self.off(eventName, newCallback);
        callback.apply(null, arguments);
    });
    if (!callback) {
        return new Promise(function (resolve) {
            callback = resolve;
        });
    }
};
EventEmitter.setDefaultHandler = function (eventName, callback) {
    var handlers = this._defaultHandlers;
    if (!handlers)
        handlers = this._defaultHandlers = { _disabled_: {} };
    if (handlers[eventName]) {
        var old = handlers[eventName];
        var disabled = handlers._disabled_[eventName];
        if (!disabled)
            handlers._disabled_[eventName] = disabled = [];
        disabled.push(old);
        var i = disabled.indexOf(callback);
        if (i != -1)
            disabled.splice(i, 1);
    }
    handlers[eventName] = callback;
};
EventEmitter.removeDefaultHandler = function (eventName, callback) {
    var handlers = this._defaultHandlers;
    if (!handlers)
        return;
    var disabled = handlers._disabled_[eventName];
    if (handlers[eventName] == callback) {
        if (disabled)
            this.setDefaultHandler(eventName, disabled.pop());
    }
    else if (disabled) {
        var i = disabled.indexOf(callback);
        if (i != -1)
            disabled.splice(i, 1);
    }
};
EventEmitter.on =
    EventEmitter.addEventListener = function (eventName, callback, capturing) {
        this._eventRegistry = this._eventRegistry || {};
        var listeners = this._eventRegistry[eventName];
        if (!listeners)
            listeners = this._eventRegistry[eventName] = [];
        if (listeners.indexOf(callback) == -1)
            listeners[capturing ? &quot;unshift&quot; : &quot;push&quot;](callback);
        return callback;
    };
EventEmitter.off =
    EventEmitter.removeListener =
        EventEmitter.removeEventListener = function (eventName, callback) {
            this._eventRegistry = this._eventRegistry || {};
            var listeners = this._eventRegistry[eventName];
            if (!listeners)
                return;
            var index = listeners.indexOf(callback);
            if (index !== -1)
                listeners.splice(index, 1);
        };
EventEmitter.removeAllListeners = function (eventName) {
    if (!eventName)
        this._eventRegistry = this._defaultHandlers = undefined;
    if (this._eventRegistry)
        this._eventRegistry[eventName] = undefined;
    if (this._defaultHandlers)
        this._defaultHandlers[eventName] = undefined;
};
exports.EventEmitter = EventEmitter;

});

define(&quot;ace/lib/app_config&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/event_emitter&quot;], function(require, exports, module){&quot;no use strict&quot;;
var oop = require(&quot;./oop&quot;);
var EventEmitter = require(&quot;./event_emitter&quot;).EventEmitter;
var optionsProvider = {
    setOptions: function (optList) {
        Object.keys(optList).forEach(function (key) {
            this.setOption(key, optList[key]);
        }, this);
    },
    getOptions: function (optionNames) {
        var result = {};
        if (!optionNames) {
            var options = this.$options;
            optionNames = Object.keys(options).filter(function (key) {
                return !options[key].hidden;
            });
        }
        else if (!Array.isArray(optionNames)) {
            result = optionNames;
            optionNames = Object.keys(result);
        }
        optionNames.forEach(function (key) {
            result[key] = this.getOption(key);
        }, this);
        return result;
    },
    setOption: function (name, value) {
        if (this[&quot;$&quot; + name] === value)
            return;
        var opt = this.$options[name];
        if (!opt) {
            return warn(&#039;misspelled option &quot;&#039; + name + &#039;&quot;&#039;);
        }
        if (opt.forwardTo)
            return this[opt.forwardTo] &amp;&amp; this[opt.forwardTo].setOption(name, value);
        if (!opt.handlesSet)
            this[&quot;$&quot; + name] = value;
        if (opt &amp;&amp; opt.set)
            opt.set.call(this, value);
    },
    getOption: function (name) {
        var opt = this.$options[name];
        if (!opt) {
            return warn(&#039;misspelled option &quot;&#039; + name + &#039;&quot;&#039;);
        }
        if (opt.forwardTo)
            return this[opt.forwardTo] &amp;&amp; this[opt.forwardTo].getOption(name);
        return opt &amp;&amp; opt.get ? opt.get.call(this) : this[&quot;$&quot; + name];
    }
};
function warn(message) {
    if (typeof console != &quot;undefined&quot; &amp;&amp; console.warn)
        console.warn.apply(console, arguments);
}
function reportError(msg, data) {
    var e = new Error(msg);
    e.data = data;
    if (typeof console == &quot;object&quot; &amp;&amp; console.error)
        console.error(e);
    setTimeout(function () { throw e; });
}
var AppConfig = function () {
    this.$defaultOptions = {};
};
(function () {
    oop.implement(this, EventEmitter);
    this.defineOptions = function (obj, path, options) {
        if (!obj.$options)
            this.$defaultOptions[path] = obj.$options = {};
        Object.keys(options).forEach(function (key) {
            var opt = options[key];
            if (typeof opt == &quot;string&quot;)
                opt = { forwardTo: opt };
            opt.name || (opt.name = key);
            obj.$options[opt.name] = opt;
            if (&quot;initialValue&quot; in opt)
                obj[&quot;$&quot; + opt.name] = opt.initialValue;
        });
        oop.implement(obj, optionsProvider);
        return this;
    };
    this.resetOptions = function (obj) {
        Object.keys(obj.$options).forEach(function (key) {
            var opt = obj.$options[key];
            if (&quot;value&quot; in opt)
                obj.setOption(key, opt.value);
        });
    };
    this.setDefaultValue = function (path, name, value) {
        if (!path) {
            for (path in this.$defaultOptions)
                if (this.$defaultOptions[path][name])
                    break;
            if (!this.$defaultOptions[path][name])
                return false;
        }
        var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
        if (opts[name]) {
            if (opts.forwardTo)
                this.setDefaultValue(opts.forwardTo, name, value);
            else
                opts[name].value = value;
        }
    };
    this.setDefaultValues = function (path, optionHash) {
        Object.keys(optionHash).forEach(function (key) {
            this.setDefaultValue(path, key, optionHash[key]);
        }, this);
    };
    this.warn = warn;
    this.reportError = reportError;
}).call(AppConfig.prototype);
exports.AppConfig = AppConfig;

});

define(&quot;ace/theme/textmate.css&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;], function(require, exports, module){module.exports = &quot;.ace-tm .ace_gutter {\n  background: #f0f0f0;\n  color: #333;\n}\n\n.ace-tm .ace_print-margin {\n  width: 1px;\n  background: #e8e8e8;\n}\n\n.ace-tm .ace_fold {\n    background-color: #6B72E6;\n}\n\n.ace-tm {\n  background-color: #FFFFFF;\n  color: black;\n}\n\n.ace-tm .ace_cursor {\n  color: black;\n}\n        \n.ace-tm .ace_invisible {\n  color: rgb(191, 191, 191);\n}\n\n.ace-tm .ace_storage,\n.ace-tm .ace_keyword {\n  color: blue;\n}\n\n.ace-tm .ace_constant {\n  color: rgb(197, 6, 11);\n}\n\n.ace-tm .ace_constant.ace_buildin {\n  color: rgb(88, 72, 246);\n}\n\n.ace-tm .ace_constant.ace_language {\n  color: rgb(88, 92, 246);\n}\n\n.ace-tm .ace_constant.ace_library {\n  color: rgb(6, 150, 14);\n}\n\n.ace-tm .ace_invalid {\n  background-color: rgba(255, 0, 0, 0.1);\n  color: red;\n}\n\n.ace-tm .ace_support.ace_function {\n  color: rgb(60, 76, 114);\n}\n\n.ace-tm .ace_support.ace_constant {\n  color: rgb(6, 150, 14);\n}\n\n.ace-tm .ace_support.ace_type,\n.ace-tm .ace_support.ace_class {\n  color: rgb(109, 121, 222);\n}\n\n.ace-tm .ace_keyword.ace_operator {\n  color: rgb(104, 118, 135);\n}\n\n.ace-tm .ace_string {\n  color: rgb(3, 106, 7);\n}\n\n.ace-tm .ace_comment {\n  color: rgb(76, 136, 107);\n}\n\n.ace-tm .ace_comment.ace_doc {\n  color: rgb(0, 102, 255);\n}\n\n.ace-tm .ace_comment.ace_doc.ace_tag {\n  color: rgb(128, 159, 191);\n}\n\n.ace-tm .ace_constant.ace_numeric {\n  color: rgb(0, 0, 205);\n}\n\n.ace-tm .ace_variable {\n  color: rgb(49, 132, 149);\n}\n\n.ace-tm .ace_xml-pe {\n  color: rgb(104, 104, 91);\n}\n\n.ace-tm .ace_entity.ace_name.ace_function {\n  color: #0000A2;\n}\n\n\n.ace-tm .ace_heading {\n  color: rgb(12, 7, 255);\n}\n\n.ace-tm .ace_list {\n  color:rgb(185, 6, 144);\n}\n\n.ace-tm .ace_meta.ace_tag {\n  color:rgb(0, 22, 142);\n}\n\n.ace-tm .ace_string.ace_regex {\n  color: rgb(255, 0, 0)\n}\n\n.ace-tm .ace_marker-layer .ace_selection {\n  background: rgb(181, 213, 255);\n}\n.ace-tm.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px white;\n}\n.ace-tm .ace_marker-layer .ace_step {\n  background: rgb(252, 255, 0);\n}\n\n.ace-tm .ace_marker-layer .ace_stack {\n  background: rgb(164, 229, 101);\n}\n\n.ace-tm .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgb(192, 192, 192);\n}\n\n.ace-tm .ace_marker-layer .ace_active-line {\n  background: rgba(0, 0, 0, 0.07);\n}\n\n.ace-tm .ace_gutter-active-line {\n    background-color : #dcdcdc;\n}\n\n.ace-tm .ace_marker-layer .ace_selected-word {\n  background: rgb(250, 250, 255);\n  border: 1px solid rgb(200, 200, 250);\n}\n\n.ace-tm .ace_indent-guide {\n  background: url(\&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\&quot;) right repeat-y;\n}\n\n.ace-tm .ace_indent-guide-active {\n  background: url(\&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC\&quot;) right repeat-y;\n}\n&quot;;

});

define(&quot;ace/theme/textmate&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/theme/textmate.css&quot;,&quot;ace/lib/dom&quot;], function(require, exports, module){&quot;use strict&quot;;
exports.isDark = false;
exports.cssClass = &quot;ace-tm&quot;;
exports.cssText = require(&quot;./textmate.css&quot;);
exports.$id = &quot;ace/theme/textmate&quot;;
var dom = require(&quot;../lib/dom&quot;);
dom.importCssString(exports.cssText, exports.cssClass, false);

});

define(&quot;ace/config&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/lang&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/net&quot;,&quot;ace/lib/dom&quot;,&quot;ace/lib/app_config&quot;,&quot;ace/theme/textmate&quot;], function(require, exports, module){&quot;no use strict&quot;;
var lang = require(&quot;./lib/lang&quot;);
var oop = require(&quot;./lib/oop&quot;);
var net = require(&quot;./lib/net&quot;);
var dom = require(&quot;./lib/dom&quot;);
var AppConfig = require(&quot;./lib/app_config&quot;).AppConfig;
module.exports = exports = new AppConfig();
var options = {
    packaged: false,
    workerPath: null,
    modePath: null,
    themePath: null,
    basePath: &quot;&quot;,
    suffix: &quot;.js&quot;,
    $moduleUrls: {},
    loadWorkerFromBlob: true,
    sharedPopups: false,
    useStrictCSP: null
};
exports.get = function (key) {
    if (!options.hasOwnProperty(key))
        throw new Error(&quot;Unknown config key: &quot; + key);
    return options[key];
};
exports.set = function (key, value) {
    if (options.hasOwnProperty(key))
        options[key] = value;
    else if (this.setDefaultValue(&quot;&quot;, key, value) == false)
        throw new Error(&quot;Unknown config key: &quot; + key);
    if (key == &quot;useStrictCSP&quot;)
        dom.useStrictCSP(value);
};
exports.all = function () {
    return lang.copyObject(options);
};
exports.$modes = {};
exports.moduleUrl = function (name, component) {
    if (options.$moduleUrls[name])
        return options.$moduleUrls[name];
    var parts = name.split(&quot;/&quot;);
    component = component || parts[parts.length - 2] || &quot;&quot;;
    var sep = component == &quot;snippets&quot; ? &quot;/&quot; : &quot;-&quot;;
    var base = parts[parts.length - 1];
    if (component == &quot;worker&quot; &amp;&amp; sep == &quot;-&quot;) {
        var re = new RegExp(&quot;^&quot; + component + &quot;[\\-_]|[\\-_]&quot; + component + &quot;$&quot;, &quot;g&quot;);
        base = base.replace(re, &quot;&quot;);
    }
    if ((!base || base == component) &amp;&amp; parts.length &gt; 1)
        base = parts[parts.length - 2];
    var path = options[component + &quot;Path&quot;];
    if (path == null) {
        path = options.basePath;
    }
    else if (sep == &quot;/&quot;) {
        component = sep = &quot;&quot;;
    }
    if (path &amp;&amp; path.slice(-1) != &quot;/&quot;)
        path += &quot;/&quot;;
    return path + component + sep + base + this.get(&quot;suffix&quot;);
};
exports.setModuleUrl = function (name, subst) {
    return options.$moduleUrls[name] = subst;
};
var loader = function (moduleName, cb) {
    if (moduleName == &quot;ace/theme/textmate&quot;)
        return cb(null, require(&quot;./theme/textmate&quot;));
    return console.error(&quot;loader is not configured&quot;);
};
exports.setLoader = function (cb) {
    loader = cb;
};
exports.$loading = {};
exports.loadModule = function (moduleName, onLoad) {
    var module, moduleType;
    if (Array.isArray(moduleName)) {
        moduleType = moduleName[0];
        moduleName = moduleName[1];
    }
    try {
        module = require(moduleName);
    }
    catch (e) { }
    if (module &amp;&amp; !exports.$loading[moduleName])
        return onLoad &amp;&amp; onLoad(module);
    if (!exports.$loading[moduleName])
        exports.$loading[moduleName] = [];
    exports.$loading[moduleName].push(onLoad);
    if (exports.$loading[moduleName].length &gt; 1)
        return;
    var afterLoad = function () {
        loader(moduleName, function (err, module) {
            exports._emit(&quot;load.module&quot;, { name: moduleName, module: module });
            var listeners = exports.$loading[moduleName];
            exports.$loading[moduleName] = null;
            listeners.forEach(function (onLoad) {
                onLoad &amp;&amp; onLoad(module);
            });
        });
    };
    if (!exports.get(&quot;packaged&quot;))
        return afterLoad();
    net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);
    reportErrorIfPathIsNotConfigured();
};
var reportErrorIfPathIsNotConfigured = function () {
    if (!options.basePath &amp;&amp; !options.workerPath
        &amp;&amp; !options.modePath &amp;&amp; !options.themePath
        &amp;&amp; !Object.keys(options.$moduleUrls).length) {
        console.error(&quot;Unable to infer path to ace from script src,&quot;, &quot;use ace.config.set(&#039;basePath&#039;, &#039;path&#039;) to enable dynamic loading of modes and themes&quot;, &quot;or with webpack use ace/webpack-resolver&quot;);
        reportErrorIfPathIsNotConfigured = function () { };
    }
};
exports.version = &quot;1.14.0&quot;;

});

define(&quot;ace/loader_build&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/fixoldbrowsers&quot;,&quot;ace/config&quot;], function(require, exports, module) {
&quot;use strict&quot;;

require(&quot;./lib/fixoldbrowsers&quot;);
var config = require(&quot;./config&quot;);
config.setLoader(function(moduleName, cb) {
    require([moduleName], function(module) {
        cb(null, module);
    });
});

var global = (function() {
    return this || typeof window != &quot;undefined&quot; &amp;&amp; window;
})();

module.exports = function(ace) {
    config.init = init;
    ace.require = require;

    if (typeof define === &quot;function&quot;)
        ace.define = define;
};
init(true);function init(packaged) {

    if (!global || !global.document)
        return;
    
    config.set(&quot;packaged&quot;, packaged || require.packaged || module.packaged || (global.define &amp;&amp; define.packaged));

    var scriptOptions = {};
    var scriptUrl = &quot;&quot;;
    var currentScript = (document.currentScript || document._currentScript ); // native or polyfill
    var currentDocument = currentScript &amp;&amp; currentScript.ownerDocument || document;
    
    var scripts = currentDocument.getElementsByTagName(&quot;script&quot;);
    for (var i=0; i&lt;scripts.length; i++) {
        var script = scripts[i];

        var src = script.src || script.getAttribute(&quot;src&quot;);
        if (!src)
            continue;

        var attributes = script.attributes;
        for (var j=0, l=attributes.length; j &lt; l; j++) {
            var attr = attributes[j];
            if (attr.name.indexOf(&quot;data-ace-&quot;) === 0) {
                scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, &quot;&quot;))] = attr.value;
            }
        }

        var m = src.match(/^(.*)\/ace(\-\w+)?\.js(\?|$)/);
        if (m)
            scriptUrl = m[1];
    }

    if (scriptUrl) {
        scriptOptions.base = scriptOptions.base || scriptUrl;
        scriptOptions.packaged = true;
    }

    scriptOptions.basePath = scriptOptions.base;
    scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
    scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
    scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
    delete scriptOptions.base;

    for (var key in scriptOptions)
        if (typeof scriptOptions[key] !== &quot;undefined&quot;)
            config.set(key, scriptOptions[key]);
}

function deHyphenate(str) {
    return str.replace(/-(.)/g, function(m, m1) { return m1.toUpperCase(); });
}
});

define(&quot;ace/lib/keys&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;], function(require, exports, module){/*! @license
==========================================================================
SproutCore -- JavaScript Application Framework
copyright 2006-2009, Sprout Systems Inc., Apple Inc. and contributors.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the &quot;Software&quot;),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

SproutCore and the SproutCore logo are trademarks of Sprout Systems, Inc.

For more information about SproutCore, visit http://www.sproutcore.com


==========================================================================
@license */
&quot;use strict&quot;;
var oop = require(&quot;./oop&quot;);
var Keys = (function () {
    var ret = {
        MODIFIER_KEYS: {
            16: &#039;Shift&#039;, 17: &#039;Ctrl&#039;, 18: &#039;Alt&#039;, 224: &#039;Meta&#039;,
            91: &#039;MetaLeft&#039;, 92: &#039;MetaRight&#039;, 93: &#039;ContextMenu&#039;
        },
        KEY_MODS: {
            &quot;ctrl&quot;: 1, &quot;alt&quot;: 2, &quot;option&quot;: 2, &quot;shift&quot;: 4,
            &quot;super&quot;: 8, &quot;meta&quot;: 8, &quot;command&quot;: 8, &quot;cmd&quot;: 8,
            &quot;control&quot;: 1
        },
        FUNCTION_KEYS: {
            8: &quot;Backspace&quot;,
            9: &quot;Tab&quot;,
            13: &quot;Return&quot;,
            19: &quot;Pause&quot;,
            27: &quot;Esc&quot;,
            32: &quot;Space&quot;,
            33: &quot;PageUp&quot;,
            34: &quot;PageDown&quot;,
            35: &quot;End&quot;,
            36: &quot;Home&quot;,
            37: &quot;Left&quot;,
            38: &quot;Up&quot;,
            39: &quot;Right&quot;,
            40: &quot;Down&quot;,
            44: &quot;Print&quot;,
            45: &quot;Insert&quot;,
            46: &quot;Delete&quot;,
            96: &quot;Numpad0&quot;,
            97: &quot;Numpad1&quot;,
            98: &quot;Numpad2&quot;,
            99: &quot;Numpad3&quot;,
            100: &quot;Numpad4&quot;,
            101: &quot;Numpad5&quot;,
            102: &quot;Numpad6&quot;,
            103: &quot;Numpad7&quot;,
            104: &quot;Numpad8&quot;,
            105: &quot;Numpad9&quot;,
            &#039;-13&#039;: &quot;NumpadEnter&quot;,
            112: &quot;F1&quot;,
            113: &quot;F2&quot;,
            114: &quot;F3&quot;,
            115: &quot;F4&quot;,
            116: &quot;F5&quot;,
            117: &quot;F6&quot;,
            118: &quot;F7&quot;,
            119: &quot;F8&quot;,
            120: &quot;F9&quot;,
            121: &quot;F10&quot;,
            122: &quot;F11&quot;,
            123: &quot;F12&quot;,
            144: &quot;Numlock&quot;,
            145: &quot;Scrolllock&quot;
        },
        PRINTABLE_KEYS: {
            32: &#039; &#039;, 48: &#039;0&#039;, 49: &#039;1&#039;, 50: &#039;2&#039;, 51: &#039;3&#039;, 52: &#039;4&#039;, 53: &#039;5&#039;,
            54: &#039;6&#039;, 55: &#039;7&#039;, 56: &#039;8&#039;, 57: &#039;9&#039;, 59: &#039;;&#039;, 61: &#039;=&#039;, 65: &#039;a&#039;,
            66: &#039;b&#039;, 67: &#039;c&#039;, 68: &#039;d&#039;, 69: &#039;e&#039;, 70: &#039;f&#039;, 71: &#039;g&#039;, 72: &#039;h&#039;,
            73: &#039;i&#039;, 74: &#039;j&#039;, 75: &#039;k&#039;, 76: &#039;l&#039;, 77: &#039;m&#039;, 78: &#039;n&#039;, 79: &#039;o&#039;,
            80: &#039;p&#039;, 81: &#039;q&#039;, 82: &#039;r&#039;, 83: &#039;s&#039;, 84: &#039;t&#039;, 85: &#039;u&#039;, 86: &#039;v&#039;,
            87: &#039;w&#039;, 88: &#039;x&#039;, 89: &#039;y&#039;, 90: &#039;z&#039;, 107: &#039;+&#039;, 109: &#039;-&#039;, 110: &#039;.&#039;,
            186: &#039;;&#039;, 187: &#039;=&#039;, 188: &#039;,&#039;, 189: &#039;-&#039;, 190: &#039;.&#039;, 191: &#039;/&#039;, 192: &#039;`&#039;,
            219: &#039;[&#039;, 220: &#039;\\&#039;, 221: &#039;]&#039;, 222: &quot;&#039;&quot;, 111: &#039;/&#039;, 106: &#039;*&#039;
        }
    };
    ret.PRINTABLE_KEYS[173] = &#039;-&#039;;
    var name, i;
    for (i in ret.FUNCTION_KEYS) {
        name = ret.FUNCTION_KEYS[i].toLowerCase();
        ret[name] = parseInt(i, 10);
    }
    for (i in ret.PRINTABLE_KEYS) {
        name = ret.PRINTABLE_KEYS[i].toLowerCase();
        ret[name] = parseInt(i, 10);
    }
    oop.mixin(ret, ret.MODIFIER_KEYS);
    oop.mixin(ret, ret.PRINTABLE_KEYS);
    oop.mixin(ret, ret.FUNCTION_KEYS);
    ret.enter = ret[&quot;return&quot;];
    ret.escape = ret.esc;
    ret.del = ret[&quot;delete&quot;];
    (function () {
        var mods = [&quot;cmd&quot;, &quot;ctrl&quot;, &quot;alt&quot;, &quot;shift&quot;];
        for (var i = Math.pow(2, mods.length); i--;) {
            ret.KEY_MODS[i] = mods.filter(function (x) {
                return i &amp; ret.KEY_MODS[x];
            }).join(&quot;-&quot;) + &quot;-&quot;;
        }
    })();
    ret.KEY_MODS[0] = &quot;&quot;;
    ret.KEY_MODS[-1] = &quot;input-&quot;;
    return ret;
})();
oop.mixin(exports, Keys);
exports.keyCodeToString = function (keyCode) {
    var keyString = Keys[keyCode];
    if (typeof keyString != &quot;string&quot;)
        keyString = String.fromCharCode(keyCode);
    return keyString.toLowerCase();
};

});

define(&quot;ace/lib/event&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/keys&quot;,&quot;ace/lib/useragent&quot;], function(require, exports, module){&quot;use strict&quot;;
var keys = require(&quot;./keys&quot;);
var useragent = require(&quot;./useragent&quot;);
var pressedKeys = null;
var ts = 0;
var activeListenerOptions;
function detectListenerOptionsSupport() {
    activeListenerOptions = false;
    try {
        document.createComment(&quot;&quot;).addEventListener(&quot;test&quot;, function () { }, {
            get passive() {
                activeListenerOptions = { passive: false };
            }
        });
    }
    catch (e) { }
}
function getListenerOptions() {
    if (activeListenerOptions == undefined)
        detectListenerOptionsSupport();
    return activeListenerOptions;
}
function EventListener(elem, type, callback) {
    this.elem = elem;
    this.type = type;
    this.callback = callback;
}
EventListener.prototype.destroy = function () {
    removeListener(this.elem, this.type, this.callback);
    this.elem = this.type = this.callback = undefined;
};
var addListener = exports.addListener = function (elem, type, callback, destroyer) {
    elem.addEventListener(type, callback, getListenerOptions());
    if (destroyer)
        destroyer.$toDestroy.push(new EventListener(elem, type, callback));
};
var removeListener = exports.removeListener = function (elem, type, callback) {
    elem.removeEventListener(type, callback, getListenerOptions());
};
exports.stopEvent = function (e) {
    exports.stopPropagation(e);
    exports.preventDefault(e);
    return false;
};
exports.stopPropagation = function (e) {
    if (e.stopPropagation)
        e.stopPropagation();
};
exports.preventDefault = function (e) {
    if (e.preventDefault)
        e.preventDefault();
};
exports.getButton = function (e) {
    if (e.type == &quot;dblclick&quot;)
        return 0;
    if (e.type == &quot;contextmenu&quot; || (useragent.isMac &amp;&amp; (e.ctrlKey &amp;&amp; !e.altKey &amp;&amp; !e.shiftKey)))
        return 2;
    return e.button;
};
exports.capture = function (el, eventHandler, releaseCaptureHandler) {
    var ownerDocument = el &amp;&amp; el.ownerDocument || document;
    function onMouseUp(e) {
        eventHandler &amp;&amp; eventHandler(e);
        releaseCaptureHandler &amp;&amp; releaseCaptureHandler(e);
        removeListener(ownerDocument, &quot;mousemove&quot;, eventHandler);
        removeListener(ownerDocument, &quot;mouseup&quot;, onMouseUp);
        removeListener(ownerDocument, &quot;dragstart&quot;, onMouseUp);
    }
    addListener(ownerDocument, &quot;mousemove&quot;, eventHandler);
    addListener(ownerDocument, &quot;mouseup&quot;, onMouseUp);
    addListener(ownerDocument, &quot;dragstart&quot;, onMouseUp);
    return onMouseUp;
};
exports.addMouseWheelListener = function (el, callback, destroyer) {
    addListener(el, &quot;wheel&quot;, function (e) {
        var factor = 0.15;
        var deltaX = e.deltaX || 0;
        var deltaY = e.deltaY || 0;
        switch (e.deltaMode) {
            case e.DOM_DELTA_PIXEL:
                e.wheelX = deltaX * factor;
                e.wheelY = deltaY * factor;
                break;
            case e.DOM_DELTA_LINE:
                var linePixels = 15;
                e.wheelX = deltaX * linePixels;
                e.wheelY = deltaY * linePixels;
                break;
            case e.DOM_DELTA_PAGE:
                var pagePixels = 150;
                e.wheelX = deltaX * pagePixels;
                e.wheelY = deltaY * pagePixels;
                break;
        }
        callback(e);
    }, destroyer);
};
exports.addMultiMouseDownListener = function (elements, timeouts, eventHandler, callbackName, destroyer) {
    var clicks = 0;
    var startX, startY, timer;
    var eventNames = {
        2: &quot;dblclick&quot;,
        3: &quot;tripleclick&quot;,
        4: &quot;quadclick&quot;
    };
    function onMousedown(e) {
        if (exports.getButton(e) !== 0) {
            clicks = 0;
        }
        else if (e.detail &gt; 1) {
            clicks++;
            if (clicks &gt; 4)
                clicks = 1;
        }
        else {
            clicks = 1;
        }
        if (useragent.isIE) {
            var isNewClick = Math.abs(e.clientX - startX) &gt; 5 || Math.abs(e.clientY - startY) &gt; 5;
            if (!timer || isNewClick)
                clicks = 1;
            if (timer)
                clearTimeout(timer);
            timer = setTimeout(function () { timer = null; }, timeouts[clicks - 1] || 600);
            if (clicks == 1) {
                startX = e.clientX;
                startY = e.clientY;
            }
        }
        e._clicks = clicks;
        eventHandler[callbackName](&quot;mousedown&quot;, e);
        if (clicks &gt; 4)
            clicks = 0;
        else if (clicks &gt; 1)
            return eventHandler[callbackName](eventNames[clicks], e);
    }
    if (!Array.isArray(elements))
        elements = [elements];
    elements.forEach(function (el) {
        addListener(el, &quot;mousedown&quot;, onMousedown, destroyer);
    });
};
var getModifierHash = function (e) {
    return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
};
exports.getModifierString = function (e) {
    return keys.KEY_MODS[getModifierHash(e)];
};
function normalizeCommandKeys(callback, e, keyCode) {
    var hashId = getModifierHash(e);
    if (!useragent.isMac &amp;&amp; pressedKeys) {
        if (e.getModifierState &amp;&amp; (e.getModifierState(&quot;OS&quot;) || e.getModifierState(&quot;Win&quot;)))
            hashId |= 8;
        if (pressedKeys.altGr) {
            if ((3 &amp; hashId) != 3)
                pressedKeys.altGr = 0;
            else
                return;
        }
        if (keyCode === 18 || keyCode === 17) {
            var location = &quot;location&quot; in e ? e.location : e.keyLocation;
            if (keyCode === 17 &amp;&amp; location === 1) {
                if (pressedKeys[keyCode] == 1)
                    ts = e.timeStamp;
            }
            else if (keyCode === 18 &amp;&amp; hashId === 3 &amp;&amp; location === 2) {
                var dt = e.timeStamp - ts;
                if (dt &lt; 50)
                    pressedKeys.altGr = true;
            }
        }
    }
    if (keyCode in keys.MODIFIER_KEYS) {
        keyCode = -1;
    }
    if (!hashId &amp;&amp; keyCode === 13) {
        var location = &quot;location&quot; in e ? e.location : e.keyLocation;
        if (location === 3) {
            callback(e, hashId, -keyCode);
            if (e.defaultPrevented)
                return;
        }
    }
    if (useragent.isChromeOS &amp;&amp; hashId &amp; 8) {
        callback(e, hashId, keyCode);
        if (e.defaultPrevented)
            return;
        else
            hashId &amp;= ~8;
    }
    if (!hashId &amp;&amp; !(keyCode in keys.FUNCTION_KEYS) &amp;&amp; !(keyCode in keys.PRINTABLE_KEYS)) {
        return false;
    }
    return callback(e, hashId, keyCode);
}
exports.addCommandKeyListener = function (el, callback, destroyer) {
    if (useragent.isOldGecko || (useragent.isOpera &amp;&amp; !(&quot;KeyboardEvent&quot; in window))) {
        var lastKeyDownKeyCode = null;
        addListener(el, &quot;keydown&quot;, function (e) {
            lastKeyDownKeyCode = e.keyCode;
        }, destroyer);
        addListener(el, &quot;keypress&quot;, function (e) {
            return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
        }, destroyer);
    }
    else {
        var lastDefaultPrevented = null;
        addListener(el, &quot;keydown&quot;, function (e) {
            pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;
            var result = normalizeCommandKeys(callback, e, e.keyCode);
            lastDefaultPrevented = e.defaultPrevented;
            return result;
        }, destroyer);
        addListener(el, &quot;keypress&quot;, function (e) {
            if (lastDefaultPrevented &amp;&amp; (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
                exports.stopEvent(e);
                lastDefaultPrevented = null;
            }
        }, destroyer);
        addListener(el, &quot;keyup&quot;, function (e) {
            pressedKeys[e.keyCode] = null;
        }, destroyer);
        if (!pressedKeys) {
            resetPressedKeys();
            addListener(window, &quot;focus&quot;, resetPressedKeys);
        }
    }
};
function resetPressedKeys() {
    pressedKeys = Object.create(null);
}
if (typeof window == &quot;object&quot; &amp;&amp; window.postMessage &amp;&amp; !useragent.isOldIE) {
    var postMessageId = 1;
    exports.nextTick = function (callback, win) {
        win = win || window;
        var messageName = &quot;zero-timeout-message-&quot; + (postMessageId++);
        var listener = function (e) {
            if (e.data == messageName) {
                exports.stopPropagation(e);
                removeListener(win, &quot;message&quot;, listener);
                callback();
            }
        };
        addListener(win, &quot;message&quot;, listener);
        win.postMessage(messageName, &quot;*&quot;);
    };
}
exports.$idleBlocked = false;
exports.onIdle = function (cb, timeout) {
    return setTimeout(function handler() {
        if (!exports.$idleBlocked) {
            cb();
        }
        else {
            setTimeout(handler, 100);
        }
    }, timeout);
};
exports.$idleBlockId = null;
exports.blockIdle = function (delay) {
    if (exports.$idleBlockId)
        clearTimeout(exports.$idleBlockId);
    exports.$idleBlocked = true;
    exports.$idleBlockId = setTimeout(function () {
        exports.$idleBlocked = false;
    }, delay || 100);
};
exports.nextFrame = typeof window == &quot;object&quot; &amp;&amp; (window.requestAnimationFrame
    || window.mozRequestAnimationFrame
    || window.webkitRequestAnimationFrame
    || window.msRequestAnimationFrame
    || window.oRequestAnimationFrame);
if (exports.nextFrame)
    exports.nextFrame = exports.nextFrame.bind(window);
else
    exports.nextFrame = function (callback) {
        setTimeout(callback, 17);
    };

});

define(&quot;ace/range&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;], function(require, exports, module){&quot;use strict&quot;;
var comparePoints = function (p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
};
var Range = function (startRow, startColumn, endRow, endColumn) {
    this.start = {
        row: startRow,
        column: startColumn
    };
    this.end = {
        row: endRow,
        column: endColumn
    };
};
(function () {
    this.isEqual = function (range) {
        return this.start.row === range.start.row &amp;&amp;
            this.end.row === range.end.row &amp;&amp;
            this.start.column === range.start.column &amp;&amp;
            this.end.column === range.end.column;
    };
    this.toString = function () {
        return (&quot;Range: [&quot; + this.start.row + &quot;/&quot; + this.start.column +
            &quot;] -&gt; [&quot; + this.end.row + &quot;/&quot; + this.end.column + &quot;]&quot;);
    };
    this.contains = function (row, column) {
        return this.compare(row, column) == 0;
    };
    this.compareRange = function (range) {
        var cmp, end = range.end, start = range.start;
        cmp = this.compare(end.row, end.column);
        if (cmp == 1) {
            cmp = this.compare(start.row, start.column);
            if (cmp == 1) {
                return 2;
            }
            else if (cmp == 0) {
                return 1;
            }
            else {
                return 0;
            }
        }
        else if (cmp == -1) {
            return -2;
        }
        else {
            cmp = this.compare(start.row, start.column);
            if (cmp == -1) {
                return -1;
            }
            else if (cmp == 1) {
                return 42;
            }
            else {
                return 0;
            }
        }
    };
    this.comparePoint = function (p) {
        return this.compare(p.row, p.column);
    };
    this.containsRange = function (range) {
        return this.comparePoint(range.start) == 0 &amp;&amp; this.comparePoint(range.end) == 0;
    };
    this.intersects = function (range) {
        var cmp = this.compareRange(range);
        return (cmp == -1 || cmp == 0 || cmp == 1);
    };
    this.isEnd = function (row, column) {
        return this.end.row == row &amp;&amp; this.end.column == column;
    };
    this.isStart = function (row, column) {
        return this.start.row == row &amp;&amp; this.start.column == column;
    };
    this.setStart = function (row, column) {
        if (typeof row == &quot;object&quot;) {
            this.start.column = row.column;
            this.start.row = row.row;
        }
        else {
            this.start.row = row;
            this.start.column = column;
        }
    };
    this.setEnd = function (row, column) {
        if (typeof row == &quot;object&quot;) {
            this.end.column = row.column;
            this.end.row = row.row;
        }
        else {
            this.end.row = row;
            this.end.column = column;
        }
    };
    this.inside = function (row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column) || this.isStart(row, column)) {
                return false;
            }
            else {
                return true;
            }
        }
        return false;
    };
    this.insideStart = function (row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column)) {
                return false;
            }
            else {
                return true;
            }
        }
        return false;
    };
    this.insideEnd = function (row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isStart(row, column)) {
                return false;
            }
            else {
                return true;
            }
        }
        return false;
    };
    this.compare = function (row, column) {
        if (!this.isMultiLine()) {
            if (row === this.start.row) {
                return column &lt; this.start.column ? -1 : (column &gt; this.end.column ? 1 : 0);
            }
        }
        if (row &lt; this.start.row)
            return -1;
        if (row &gt; this.end.row)
            return 1;
        if (this.start.row === row)
            return column &gt;= this.start.column ? 0 : -1;
        if (this.end.row === row)
            return column &lt;= this.end.column ? 0 : 1;
        return 0;
    };
    this.compareStart = function (row, column) {
        if (this.start.row == row &amp;&amp; this.start.column == column) {
            return -1;
        }
        else {
            return this.compare(row, column);
        }
    };
    this.compareEnd = function (row, column) {
        if (this.end.row == row &amp;&amp; this.end.column == column) {
            return 1;
        }
        else {
            return this.compare(row, column);
        }
    };
    this.compareInside = function (row, column) {
        if (this.end.row == row &amp;&amp; this.end.column == column) {
            return 1;
        }
        else if (this.start.row == row &amp;&amp; this.start.column == column) {
            return -1;
        }
        else {
            return this.compare(row, column);
        }
    };
    this.clipRows = function (firstRow, lastRow) {
        if (this.end.row &gt; lastRow)
            var end = { row: lastRow + 1, column: 0 };
        else if (this.end.row &lt; firstRow)
            var end = { row: firstRow, column: 0 };
        if (this.start.row &gt; lastRow)
            var start = { row: lastRow + 1, column: 0 };
        else if (this.start.row &lt; firstRow)
            var start = { row: firstRow, column: 0 };
        return Range.fromPoints(start || this.start, end || this.end);
    };
    this.extend = function (row, column) {
        var cmp = this.compare(row, column);
        if (cmp == 0)
            return this;
        else if (cmp == -1)
            var start = { row: row, column: column };
        else
            var end = { row: row, column: column };
        return Range.fromPoints(start || this.start, end || this.end);
    };
    this.isEmpty = function () {
        return (this.start.row === this.end.row &amp;&amp; this.start.column === this.end.column);
    };
    this.isMultiLine = function () {
        return (this.start.row !== this.end.row);
    };
    this.clone = function () {
        return Range.fromPoints(this.start, this.end);
    };
    this.collapseRows = function () {
        if (this.end.column == 0)
            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);
        else
            return new Range(this.start.row, 0, this.end.row, 0);
    };
    this.toScreenRange = function (session) {
        var screenPosStart = session.documentToScreenPosition(this.start);
        var screenPosEnd = session.documentToScreenPosition(this.end);
        return new Range(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);
    };
    this.moveBy = function (row, column) {
        this.start.row += row;
        this.start.column += column;
        this.end.row += row;
        this.end.column += column;
    };
}).call(Range.prototype);
Range.fromPoints = function (start, end) {
    return new Range(start.row, start.column, end.row, end.column);
};
Range.comparePoints = comparePoints;
Range.comparePoints = function (p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
};
exports.Range = Range;

});

define(&quot;ace/clipboard&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;], function(require, exports, module){&quot;use strict&quot;;
var $cancelT;
module.exports = {
    lineMode: false,
    pasteCancelled: function () {
        if ($cancelT &amp;&amp; $cancelT &gt; Date.now() - 50)
            return true;
        return $cancelT = false;
    },
    cancel: function () {
        $cancelT = Date.now();
    }
};

});

define(&quot;ace/keyboard/textinput&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/event&quot;,&quot;ace/lib/useragent&quot;,&quot;ace/lib/dom&quot;,&quot;ace/lib/lang&quot;,&quot;ace/clipboard&quot;,&quot;ace/lib/keys&quot;], function(require, exports, module){&quot;use strict&quot;;
var event = require(&quot;../lib/event&quot;);
var useragent = require(&quot;../lib/useragent&quot;);
var dom = require(&quot;../lib/dom&quot;);
var lang = require(&quot;../lib/lang&quot;);
var clipboard = require(&quot;../clipboard&quot;);
var BROKEN_SETDATA = useragent.isChrome &lt; 18;
var USE_IE_MIME_TYPE = useragent.isIE;
var HAS_FOCUS_ARGS = useragent.isChrome &gt; 63;
var MAX_LINE_LENGTH = 400;
var KEYS = require(&quot;../lib/keys&quot;);
var MODS = KEYS.KEY_MODS;
var isIOS = useragent.isIOS;
var valueResetRegex = isIOS ? /\s/ : /\n/;
var isMobile = useragent.isMobile;
var TextInput = function (parentNode, host) {
    var text = dom.createElement(&quot;textarea&quot;);
    text.className = &quot;ace_text-input&quot;;
    text.setAttribute(&quot;wrap&quot;, &quot;off&quot;);
    text.setAttribute(&quot;autocorrect&quot;, &quot;off&quot;);
    text.setAttribute(&quot;autocapitalize&quot;, &quot;off&quot;);
    text.setAttribute(&quot;spellcheck&quot;, false);
    text.style.opacity = &quot;0&quot;;
    parentNode.insertBefore(text, parentNode.firstChild);
    var copied = false;
    var pasted = false;
    var inComposition = false;
    var sendingText = false;
    var tempStyle = &#039;&#039;;
    if (!isMobile)
        text.style.fontSize = &quot;1px&quot;;
    var commandMode = false;
    var ignoreFocusEvents = false;
    var lastValue = &quot;&quot;;
    var lastSelectionStart = 0;
    var lastSelectionEnd = 0;
    var lastRestoreEnd = 0;
    try {
        var isFocused = document.activeElement === text;
    }
    catch (e) { }
    this.setAriaOptions = function (options) {
        if (options.activeDescendant) {
            text.setAttribute(&quot;aria-haspopup&quot;, &quot;true&quot;);
            text.setAttribute(&quot;aria-autocomplete&quot;, &quot;list&quot;);
            text.setAttribute(&quot;aria-activedescendant&quot;, options.activeDescendant);
        }
        else {
            text.setAttribute(&quot;aria-haspopup&quot;, &quot;false&quot;);
            text.setAttribute(&quot;aria-autocomplete&quot;, &quot;both&quot;);
            text.removeAttribute(&quot;aria-activedescendant&quot;);
        }
        if (options.role) {
            text.setAttribute(&quot;role&quot;, options.role);
        }
    };
    this.setAriaOptions({ role: &quot;textbox&quot; });
    event.addListener(text, &quot;blur&quot;, function (e) {
        if (ignoreFocusEvents)
            return;
        host.onBlur(e);
        isFocused = false;
    }, host);
    event.addListener(text, &quot;focus&quot;, function (e) {
        if (ignoreFocusEvents)
            return;
        isFocused = true;
        if (useragent.isEdge) {
            try {
                if (!document.hasFocus())
                    return;
            }
            catch (e) { }
        }
        host.onFocus(e);
        if (useragent.isEdge)
            setTimeout(resetSelection);
        else
            resetSelection();
    }, host);
    this.$focusScroll = false;
    this.focus = function () {
        if (tempStyle || HAS_FOCUS_ARGS || this.$focusScroll == &quot;browser&quot;)
            return text.focus({ preventScroll: true });
        var top = text.style.top;
        text.style.position = &quot;fixed&quot;;
        text.style.top = &quot;0px&quot;;
        try {
            var isTransformed = text.getBoundingClientRect().top != 0;
        }
        catch (e) {
            return;
        }
        var ancestors = [];
        if (isTransformed) {
            var t = text.parentElement;
            while (t &amp;&amp; t.nodeType == 1) {
                ancestors.push(t);
                t.setAttribute(&quot;ace_nocontext&quot;, true);
                if (!t.parentElement &amp;&amp; t.getRootNode)
                    t = t.getRootNode().host;
                else
                    t = t.parentElement;
            }
        }
        text.focus({ preventScroll: true });
        if (isTransformed) {
            ancestors.forEach(function (p) {
                p.removeAttribute(&quot;ace_nocontext&quot;);
            });
        }
        setTimeout(function () {
            text.style.position = &quot;&quot;;
            if (text.style.top == &quot;0px&quot;)
                text.style.top = top;
        }, 0);
    };
    this.blur = function () {
        text.blur();
    };
    this.isFocused = function () {
        return isFocused;
    };
    host.on(&quot;beforeEndOperation&quot;, function () {
        var curOp = host.curOp;
        var commandName = curOp &amp;&amp; curOp.command &amp;&amp; curOp.command.name;
        if (commandName == &quot;insertstring&quot;)
            return;
        var isUserAction = commandName &amp;&amp; (curOp.docChanged || curOp.selectionChanged);
        if (inComposition &amp;&amp; isUserAction) {
            lastValue = text.value = &quot;&quot;;
            onCompositionEnd();
        }
        resetSelection();
    });
    var resetSelection = isIOS
        ? function (value) {
            if (!isFocused || (copied &amp;&amp; !value) || sendingText)
                return;
            if (!value)
                value = &quot;&quot;;
            var newValue = &quot;\n ab&quot; + value + &quot;cde fg\n&quot;;
            if (newValue != text.value)
                text.value = lastValue = newValue;
            var selectionStart = 4;
            var selectionEnd = 4 + (value.length || (host.selection.isEmpty() ? 0 : 1));
            if (lastSelectionStart != selectionStart || lastSelectionEnd != selectionEnd) {
                text.setSelectionRange(selectionStart, selectionEnd);
            }
            lastSelectionStart = selectionStart;
            lastSelectionEnd = selectionEnd;
        }
        : function () {
            if (inComposition || sendingText)
                return;
            if (!isFocused &amp;&amp; !afterContextMenu)
                return;
            inComposition = true;
            var selectionStart = 0;
            var selectionEnd = 0;
            var line = &quot;&quot;;
            if (host.session) {
                var selection = host.selection;
                var range = selection.getRange();
                var row = selection.cursor.row;
                selectionStart = range.start.column;
                selectionEnd = range.end.column;
                line = host.session.getLine(row);
                if (range.start.row != row) {
                    var prevLine = host.session.getLine(row - 1);
                    selectionStart = range.start.row &lt; row - 1 ? 0 : selectionStart;
                    selectionEnd += prevLine.length + 1;
                    line = prevLine + &quot;\n&quot; + line;
                }
                else if (range.end.row != row) {
                    var nextLine = host.session.getLine(row + 1);
                    selectionEnd = range.end.row &gt; row + 1 ? nextLine.length : selectionEnd;
                    selectionEnd += line.length + 1;
                    line = line + &quot;\n&quot; + nextLine;
                }
                else if (isMobile &amp;&amp; row &gt; 0) {
                    line = &quot;\n&quot; + line;
                    selectionEnd += 1;
                    selectionStart += 1;
                }
                if (line.length &gt; MAX_LINE_LENGTH) {
                    if (selectionStart &lt; MAX_LINE_LENGTH &amp;&amp; selectionEnd &lt; MAX_LINE_LENGTH) {
                        line = line.slice(0, MAX_LINE_LENGTH);
                    }
                    else {
                        line = &quot;\n&quot;;
                        if (selectionStart == selectionEnd) {
                            selectionStart = selectionEnd = 0;
                        }
                        else {
                            selectionStart = 0;
                            selectionEnd = 1;
                        }
                    }
                }
            }
            var newValue = line + &quot;\n\n&quot;;
            if (newValue != lastValue) {
                text.value = lastValue = newValue;
                lastSelectionStart = lastSelectionEnd = newValue.length;
            }
            if (afterContextMenu) {
                lastSelectionStart = text.selectionStart;
                lastSelectionEnd = text.selectionEnd;
            }
            if (lastSelectionEnd != selectionEnd
                || lastSelectionStart != selectionStart
                || text.selectionEnd != lastSelectionEnd // on ie edge selectionEnd changes silently after the initialization
            ) {
                try {
                    text.setSelectionRange(selectionStart, selectionEnd);
                    lastSelectionStart = selectionStart;
                    lastSelectionEnd = selectionEnd;
                }
                catch (e) { }
            }
            inComposition = false;
        };
    this.resetSelection = resetSelection;
    if (isFocused)
        host.onFocus();
    var isAllSelected = function (text) {
        return text.selectionStart === 0 &amp;&amp; text.selectionEnd &gt;= lastValue.length
            &amp;&amp; text.value === lastValue &amp;&amp; lastValue
            &amp;&amp; text.selectionEnd !== lastSelectionEnd;
    };
    var onSelect = function (e) {
        if (inComposition)
            return;
        if (copied) {
            copied = false;
        }
        else if (isAllSelected(text)) {
            host.selectAll();
            resetSelection();
        }
        else if (isMobile &amp;&amp; text.selectionStart != lastSelectionStart) {
            resetSelection();
        }
    };
    var inputHandler = null;
    this.setInputHandler = function (cb) { inputHandler = cb; };
    this.getInputHandler = function () { return inputHandler; };
    var afterContextMenu = false;
    var sendText = function (value, fromInput) {
        if (afterContextMenu)
            afterContextMenu = false;
        if (pasted) {
            resetSelection();
            if (value)
                host.onPaste(value);
            pasted = false;
            return &quot;&quot;;
        }
        else {
            var selectionStart = text.selectionStart;
            var selectionEnd = text.selectionEnd;
            var extendLeft = lastSelectionStart;
            var extendRight = lastValue.length - lastSelectionEnd;
            var inserted = value;
            var restoreStart = value.length - selectionStart;
            var restoreEnd = value.length - selectionEnd;
            var i = 0;
            while (extendLeft &gt; 0 &amp;&amp; lastValue[i] == value[i]) {
                i++;
                extendLeft--;
            }
            inserted = inserted.slice(i);
            i = 1;
            while (extendRight &gt; 0 &amp;&amp; lastValue.length - i &gt; lastSelectionStart - 1 &amp;&amp; lastValue[lastValue.length - i] == value[value.length - i]) {
                i++;
                extendRight--;
            }
            restoreStart -= i - 1;
            restoreEnd -= i - 1;
            var endIndex = inserted.length - i + 1;
            if (endIndex &lt; 0) {
                extendLeft = -endIndex;
                endIndex = 0;
            }
            inserted = inserted.slice(0, endIndex);
            if (!fromInput &amp;&amp; !inserted &amp;&amp; !restoreStart &amp;&amp; !extendLeft &amp;&amp; !extendRight &amp;&amp; !restoreEnd)
                return &quot;&quot;;
            sendingText = true;
            var shouldReset = false;
            if (useragent.isAndroid &amp;&amp; inserted == &quot;. &quot;) {
                inserted = &quot;  &quot;;
                shouldReset = true;
            }
            if (inserted &amp;&amp; !extendLeft &amp;&amp; !extendRight &amp;&amp; !restoreStart &amp;&amp; !restoreEnd || commandMode) {
                host.onTextInput(inserted);
            }
            else {
                host.onTextInput(inserted, {
                    extendLeft: extendLeft,
                    extendRight: extendRight,
                    restoreStart: restoreStart,
                    restoreEnd: restoreEnd
                });
            }
            sendingText = false;
            lastValue = value;
            lastSelectionStart = selectionStart;
            lastSelectionEnd = selectionEnd;
            lastRestoreEnd = restoreEnd;
            return shouldReset ? &quot;\n&quot; : inserted;
        }
    };
    var onInput = function (e) {
        if (inComposition)
            return onCompositionUpdate();
        if (e &amp;&amp; e.inputType) {
            if (e.inputType == &quot;historyUndo&quot;)
                return host.execCommand(&quot;undo&quot;);
            if (e.inputType == &quot;historyRedo&quot;)
                return host.execCommand(&quot;redo&quot;);
        }
        var data = text.value;
        var inserted = sendText(data, true);
        if (data.length &gt; MAX_LINE_LENGTH + 100
            || valueResetRegex.test(inserted)
            || isMobile &amp;&amp; lastSelectionStart &lt; 1 &amp;&amp; lastSelectionStart == lastSelectionEnd) {
            resetSelection();
        }
    };
    var handleClipboardData = function (e, data, forceIEMime) {
        var clipboardData = e.clipboardData || window.clipboardData;
        if (!clipboardData || BROKEN_SETDATA)
            return;
        var mime = USE_IE_MIME_TYPE || forceIEMime ? &quot;Text&quot; : &quot;text/plain&quot;;
        try {
            if (data) {
                return clipboardData.setData(mime, data) !== false;
            }
            else {
                return clipboardData.getData(mime);
            }
        }
        catch (e) {
            if (!forceIEMime)
                return handleClipboardData(e, data, true);
        }
    };
    var doCopy = function (e, isCut) {
        var data = host.getCopyText();
        if (!data)
            return event.preventDefault(e);
        if (handleClipboardData(e, data)) {
            if (isIOS) {
                resetSelection(data);
                copied = data;
                setTimeout(function () {
                    copied = false;
                }, 10);
            }
            isCut ? host.onCut() : host.onCopy();
            event.preventDefault(e);
        }
        else {
            copied = true;
            text.value = data;
            text.select();
            setTimeout(function () {
                copied = false;
                resetSelection();
                isCut ? host.onCut() : host.onCopy();
            });
        }
    };
    var onCut = function (e) {
        doCopy(e, true);
    };
    var onCopy = function (e) {
        doCopy(e, false);
    };
    var onPaste = function (e) {
        var data = handleClipboardData(e);
        if (clipboard.pasteCancelled())
            return;
        if (typeof data == &quot;string&quot;) {
            if (data)
                host.onPaste(data, e);
            if (useragent.isIE)
                setTimeout(resetSelection);
            event.preventDefault(e);
        }
        else {
            text.value = &quot;&quot;;
            pasted = true;
        }
    };
    event.addCommandKeyListener(text, host.onCommandKey.bind(host), host);
    event.addListener(text, &quot;select&quot;, onSelect, host);
    event.addListener(text, &quot;input&quot;, onInput, host);
    event.addListener(text, &quot;cut&quot;, onCut, host);
    event.addListener(text, &quot;copy&quot;, onCopy, host);
    event.addListener(text, &quot;paste&quot;, onPaste, host);
    if (!(&#039;oncut&#039; in text) || !(&#039;oncopy&#039; in text) || !(&#039;onpaste&#039; in text)) {
        event.addListener(parentNode, &quot;keydown&quot;, function (e) {
            if ((useragent.isMac &amp;&amp; !e.metaKey) || !e.ctrlKey)
                return;
            switch (e.keyCode) {
                case 67:
                    onCopy(e);
                    break;
                case 86:
                    onPaste(e);
                    break;
                case 88:
                    onCut(e);
                    break;
            }
        }, host);
    }
    var onCompositionStart = function (e) {
        if (inComposition || !host.onCompositionStart || host.$readOnly)
            return;
        inComposition = {};
        if (commandMode)
            return;
        if (e.data)
            inComposition.useTextareaForIME = false;
        setTimeout(onCompositionUpdate, 0);
        host._signal(&quot;compositionStart&quot;);
        host.on(&quot;mousedown&quot;, cancelComposition);
        var range = host.getSelectionRange();
        range.end.row = range.start.row;
        range.end.column = range.start.column;
        inComposition.markerRange = range;
        inComposition.selectionStart = lastSelectionStart;
        host.onCompositionStart(inComposition);
        if (inComposition.useTextareaForIME) {
            lastValue = text.value = &quot;&quot;;
            lastSelectionStart = 0;
            lastSelectionEnd = 0;
        }
        else {
            if (text.msGetInputContext)
                inComposition.context = text.msGetInputContext();
            if (text.getInputContext)
                inComposition.context = text.getInputContext();
        }
    };
    var onCompositionUpdate = function () {
        if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
            return;
        if (commandMode)
            return cancelComposition();
        if (inComposition.useTextareaForIME) {
            host.onCompositionUpdate(text.value);
        }
        else {
            var data = text.value;
            sendText(data);
            if (inComposition.markerRange) {
                if (inComposition.context) {
                    inComposition.markerRange.start.column = inComposition.selectionStart
                        = inComposition.context.compositionStartOffset;
                }
                inComposition.markerRange.end.column = inComposition.markerRange.start.column
                    + lastSelectionEnd - inComposition.selectionStart + lastRestoreEnd;
            }
        }
    };
    var onCompositionEnd = function (e) {
        if (!host.onCompositionEnd || host.$readOnly)
            return;
        inComposition = false;
        host.onCompositionEnd();
        host.off(&quot;mousedown&quot;, cancelComposition);
        if (e)
            onInput();
    };
    function cancelComposition() {
        ignoreFocusEvents = true;
        text.blur();
        text.focus();
        ignoreFocusEvents = false;
    }
    var syncComposition = lang.delayedCall(onCompositionUpdate, 50).schedule.bind(null, null);
    function onKeyup(e) {
        if (e.keyCode == 27 &amp;&amp; text.value.length &lt; text.selectionStart) {
            if (!inComposition)
                lastValue = text.value;
            lastSelectionStart = lastSelectionEnd = -1;
            resetSelection();
        }
        syncComposition();
    }
    event.addListener(text, &quot;compositionstart&quot;, onCompositionStart, host);
    event.addListener(text, &quot;compositionupdate&quot;, onCompositionUpdate, host);
    event.addListener(text, &quot;keyup&quot;, onKeyup, host);
    event.addListener(text, &quot;keydown&quot;, syncComposition, host);
    event.addListener(text, &quot;compositionend&quot;, onCompositionEnd, host);
    this.getElement = function () {
        return text;
    };
    this.setCommandMode = function (value) {
        commandMode = value;
        text.readOnly = false;
    };
    this.setReadOnly = function (readOnly) {
        if (!commandMode)
            text.readOnly = readOnly;
    };
    this.setCopyWithEmptySelection = function (value) {
    };
    this.onContextMenu = function (e) {
        afterContextMenu = true;
        resetSelection();
        host._emit(&quot;nativecontextmenu&quot;, { target: host, domEvent: e });
        this.moveToMouse(e, true);
    };
    this.moveToMouse = function (e, bringToFront) {
        if (!tempStyle)
            tempStyle = text.style.cssText;
        text.style.cssText = (bringToFront ? &quot;z-index:100000;&quot; : &quot;&quot;)
            + (useragent.isIE ? &quot;opacity:0.1;&quot; : &quot;&quot;)
            + &quot;text-indent: -&quot; + (lastSelectionStart + lastSelectionEnd) * host.renderer.characterWidth * 0.5 + &quot;px;&quot;;
        var rect = host.container.getBoundingClientRect();
        var style = dom.computedStyle(host.container);
        var top = rect.top + (parseInt(style.borderTopWidth) || 0);
        var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
        var maxTop = rect.bottom - top - text.clientHeight - 2;
        var move = function (e) {
            dom.translate(text, e.clientX - left - 2, Math.min(e.clientY - top - 2, maxTop));
        };
        move(e);
        if (e.type != &quot;mousedown&quot;)
            return;
        host.renderer.$isMousePressed = true;
        clearTimeout(closeTimeout);
        if (useragent.isWin)
            event.capture(host.container, move, onContextMenuClose);
    };
    this.onContextMenuClose = onContextMenuClose;
    var closeTimeout;
    function onContextMenuClose() {
        clearTimeout(closeTimeout);
        closeTimeout = setTimeout(function () {
            if (tempStyle) {
                text.style.cssText = tempStyle;
                tempStyle = &#039;&#039;;
            }
            host.renderer.$isMousePressed = false;
            if (host.renderer.$keepTextAreaAtCursor)
                host.renderer.$moveTextAreaToCursor();
        }, 0);
    }
    var onContextMenu = function (e) {
        host.textInput.onContextMenu(e);
        onContextMenuClose();
    };
    event.addListener(text, &quot;mouseup&quot;, onContextMenu, host);
    event.addListener(text, &quot;mousedown&quot;, function (e) {
        e.preventDefault();
        onContextMenuClose();
    }, host);
    event.addListener(host.renderer.scroller, &quot;contextmenu&quot;, onContextMenu, host);
    event.addListener(text, &quot;contextmenu&quot;, onContextMenu, host);
    if (isIOS)
        addIosSelectionHandler(parentNode, host, text);
    function addIosSelectionHandler(parentNode, host, text) {
        var typingResetTimeout = null;
        var typing = false;
        text.addEventListener(&quot;keydown&quot;, function (e) {
            if (typingResetTimeout)
                clearTimeout(typingResetTimeout);
            typing = true;
        }, true);
        text.addEventListener(&quot;keyup&quot;, function (e) {
            typingResetTimeout = setTimeout(function () {
                typing = false;
            }, 100);
        }, true);
        var detectArrowKeys = function (e) {
            if (document.activeElement !== text)
                return;
            if (typing || inComposition || host.$mouseHandler.isMousePressed)
                return;
            if (copied) {
                return;
            }
            var selectionStart = text.selectionStart;
            var selectionEnd = text.selectionEnd;
            var key = null;
            var modifier = 0;
            if (selectionStart == 0) {
                key = KEYS.up;
            }
            else if (selectionStart == 1) {
                key = KEYS.home;
            }
            else if (selectionEnd &gt; lastSelectionEnd &amp;&amp; lastValue[selectionEnd] == &quot;\n&quot;) {
                key = KEYS.end;
            }
            else if (selectionStart &lt; lastSelectionStart &amp;&amp; lastValue[selectionStart - 1] == &quot; &quot;) {
                key = KEYS.left;
                modifier = MODS.option;
            }
            else if (selectionStart &lt; lastSelectionStart
                || (selectionStart == lastSelectionStart
                    &amp;&amp; lastSelectionEnd != lastSelectionStart
                    &amp;&amp; selectionStart == selectionEnd)) {
                key = KEYS.left;
            }
            else if (selectionEnd &gt; lastSelectionEnd &amp;&amp; lastValue.slice(0, selectionEnd).split(&quot;\n&quot;).length &gt; 2) {
                key = KEYS.down;
            }
            else if (selectionEnd &gt; lastSelectionEnd &amp;&amp; lastValue[selectionEnd - 1] == &quot; &quot;) {
                key = KEYS.right;
                modifier = MODS.option;
            }
            else if (selectionEnd &gt; lastSelectionEnd
                || (selectionEnd == lastSelectionEnd
                    &amp;&amp; lastSelectionEnd != lastSelectionStart
                    &amp;&amp; selectionStart == selectionEnd)) {
                key = KEYS.right;
            }
            if (selectionStart !== selectionEnd)
                modifier |= MODS.shift;
            if (key) {
                var result = host.onCommandKey({}, modifier, key);
                if (!result &amp;&amp; host.commands) {
                    key = KEYS.keyCodeToString(key);
                    var command = host.commands.findKeyCommand(modifier, key);
                    if (command)
                        host.execCommand(command);
                }
                lastSelectionStart = selectionStart;
                lastSelectionEnd = selectionEnd;
                resetSelection(&quot;&quot;);
            }
        };
        document.addEventListener(&quot;selectionchange&quot;, detectArrowKeys);
        host.on(&quot;destroy&quot;, function () {
            document.removeEventListener(&quot;selectionchange&quot;, detectArrowKeys);
        });
    }
    this.destroy = function () {
        if (text.parentElement)
            text.parentElement.removeChild(text);
    };
};
exports.TextInput = TextInput;
exports.$setUserAgentForTests = function (_isMobile, _isIOS) {
    isMobile = _isMobile;
    isIOS = _isIOS;
};

});

define(&quot;ace/mouse/default_handlers&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/useragent&quot;], function(require, exports, module){&quot;use strict&quot;;
var useragent = require(&quot;../lib/useragent&quot;);
var DRAG_OFFSET = 0; // pixels
var SCROLL_COOLDOWN_T = 550; // milliseconds
function DefaultHandlers(mouseHandler) {
    mouseHandler.$clickSelection = null;
    var editor = mouseHandler.editor;
    editor.setDefaultHandler(&quot;mousedown&quot;, this.onMouseDown.bind(mouseHandler));
    editor.setDefaultHandler(&quot;dblclick&quot;, this.onDoubleClick.bind(mouseHandler));
    editor.setDefaultHandler(&quot;tripleclick&quot;, this.onTripleClick.bind(mouseHandler));
    editor.setDefaultHandler(&quot;quadclick&quot;, this.onQuadClick.bind(mouseHandler));
    editor.setDefaultHandler(&quot;mousewheel&quot;, this.onMouseWheel.bind(mouseHandler));
    var exports = [&quot;select&quot;, &quot;startSelect&quot;, &quot;selectEnd&quot;, &quot;selectAllEnd&quot;, &quot;selectByWordsEnd&quot;,
        &quot;selectByLinesEnd&quot;, &quot;dragWait&quot;, &quot;dragWaitEnd&quot;, &quot;focusWait&quot;];
    exports.forEach(function (x) {
        mouseHandler[x] = this[x];
    }, this);
    mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, &quot;getLineRange&quot;);
    mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, &quot;getWordRange&quot;);
}
(function () {
    this.onMouseDown = function (ev) {
        var inSelection = ev.inSelection();
        var pos = ev.getDocumentPosition();
        this.mousedownEvent = ev;
        var editor = this.editor;
        var button = ev.getButton();
        if (button !== 0) {
            var selectionRange = editor.getSelectionRange();
            var selectionEmpty = selectionRange.isEmpty();
            if (selectionEmpty || button == 1)
                editor.selection.moveToPosition(pos);
            if (button == 2) {
                editor.textInput.onContextMenu(ev.domEvent);
                if (!useragent.isMozilla)
                    ev.preventDefault();
            }
            return;
        }
        this.mousedownEvent.time = Date.now();
        if (inSelection &amp;&amp; !editor.isFocused()) {
            editor.focus();
            if (this.$focusTimeout &amp;&amp; !this.$clickSelection &amp;&amp; !editor.inMultiSelectMode) {
                this.setState(&quot;focusWait&quot;);
                this.captureMouse(ev);
                return;
            }
        }
        this.captureMouse(ev);
        this.startSelect(pos, ev.domEvent._clicks &gt; 1);
        return ev.preventDefault();
    };
    this.startSelect = function (pos, waitForClickSelection) {
        pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
        var editor = this.editor;
        if (!this.mousedownEvent)
            return;
        if (this.mousedownEvent.getShiftKey())
            editor.selection.selectToPosition(pos);
        else if (!waitForClickSelection)
            editor.selection.moveToPosition(pos);
        if (!waitForClickSelection)
            this.select();
        if (editor.renderer.scroller.setCapture) {
            editor.renderer.scroller.setCapture();
        }
        editor.setStyle(&quot;ace_selecting&quot;);
        this.setState(&quot;select&quot;);
    };
    this.select = function () {
        var anchor, editor = this.editor;
        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
        if (this.$clickSelection) {
            var cmp = this.$clickSelection.comparePoint(cursor);
            if (cmp == -1) {
                anchor = this.$clickSelection.end;
            }
            else if (cmp == 1) {
                anchor = this.$clickSelection.start;
            }
            else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
            }
            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
        }
        editor.selection.selectToPosition(cursor);
        editor.renderer.scrollCursorIntoView();
    };
    this.extendSelectionBy = function (unitName) {
        var anchor, editor = this.editor;
        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
        var range = editor.selection[unitName](cursor.row, cursor.column);
        if (this.$clickSelection) {
            var cmpStart = this.$clickSelection.comparePoint(range.start);
            var cmpEnd = this.$clickSelection.comparePoint(range.end);
            if (cmpStart == -1 &amp;&amp; cmpEnd &lt;= 0) {
                anchor = this.$clickSelection.end;
                if (range.end.row != cursor.row || range.end.column != cursor.column)
                    cursor = range.start;
            }
            else if (cmpEnd == 1 &amp;&amp; cmpStart &gt;= 0) {
                anchor = this.$clickSelection.start;
                if (range.start.row != cursor.row || range.start.column != cursor.column)
                    cursor = range.end;
            }
            else if (cmpStart == -1 &amp;&amp; cmpEnd == 1) {
                cursor = range.end;
                anchor = range.start;
            }
            else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
            }
            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
        }
        editor.selection.selectToPosition(cursor);
        editor.renderer.scrollCursorIntoView();
    };
    this.selectEnd =
        this.selectAllEnd =
            this.selectByWordsEnd =
                this.selectByLinesEnd = function () {
                    this.$clickSelection = null;
                    this.editor.unsetStyle(&quot;ace_selecting&quot;);
                    if (this.editor.renderer.scroller.releaseCapture) {
                        this.editor.renderer.scroller.releaseCapture();
                    }
                };
    this.focusWait = function () {
        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
        var time = Date.now();
        if (distance &gt; DRAG_OFFSET || time - this.mousedownEvent.time &gt; this.$focusTimeout)
            this.startSelect(this.mousedownEvent.getDocumentPosition());
    };
    this.onDoubleClick = function (ev) {
        var pos = ev.getDocumentPosition();
        var editor = this.editor;
        var session = editor.session;
        var range = session.getBracketRange(pos);
        if (range) {
            if (range.isEmpty()) {
                range.start.column--;
                range.end.column++;
            }
            this.setState(&quot;select&quot;);
        }
        else {
            range = editor.selection.getWordRange(pos.row, pos.column);
            this.setState(&quot;selectByWords&quot;);
        }
        this.$clickSelection = range;
        this.select();
    };
    this.onTripleClick = function (ev) {
        var pos = ev.getDocumentPosition();
        var editor = this.editor;
        this.setState(&quot;selectByLines&quot;);
        var range = editor.getSelectionRange();
        if (range.isMultiLine() &amp;&amp; range.contains(pos.row, pos.column)) {
            this.$clickSelection = editor.selection.getLineRange(range.start.row);
            this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
        }
        else {
            this.$clickSelection = editor.selection.getLineRange(pos.row);
        }
        this.select();
    };
    this.onQuadClick = function (ev) {
        var editor = this.editor;
        editor.selectAll();
        this.$clickSelection = editor.getSelectionRange();
        this.setState(&quot;selectAll&quot;);
    };
    this.onMouseWheel = function (ev) {
        if (ev.getAccelKey())
            return;
        if (ev.getShiftKey() &amp;&amp; ev.wheelY &amp;&amp; !ev.wheelX) {
            ev.wheelX = ev.wheelY;
            ev.wheelY = 0;
        }
        var editor = this.editor;
        if (!this.$lastScroll)
            this.$lastScroll = { t: 0, vx: 0, vy: 0, allowed: 0 };
        var prevScroll = this.$lastScroll;
        var t = ev.domEvent.timeStamp;
        var dt = t - prevScroll.t;
        var vx = dt ? ev.wheelX / dt : prevScroll.vx;
        var vy = dt ? ev.wheelY / dt : prevScroll.vy;
        if (dt &lt; SCROLL_COOLDOWN_T) {
            vx = (vx + prevScroll.vx) / 2;
            vy = (vy + prevScroll.vy) / 2;
        }
        var direction = Math.abs(vx / vy);
        var canScroll = false;
        if (direction &gt;= 1 &amp;&amp; editor.renderer.isScrollableBy(ev.wheelX * ev.speed, 0))
            canScroll = true;
        if (direction &lt;= 1 &amp;&amp; editor.renderer.isScrollableBy(0, ev.wheelY * ev.speed))
            canScroll = true;
        if (canScroll) {
            prevScroll.allowed = t;
        }
        else if (t - prevScroll.allowed &lt; SCROLL_COOLDOWN_T) {
            var isSlower = Math.abs(vx) &lt;= 1.5 * Math.abs(prevScroll.vx)
                &amp;&amp; Math.abs(vy) &lt;= 1.5 * Math.abs(prevScroll.vy);
            if (isSlower) {
                canScroll = true;
                prevScroll.allowed = t;
            }
            else {
                prevScroll.allowed = 0;
            }
        }
        prevScroll.t = t;
        prevScroll.vx = vx;
        prevScroll.vy = vy;
        if (canScroll) {
            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
            return ev.stop();
        }
    };
}).call(DefaultHandlers.prototype);
exports.DefaultHandlers = DefaultHandlers;
function calcDistance(ax, ay, bx, by) {
    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
}
function calcRangeOrientation(range, cursor) {
    if (range.start.row == range.end.row)
        var cmp = 2 * cursor.column - range.start.column - range.end.column;
    else if (range.start.row == range.end.row - 1 &amp;&amp; !range.start.column &amp;&amp; !range.end.column)
        var cmp = cursor.column - 4;
    else
        var cmp = 2 * cursor.row - range.start.row - range.end.row;
    if (cmp &lt; 0)
        return { cursor: range.start, anchor: range.end };
    else
        return { cursor: range.end, anchor: range.start };
}

});

define(&quot;ace/tooltip&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/dom&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;./lib/oop&quot;);
var dom = require(&quot;./lib/dom&quot;);
var CLASSNAME = &quot;ace_tooltip&quot;;
function Tooltip(parentNode) {
    this.isOpen = false;
    this.$element = null;
    this.$parentNode = parentNode;
}
(function () {
    this.$init = function () {
        this.$element = dom.createElement(&quot;div&quot;);
        this.$element.className = CLASSNAME;
        this.$element.style.display = &quot;none&quot;;
        this.$parentNode.appendChild(this.$element);
        return this.$element;
    };
    this.getElement = function () {
        return this.$element || this.$init();
    };
    this.setText = function (text) {
        this.getElement().textContent = text;
    };
    this.setHtml = function (html) {
        this.getElement().innerHTML = html;
    };
    this.setPosition = function (x, y) {
        this.getElement().style.left = x + &quot;px&quot;;
        this.getElement().style.top = y + &quot;px&quot;;
    };
    this.setClassName = function (className) {
        dom.addCssClass(this.getElement(), className);
    };
    this.show = function (text, x, y) {
        if (text != null)
            this.setText(text);
        if (x != null &amp;&amp; y != null)
            this.setPosition(x, y);
        if (!this.isOpen) {
            this.getElement().style.display = &quot;block&quot;;
            this.isOpen = true;
        }
    };
    this.hide = function () {
        if (this.isOpen) {
            this.getElement().style.display = &quot;none&quot;;
            this.getElement().className = CLASSNAME;
            this.isOpen = false;
        }
    };
    this.getHeight = function () {
        return this.getElement().offsetHeight;
    };
    this.getWidth = function () {
        return this.getElement().offsetWidth;
    };
    this.destroy = function () {
        this.isOpen = false;
        if (this.$element &amp;&amp; this.$element.parentNode) {
            this.$element.parentNode.removeChild(this.$element);
        }
    };
}).call(Tooltip.prototype);
exports.Tooltip = Tooltip;

});

define(&quot;ace/mouse/default_gutter_handler&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/dom&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/event&quot;,&quot;ace/tooltip&quot;], function(require, exports, module){&quot;use strict&quot;;
var dom = require(&quot;../lib/dom&quot;);
var oop = require(&quot;../lib/oop&quot;);
var event = require(&quot;../lib/event&quot;);
var Tooltip = require(&quot;../tooltip&quot;).Tooltip;
function GutterHandler(mouseHandler) {
    var editor = mouseHandler.editor;
    var gutter = editor.renderer.$gutterLayer;
    var tooltip = new GutterTooltip(editor.container);
    mouseHandler.editor.setDefaultHandler(&quot;guttermousedown&quot;, function (e) {
        if (!editor.isFocused() || e.getButton() != 0)
            return;
        var gutterRegion = gutter.getRegion(e);
        if (gutterRegion == &quot;foldWidgets&quot;)
            return;
        var row = e.getDocumentPosition().row;
        var selection = editor.session.selection;
        if (e.getShiftKey())
            selection.selectTo(row, 0);
        else {
            if (e.domEvent.detail == 2) {
                editor.selectAll();
                return e.preventDefault();
            }
            mouseHandler.$clickSelection = editor.selection.getLineRange(row);
        }
        mouseHandler.setState(&quot;selectByLines&quot;);
        mouseHandler.captureMouse(e);
        return e.preventDefault();
    });
    var tooltipTimeout, mouseEvent, tooltipAnnotation;
    function showTooltip() {
        var row = mouseEvent.getDocumentPosition().row;
        var annotation = gutter.$annotations[row];
        if (!annotation)
            return hideTooltip();
        var maxRow = editor.session.getLength();
        if (row == maxRow) {
            var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
            var pos = mouseEvent.$pos;
            if (screenRow &gt; editor.session.documentToScreenRow(pos.row, pos.column))
                return hideTooltip();
        }
        if (tooltipAnnotation == annotation)
            return;
        tooltipAnnotation = annotation.text.join(&quot;&lt;br/&gt;&quot;);
        tooltip.setHtml(tooltipAnnotation);
        var annotationClassName = annotation.className;
        if (annotationClassName) {
            tooltip.setClassName(annotationClassName.trim());
        }
        tooltip.show();
        editor._signal(&quot;showGutterTooltip&quot;, tooltip);
        editor.on(&quot;mousewheel&quot;, hideTooltip);
        if (mouseHandler.$tooltipFollowsMouse) {
            moveTooltip(mouseEvent);
        }
        else {
            var gutterElement = mouseEvent.domEvent.target;
            var rect = gutterElement.getBoundingClientRect();
            var style = tooltip.getElement().style;
            style.left = rect.right + &quot;px&quot;;
            style.top = rect.bottom + &quot;px&quot;;
        }
    }
    function hideTooltip() {
        if (tooltipTimeout)
            tooltipTimeout = clearTimeout(tooltipTimeout);
        if (tooltipAnnotation) {
            tooltip.hide();
            tooltipAnnotation = null;
            editor._signal(&quot;hideGutterTooltip&quot;, tooltip);
            editor.off(&quot;mousewheel&quot;, hideTooltip);
        }
    }
    function moveTooltip(e) {
        tooltip.setPosition(e.x, e.y);
    }
    mouseHandler.editor.setDefaultHandler(&quot;guttermousemove&quot;, function (e) {
        var target = e.domEvent.target || e.domEvent.srcElement;
        if (dom.hasCssClass(target, &quot;ace_fold-widget&quot;))
            return hideTooltip();
        if (tooltipAnnotation &amp;&amp; mouseHandler.$tooltipFollowsMouse)
            moveTooltip(e);
        mouseEvent = e;
        if (tooltipTimeout)
            return;
        tooltipTimeout = setTimeout(function () {
            tooltipTimeout = null;
            if (mouseEvent &amp;&amp; !mouseHandler.isMousePressed)
                showTooltip();
            else
                hideTooltip();
        }, 50);
    });
    event.addListener(editor.renderer.$gutter, &quot;mouseout&quot;, function (e) {
        mouseEvent = null;
        if (!tooltipAnnotation || tooltipTimeout)
            return;
        tooltipTimeout = setTimeout(function () {
            tooltipTimeout = null;
            hideTooltip();
        }, 50);
    }, editor);
    editor.on(&quot;changeSession&quot;, hideTooltip);
}
function GutterTooltip(parentNode) {
    Tooltip.call(this, parentNode);
}
oop.inherits(GutterTooltip, Tooltip);
(function () {
    this.setPosition = function (x, y) {
        var windowWidth = window.innerWidth || document.documentElement.clientWidth;
        var windowHeight = window.innerHeight || document.documentElement.clientHeight;
        var width = this.getWidth();
        var height = this.getHeight();
        x += 15;
        y += 15;
        if (x + width &gt; windowWidth) {
            x -= (x + width) - windowWidth;
        }
        if (y + height &gt; windowHeight) {
            y -= 20 + height;
        }
        Tooltip.prototype.setPosition.call(this, x, y);
    };
}).call(GutterTooltip.prototype);
exports.GutterHandler = GutterHandler;

});

define(&quot;ace/mouse/mouse_event&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/event&quot;,&quot;ace/lib/useragent&quot;], function(require, exports, module){&quot;use strict&quot;;
var event = require(&quot;../lib/event&quot;);
var useragent = require(&quot;../lib/useragent&quot;);
var MouseEvent = exports.MouseEvent = function (domEvent, editor) {
    this.domEvent = domEvent;
    this.editor = editor;
    this.x = this.clientX = domEvent.clientX;
    this.y = this.clientY = domEvent.clientY;
    this.$pos = null;
    this.$inSelection = null;
    this.propagationStopped = false;
    this.defaultPrevented = false;
};
(function () {
    this.stopPropagation = function () {
        event.stopPropagation(this.domEvent);
        this.propagationStopped = true;
    };
    this.preventDefault = function () {
        event.preventDefault(this.domEvent);
        this.defaultPrevented = true;
    };
    this.stop = function () {
        this.stopPropagation();
        this.preventDefault();
    };
    this.getDocumentPosition = function () {
        if (this.$pos)
            return this.$pos;
        this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
        return this.$pos;
    };
    this.inSelection = function () {
        if (this.$inSelection !== null)
            return this.$inSelection;
        var editor = this.editor;
        var selectionRange = editor.getSelectionRange();
        if (selectionRange.isEmpty())
            this.$inSelection = false;
        else {
            var pos = this.getDocumentPosition();
            this.$inSelection = selectionRange.contains(pos.row, pos.column);
        }
        return this.$inSelection;
    };
    this.getButton = function () {
        return event.getButton(this.domEvent);
    };
    this.getShiftKey = function () {
        return this.domEvent.shiftKey;
    };
    this.getAccelKey = useragent.isMac
        ? function () { return this.domEvent.metaKey; }
        : function () { return this.domEvent.ctrlKey; };
}).call(MouseEvent.prototype);

});

define(&quot;ace/mouse/dragdrop_handler&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/dom&quot;,&quot;ace/lib/event&quot;,&quot;ace/lib/useragent&quot;], function(require, exports, module){&quot;use strict&quot;;
var dom = require(&quot;../lib/dom&quot;);
var event = require(&quot;../lib/event&quot;);
var useragent = require(&quot;../lib/useragent&quot;);
var AUTOSCROLL_DELAY = 200;
var SCROLL_CURSOR_DELAY = 200;
var SCROLL_CURSOR_HYSTERESIS = 5;
function DragdropHandler(mouseHandler) {
    var editor = mouseHandler.editor;
    var dragImage = dom.createElement(&quot;div&quot;);
    dragImage.style.cssText = &quot;top:-100px;position:absolute;z-index:2147483647;opacity:0.5&quot;;
    dragImage.textContent = &quot;\xa0&quot;;
    var exports = [&quot;dragWait&quot;, &quot;dragWaitEnd&quot;, &quot;startDrag&quot;, &quot;dragReadyEnd&quot;, &quot;onMouseDrag&quot;];
    exports.forEach(function (x) {
        mouseHandler[x] = this[x];
    }, this);
    editor.on(&quot;mousedown&quot;, this.onMouseDown.bind(mouseHandler));
    var mouseTarget = editor.container;
    var dragSelectionMarker, x, y;
    var timerId, range;
    var dragCursor, counter = 0;
    var dragOperation;
    var isInternal;
    var autoScrollStartTime;
    var cursorMovedTime;
    var cursorPointOnCaretMoved;
    this.onDragStart = function (e) {
        if (this.cancelDrag || !mouseTarget.draggable) {
            var self = this;
            setTimeout(function () {
                self.startSelect();
                self.captureMouse(e);
            }, 0);
            return e.preventDefault();
        }
        range = editor.getSelectionRange();
        var dataTransfer = e.dataTransfer;
        dataTransfer.effectAllowed = editor.getReadOnly() ? &quot;copy&quot; : &quot;copyMove&quot;;
        editor.container.appendChild(dragImage);
        dataTransfer.setDragImage &amp;&amp; dataTransfer.setDragImage(dragImage, 0, 0);
        setTimeout(function () {
            editor.container.removeChild(dragImage);
        });
        dataTransfer.clearData();
        dataTransfer.setData(&quot;Text&quot;, editor.session.getTextRange());
        isInternal = true;
        this.setState(&quot;drag&quot;);
    };
    this.onDragEnd = function (e) {
        mouseTarget.draggable = false;
        isInternal = false;
        this.setState(null);
        if (!editor.getReadOnly()) {
            var dropEffect = e.dataTransfer.dropEffect;
            if (!dragOperation &amp;&amp; dropEffect == &quot;move&quot;)
                editor.session.remove(editor.getSelectionRange());
            editor.$resetCursorStyle();
        }
        this.editor.unsetStyle(&quot;ace_dragging&quot;);
        this.editor.renderer.setCursorStyle(&quot;&quot;);
    };
    this.onDragEnter = function (e) {
        if (editor.getReadOnly() || !canAccept(e.dataTransfer))
            return;
        x = e.clientX;
        y = e.clientY;
        if (!dragSelectionMarker)
            addDragMarker();
        counter++;
        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
        return event.preventDefault(e);
    };
    this.onDragOver = function (e) {
        if (editor.getReadOnly() || !canAccept(e.dataTransfer))
            return;
        x = e.clientX;
        y = e.clientY;
        if (!dragSelectionMarker) {
            addDragMarker();
            counter++;
        }
        if (onMouseMoveTimer !== null)
            onMouseMoveTimer = null;
        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
        return event.preventDefault(e);
    };
    this.onDragLeave = function (e) {
        counter--;
        if (counter &lt;= 0 &amp;&amp; dragSelectionMarker) {
            clearDragMarker();
            dragOperation = null;
            return event.preventDefault(e);
        }
    };
    this.onDrop = function (e) {
        if (!dragCursor)
            return;
        var dataTransfer = e.dataTransfer;
        if (isInternal) {
            switch (dragOperation) {
                case &quot;move&quot;:
                    if (range.contains(dragCursor.row, dragCursor.column)) {
                        range = {
                            start: dragCursor,
                            end: dragCursor
                        };
                    }
                    else {
                        range = editor.moveText(range, dragCursor);
                    }
                    break;
                case &quot;copy&quot;:
                    range = editor.moveText(range, dragCursor, true);
                    break;
            }
        }
        else {
            var dropData = dataTransfer.getData(&#039;Text&#039;);
            range = {
                start: dragCursor,
                end: editor.session.insert(dragCursor, dropData)
            };
            editor.focus();
            dragOperation = null;
        }
        clearDragMarker();
        return event.preventDefault(e);
    };
    event.addListener(mouseTarget, &quot;dragstart&quot;, this.onDragStart.bind(mouseHandler), editor);
    event.addListener(mouseTarget, &quot;dragend&quot;, this.onDragEnd.bind(mouseHandler), editor);
    event.addListener(mouseTarget, &quot;dragenter&quot;, this.onDragEnter.bind(mouseHandler), editor);
    event.addListener(mouseTarget, &quot;dragover&quot;, this.onDragOver.bind(mouseHandler), editor);
    event.addListener(mouseTarget, &quot;dragleave&quot;, this.onDragLeave.bind(mouseHandler), editor);
    event.addListener(mouseTarget, &quot;drop&quot;, this.onDrop.bind(mouseHandler), editor);
    function scrollCursorIntoView(cursor, prevCursor) {
        var now = Date.now();
        var vMovement = !prevCursor || cursor.row != prevCursor.row;
        var hMovement = !prevCursor || cursor.column != prevCursor.column;
        if (!cursorMovedTime || vMovement || hMovement) {
            editor.moveCursorToPosition(cursor);
            cursorMovedTime = now;
            cursorPointOnCaretMoved = { x: x, y: y };
        }
        else {
            var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
            if (distance &gt; SCROLL_CURSOR_HYSTERESIS) {
                cursorMovedTime = null;
            }
            else if (now - cursorMovedTime &gt;= SCROLL_CURSOR_DELAY) {
                editor.renderer.scrollCursorIntoView();
                cursorMovedTime = null;
            }
        }
    }
    function autoScroll(cursor, prevCursor) {
        var now = Date.now();
        var lineHeight = editor.renderer.layerConfig.lineHeight;
        var characterWidth = editor.renderer.layerConfig.characterWidth;
        var editorRect = editor.renderer.scroller.getBoundingClientRect();
        var offsets = {
            x: {
                left: x - editorRect.left,
                right: editorRect.right - x
            },
            y: {
                top: y - editorRect.top,
                bottom: editorRect.bottom - y
            }
        };
        var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
        var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
        var scrollCursor = { row: cursor.row, column: cursor.column };
        if (nearestXOffset / characterWidth &lt;= 2) {
            scrollCursor.column += (offsets.x.left &lt; offsets.x.right ? -3 : +2);
        }
        if (nearestYOffset / lineHeight &lt;= 1) {
            scrollCursor.row += (offsets.y.top &lt; offsets.y.bottom ? -1 : +1);
        }
        var vScroll = cursor.row != scrollCursor.row;
        var hScroll = cursor.column != scrollCursor.column;
        var vMovement = !prevCursor || cursor.row != prevCursor.row;
        if (vScroll || (hScroll &amp;&amp; !vMovement)) {
            if (!autoScrollStartTime)
                autoScrollStartTime = now;
            else if (now - autoScrollStartTime &gt;= AUTOSCROLL_DELAY)
                editor.renderer.scrollCursorIntoView(scrollCursor);
        }
        else {
            autoScrollStartTime = null;
        }
    }
    function onDragInterval() {
        var prevCursor = dragCursor;
        dragCursor = editor.renderer.screenToTextCoordinates(x, y);
        scrollCursorIntoView(dragCursor, prevCursor);
        autoScroll(dragCursor, prevCursor);
    }
    function addDragMarker() {
        range = editor.selection.toOrientedRange();
        dragSelectionMarker = editor.session.addMarker(range, &quot;ace_selection&quot;, editor.getSelectionStyle());
        editor.clearSelection();
        if (editor.isFocused())
            editor.renderer.$cursorLayer.setBlinking(false);
        clearInterval(timerId);
        onDragInterval();
        timerId = setInterval(onDragInterval, 20);
        counter = 0;
        event.addListener(document, &quot;mousemove&quot;, onMouseMove);
    }
    function clearDragMarker() {
        clearInterval(timerId);
        editor.session.removeMarker(dragSelectionMarker);
        dragSelectionMarker = null;
        editor.selection.fromOrientedRange(range);
        if (editor.isFocused() &amp;&amp; !isInternal)
            editor.$resetCursorStyle();
        range = null;
        dragCursor = null;
        counter = 0;
        autoScrollStartTime = null;
        cursorMovedTime = null;
        event.removeListener(document, &quot;mousemove&quot;, onMouseMove);
    }
    var onMouseMoveTimer = null;
    function onMouseMove() {
        if (onMouseMoveTimer == null) {
            onMouseMoveTimer = setTimeout(function () {
                if (onMouseMoveTimer != null &amp;&amp; dragSelectionMarker)
                    clearDragMarker();
            }, 20);
        }
    }
    function canAccept(dataTransfer) {
        var types = dataTransfer.types;
        return !types || Array.prototype.some.call(types, function (type) {
            return type == &#039;text/plain&#039; || type == &#039;Text&#039;;
        });
    }
    function getDropEffect(e) {
        var copyAllowed = [&#039;copy&#039;, &#039;copymove&#039;, &#039;all&#039;, &#039;uninitialized&#039;];
        var moveAllowed = [&#039;move&#039;, &#039;copymove&#039;, &#039;linkmove&#039;, &#039;all&#039;, &#039;uninitialized&#039;];
        var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;
        var effectAllowed = &quot;uninitialized&quot;;
        try {
            effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
        }
        catch (e) { }
        var dropEffect = &quot;none&quot;;
        if (copyModifierState &amp;&amp; copyAllowed.indexOf(effectAllowed) &gt;= 0)
            dropEffect = &quot;copy&quot;;
        else if (moveAllowed.indexOf(effectAllowed) &gt;= 0)
            dropEffect = &quot;move&quot;;
        else if (copyAllowed.indexOf(effectAllowed) &gt;= 0)
            dropEffect = &quot;copy&quot;;
        return dropEffect;
    }
}
(function () {
    this.dragWait = function () {
        var interval = Date.now() - this.mousedownEvent.time;
        if (interval &gt; this.editor.getDragDelay())
            this.startDrag();
    };
    this.dragWaitEnd = function () {
        var target = this.editor.container;
        target.draggable = false;
        this.startSelect(this.mousedownEvent.getDocumentPosition());
        this.selectEnd();
    };
    this.dragReadyEnd = function (e) {
        this.editor.$resetCursorStyle();
        this.editor.unsetStyle(&quot;ace_dragging&quot;);
        this.editor.renderer.setCursorStyle(&quot;&quot;);
        this.dragWaitEnd();
    };
    this.startDrag = function () {
        this.cancelDrag = false;
        var editor = this.editor;
        var target = editor.container;
        target.draggable = true;
        editor.renderer.$cursorLayer.setBlinking(false);
        editor.setStyle(&quot;ace_dragging&quot;);
        var cursorStyle = useragent.isWin ? &quot;default&quot; : &quot;move&quot;;
        editor.renderer.setCursorStyle(cursorStyle);
        this.setState(&quot;dragReady&quot;);
    };
    this.onMouseDrag = function (e) {
        var target = this.editor.container;
        if (useragent.isIE &amp;&amp; this.state == &quot;dragReady&quot;) {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance &gt; 3)
                target.dragDrop();
        }
        if (this.state === &quot;dragWait&quot;) {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance &gt; 0) {
                target.draggable = false;
                this.startSelect(this.mousedownEvent.getDocumentPosition());
            }
        }
    };
    this.onMouseDown = function (e) {
        if (!this.$dragEnabled)
            return;
        this.mousedownEvent = e;
        var editor = this.editor;
        var inSelection = e.inSelection();
        var button = e.getButton();
        var clickCount = e.domEvent.detail || 1;
        if (clickCount === 1 &amp;&amp; button === 0 &amp;&amp; inSelection) {
            if (e.editor.inMultiSelectMode &amp;&amp; (e.getAccelKey() || e.getShiftKey()))
                return;
            this.mousedownEvent.time = Date.now();
            var eventTarget = e.domEvent.target || e.domEvent.srcElement;
            if (&quot;unselectable&quot; in eventTarget)
                eventTarget.unselectable = &quot;on&quot;;
            if (editor.getDragDelay()) {
                if (useragent.isWebKit) {
                    this.cancelDrag = true;
                    var mouseTarget = editor.container;
                    mouseTarget.draggable = true;
                }
                this.setState(&quot;dragWait&quot;);
            }
            else {
                this.startDrag();
            }
            this.captureMouse(e, this.onMouseDrag.bind(this));
            e.defaultPrevented = true;
        }
    };
}).call(DragdropHandler.prototype);
function calcDistance(ax, ay, bx, by) {
    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
}
exports.DragdropHandler = DragdropHandler;

});

define(&quot;ace/mouse/touch_handler&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/mouse/mouse_event&quot;,&quot;ace/lib/event&quot;,&quot;ace/lib/dom&quot;], function(require, exports, module){&quot;use strict&quot;;
var MouseEvent = require(&quot;./mouse_event&quot;).MouseEvent;
var event = require(&quot;../lib/event&quot;);
var dom = require(&quot;../lib/dom&quot;);
exports.addTouchListeners = function (el, editor) {
    var mode = &quot;scroll&quot;;
    var startX;
    var startY;
    var touchStartT;
    var lastT;
    var longTouchTimer;
    var animationTimer;
    var animationSteps = 0;
    var pos;
    var clickCount = 0;
    var vX = 0;
    var vY = 0;
    var pressed;
    var contextMenu;
    function createContextMenu() {
        var clipboard = window.navigator &amp;&amp; window.navigator.clipboard;
        var isOpen = false;
        var updateMenu = function () {
            var selected = editor.getCopyText();
            var hasUndo = editor.session.getUndoManager().hasUndo();
            contextMenu.replaceChild(dom.buildDom(isOpen ? [&quot;span&quot;,
                !selected &amp;&amp; [&quot;span&quot;, { class: &quot;ace_mobile-button&quot;, action: &quot;selectall&quot; }, &quot;Select All&quot;],
                selected &amp;&amp; [&quot;span&quot;, { class: &quot;ace_mobile-button&quot;, action: &quot;copy&quot; }, &quot;Copy&quot;],
                selected &amp;&amp; [&quot;span&quot;, { class: &quot;ace_mobile-button&quot;, action: &quot;cut&quot; }, &quot;Cut&quot;],
                clipboard &amp;&amp; [&quot;span&quot;, { class: &quot;ace_mobile-button&quot;, action: &quot;paste&quot; }, &quot;Paste&quot;],
                hasUndo &amp;&amp; [&quot;span&quot;, { class: &quot;ace_mobile-button&quot;, action: &quot;undo&quot; }, &quot;Undo&quot;],
                [&quot;span&quot;, { class: &quot;ace_mobile-button&quot;, action: &quot;find&quot; }, &quot;Find&quot;],
                [&quot;span&quot;, { class: &quot;ace_mobile-button&quot;, action: &quot;openCommandPallete&quot; }, &quot;Palette&quot;]
            ] : [&quot;span&quot;]), contextMenu.firstChild);
        };
        var handleClick = function (e) {
            var action = e.target.getAttribute(&quot;action&quot;);
            if (action == &quot;more&quot; || !isOpen) {
                isOpen = !isOpen;
                return updateMenu();
            }
            if (action == &quot;paste&quot;) {
                clipboard.readText().then(function (text) {
                    editor.execCommand(action, text);
                });
            }
            else if (action) {
                if (action == &quot;cut&quot; || action == &quot;copy&quot;) {
                    if (clipboard)
                        clipboard.writeText(editor.getCopyText());
                    else
                        document.execCommand(&quot;copy&quot;);
                }
                editor.execCommand(action);
            }
            contextMenu.firstChild.style.display = &quot;none&quot;;
            isOpen = false;
            if (action != &quot;openCommandPallete&quot;)
                editor.focus();
        };
        contextMenu = dom.buildDom([&quot;div&quot;,
            {
                class: &quot;ace_mobile-menu&quot;,
                ontouchstart: function (e) {
                    mode = &quot;menu&quot;;
                    e.stopPropagation();
                    e.preventDefault();
                    editor.textInput.focus();
                },
                ontouchend: function (e) {
                    e.stopPropagation();
                    e.preventDefault();
                    handleClick(e);
                },
                onclick: handleClick
            },
            [&quot;span&quot;],
            [&quot;span&quot;, { class: &quot;ace_mobile-button&quot;, action: &quot;more&quot; }, &quot;...&quot;]
        ], editor.container);
    }
    function showContextMenu() {
        if (!contextMenu)
            createContextMenu();
        var cursor = editor.selection.cursor;
        var pagePos = editor.renderer.textToScreenCoordinates(cursor.row, cursor.column);
        var leftOffset = editor.renderer.textToScreenCoordinates(0, 0).pageX;
        var scrollLeft = editor.renderer.scrollLeft;
        var rect = editor.container.getBoundingClientRect();
        contextMenu.style.top = pagePos.pageY - rect.top - 3 + &quot;px&quot;;
        if (pagePos.pageX - rect.left &lt; rect.width - 70) {
            contextMenu.style.left = &quot;&quot;;
            contextMenu.style.right = &quot;10px&quot;;
        }
        else {
            contextMenu.style.right = &quot;&quot;;
            contextMenu.style.left = leftOffset + scrollLeft - rect.left + &quot;px&quot;;
        }
        contextMenu.style.display = &quot;&quot;;
        contextMenu.firstChild.style.display = &quot;none&quot;;
        editor.on(&quot;input&quot;, hideContextMenu);
    }
    function hideContextMenu(e) {
        if (contextMenu)
            contextMenu.style.display = &quot;none&quot;;
        editor.off(&quot;input&quot;, hideContextMenu);
    }
    function handleLongTap() {
        longTouchTimer = null;
        clearTimeout(longTouchTimer);
        var range = editor.selection.getRange();
        var inSelection = range.contains(pos.row, pos.column);
        if (range.isEmpty() || !inSelection) {
            editor.selection.moveToPosition(pos);
            editor.selection.selectWord();
        }
        mode = &quot;wait&quot;;
        showContextMenu();
    }
    function switchToSelectionMode() {
        longTouchTimer = null;
        clearTimeout(longTouchTimer);
        editor.selection.moveToPosition(pos);
        var range = clickCount &gt;= 2
            ? editor.selection.getLineRange(pos.row)
            : editor.session.getBracketRange(pos);
        if (range &amp;&amp; !range.isEmpty()) {
            editor.selection.setRange(range);
        }
        else {
            editor.selection.selectWord();
        }
        mode = &quot;wait&quot;;
    }
    event.addListener(el, &quot;contextmenu&quot;, function (e) {
        if (!pressed)
            return;
        var textarea = editor.textInput.getElement();
        textarea.focus();
    }, editor);
    event.addListener(el, &quot;touchstart&quot;, function (e) {
        var touches = e.touches;
        if (longTouchTimer || touches.length &gt; 1) {
            clearTimeout(longTouchTimer);
            longTouchTimer = null;
            touchStartT = -1;
            mode = &quot;zoom&quot;;
            return;
        }
        pressed = editor.$mouseHandler.isMousePressed = true;
        var h = editor.renderer.layerConfig.lineHeight;
        var w = editor.renderer.layerConfig.lineHeight;
        var t = e.timeStamp;
        lastT = t;
        var touchObj = touches[0];
        var x = touchObj.clientX;
        var y = touchObj.clientY;
        if (Math.abs(startX - x) + Math.abs(startY - y) &gt; h)
            touchStartT = -1;
        startX = e.clientX = x;
        startY = e.clientY = y;
        vX = vY = 0;
        var ev = new MouseEvent(e, editor);
        pos = ev.getDocumentPosition();
        if (t - touchStartT &lt; 500 &amp;&amp; touches.length == 1 &amp;&amp; !animationSteps) {
            clickCount++;
            e.preventDefault();
            e.button = 0;
            switchToSelectionMode();
        }
        else {
            clickCount = 0;
            var cursor = editor.selection.cursor;
            var anchor = editor.selection.isEmpty() ? cursor : editor.selection.anchor;
            var cursorPos = editor.renderer.$cursorLayer.getPixelPosition(cursor, true);
            var anchorPos = editor.renderer.$cursorLayer.getPixelPosition(anchor, true);
            var rect = editor.renderer.scroller.getBoundingClientRect();
            var offsetTop = editor.renderer.layerConfig.offset;
            var offsetLeft = editor.renderer.scrollLeft;
            var weightedDistance = function (x, y) {
                x = x / w;
                y = y / h - 0.75;
                return x * x + y * y;
            };
            if (e.clientX &lt; rect.left) {
                mode = &quot;zoom&quot;;
                return;
            }
            var diff1 = weightedDistance(e.clientX - rect.left - cursorPos.left + offsetLeft, e.clientY - rect.top - cursorPos.top + offsetTop);
            var diff2 = weightedDistance(e.clientX - rect.left - anchorPos.left + offsetLeft, e.clientY - rect.top - anchorPos.top + offsetTop);
            if (diff1 &lt; 3.5 &amp;&amp; diff2 &lt; 3.5)
                mode = diff1 &gt; diff2 ? &quot;cursor&quot; : &quot;anchor&quot;;
            if (diff2 &lt; 3.5)
                mode = &quot;anchor&quot;;
            else if (diff1 &lt; 3.5)
                mode = &quot;cursor&quot;;
            else
                mode = &quot;scroll&quot;;
            longTouchTimer = setTimeout(handleLongTap, 450);
        }
        touchStartT = t;
    }, editor);
    event.addListener(el, &quot;touchend&quot;, function (e) {
        pressed = editor.$mouseHandler.isMousePressed = false;
        if (animationTimer)
            clearInterval(animationTimer);
        if (mode == &quot;zoom&quot;) {
            mode = &quot;&quot;;
            animationSteps = 0;
        }
        else if (longTouchTimer) {
            editor.selection.moveToPosition(pos);
            animationSteps = 0;
            showContextMenu();
        }
        else if (mode == &quot;scroll&quot;) {
            animate();
            hideContextMenu();
        }
        else {
            showContextMenu();
        }
        clearTimeout(longTouchTimer);
        longTouchTimer = null;
    }, editor);
    event.addListener(el, &quot;touchmove&quot;, function (e) {
        if (longTouchTimer) {
            clearTimeout(longTouchTimer);
            longTouchTimer = null;
        }
        var touches = e.touches;
        if (touches.length &gt; 1 || mode == &quot;zoom&quot;)
            return;
        var touchObj = touches[0];
        var wheelX = startX - touchObj.clientX;
        var wheelY = startY - touchObj.clientY;
        if (mode == &quot;wait&quot;) {
            if (wheelX * wheelX + wheelY * wheelY &gt; 4)
                mode = &quot;cursor&quot;;
            else
                return e.preventDefault();
        }
        startX = touchObj.clientX;
        startY = touchObj.clientY;
        e.clientX = touchObj.clientX;
        e.clientY = touchObj.clientY;
        var t = e.timeStamp;
        var dt = t - lastT;
        lastT = t;
        if (mode == &quot;scroll&quot;) {
            var mouseEvent = new MouseEvent(e, editor);
            mouseEvent.speed = 1;
            mouseEvent.wheelX = wheelX;
            mouseEvent.wheelY = wheelY;
            if (10 * Math.abs(wheelX) &lt; Math.abs(wheelY))
                wheelX = 0;
            if (10 * Math.abs(wheelY) &lt; Math.abs(wheelX))
                wheelY = 0;
            if (dt != 0) {
                vX = wheelX / dt;
                vY = wheelY / dt;
            }
            editor._emit(&quot;mousewheel&quot;, mouseEvent);
            if (!mouseEvent.propagationStopped) {
                vX = vY = 0;
            }
        }
        else {
            var ev = new MouseEvent(e, editor);
            var pos = ev.getDocumentPosition();
            if (mode == &quot;cursor&quot;)
                editor.selection.moveCursorToPosition(pos);
            else if (mode == &quot;anchor&quot;)
                editor.selection.setSelectionAnchor(pos.row, pos.column);
            editor.renderer.scrollCursorIntoView(pos);
            e.preventDefault();
        }
    }, editor);
    function animate() {
        animationSteps += 60;
        animationTimer = setInterval(function () {
            if (animationSteps-- &lt;= 0) {
                clearInterval(animationTimer);
                animationTimer = null;
            }
            if (Math.abs(vX) &lt; 0.01)
                vX = 0;
            if (Math.abs(vY) &lt; 0.01)
                vY = 0;
            if (animationSteps &lt; 20)
                vX = 0.9 * vX;
            if (animationSteps &lt; 20)
                vY = 0.9 * vY;
            var oldScrollTop = editor.session.getScrollTop();
            editor.renderer.scrollBy(10 * vX, 10 * vY);
            if (oldScrollTop == editor.session.getScrollTop())
                animationSteps = 0;
        }, 10);
    }
};

});

define(&quot;ace/mouse/mouse_handler&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/event&quot;,&quot;ace/lib/useragent&quot;,&quot;ace/mouse/default_handlers&quot;,&quot;ace/mouse/default_gutter_handler&quot;,&quot;ace/mouse/mouse_event&quot;,&quot;ace/mouse/dragdrop_handler&quot;,&quot;ace/mouse/touch_handler&quot;,&quot;ace/config&quot;], function(require, exports, module){&quot;use strict&quot;;
var event = require(&quot;../lib/event&quot;);
var useragent = require(&quot;../lib/useragent&quot;);
var DefaultHandlers = require(&quot;./default_handlers&quot;).DefaultHandlers;
var DefaultGutterHandler = require(&quot;./default_gutter_handler&quot;).GutterHandler;
var MouseEvent = require(&quot;./mouse_event&quot;).MouseEvent;
var DragdropHandler = require(&quot;./dragdrop_handler&quot;).DragdropHandler;
var addTouchListeners = require(&quot;./touch_handler&quot;).addTouchListeners;
var config = require(&quot;../config&quot;);
var MouseHandler = function (editor) {
    var _self = this;
    this.editor = editor;
    new DefaultHandlers(this);
    new DefaultGutterHandler(this);
    new DragdropHandler(this);
    var focusEditor = function (e) {
        var windowBlurred = !document.hasFocus || !document.hasFocus()
            || !editor.isFocused() &amp;&amp; document.activeElement == (editor.textInput &amp;&amp; editor.textInput.getElement());
        if (windowBlurred)
            window.focus();
        editor.focus();
        setTimeout(function () {
            if (!editor.isFocused())
                editor.focus();
        });
    };
    var mouseTarget = editor.renderer.getMouseEventTarget();
    event.addListener(mouseTarget, &quot;click&quot;, this.onMouseEvent.bind(this, &quot;click&quot;), editor);
    event.addListener(mouseTarget, &quot;mousemove&quot;, this.onMouseMove.bind(this, &quot;mousemove&quot;), editor);
    event.addMultiMouseDownListener([
        mouseTarget,
        editor.renderer.scrollBarV &amp;&amp; editor.renderer.scrollBarV.inner,
        editor.renderer.scrollBarH &amp;&amp; editor.renderer.scrollBarH.inner,
        editor.textInput &amp;&amp; editor.textInput.getElement()
    ].filter(Boolean), [400, 300, 250], this, &quot;onMouseEvent&quot;, editor);
    event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, &quot;mousewheel&quot;), editor);
    addTouchListeners(editor.container, editor);
    var gutterEl = editor.renderer.$gutter;
    event.addListener(gutterEl, &quot;mousedown&quot;, this.onMouseEvent.bind(this, &quot;guttermousedown&quot;), editor);
    event.addListener(gutterEl, &quot;click&quot;, this.onMouseEvent.bind(this, &quot;gutterclick&quot;), editor);
    event.addListener(gutterEl, &quot;dblclick&quot;, this.onMouseEvent.bind(this, &quot;gutterdblclick&quot;), editor);
    event.addListener(gutterEl, &quot;mousemove&quot;, this.onMouseEvent.bind(this, &quot;guttermousemove&quot;), editor);
    event.addListener(mouseTarget, &quot;mousedown&quot;, focusEditor, editor);
    event.addListener(gutterEl, &quot;mousedown&quot;, focusEditor, editor);
    if (useragent.isIE &amp;&amp; editor.renderer.scrollBarV) {
        event.addListener(editor.renderer.scrollBarV.element, &quot;mousedown&quot;, focusEditor, editor);
        event.addListener(editor.renderer.scrollBarH.element, &quot;mousedown&quot;, focusEditor, editor);
    }
    editor.on(&quot;mousemove&quot;, function (e) {
        if (_self.state || _self.$dragDelay || !_self.$dragEnabled)
            return;
        var character = editor.renderer.screenToTextCoordinates(e.x, e.y);
        var range = editor.session.selection.getRange();
        var renderer = editor.renderer;
        if (!range.isEmpty() &amp;&amp; range.insideStart(character.row, character.column)) {
            renderer.setCursorStyle(&quot;default&quot;);
        }
        else {
            renderer.setCursorStyle(&quot;&quot;);
        }
    }, editor);
};
(function () {
    this.onMouseEvent = function (name, e) {
        if (!this.editor.session)
            return;
        this.editor._emit(name, new MouseEvent(e, this.editor));
    };
    this.onMouseMove = function (name, e) {
        var listeners = this.editor._eventRegistry &amp;&amp; this.editor._eventRegistry.mousemove;
        if (!listeners || !listeners.length)
            return;
        this.editor._emit(name, new MouseEvent(e, this.editor));
    };
    this.onMouseWheel = function (name, e) {
        var mouseEvent = new MouseEvent(e, this.editor);
        mouseEvent.speed = this.$scrollSpeed * 2;
        mouseEvent.wheelX = e.wheelX;
        mouseEvent.wheelY = e.wheelY;
        this.editor._emit(name, mouseEvent);
    };
    this.setState = function (state) {
        this.state = state;
    };
    this.captureMouse = function (ev, mouseMoveHandler) {
        this.x = ev.x;
        this.y = ev.y;
        this.isMousePressed = true;
        var editor = this.editor;
        var renderer = this.editor.renderer;
        renderer.$isMousePressed = true;
        var self = this;
        var onMouseMove = function (e) {
            if (!e)
                return;
            if (useragent.isWebKit &amp;&amp; !e.which &amp;&amp; self.releaseMouse)
                return self.releaseMouse();
            self.x = e.clientX;
            self.y = e.clientY;
            mouseMoveHandler &amp;&amp; mouseMoveHandler(e);
            self.mouseEvent = new MouseEvent(e, self.editor);
            self.$mouseMoved = true;
        };
        var onCaptureEnd = function (e) {
            editor.off(&quot;beforeEndOperation&quot;, onOperationEnd);
            clearInterval(timerId);
            if (editor.session)
                onCaptureInterval();
            self[self.state + &quot;End&quot;] &amp;&amp; self[self.state + &quot;End&quot;](e);
            self.state = &quot;&quot;;
            self.isMousePressed = renderer.$isMousePressed = false;
            if (renderer.$keepTextAreaAtCursor)
                renderer.$moveTextAreaToCursor();
            self.$onCaptureMouseMove = self.releaseMouse = null;
            e &amp;&amp; self.onMouseEvent(&quot;mouseup&quot;, e);
            editor.endOperation();
        };
        var onCaptureInterval = function () {
            self[self.state] &amp;&amp; self[self.state]();
            self.$mouseMoved = false;
        };
        if (useragent.isOldIE &amp;&amp; ev.domEvent.type == &quot;dblclick&quot;) {
            return setTimeout(function () { onCaptureEnd(ev); });
        }
        var onOperationEnd = function (e) {
            if (!self.releaseMouse)
                return;
            if (editor.curOp.command.name &amp;&amp; editor.curOp.selectionChanged) {
                self[self.state + &quot;End&quot;] &amp;&amp; self[self.state + &quot;End&quot;]();
                self.state = &quot;&quot;;
                self.releaseMouse();
            }
        };
        editor.on(&quot;beforeEndOperation&quot;, onOperationEnd);
        editor.startOperation({ command: { name: &quot;mouse&quot; } });
        self.$onCaptureMouseMove = onMouseMove;
        self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
        var timerId = setInterval(onCaptureInterval, 20);
    };
    this.releaseMouse = null;
    this.cancelContextMenu = function () {
        var stop = function (e) {
            if (e &amp;&amp; e.domEvent &amp;&amp; e.domEvent.type != &quot;contextmenu&quot;)
                return;
            this.editor.off(&quot;nativecontextmenu&quot;, stop);
            if (e &amp;&amp; e.domEvent)
                event.stopEvent(e.domEvent);
        }.bind(this);
        setTimeout(stop, 10);
        this.editor.on(&quot;nativecontextmenu&quot;, stop);
    };
    this.destroy = function () {
        if (this.releaseMouse)
            this.releaseMouse();
    };
}).call(MouseHandler.prototype);
config.defineOptions(MouseHandler.prototype, &quot;mouseHandler&quot;, {
    scrollSpeed: { initialValue: 2 },
    dragDelay: { initialValue: (useragent.isMac ? 150 : 0) },
    dragEnabled: { initialValue: true },
    focusTimeout: { initialValue: 0 },
    tooltipFollowsMouse: { initialValue: true }
});
exports.MouseHandler = MouseHandler;

});

define(&quot;ace/mouse/fold_handler&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/dom&quot;], function(require, exports, module){&quot;use strict&quot;;
var dom = require(&quot;../lib/dom&quot;);
function FoldHandler(editor) {
    editor.on(&quot;click&quot;, function (e) {
        var position = e.getDocumentPosition();
        var session = editor.session;
        var fold = session.getFoldAt(position.row, position.column, 1);
        if (fold) {
            if (e.getAccelKey())
                session.removeFold(fold);
            else
                session.expandFold(fold);
            e.stop();
        }
        var target = e.domEvent &amp;&amp; e.domEvent.target;
        if (target &amp;&amp; dom.hasCssClass(target, &quot;ace_inline_button&quot;)) {
            if (dom.hasCssClass(target, &quot;ace_toggle_wrap&quot;)) {
                session.setOption(&quot;wrap&quot;, !session.getUseWrapMode());
                editor.renderer.scrollCursorIntoView();
            }
        }
    });
    editor.on(&quot;gutterclick&quot;, function (e) {
        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
        if (gutterRegion == &quot;foldWidgets&quot;) {
            var row = e.getDocumentPosition().row;
            var session = editor.session;
            if (session.foldWidgets &amp;&amp; session.foldWidgets[row])
                editor.session.onFoldWidgetClick(row, e);
            if (!editor.isFocused())
                editor.focus();
            e.stop();
        }
    });
    editor.on(&quot;gutterdblclick&quot;, function (e) {
        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
        if (gutterRegion == &quot;foldWidgets&quot;) {
            var row = e.getDocumentPosition().row;
            var session = editor.session;
            var data = session.getParentFoldRangeData(row, true);
            var range = data.range || data.firstRange;
            if (range) {
                row = range.start.row;
                var fold = session.getFoldAt(row, session.getLine(row).length, 1);
                if (fold) {
                    session.removeFold(fold);
                }
                else {
                    session.addFold(&quot;...&quot;, range);
                    editor.renderer.scrollCursorIntoView({ row: range.start.row, column: 0 });
                }
            }
            e.stop();
        }
    });
}
exports.FoldHandler = FoldHandler;

});

define(&quot;ace/keyboard/keybinding&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/keys&quot;,&quot;ace/lib/event&quot;], function(require, exports, module){&quot;use strict&quot;;
var keyUtil = require(&quot;../lib/keys&quot;);
var event = require(&quot;../lib/event&quot;);
var KeyBinding = function (editor) {
    this.$editor = editor;
    this.$data = { editor: editor };
    this.$handlers = [];
    this.setDefaultHandler(editor.commands);
};
(function () {
    this.setDefaultHandler = function (kb) {
        this.removeKeyboardHandler(this.$defaultHandler);
        this.$defaultHandler = kb;
        this.addKeyboardHandler(kb, 0);
    };
    this.setKeyboardHandler = function (kb) {
        var h = this.$handlers;
        if (h[h.length - 1] == kb)
            return;
        while (h[h.length - 1] &amp;&amp; h[h.length - 1] != this.$defaultHandler)
            this.removeKeyboardHandler(h[h.length - 1]);
        this.addKeyboardHandler(kb, 1);
    };
    this.addKeyboardHandler = function (kb, pos) {
        if (!kb)
            return;
        if (typeof kb == &quot;function&quot; &amp;&amp; !kb.handleKeyboard)
            kb.handleKeyboard = kb;
        var i = this.$handlers.indexOf(kb);
        if (i != -1)
            this.$handlers.splice(i, 1);
        if (pos == undefined)
            this.$handlers.push(kb);
        else
            this.$handlers.splice(pos, 0, kb);
        if (i == -1 &amp;&amp; kb.attach)
            kb.attach(this.$editor);
    };
    this.removeKeyboardHandler = function (kb) {
        var i = this.$handlers.indexOf(kb);
        if (i == -1)
            return false;
        this.$handlers.splice(i, 1);
        kb.detach &amp;&amp; kb.detach(this.$editor);
        return true;
    };
    this.getKeyboardHandler = function () {
        return this.$handlers[this.$handlers.length - 1];
    };
    this.getStatusText = function () {
        var data = this.$data;
        var editor = data.editor;
        return this.$handlers.map(function (h) {
            return h.getStatusText &amp;&amp; h.getStatusText(editor, data) || &quot;&quot;;
        }).filter(Boolean).join(&quot; &quot;);
    };
    this.$callKeyboardHandlers = function (hashId, keyString, keyCode, e) {
        var toExecute;
        var success = false;
        var commands = this.$editor.commands;
        for (var i = this.$handlers.length; i--;) {
            toExecute = this.$handlers[i].handleKeyboard(this.$data, hashId, keyString, keyCode, e);
            if (!toExecute || !toExecute.command)
                continue;
            if (toExecute.command == &quot;null&quot;) {
                success = true;
            }
            else {
                success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
            }
            if (success &amp;&amp; e &amp;&amp; hashId != -1 &amp;&amp;
                toExecute.passEvent != true &amp;&amp; toExecute.command.passEvent != true) {
                event.stopEvent(e);
            }
            if (success)
                break;
        }
        if (!success &amp;&amp; hashId == -1) {
            toExecute = { command: &quot;insertstring&quot; };
            success = commands.exec(&quot;insertstring&quot;, this.$editor, keyString);
        }
        if (success &amp;&amp; this.$editor._signal)
            this.$editor._signal(&quot;keyboardActivity&quot;, toExecute);
        return success;
    };
    this.onCommandKey = function (e, hashId, keyCode) {
        var keyString = keyUtil.keyCodeToString(keyCode);
        return this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
    };
    this.onTextInput = function (text) {
        return this.$callKeyboardHandlers(-1, text);
    };
}).call(KeyBinding.prototype);
exports.KeyBinding = KeyBinding;

});

define(&quot;ace/lib/bidiutil&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;], function(require, exports, module){&quot;use strict&quot;;
var ArabicAlefBetIntervalsBegine = [&#039;\u0621&#039;, &#039;\u0641&#039;];
var ArabicAlefBetIntervalsEnd = [&#039;\u063A&#039;, &#039;\u064a&#039;];
var dir = 0, hiLevel = 0;
var lastArabic = false, hasUBAT_AL = false, hasUBAT_B = false, hasUBAT_S = false, hasBlockSep = false, hasSegSep = false;
var impTab_LTR = [ [0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 0x11, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 0x15, 0x15, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]
];
var impTab_RTL = [ [2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 0x21, 3, 1, 1]
];
var LTR = 0, RTL = 1;
var L = 0;
var R = 1;
var EN = 2;
var AN = 3;
var ON = 4;
var B = 5;
var S = 6;
var AL = 7;
var WS = 8;
var CS = 9;
var ES = 10;
var ET = 11;
var NSM = 12;
var LRE = 13;
var RLE = 14;
var PDF = 15;
var LRO = 16;
var RLO = 17;
var BN = 18;
var UnicodeTBL00 = [
    BN, BN, BN, BN, BN, BN, BN, BN, BN, S, B, S, WS, B, BN, BN,
    BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, B, B, B, S,
    WS, ON, ON, ET, ET, ET, ON, ON, ON, ON, ON, ES, CS, ES, CS, CS,
    EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, CS, ON, ON, ON, ON, ON,
    ON, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L,
    L, L, L, L, L, L, L, L, L, L, L, ON, ON, ON, ON, ON,
    ON, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L,
    L, L, L, L, L, L, L, L, L, L, L, ON, ON, ON, ON, BN,
    BN, BN, BN, BN, BN, B, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
    BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
    CS, ON, ET, ET, ET, ET, ON, ON, ON, ON, L, ON, ON, BN, ON, ON,
    ET, ET, EN, EN, ON, L, ON, ON, ON, EN, L, ON, ON, ON, ON, ON
];
var UnicodeTBL20 = [
    WS, WS, WS, WS, WS, WS, WS, WS, WS, WS, WS, BN, BN, BN, L, R,
    ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
    ON, ON, ON, ON, ON, ON, ON, ON, WS, B, LRE, RLE, PDF, LRO, RLO, CS,
    ET, ET, ET, ET, ET, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
    ON, ON, ON, ON, CS, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
    ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, WS
];
function _computeLevels(chars, levels, len, charTypes) {
    var impTab = dir ? impTab_RTL : impTab_LTR, prevState = null, newClass = null, newLevel = null, newState = 0, action = null, cond = null, condPos = -1, i = null, ix = null, classes = [];
    if (!charTypes) {
        for (i = 0, charTypes = []; i &lt; len; i++) {
            charTypes[i] = _getCharacterType(chars[i]);
        }
    }
    hiLevel = dir;
    lastArabic = false;
    hasUBAT_AL = false;
    hasUBAT_B = false;
    hasUBAT_S = false;
    for (ix = 0; ix &lt; len; ix++) {
        prevState = newState;
        classes[ix] = newClass = _getCharClass(chars, charTypes, classes, ix);
        newState = impTab[prevState][newClass];
        action = newState &amp; 0xF0;
        newState &amp;= 0x0F;
        levels[ix] = newLevel = impTab[newState][5];
        if (action &gt; 0) {
            if (action == 0x10) {
                for (i = condPos; i &lt; ix; i++) {
                    levels[i] = 1;
                }
                condPos = -1;
            }
            else {
                condPos = -1;
            }
        }
        cond = impTab[newState][6];
        if (cond) {
            if (condPos == -1) {
                condPos = ix;
            }
        }
        else {
            if (condPos &gt; -1) {
                for (i = condPos; i &lt; ix; i++) {
                    levels[i] = newLevel;
                }
                condPos = -1;
            }
        }
        if (charTypes[ix] == B) {
            levels[ix] = 0;
        }
        hiLevel |= newLevel;
    }
    if (hasUBAT_S) {
        for (i = 0; i &lt; len; i++) {
            if (charTypes[i] == S) {
                levels[i] = dir;
                for (var j = i - 1; j &gt;= 0; j--) {
                    if (charTypes[j] == WS) {
                        levels[j] = dir;
                    }
                    else {
                        break;
                    }
                }
            }
        }
    }
}
function _invertLevel(lev, levels, _array) {
    if (hiLevel &lt; lev) {
        return;
    }
    if (lev == 1 &amp;&amp; dir == RTL &amp;&amp; !hasUBAT_B) {
        _array.reverse();
        return;
    }
    var len = _array.length, start = 0, end, lo, hi, tmp;
    while (start &lt; len) {
        if (levels[start] &gt;= lev) {
            end = start + 1;
            while (end &lt; len &amp;&amp; levels[end] &gt;= lev) {
                end++;
            }
            for (lo = start, hi = end - 1; lo &lt; hi; lo++, hi--) {
                tmp = _array[lo];
                _array[lo] = _array[hi];
                _array[hi] = tmp;
            }
            start = end;
        }
        start++;
    }
}
function _getCharClass(chars, types, classes, ix) {
    var cType = types[ix], wType, nType, len, i;
    switch (cType) {
        case L:
        case R:
            lastArabic = false;
        case ON:
        case AN:
            return cType;
        case EN:
            return lastArabic ? AN : EN;
        case AL:
            lastArabic = true;
            hasUBAT_AL = true;
            return R;
        case WS:
            return ON;
        case CS:
            if (ix &lt; 1 || (ix + 1) &gt;= types.length ||
                ((wType = classes[ix - 1]) != EN &amp;&amp; wType != AN) ||
                ((nType = types[ix + 1]) != EN &amp;&amp; nType != AN)) {
                return ON;
            }
            if (lastArabic) {
                nType = AN;
            }
            return nType == wType ? nType : ON;
        case ES:
            wType = ix &gt; 0 ? classes[ix - 1] : B;
            if (wType == EN &amp;&amp; (ix + 1) &lt; types.length &amp;&amp; types[ix + 1] == EN) {
                return EN;
            }
            return ON;
        case ET:
            if (ix &gt; 0 &amp;&amp; classes[ix - 1] == EN) {
                return EN;
            }
            if (lastArabic) {
                return ON;
            }
            i = ix + 1;
            len = types.length;
            while (i &lt; len &amp;&amp; types[i] == ET) {
                i++;
            }
            if (i &lt; len &amp;&amp; types[i] == EN) {
                return EN;
            }
            return ON;
        case NSM:
            len = types.length;
            i = ix + 1;
            while (i &lt; len &amp;&amp; types[i] == NSM) {
                i++;
            }
            if (i &lt; len) {
                var c = chars[ix], rtlCandidate = (c &gt;= 0x0591 &amp;&amp; c &lt;= 0x08FF) || c == 0xFB1E;
                wType = types[i];
                if (rtlCandidate &amp;&amp; (wType == R || wType == AL)) {
                    return R;
                }
            }
            if (ix &lt; 1 || (wType = types[ix - 1]) == B) {
                return ON;
            }
            return classes[ix - 1];
        case B:
            lastArabic = false;
            hasUBAT_B = true;
            return dir;
        case S:
            hasUBAT_S = true;
            return ON;
        case LRE:
        case RLE:
        case LRO:
        case RLO:
        case PDF:
            lastArabic = false;
        case BN:
            return ON;
    }
}
function _getCharacterType(ch) {
    var uc = ch.charCodeAt(0), hi = uc &gt;&gt; 8;
    if (hi == 0) {
        return ((uc &gt; 0x00BF) ? L : UnicodeTBL00[uc]);
    }
    else if (hi == 5) {
        return (/[\u0591-\u05f4]/.test(ch) ? R : L);
    }
    else if (hi == 6) {
        if (/[\u0610-\u061a\u064b-\u065f\u06d6-\u06e4\u06e7-\u06ed]/.test(ch))
            return NSM;
        else if (/[\u0660-\u0669\u066b-\u066c]/.test(ch))
            return AN;
        else if (uc == 0x066A)
            return ET;
        else if (/[\u06f0-\u06f9]/.test(ch))
            return EN;
        else
            return AL;
    }
    else if (hi == 0x20 &amp;&amp; uc &lt;= 0x205F) {
        return UnicodeTBL20[uc &amp; 0xFF];
    }
    else if (hi == 0xFE) {
        return (uc &gt;= 0xFE70 ? AL : ON);
    }
    return ON;
}
function _isArabicDiacritics(ch) {
    return (ch &gt;= &#039;\u064b&#039; &amp;&amp; ch &lt;= &#039;\u0655&#039;);
}
exports.L = L;
exports.R = R;
exports.EN = EN;
exports.ON_R = 3;
exports.AN = 4;
exports.R_H = 5;
exports.B = 6;
exports.RLE = 7;
exports.DOT = &quot;\xB7&quot;;
exports.doBidiReorder = function (text, textCharTypes, isRtl) {
    if (text.length &lt; 2)
        return {};
    var chars = text.split(&quot;&quot;), logicalFromVisual = new Array(chars.length), bidiLevels = new Array(chars.length), levels = [];
    dir = isRtl ? RTL : LTR;
    _computeLevels(chars, levels, chars.length, textCharTypes);
    for (var i = 0; i &lt; logicalFromVisual.length; logicalFromVisual[i] = i, i++)
        ;
    _invertLevel(2, levels, logicalFromVisual);
    _invertLevel(1, levels, logicalFromVisual);
    for (var i = 0; i &lt; logicalFromVisual.length - 1; i++) { //fix levels to reflect character width
        if (textCharTypes[i] === AN) {
            levels[i] = exports.AN;
        }
        else if (levels[i] === R &amp;&amp; ((textCharTypes[i] &gt; AL &amp;&amp; textCharTypes[i] &lt; LRE)
            || textCharTypes[i] === ON || textCharTypes[i] === BN)) {
            levels[i] = exports.ON_R;
        }
        else if ((i &gt; 0 &amp;&amp; chars[i - 1] === &#039;\u0644&#039;) &amp;&amp; /\u0622|\u0623|\u0625|\u0627/.test(chars[i])) {
            levels[i - 1] = levels[i] = exports.R_H;
            i++;
        }
    }
    if (chars[chars.length - 1] === exports.DOT)
        levels[chars.length - 1] = exports.B;
    if (chars[0] === &#039;\u202B&#039;)
        levels[0] = exports.RLE;
    for (var i = 0; i &lt; logicalFromVisual.length; i++) {
        bidiLevels[i] = levels[logicalFromVisual[i]];
    }
    return { &#039;logicalFromVisual&#039;: logicalFromVisual, &#039;bidiLevels&#039;: bidiLevels };
};
exports.hasBidiCharacters = function (text, textCharTypes) {
    var ret = false;
    for (var i = 0; i &lt; text.length; i++) {
        textCharTypes[i] = _getCharacterType(text.charAt(i));
        if (!ret &amp;&amp; (textCharTypes[i] == R || textCharTypes[i] == AL || textCharTypes[i] == AN))
            ret = true;
    }
    return ret;
};
exports.getVisualFromLogicalIdx = function (logIdx, rowMap) {
    for (var i = 0; i &lt; rowMap.logicalFromVisual.length; i++) {
        if (rowMap.logicalFromVisual[i] == logIdx)
            return i;
    }
    return 0;
};

});

define(&quot;ace/bidihandler&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/bidiutil&quot;,&quot;ace/lib/lang&quot;], function(require, exports, module){&quot;use strict&quot;;
var bidiUtil = require(&quot;./lib/bidiutil&quot;);
var lang = require(&quot;./lib/lang&quot;);
var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\u202B]/;
var BidiHandler = function (session) {
    this.session = session;
    this.bidiMap = {};
    this.currentRow = null;
    this.bidiUtil = bidiUtil;
    this.charWidths = [];
    this.EOL = &quot;\xAC&quot;;
    this.showInvisibles = true;
    this.isRtlDir = false;
    this.$isRtl = false;
    this.line = &quot;&quot;;
    this.wrapIndent = 0;
    this.EOF = &quot;\xB6&quot;;
    this.RLE = &quot;\u202B&quot;;
    this.contentWidth = 0;
    this.fontMetrics = null;
    this.rtlLineOffset = 0;
    this.wrapOffset = 0;
    this.isMoveLeftOperation = false;
    this.seenBidi = bidiRE.test(session.getValue());
};
(function () {
    this.isBidiRow = function (screenRow, docRow, splitIndex) {
        if (!this.seenBidi)
            return false;
        if (screenRow !== this.currentRow) {
            this.currentRow = screenRow;
            this.updateRowLine(docRow, splitIndex);
            this.updateBidiMap();
        }
        return this.bidiMap.bidiLevels;
    };
    this.onChange = function (delta) {
        if (!this.seenBidi) {
            if (delta.action == &quot;insert&quot; &amp;&amp; bidiRE.test(delta.lines.join(&quot;\n&quot;))) {
                this.seenBidi = true;
                this.currentRow = null;
            }
        }
        else {
            this.currentRow = null;
        }
    };
    this.getDocumentRow = function () {
        var docRow = 0;
        var rowCache = this.session.$screenRowCache;
        if (rowCache.length) {
            var index = this.session.$getRowCacheIndex(rowCache, this.currentRow);
            if (index &gt;= 0)
                docRow = this.session.$docRowCache[index];
        }
        return docRow;
    };
    this.getSplitIndex = function () {
        var splitIndex = 0;
        var rowCache = this.session.$screenRowCache;
        if (rowCache.length) {
            var currentIndex, prevIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow);
            while (this.currentRow - splitIndex &gt; 0) {
                currentIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow - splitIndex - 1);
                if (currentIndex !== prevIndex)
                    break;
                prevIndex = currentIndex;
                splitIndex++;
            }
        }
        else {
            splitIndex = this.currentRow;
        }
        return splitIndex;
    };
    this.updateRowLine = function (docRow, splitIndex) {
        if (docRow === undefined)
            docRow = this.getDocumentRow();
        var isLastRow = (docRow === this.session.getLength() - 1), endOfLine = isLastRow ? this.EOF : this.EOL;
        this.wrapIndent = 0;
        this.line = this.session.getLine(docRow);
        this.isRtlDir = this.$isRtl || this.line.charAt(0) === this.RLE;
        if (this.session.$useWrapMode) {
            var splits = this.session.$wrapData[docRow];
            if (splits) {
                if (splitIndex === undefined)
                    splitIndex = this.getSplitIndex();
                if (splitIndex &gt; 0 &amp;&amp; splits.length) {
                    this.wrapIndent = splits.indent;
                    this.wrapOffset = this.wrapIndent * this.charWidths[bidiUtil.L];
                    this.line = (splitIndex &lt; splits.length) ?
                        this.line.substring(splits[splitIndex - 1], splits[splitIndex]) :
                        this.line.substring(splits[splits.length - 1]);
                }
                else {
                    this.line = this.line.substring(0, splits[splitIndex]);
                }
                if (splitIndex == splits.length) {
                    this.line += (this.showInvisibles) ? endOfLine : bidiUtil.DOT;
                }
            }
        }
        else {
            this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;
        }
        var session = this.session, shift = 0, size;
        this.line = this.line.replace(/\t|[\u1100-\u2029, \u202F-\uFFE6]/g, function (ch, i) {
            if (ch === &#039;\t&#039; || session.isFullWidth(ch.charCodeAt(0))) {
                size = (ch === &#039;\t&#039;) ? session.getScreenTabSize(i + shift) : 2;
                shift += size - 1;
                return lang.stringRepeat(bidiUtil.DOT, size);
            }
            return ch;
        });
        if (this.isRtlDir) {
            this.fontMetrics.$main.textContent = (this.line.charAt(this.line.length - 1) == bidiUtil.DOT) ? this.line.substr(0, this.line.length - 1) : this.line;
            this.rtlLineOffset = this.contentWidth - this.fontMetrics.$main.getBoundingClientRect().width;
        }
    };
    this.updateBidiMap = function () {
        var textCharTypes = [];
        if (bidiUtil.hasBidiCharacters(this.line, textCharTypes) || this.isRtlDir) {
            this.bidiMap = bidiUtil.doBidiReorder(this.line, textCharTypes, this.isRtlDir);
        }
        else {
            this.bidiMap = {};
        }
    };
    this.markAsDirty = function () {
        this.currentRow = null;
    };
    this.updateCharacterWidths = function (fontMetrics) {
        if (this.characterWidth === fontMetrics.$characterSize.width)
            return;
        this.fontMetrics = fontMetrics;
        var characterWidth = this.characterWidth = fontMetrics.$characterSize.width;
        var bidiCharWidth = fontMetrics.$measureCharWidth(&quot;\u05d4&quot;);
        this.charWidths[bidiUtil.L] = this.charWidths[bidiUtil.EN] = this.charWidths[bidiUtil.ON_R] = characterWidth;
        this.charWidths[bidiUtil.R] = this.charWidths[bidiUtil.AN] = bidiCharWidth;
        this.charWidths[bidiUtil.R_H] = bidiCharWidth * 0.45;
        this.charWidths[bidiUtil.B] = this.charWidths[bidiUtil.RLE] = 0;
        this.currentRow = null;
    };
    this.setShowInvisibles = function (showInvisibles) {
        this.showInvisibles = showInvisibles;
        this.currentRow = null;
    };
    this.setEolChar = function (eolChar) {
        this.EOL = eolChar;
    };
    this.setContentWidth = function (width) {
        this.contentWidth = width;
    };
    this.isRtlLine = function (row) {
        if (this.$isRtl)
            return true;
        if (row != undefined)
            return (this.session.getLine(row).charAt(0) == this.RLE);
        else
            return this.isRtlDir;
    };
    this.setRtlDirection = function (editor, isRtlDir) {
        var cursor = editor.getCursorPosition();
        for (var row = editor.selection.getSelectionAnchor().row; row &lt;= cursor.row; row++) {
            if (!isRtlDir &amp;&amp; editor.session.getLine(row).charAt(0) === editor.session.$bidiHandler.RLE)
                editor.session.doc.removeInLine(row, 0, 1);
            else if (isRtlDir &amp;&amp; editor.session.getLine(row).charAt(0) !== editor.session.$bidiHandler.RLE)
                editor.session.doc.insert({ column: 0, row: row }, editor.session.$bidiHandler.RLE);
        }
    };
    this.getPosLeft = function (col) {
        col -= this.wrapIndent;
        var leftBoundary = (this.line.charAt(0) === this.RLE) ? 1 : 0;
        var logicalIdx = (col &gt; leftBoundary) ? (this.session.getOverwrite() ? col : col - 1) : leftBoundary;
        var visualIdx = bidiUtil.getVisualFromLogicalIdx(logicalIdx, this.bidiMap), levels = this.bidiMap.bidiLevels, left = 0;
        if (!this.session.getOverwrite() &amp;&amp; col &lt;= leftBoundary &amp;&amp; levels[visualIdx] % 2 !== 0)
            visualIdx++;
        for (var i = 0; i &lt; visualIdx; i++) {
            left += this.charWidths[levels[i]];
        }
        if (!this.session.getOverwrite() &amp;&amp; (col &gt; leftBoundary) &amp;&amp; (levels[visualIdx] % 2 === 0))
            left += this.charWidths[levels[visualIdx]];
        if (this.wrapIndent)
            left += this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;
        if (this.isRtlDir)
            left += this.rtlLineOffset;
        return left;
    };
    this.getSelections = function (startCol, endCol) {
        var map = this.bidiMap, levels = map.bidiLevels, level, selections = [], offset = 0, selColMin = Math.min(startCol, endCol) - this.wrapIndent, selColMax = Math.max(startCol, endCol) - this.wrapIndent, isSelected = false, isSelectedPrev = false, selectionStart = 0;
        if (this.wrapIndent)
            offset += this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;
        for (var logIdx, visIdx = 0; visIdx &lt; levels.length; visIdx++) {
            logIdx = map.logicalFromVisual[visIdx];
            level = levels[visIdx];
            isSelected = (logIdx &gt;= selColMin) &amp;&amp; (logIdx &lt; selColMax);
            if (isSelected &amp;&amp; !isSelectedPrev) {
                selectionStart = offset;
            }
            else if (!isSelected &amp;&amp; isSelectedPrev) {
                selections.push({ left: selectionStart, width: offset - selectionStart });
            }
            offset += this.charWidths[level];
            isSelectedPrev = isSelected;
        }
        if (isSelected &amp;&amp; (visIdx === levels.length)) {
            selections.push({ left: selectionStart, width: offset - selectionStart });
        }
        if (this.isRtlDir) {
            for (var i = 0; i &lt; selections.length; i++) {
                selections[i].left += this.rtlLineOffset;
            }
        }
        return selections;
    };
    this.offsetToCol = function (posX) {
        if (this.isRtlDir)
            posX -= this.rtlLineOffset;
        var logicalIdx = 0, posX = Math.max(posX, 0), offset = 0, visualIdx = 0, levels = this.bidiMap.bidiLevels, charWidth = this.charWidths[levels[visualIdx]];
        if (this.wrapIndent)
            posX -= this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;
        while (posX &gt; offset + charWidth / 2) {
            offset += charWidth;
            if (visualIdx === levels.length - 1) {
                charWidth = 0;
                break;
            }
            charWidth = this.charWidths[levels[++visualIdx]];
        }
        if (visualIdx &gt; 0 &amp;&amp; (levels[visualIdx - 1] % 2 !== 0) &amp;&amp; (levels[visualIdx] % 2 === 0)) {
            if (posX &lt; offset)
                visualIdx--;
            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
        }
        else if (visualIdx &gt; 0 &amp;&amp; (levels[visualIdx - 1] % 2 === 0) &amp;&amp; (levels[visualIdx] % 2 !== 0)) {
            logicalIdx = 1 + ((posX &gt; offset) ? this.bidiMap.logicalFromVisual[visualIdx]
                : this.bidiMap.logicalFromVisual[visualIdx - 1]);
        }
        else if ((this.isRtlDir &amp;&amp; visualIdx === levels.length - 1 &amp;&amp; charWidth === 0 &amp;&amp; (levels[visualIdx - 1] % 2 === 0))
            || (!this.isRtlDir &amp;&amp; visualIdx === 0 &amp;&amp; (levels[visualIdx] % 2 !== 0))) {
            logicalIdx = 1 + this.bidiMap.logicalFromVisual[visualIdx];
        }
        else {
            if (visualIdx &gt; 0 &amp;&amp; (levels[visualIdx - 1] % 2 !== 0) &amp;&amp; charWidth !== 0)
                visualIdx--;
            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
        }
        if (logicalIdx === 0 &amp;&amp; this.isRtlDir)
            logicalIdx++;
        return (logicalIdx + this.wrapIndent);
    };
}).call(BidiHandler.prototype);
exports.BidiHandler = BidiHandler;

});

define(&quot;ace/selection&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/lang&quot;,&quot;ace/lib/event_emitter&quot;,&quot;ace/range&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;./lib/oop&quot;);
var lang = require(&quot;./lib/lang&quot;);
var EventEmitter = require(&quot;./lib/event_emitter&quot;).EventEmitter;
var Range = require(&quot;./range&quot;).Range;
var Selection = function (session) {
    this.session = session;
    this.doc = session.getDocument();
    this.clearSelection();
    this.cursor = this.lead = this.doc.createAnchor(0, 0);
    this.anchor = this.doc.createAnchor(0, 0);
    this.$silent = false;
    var self = this;
    this.cursor.on(&quot;change&quot;, function (e) {
        self.$cursorChanged = true;
        if (!self.$silent)
            self._emit(&quot;changeCursor&quot;);
        if (!self.$isEmpty &amp;&amp; !self.$silent)
            self._emit(&quot;changeSelection&quot;);
        if (!self.$keepDesiredColumnOnChange &amp;&amp; e.old.column != e.value.column)
            self.$desiredColumn = null;
    });
    this.anchor.on(&quot;change&quot;, function () {
        self.$anchorChanged = true;
        if (!self.$isEmpty &amp;&amp; !self.$silent)
            self._emit(&quot;changeSelection&quot;);
    });
};
(function () {
    oop.implement(this, EventEmitter);
    this.isEmpty = function () {
        return this.$isEmpty || (this.anchor.row == this.lead.row &amp;&amp;
            this.anchor.column == this.lead.column);
    };
    this.isMultiLine = function () {
        return !this.$isEmpty &amp;&amp; this.anchor.row != this.cursor.row;
    };
    this.getCursor = function () {
        return this.lead.getPosition();
    };
    this.setSelectionAnchor = function (row, column) {
        this.$isEmpty = false;
        this.anchor.setPosition(row, column);
    };
    this.getAnchor =
        this.getSelectionAnchor = function () {
            if (this.$isEmpty)
                return this.getSelectionLead();
            return this.anchor.getPosition();
        };
    this.getSelectionLead = function () {
        return this.lead.getPosition();
    };
    this.isBackwards = function () {
        var anchor = this.anchor;
        var lead = this.lead;
        return (anchor.row &gt; lead.row || (anchor.row == lead.row &amp;&amp; anchor.column &gt; lead.column));
    };
    this.getRange = function () {
        var anchor = this.anchor;
        var lead = this.lead;
        if (this.$isEmpty)
            return Range.fromPoints(lead, lead);
        return this.isBackwards()
            ? Range.fromPoints(lead, anchor)
            : Range.fromPoints(anchor, lead);
    };
    this.clearSelection = function () {
        if (!this.$isEmpty) {
            this.$isEmpty = true;
            this._emit(&quot;changeSelection&quot;);
        }
    };
    this.selectAll = function () {
        this.$setSelection(0, 0, Number.MAX_VALUE, Number.MAX_VALUE);
    };
    this.setRange =
        this.setSelectionRange = function (range, reverse) {
            var start = reverse ? range.end : range.start;
            var end = reverse ? range.start : range.end;
            this.$setSelection(start.row, start.column, end.row, end.column);
        };
    this.$setSelection = function (anchorRow, anchorColumn, cursorRow, cursorColumn) {
        if (this.$silent)
            return;
        var wasEmpty = this.$isEmpty;
        var wasMultiselect = this.inMultiSelectMode;
        this.$silent = true;
        this.$cursorChanged = this.$anchorChanged = false;
        this.anchor.setPosition(anchorRow, anchorColumn);
        this.cursor.setPosition(cursorRow, cursorColumn);
        this.$isEmpty = !Range.comparePoints(this.anchor, this.cursor);
        this.$silent = false;
        if (this.$cursorChanged)
            this._emit(&quot;changeCursor&quot;);
        if (this.$cursorChanged || this.$anchorChanged || wasEmpty != this.$isEmpty || wasMultiselect)
            this._emit(&quot;changeSelection&quot;);
    };
    this.$moveSelection = function (mover) {
        var lead = this.lead;
        if (this.$isEmpty)
            this.setSelectionAnchor(lead.row, lead.column);
        mover.call(this);
    };
    this.selectTo = function (row, column) {
        this.$moveSelection(function () {
            this.moveCursorTo(row, column);
        });
    };
    this.selectToPosition = function (pos) {
        this.$moveSelection(function () {
            this.moveCursorToPosition(pos);
        });
    };
    this.moveTo = function (row, column) {
        this.clearSelection();
        this.moveCursorTo(row, column);
    };
    this.moveToPosition = function (pos) {
        this.clearSelection();
        this.moveCursorToPosition(pos);
    };
    this.selectUp = function () {
        this.$moveSelection(this.moveCursorUp);
    };
    this.selectDown = function () {
        this.$moveSelection(this.moveCursorDown);
    };
    this.selectRight = function () {
        this.$moveSelection(this.moveCursorRight);
    };
    this.selectLeft = function () {
        this.$moveSelection(this.moveCursorLeft);
    };
    this.selectLineStart = function () {
        this.$moveSelection(this.moveCursorLineStart);
    };
    this.selectLineEnd = function () {
        this.$moveSelection(this.moveCursorLineEnd);
    };
    this.selectFileEnd = function () {
        this.$moveSelection(this.moveCursorFileEnd);
    };
    this.selectFileStart = function () {
        this.$moveSelection(this.moveCursorFileStart);
    };
    this.selectWordRight = function () {
        this.$moveSelection(this.moveCursorWordRight);
    };
    this.selectWordLeft = function () {
        this.$moveSelection(this.moveCursorWordLeft);
    };
    this.getWordRange = function (row, column) {
        if (typeof column == &quot;undefined&quot;) {
            var cursor = row || this.lead;
            row = cursor.row;
            column = cursor.column;
        }
        return this.session.getWordRange(row, column);
    };
    this.selectWord = function () {
        this.setSelectionRange(this.getWordRange());
    };
    this.selectAWord = function () {
        var cursor = this.getCursor();
        var range = this.session.getAWordRange(cursor.row, cursor.column);
        this.setSelectionRange(range);
    };
    this.getLineRange = function (row, excludeLastChar) {
        var rowStart = typeof row == &quot;number&quot; ? row : this.lead.row;
        var rowEnd;
        var foldLine = this.session.getFoldLine(rowStart);
        if (foldLine) {
            rowStart = foldLine.start.row;
            rowEnd = foldLine.end.row;
        }
        else {
            rowEnd = rowStart;
        }
        if (excludeLastChar === true)
            return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
        else
            return new Range(rowStart, 0, rowEnd + 1, 0);
    };
    this.selectLine = function () {
        this.setSelectionRange(this.getLineRange());
    };
    this.moveCursorUp = function () {
        this.moveCursorBy(-1, 0);
    };
    this.moveCursorDown = function () {
        this.moveCursorBy(1, 0);
    };
    this.wouldMoveIntoSoftTab = function (cursor, tabSize, direction) {
        var start = cursor.column;
        var end = cursor.column + tabSize;
        if (direction &lt; 0) {
            start = cursor.column - tabSize;
            end = cursor.column;
        }
        return this.session.isTabStop(cursor) &amp;&amp; this.doc.getLine(cursor.row).slice(start, end).split(&quot; &quot;).length - 1 == tabSize;
    };
    this.moveCursorLeft = function () {
        var cursor = this.lead.getPosition(), fold;
        if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
        }
        else if (cursor.column === 0) {
            if (cursor.row &gt; 0) {
                this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
            }
        }
        else {
            var tabSize = this.session.getTabSize();
            if (this.wouldMoveIntoSoftTab(cursor, tabSize, -1) &amp;&amp; !this.session.getNavigateWithinSoftTabs()) {
                this.moveCursorBy(0, -tabSize);
            }
            else {
                this.moveCursorBy(0, -1);
            }
        }
    };
    this.moveCursorRight = function () {
        var cursor = this.lead.getPosition(), fold;
        if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
            this.moveCursorTo(fold.end.row, fold.end.column);
        }
        else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
            if (this.lead.row &lt; this.doc.getLength() - 1) {
                this.moveCursorTo(this.lead.row + 1, 0);
            }
        }
        else {
            var tabSize = this.session.getTabSize();
            var cursor = this.lead;
            if (this.wouldMoveIntoSoftTab(cursor, tabSize, 1) &amp;&amp; !this.session.getNavigateWithinSoftTabs()) {
                this.moveCursorBy(0, tabSize);
            }
            else {
                this.moveCursorBy(0, 1);
            }
        }
    };
    this.moveCursorLineStart = function () {
        var row = this.lead.row;
        var column = this.lead.column;
        var screenRow = this.session.documentToScreenRow(row, column);
        var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
        var beforeCursor = this.session.getDisplayLine(row, null, firstColumnPosition.row, firstColumnPosition.column);
        var leadingSpace = beforeCursor.match(/^\s*/);
        if (leadingSpace[0].length != column &amp;&amp; !this.session.$useEmacsStyleLineStart)
            firstColumnPosition.column += leadingSpace[0].length;
        this.moveCursorToPosition(firstColumnPosition);
    };
    this.moveCursorLineEnd = function () {
        var lead = this.lead;
        var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
        if (this.lead.column == lineEnd.column) {
            var line = this.session.getLine(lineEnd.row);
            if (lineEnd.column == line.length) {
                var textEnd = line.search(/\s+$/);
                if (textEnd &gt; 0)
                    lineEnd.column = textEnd;
            }
        }
        this.moveCursorTo(lineEnd.row, lineEnd.column);
    };
    this.moveCursorFileEnd = function () {
        var row = this.doc.getLength() - 1;
        var column = this.doc.getLine(row).length;
        this.moveCursorTo(row, column);
    };
    this.moveCursorFileStart = function () {
        this.moveCursorTo(0, 0);
    };
    this.moveCursorLongWordRight = function () {
        var row = this.lead.row;
        var column = this.lead.column;
        var line = this.doc.getLine(row);
        var rightOfCursor = line.substring(column);
        this.session.nonTokenRe.lastIndex = 0;
        this.session.tokenRe.lastIndex = 0;
        var fold = this.session.getFoldAt(row, column, 1);
        if (fold) {
            this.moveCursorTo(fold.end.row, fold.end.column);
            return;
        }
        if (this.session.nonTokenRe.exec(rightOfCursor)) {
            column += this.session.nonTokenRe.lastIndex;
            this.session.nonTokenRe.lastIndex = 0;
            rightOfCursor = line.substring(column);
        }
        if (column &gt;= line.length) {
            this.moveCursorTo(row, line.length);
            this.moveCursorRight();
            if (row &lt; this.doc.getLength() - 1)
                this.moveCursorWordRight();
            return;
        }
        if (this.session.tokenRe.exec(rightOfCursor)) {
            column += this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
        }
        this.moveCursorTo(row, column);
    };
    this.moveCursorLongWordLeft = function () {
        var row = this.lead.row;
        var column = this.lead.column;
        var fold;
        if (fold = this.session.getFoldAt(row, column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
            return;
        }
        var str = this.session.getFoldStringAt(row, column, -1);
        if (str == null) {
            str = this.doc.getLine(row).substring(0, column);
        }
        var leftOfCursor = lang.stringReverse(str);
        this.session.nonTokenRe.lastIndex = 0;
        this.session.tokenRe.lastIndex = 0;
        if (this.session.nonTokenRe.exec(leftOfCursor)) {
            column -= this.session.nonTokenRe.lastIndex;
            leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
            this.session.nonTokenRe.lastIndex = 0;
        }
        if (column &lt;= 0) {
            this.moveCursorTo(row, 0);
            this.moveCursorLeft();
            if (row &gt; 0)
                this.moveCursorWordLeft();
            return;
        }
        if (this.session.tokenRe.exec(leftOfCursor)) {
            column -= this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
        }
        this.moveCursorTo(row, column);
    };
    this.$shortWordEndIndex = function (rightOfCursor) {
        var index = 0, ch;
        var whitespaceRe = /\s/;
        var tokenRe = this.session.tokenRe;
        tokenRe.lastIndex = 0;
        if (this.session.tokenRe.exec(rightOfCursor)) {
            index = this.session.tokenRe.lastIndex;
        }
        else {
            while ((ch = rightOfCursor[index]) &amp;&amp; whitespaceRe.test(ch))
                index++;
            if (index &lt; 1) {
                tokenRe.lastIndex = 0;
                while ((ch = rightOfCursor[index]) &amp;&amp; !tokenRe.test(ch)) {
                    tokenRe.lastIndex = 0;
                    index++;
                    if (whitespaceRe.test(ch)) {
                        if (index &gt; 2) {
                            index--;
                            break;
                        }
                        else {
                            while ((ch = rightOfCursor[index]) &amp;&amp; whitespaceRe.test(ch))
                                index++;
                            if (index &gt; 2)
                                break;
                        }
                    }
                }
            }
        }
        tokenRe.lastIndex = 0;
        return index;
    };
    this.moveCursorShortWordRight = function () {
        var row = this.lead.row;
        var column = this.lead.column;
        var line = this.doc.getLine(row);
        var rightOfCursor = line.substring(column);
        var fold = this.session.getFoldAt(row, column, 1);
        if (fold)
            return this.moveCursorTo(fold.end.row, fold.end.column);
        if (column == line.length) {
            var l = this.doc.getLength();
            do {
                row++;
                rightOfCursor = this.doc.getLine(row);
            } while (row &lt; l &amp;&amp; /^\s*$/.test(rightOfCursor));
            if (!/^\s+/.test(rightOfCursor))
                rightOfCursor = &quot;&quot;;
            column = 0;
        }
        var index = this.$shortWordEndIndex(rightOfCursor);
        this.moveCursorTo(row, column + index);
    };
    this.moveCursorShortWordLeft = function () {
        var row = this.lead.row;
        var column = this.lead.column;
        var fold;
        if (fold = this.session.getFoldAt(row, column, -1))
            return this.moveCursorTo(fold.start.row, fold.start.column);
        var line = this.session.getLine(row).substring(0, column);
        if (column === 0) {
            do {
                row--;
                line = this.doc.getLine(row);
            } while (row &gt; 0 &amp;&amp; /^\s*$/.test(line));
            column = line.length;
            if (!/\s+$/.test(line))
                line = &quot;&quot;;
        }
        var leftOfCursor = lang.stringReverse(line);
        var index = this.$shortWordEndIndex(leftOfCursor);
        return this.moveCursorTo(row, column - index);
    };
    this.moveCursorWordRight = function () {
        if (this.session.$selectLongWords)
            this.moveCursorLongWordRight();
        else
            this.moveCursorShortWordRight();
    };
    this.moveCursorWordLeft = function () {
        if (this.session.$selectLongWords)
            this.moveCursorLongWordLeft();
        else
            this.moveCursorShortWordLeft();
    };
    this.moveCursorBy = function (rows, chars) {
        var screenPos = this.session.documentToScreenPosition(this.lead.row, this.lead.column);
        var offsetX;
        if (chars === 0) {
            if (rows !== 0) {
                if (this.session.$bidiHandler.isBidiRow(screenPos.row, this.lead.row)) {
                    offsetX = this.session.$bidiHandler.getPosLeft(screenPos.column);
                    screenPos.column = Math.round(offsetX / this.session.$bidiHandler.charWidths[0]);
                }
                else {
                    offsetX = screenPos.column * this.session.$bidiHandler.charWidths[0];
                }
            }
            if (this.$desiredColumn)
                screenPos.column = this.$desiredColumn;
            else
                this.$desiredColumn = screenPos.column;
        }
        if (rows != 0 &amp;&amp; this.session.lineWidgets &amp;&amp; this.session.lineWidgets[this.lead.row]) {
            var widget = this.session.lineWidgets[this.lead.row];
            if (rows &lt; 0)
                rows -= widget.rowsAbove || 0;
            else if (rows &gt; 0)
                rows += widget.rowCount - (widget.rowsAbove || 0);
        }
        var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column, offsetX);
        if (rows !== 0 &amp;&amp; chars === 0 &amp;&amp; docPos.row === this.lead.row &amp;&amp; docPos.column === this.lead.column) {
        }
        this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
    };
    this.moveCursorToPosition = function (position) {
        this.moveCursorTo(position.row, position.column);
    };
    this.moveCursorTo = function (row, column, keepDesiredColumn) {
        var fold = this.session.getFoldAt(row, column, 1);
        if (fold) {
            row = fold.start.row;
            column = fold.start.column;
        }
        this.$keepDesiredColumnOnChange = true;
        var line = this.session.getLine(row);
        if (/[\uDC00-\uDFFF]/.test(line.charAt(column)) &amp;&amp; line.charAt(column - 1)) {
            if (this.lead.row == row &amp;&amp; this.lead.column == column + 1)
                column = column - 1;
            else
                column = column + 1;
        }
        this.lead.setPosition(row, column);
        this.$keepDesiredColumnOnChange = false;
        if (!keepDesiredColumn)
            this.$desiredColumn = null;
    };
    this.moveCursorToScreen = function (row, column, keepDesiredColumn) {
        var pos = this.session.screenToDocumentPosition(row, column);
        this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
    };
    this.detach = function () {
        this.lead.detach();
        this.anchor.detach();
    };
    this.fromOrientedRange = function (range) {
        this.setSelectionRange(range, range.cursor == range.start);
        this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
    };
    this.toOrientedRange = function (range) {
        var r = this.getRange();
        if (range) {
            range.start.column = r.start.column;
            range.start.row = r.start.row;
            range.end.column = r.end.column;
            range.end.row = r.end.row;
        }
        else {
            range = r;
        }
        range.cursor = this.isBackwards() ? range.start : range.end;
        range.desiredColumn = this.$desiredColumn;
        return range;
    };
    this.getRangeOfMovements = function (func) {
        var start = this.getCursor();
        try {
            func(this);
            var end = this.getCursor();
            return Range.fromPoints(start, end);
        }
        catch (e) {
            return Range.fromPoints(start, start);
        }
        finally {
            this.moveCursorToPosition(start);
        }
    };
    this.toJSON = function () {
        if (this.rangeCount) {
            var data = this.ranges.map(function (r) {
                var r1 = r.clone();
                r1.isBackwards = r.cursor == r.start;
                return r1;
            });
        }
        else {
            var data = this.getRange();
            data.isBackwards = this.isBackwards();
        }
        return data;
    };
    this.fromJSON = function (data) {
        if (data.start == undefined) {
            if (this.rangeList &amp;&amp; data.length &gt; 1) {
                this.toSingleRange(data[0]);
                for (var i = data.length; i--;) {
                    var r = Range.fromPoints(data[i].start, data[i].end);
                    if (data[i].isBackwards)
                        r.cursor = r.start;
                    this.addRange(r, true);
                }
                return;
            }
            else {
                data = data[0];
            }
        }
        if (this.rangeList)
            this.toSingleRange(data);
        this.setSelectionRange(data, data.isBackwards);
    };
    this.isEqual = function (data) {
        if ((data.length || this.rangeCount) &amp;&amp; data.length != this.rangeCount)
            return false;
        if (!data.length || !this.ranges)
            return this.getRange().isEqual(data);
        for (var i = this.ranges.length; i--;) {
            if (!this.ranges[i].isEqual(data[i]))
                return false;
        }
        return true;
    };
}).call(Selection.prototype);
exports.Selection = Selection;

});

define(&quot;ace/tokenizer&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/config&quot;], function(require, exports, module){&quot;use strict&quot;;
var config = require(&quot;./config&quot;);
var MAX_TOKEN_COUNT = 2000;
var Tokenizer = function (rules) {
    this.states = rules;
    this.regExps = {};
    this.matchMappings = {};
    for (var key in this.states) {
        var state = this.states[key];
        var ruleRegExps = [];
        var matchTotal = 0;
        var mapping = this.matchMappings[key] = { defaultToken: &quot;text&quot; };
        var flag = &quot;g&quot;;
        var splitterRurles = [];
        for (var i = 0; i &lt; state.length; i++) {
            var rule = state[i];
            if (rule.defaultToken)
                mapping.defaultToken = rule.defaultToken;
            if (rule.caseInsensitive &amp;&amp; flag.indexOf(&quot;i&quot;) === -1)
                flag += &quot;i&quot;;
            if (rule.unicode &amp;&amp; flag.indexOf(&quot;u&quot;) === -1)
                flag += &quot;u&quot;;
            if (rule.regex == null)
                continue;
            if (rule.regex instanceof RegExp)
                rule.regex = rule.regex.toString().slice(1, -1);
            var adjustedregex = rule.regex;
            var matchcount = new RegExp(&quot;(?:(&quot; + adjustedregex + &quot;)|(.))&quot;).exec(&quot;a&quot;).length - 2;
            if (Array.isArray(rule.token)) {
                if (rule.token.length == 1 || matchcount == 1) {
                    rule.token = rule.token[0];
                }
                else if (matchcount - 1 != rule.token.length) {
                    this.reportError(&quot;number of classes and regexp groups doesn&#039;t match&quot;, {
                        rule: rule,
                        groupCount: matchcount - 1
                    });
                    rule.token = rule.token[0];
                }
                else {
                    rule.tokenArray = rule.token;
                    rule.token = null;
                    rule.onMatch = this.$arrayTokens;
                }
            }
            else if (typeof rule.token == &quot;function&quot; &amp;&amp; !rule.onMatch) {
                if (matchcount &gt; 1)
                    rule.onMatch = this.$applyToken;
                else
                    rule.onMatch = rule.token;
            }
            if (matchcount &gt; 1) {
                if (/\\\d/.test(rule.regex)) {
                    adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function (match, digit) {
                        return &quot;\\&quot; + (parseInt(digit, 10) + matchTotal + 1);
                    });
                }
                else {
                    matchcount = 1;
                    adjustedregex = this.removeCapturingGroups(rule.regex);
                }
                if (!rule.splitRegex &amp;&amp; typeof rule.token != &quot;string&quot;)
                    splitterRurles.push(rule); // flag will be known only at the very end
            }
            mapping[matchTotal] = i;
            matchTotal += matchcount;
            ruleRegExps.push(adjustedregex);
            if (!rule.onMatch)
                rule.onMatch = null;
        }
        if (!ruleRegExps.length) {
            mapping[0] = 0;
            ruleRegExps.push(&quot;$&quot;);
        }
        splitterRurles.forEach(function (rule) {
            rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);
        }, this);
        this.regExps[key] = new RegExp(&quot;(&quot; + ruleRegExps.join(&quot;)|(&quot;) + &quot;)|($)&quot;, flag);
    }
};
(function () {
    this.$setMaxTokenCount = function (m) {
        MAX_TOKEN_COUNT = m | 0;
    };
    this.$applyToken = function (str) {
        var values = this.splitRegex.exec(str).slice(1);
        var types = this.token.apply(this, values);
        if (typeof types === &quot;string&quot;)
            return [{ type: types, value: str }];
        var tokens = [];
        for (var i = 0, l = types.length; i &lt; l; i++) {
            if (values[i])
                tokens[tokens.length] = {
                    type: types[i],
                    value: values[i]
                };
        }
        return tokens;
    };
    this.$arrayTokens = function (str) {
        if (!str)
            return [];
        var values = this.splitRegex.exec(str);
        if (!values)
            return &quot;text&quot;;
        var tokens = [];
        var types = this.tokenArray;
        for (var i = 0, l = types.length; i &lt; l; i++) {
            if (values[i + 1])
                tokens[tokens.length] = {
                    type: types[i],
                    value: values[i + 1]
                };
        }
        return tokens;
    };
    this.removeCapturingGroups = function (src) {
        var r = src.replace(/\\.|\[(?:\\.|[^\\\]])*|\(\?[:=!&lt;]|(\()/g, function (x, y) { return y ? &quot;(?:&quot; : x; });
        return r;
    };
    this.createSplitterRegexp = function (src, flag) {
        if (src.indexOf(&quot;(?=&quot;) != -1) {
            var stack = 0;
            var inChClass = false;
            var lastCapture = {};
            src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function (m, esc, parenOpen, parenClose, square, index) {
                if (inChClass) {
                    inChClass = square != &quot;]&quot;;
                }
                else if (square) {
                    inChClass = true;
                }
                else if (parenClose) {
                    if (stack == lastCapture.stack) {
                        lastCapture.end = index + 1;
                        lastCapture.stack = -1;
                    }
                    stack--;
                }
                else if (parenOpen) {
                    stack++;
                    if (parenOpen.length != 1) {
                        lastCapture.stack = stack;
                        lastCapture.start = index;
                    }
                }
                return m;
            });
            if (lastCapture.end != null &amp;&amp; /^\)*$/.test(src.substr(lastCapture.end)))
                src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
        }
        if (src.charAt(0) != &quot;^&quot;)
            src = &quot;^&quot; + src;
        if (src.charAt(src.length - 1) != &quot;$&quot;)
            src += &quot;$&quot;;
        return new RegExp(src, (flag || &quot;&quot;).replace(&quot;g&quot;, &quot;&quot;));
    };
    this.getLineTokens = function (line, startState) {
        if (startState &amp;&amp; typeof startState != &quot;string&quot;) {
            var stack = startState.slice(0);
            startState = stack[0];
            if (startState === &quot;#tmp&quot;) {
                stack.shift();
                startState = stack.shift();
            }
        }
        else
            var stack = [];
        var currentState = startState || &quot;start&quot;;
        var state = this.states[currentState];
        if (!state) {
            currentState = &quot;start&quot;;
            state = this.states[currentState];
        }
        var mapping = this.matchMappings[currentState];
        var re = this.regExps[currentState];
        re.lastIndex = 0;
        var match, tokens = [];
        var lastIndex = 0;
        var matchAttempts = 0;
        var token = { type: null, value: &quot;&quot; };
        while (match = re.exec(line)) {
            var type = mapping.defaultToken;
            var rule = null;
            var value = match[0];
            var index = re.lastIndex;
            if (index - value.length &gt; lastIndex) {
                var skipped = line.substring(lastIndex, index - value.length);
                if (token.type == type) {
                    token.value += skipped;
                }
                else {
                    if (token.type)
                        tokens.push(token);
                    token = { type: type, value: skipped };
                }
            }
            for (var i = 0; i &lt; match.length - 2; i++) {
                if (match[i + 1] === undefined)
                    continue;
                rule = state[mapping[i]];
                if (rule.onMatch)
                    type = rule.onMatch(value, currentState, stack, line);
                else
                    type = rule.token;
                if (rule.next) {
                    if (typeof rule.next == &quot;string&quot;) {
                        currentState = rule.next;
                    }
                    else {
                        currentState = rule.next(currentState, stack);
                    }
                    state = this.states[currentState];
                    if (!state) {
                        this.reportError(&quot;state doesn&#039;t exist&quot;, currentState);
                        currentState = &quot;start&quot;;
                        state = this.states[currentState];
                    }
                    mapping = this.matchMappings[currentState];
                    lastIndex = index;
                    re = this.regExps[currentState];
                    re.lastIndex = index;
                }
                if (rule.consumeLineEnd)
                    lastIndex = index;
                break;
            }
            if (value) {
                if (typeof type === &quot;string&quot;) {
                    if ((!rule || rule.merge !== false) &amp;&amp; token.type === type) {
                        token.value += value;
                    }
                    else {
                        if (token.type)
                            tokens.push(token);
                        token = { type: type, value: value };
                    }
                }
                else if (type) {
                    if (token.type)
                        tokens.push(token);
                    token = { type: null, value: &quot;&quot; };
                    for (var i = 0; i &lt; type.length; i++)
                        tokens.push(type[i]);
                }
            }
            if (lastIndex == line.length)
                break;
            lastIndex = index;
            if (matchAttempts++ &gt; MAX_TOKEN_COUNT) {
                if (matchAttempts &gt; 2 * line.length) {
                    this.reportError(&quot;infinite loop with in ace tokenizer&quot;, {
                        startState: startState,
                        line: line
                    });
                }
                while (lastIndex &lt; line.length) {
                    if (token.type)
                        tokens.push(token);
                    token = {
                        value: line.substring(lastIndex, lastIndex += 500),
                        type: &quot;overflow&quot;
                    };
                }
                currentState = &quot;start&quot;;
                stack = [];
                break;
            }
        }
        if (token.type)
            tokens.push(token);
        if (stack.length &gt; 1) {
            if (stack[0] !== currentState)
                stack.unshift(&quot;#tmp&quot;, currentState);
        }
        return {
            tokens: tokens,
            state: stack.length ? stack : currentState
        };
    };
    this.reportError = config.reportError;
}).call(Tokenizer.prototype);
exports.Tokenizer = Tokenizer;

});

define(&quot;ace/mode/text_highlight_rules&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/lang&quot;], function(require, exports, module){&quot;use strict&quot;;
var lang = require(&quot;../lib/lang&quot;);
var TextHighlightRules = function () {
    this.$rules = {
        &quot;start&quot;: [{
                token: &quot;empty_line&quot;,
                regex: &#039;^$&#039;
            }, {
                defaultToken: &quot;text&quot;
            }]
    };
};
(function () {
    this.addRules = function (rules, prefix) {
        if (!prefix) {
            for (var key in rules)
                this.$rules[key] = rules[key];
            return;
        }
        for (var key in rules) {
            var state = rules[key];
            for (var i = 0; i &lt; state.length; i++) {
                var rule = state[i];
                if (rule.next || rule.onMatch) {
                    if (typeof rule.next == &quot;string&quot;) {
                        if (rule.next.indexOf(prefix) !== 0)
                            rule.next = prefix + rule.next;
                    }
                    if (rule.nextState &amp;&amp; rule.nextState.indexOf(prefix) !== 0)
                        rule.nextState = prefix + rule.nextState;
                }
            }
            this.$rules[prefix + key] = state;
        }
    };
    this.getRules = function () {
        return this.$rules;
    };
    this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {
        var embedRules = typeof HighlightRules == &quot;function&quot;
            ? new HighlightRules().getRules()
            : HighlightRules;
        if (states) {
            for (var i = 0; i &lt; states.length; i++)
                states[i] = prefix + states[i];
        }
        else {
            states = [];
            for (var key in embedRules)
                states.push(prefix + key);
        }
        this.addRules(embedRules, prefix);
        if (escapeRules) {
            var addRules = Array.prototype[append ? &quot;push&quot; : &quot;unshift&quot;];
            for (var i = 0; i &lt; states.length; i++)
                addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));
        }
        if (!this.$embeds)
            this.$embeds = [];
        this.$embeds.push(prefix);
    };
    this.getEmbeds = function () {
        return this.$embeds;
    };
    var pushState = function (currentState, stack) {
        if (currentState != &quot;start&quot; || stack.length)
            stack.unshift(this.nextState, currentState);
        return this.nextState;
    };
    var popState = function (currentState, stack) {
        stack.shift();
        return stack.shift() || &quot;start&quot;;
    };
    this.normalizeRules = function () {
        var id = 0;
        var rules = this.$rules;
        function processState(key) {
            var state = rules[key];
            state.processed = true;
            for (var i = 0; i &lt; state.length; i++) {
                var rule = state[i];
                var toInsert = null;
                if (Array.isArray(rule)) {
                    toInsert = rule;
                    rule = {};
                }
                if (!rule.regex &amp;&amp; rule.start) {
                    rule.regex = rule.start;
                    if (!rule.next)
                        rule.next = [];
                    rule.next.push({
                        defaultToken: rule.token
                    }, {
                        token: rule.token + &quot;.end&quot;,
                        regex: rule.end || rule.start,
                        next: &quot;pop&quot;
                    });
                    rule.token = rule.token + &quot;.start&quot;;
                    rule.push = true;
                }
                var next = rule.next || rule.push;
                if (next &amp;&amp; Array.isArray(next)) {
                    var stateName = rule.stateName;
                    if (!stateName) {
                        stateName = rule.token;
                        if (typeof stateName != &quot;string&quot;)
                            stateName = stateName[0] || &quot;&quot;;
                        if (rules[stateName])
                            stateName += id++;
                    }
                    rules[stateName] = next;
                    rule.next = stateName;
                    processState(stateName);
                }
                else if (next == &quot;pop&quot;) {
                    rule.next = popState;
                }
                if (rule.push) {
                    rule.nextState = rule.next || rule.push;
                    rule.next = pushState;
                    delete rule.push;
                }
                if (rule.rules) {
                    for (var r in rule.rules) {
                        if (rules[r]) {
                            if (rules[r].push)
                                rules[r].push.apply(rules[r], rule.rules[r]);
                        }
                        else {
                            rules[r] = rule.rules[r];
                        }
                    }
                }
                var includeName = typeof rule == &quot;string&quot; ? rule : rule.include;
                if (includeName) {
                    if (Array.isArray(includeName))
                        toInsert = includeName.map(function (x) { return rules[x]; });
                    else
                        toInsert = rules[includeName];
                }
                if (toInsert) {
                    var args = [i, 1].concat(toInsert);
                    if (rule.noEscape)
                        args = args.filter(function (x) { return !x.next; });
                    state.splice.apply(state, args);
                    i--;
                }
                if (rule.keywordMap) {
                    rule.token = this.createKeywordMapper(rule.keywordMap, rule.defaultToken || &quot;text&quot;, rule.caseInsensitive);
                    delete rule.defaultToken;
                }
            }
        }
        Object.keys(rules).forEach(processState, this);
    };
    this.createKeywordMapper = function (map, defaultToken, ignoreCase, splitChar) {
        var keywords = Object.create(null);
        this.$keywordList = [];
        Object.keys(map).forEach(function (className) {
            var a = map[className];
            var list = a.split(splitChar || &quot;|&quot;);
            for (var i = list.length; i--;) {
                var word = list[i];
                this.$keywordList.push(word);
                if (ignoreCase)
                    word = word.toLowerCase();
                keywords[word] = className;
            }
        }, this);
        map = null;
        return ignoreCase
            ? function (value) { return keywords[value.toLowerCase()] || defaultToken; }
            : function (value) { return keywords[value] || defaultToken; };
    };
    this.getKeywords = function () {
        return this.$keywords;
    };
}).call(TextHighlightRules.prototype);
exports.TextHighlightRules = TextHighlightRules;

});

define(&quot;ace/mode/behaviour&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;], function(require, exports, module){&quot;use strict&quot;;
var Behaviour = function () {
    this.$behaviours = {};
};
(function () {
    this.add = function (name, action, callback) {
        switch (undefined) {
            case this.$behaviours:
                this.$behaviours = {};
            case this.$behaviours[name]:
                this.$behaviours[name] = {};
        }
        this.$behaviours[name][action] = callback;
    };
    this.addBehaviours = function (behaviours) {
        for (var key in behaviours) {
            for (var action in behaviours[key]) {
                this.add(key, action, behaviours[key][action]);
            }
        }
    };
    this.remove = function (name) {
        if (this.$behaviours &amp;&amp; this.$behaviours[name]) {
            delete this.$behaviours[name];
        }
    };
    this.inherit = function (mode, filter) {
        if (typeof mode === &quot;function&quot;) {
            var behaviours = new mode().getBehaviours(filter);
        }
        else {
            var behaviours = mode.getBehaviours(filter);
        }
        this.addBehaviours(behaviours);
    };
    this.getBehaviours = function (filter) {
        if (!filter) {
            return this.$behaviours;
        }
        else {
            var ret = {};
            for (var i = 0; i &lt; filter.length; i++) {
                if (this.$behaviours[filter[i]]) {
                    ret[filter[i]] = this.$behaviours[filter[i]];
                }
            }
            return ret;
        }
    };
}).call(Behaviour.prototype);
exports.Behaviour = Behaviour;

});

define(&quot;ace/token_iterator&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/range&quot;], function(require, exports, module){&quot;use strict&quot;;
var Range = require(&quot;./range&quot;).Range;
var TokenIterator = function (session, initialRow, initialColumn) {
    this.$session = session;
    this.$row = initialRow;
    this.$rowTokens = session.getTokens(initialRow);
    var token = session.getTokenAt(initialRow, initialColumn);
    this.$tokenIndex = token ? token.index : -1;
};
(function () {
    this.stepBackward = function () {
        this.$tokenIndex -= 1;
        while (this.$tokenIndex &lt; 0) {
            this.$row -= 1;
            if (this.$row &lt; 0) {
                this.$row = 0;
                return null;
            }
            this.$rowTokens = this.$session.getTokens(this.$row);
            this.$tokenIndex = this.$rowTokens.length - 1;
        }
        return this.$rowTokens[this.$tokenIndex];
    };
    this.stepForward = function () {
        this.$tokenIndex += 1;
        var rowCount;
        while (this.$tokenIndex &gt;= this.$rowTokens.length) {
            this.$row += 1;
            if (!rowCount)
                rowCount = this.$session.getLength();
            if (this.$row &gt;= rowCount) {
                this.$row = rowCount - 1;
                return null;
            }
            this.$rowTokens = this.$session.getTokens(this.$row);
            this.$tokenIndex = 0;
        }
        return this.$rowTokens[this.$tokenIndex];
    };
    this.getCurrentToken = function () {
        return this.$rowTokens[this.$tokenIndex];
    };
    this.getCurrentTokenRow = function () {
        return this.$row;
    };
    this.getCurrentTokenColumn = function () {
        var rowTokens = this.$rowTokens;
        var tokenIndex = this.$tokenIndex;
        var column = rowTokens[tokenIndex].start;
        if (column !== undefined)
            return column;
        column = 0;
        while (tokenIndex &gt; 0) {
            tokenIndex -= 1;
            column += rowTokens[tokenIndex].value.length;
        }
        return column;
    };
    this.getCurrentTokenPosition = function () {
        return { row: this.$row, column: this.getCurrentTokenColumn() };
    };
    this.getCurrentTokenRange = function () {
        var token = this.$rowTokens[this.$tokenIndex];
        var column = this.getCurrentTokenColumn();
        return new Range(this.$row, column, this.$row, column + token.value.length);
    };
}).call(TokenIterator.prototype);
exports.TokenIterator = TokenIterator;

});

define(&quot;ace/mode/behaviour/cstyle&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/mode/behaviour&quot;,&quot;ace/token_iterator&quot;,&quot;ace/lib/lang&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;../../lib/oop&quot;);
var Behaviour = require(&quot;../behaviour&quot;).Behaviour;
var TokenIterator = require(&quot;../../token_iterator&quot;).TokenIterator;
var lang = require(&quot;../../lib/lang&quot;);
var SAFE_INSERT_IN_TOKENS = [&quot;text&quot;, &quot;paren.rparen&quot;, &quot;rparen&quot;, &quot;paren&quot;, &quot;punctuation.operator&quot;];
var SAFE_INSERT_BEFORE_TOKENS = [&quot;text&quot;, &quot;paren.rparen&quot;, &quot;rparen&quot;, &quot;paren&quot;, &quot;punctuation.operator&quot;, &quot;comment&quot;];
var context;
var contextCache = {};
var defaultQuotes = { &#039;&quot;&#039;: &#039;&quot;&#039;, &quot;&#039;&quot;: &quot;&#039;&quot; };
var initContext = function (editor) {
    var id = -1;
    if (editor.multiSelect) {
        id = editor.selection.index;
        if (contextCache.rangeCount != editor.multiSelect.rangeCount)
            contextCache = { rangeCount: editor.multiSelect.rangeCount };
    }
    if (contextCache[id])
        return context = contextCache[id];
    context = contextCache[id] = {
        autoInsertedBrackets: 0,
        autoInsertedRow: -1,
        autoInsertedLineEnd: &quot;&quot;,
        maybeInsertedBrackets: 0,
        maybeInsertedRow: -1,
        maybeInsertedLineStart: &quot;&quot;,
        maybeInsertedLineEnd: &quot;&quot;
    };
};
var getWrapped = function (selection, selected, opening, closing) {
    var rowDiff = selection.end.row - selection.start.row;
    return {
        text: opening + selected + closing,
        selection: [
            0,
            selection.start.column + 1,
            rowDiff,
            selection.end.column + (rowDiff ? 0 : 1)
        ]
    };
};
var CstyleBehaviour = function (options) {
    this.add(&quot;braces&quot;, &quot;insertion&quot;, function (state, action, editor, session, text) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (text == &#039;{&#039;) {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== &quot;&quot; &amp;&amp; selected !== &quot;{&quot; &amp;&amp; editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, &#039;{&#039;, &#039;}&#039;);
            }
            else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode || options &amp;&amp; options.braces) {
                    CstyleBehaviour.recordAutoInsert(editor, session, &quot;}&quot;);
                    return {
                        text: &#039;{}&#039;,
                        selection: [1, 1]
                    };
                }
                else {
                    CstyleBehaviour.recordMaybeInsert(editor, session, &quot;{&quot;);
                    return {
                        text: &#039;{&#039;,
                        selection: [1, 1]
                    };
                }
            }
        }
        else if (text == &#039;}&#039;) {
            initContext(editor);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == &#039;}&#039;) {
                var matching = session.$findOpeningBracket(&#039;}&#039;, { column: cursor.column + 1, row: cursor.row });
                if (matching !== null &amp;&amp; CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: &#039;&#039;,
                        selection: [1, 1]
                    };
                }
            }
        }
        else if (text == &quot;\n&quot; || text == &quot;\r\n&quot;) {
            initContext(editor);
            var closing = &quot;&quot;;
            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
                closing = lang.stringRepeat(&quot;}&quot;, context.maybeInsertedBrackets);
                CstyleBehaviour.clearMaybeInsertedClosing();
            }
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar === &#039;}&#039;) {
                var openBracePos = session.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 }, &#039;}&#039;);
                if (!openBracePos)
                    return null;
                var next_indent = this.$getIndent(session.getLine(openBracePos.row));
            }
            else if (closing) {
                var next_indent = this.$getIndent(line);
            }
            else {
                CstyleBehaviour.clearMaybeInsertedClosing();
                return;
            }
            var indent = next_indent + session.getTabString();
            return {
                text: &#039;\n&#039; + indent + &#039;\n&#039; + next_indent + closing,
                selection: [1, indent.length, 1, indent.length]
            };
        }
        else {
            CstyleBehaviour.clearMaybeInsertedClosing();
        }
    });
    this.add(&quot;braces&quot;, &quot;deletion&quot;, function (state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() &amp;&amp; selected == &#039;{&#039;) {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.end.column, range.end.column + 1);
            if (rightChar == &#039;}&#039;) {
                range.end.column++;
                return range;
            }
            else {
                context.maybeInsertedBrackets--;
            }
        }
    });
    this.add(&quot;parens&quot;, &quot;insertion&quot;, function (state, action, editor, session, text) {
        if (text == &#039;(&#039;) {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== &quot;&quot; &amp;&amp; editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, &#039;(&#039;, &#039;)&#039;);
            }
            else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                CstyleBehaviour.recordAutoInsert(editor, session, &quot;)&quot;);
                return {
                    text: &#039;()&#039;,
                    selection: [1, 1]
                };
            }
        }
        else if (text == &#039;)&#039;) {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == &#039;)&#039;) {
                var matching = session.$findOpeningBracket(&#039;)&#039;, { column: cursor.column + 1, row: cursor.row });
                if (matching !== null &amp;&amp; CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: &#039;&#039;,
                        selection: [1, 1]
                    };
                }
            }
        }
    });
    this.add(&quot;parens&quot;, &quot;deletion&quot;, function (state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() &amp;&amp; selected == &#039;(&#039;) {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == &#039;)&#039;) {
                range.end.column++;
                return range;
            }
        }
    });
    this.add(&quot;brackets&quot;, &quot;insertion&quot;, function (state, action, editor, session, text) {
        if (text == &#039;[&#039;) {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== &quot;&quot; &amp;&amp; editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, &#039;[&#039;, &#039;]&#039;);
            }
            else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                CstyleBehaviour.recordAutoInsert(editor, session, &quot;]&quot;);
                return {
                    text: &#039;[]&#039;,
                    selection: [1, 1]
                };
            }
        }
        else if (text == &#039;]&#039;) {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == &#039;]&#039;) {
                var matching = session.$findOpeningBracket(&#039;]&#039;, { column: cursor.column + 1, row: cursor.row });
                if (matching !== null &amp;&amp; CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: &#039;&#039;,
                        selection: [1, 1]
                    };
                }
            }
        }
    });
    this.add(&quot;brackets&quot;, &quot;deletion&quot;, function (state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() &amp;&amp; selected == &#039;[&#039;) {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == &#039;]&#039;) {
                range.end.column++;
                return range;
            }
        }
    });
    this.add(&quot;string_dquotes&quot;, &quot;insertion&quot;, function (state, action, editor, session, text) {
        var quotes = session.$mode.$quotes || defaultQuotes;
        if (text.length == 1 &amp;&amp; quotes[text]) {
            if (this.lineCommentStart &amp;&amp; this.lineCommentStart.indexOf(text) != -1)
                return;
            initContext(editor);
            var quote = text;
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== &quot;&quot; &amp;&amp; (selected.length != 1 || !quotes[selected]) &amp;&amp; editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, quote, quote);
            }
            else if (!selected) {
                var cursor = editor.getCursorPosition();
                var line = session.doc.getLine(cursor.row);
                var leftChar = line.substring(cursor.column - 1, cursor.column);
                var rightChar = line.substring(cursor.column, cursor.column + 1);
                var token = session.getTokenAt(cursor.row, cursor.column);
                var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
                if (leftChar == &quot;\\&quot; &amp;&amp; token &amp;&amp; /escape/.test(token.type))
                    return null;
                var stringBefore = token &amp;&amp; /string|escape/.test(token.type);
                var stringAfter = !rightToken || /string|escape/.test(rightToken.type);
                var pair;
                if (rightChar == quote) {
                    pair = stringBefore !== stringAfter;
                    if (pair &amp;&amp; /string\.end/.test(rightToken.type))
                        pair = false;
                }
                else {
                    if (stringBefore &amp;&amp; !stringAfter)
                        return null; // wrap string with different quote
                    if (stringBefore &amp;&amp; stringAfter)
                        return null; // do not pair quotes inside strings
                    var wordRe = session.$mode.tokenRe;
                    wordRe.lastIndex = 0;
                    var isWordBefore = wordRe.test(leftChar);
                    wordRe.lastIndex = 0;
                    var isWordAfter = wordRe.test(leftChar);
                    if (isWordBefore || isWordAfter)
                        return null; // before or after alphanumeric
                    if (rightChar &amp;&amp; !/[\s;,.})\]\\]/.test(rightChar))
                        return null; // there is rightChar and it isn&#039;t closing
                    var charBefore = line[cursor.column - 2];
                    if (leftChar == quote &amp;&amp; (charBefore == quote || wordRe.test(charBefore)))
                        return null;
                    pair = true;
                }
                return {
                    text: pair ? quote + quote : &quot;&quot;,
                    selection: [1, 1]
                };
            }
        }
    });
    this.add(&quot;string_dquotes&quot;, &quot;deletion&quot;, function (state, action, editor, session, range) {
        var quotes = session.$mode.$quotes || defaultQuotes;
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() &amp;&amp; quotes.hasOwnProperty(selected)) {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == selected) {
                range.end.column++;
                return range;
            }
        }
    });
};
CstyleBehaviour.isSaneInsertion = function (editor, session) {
    var cursor = editor.getCursorPosition();
    var iterator = new TokenIterator(session, cursor.row, cursor.column);
    if (!this.$matchTokenType(iterator.getCurrentToken() || &quot;text&quot;, SAFE_INSERT_IN_TOKENS)) {
        if (/[)}\]]/.test(editor.session.getLine(cursor.row)[cursor.column]))
            return true;
        var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
        if (!this.$matchTokenType(iterator2.getCurrentToken() || &quot;text&quot;, SAFE_INSERT_IN_TOKENS))
            return false;
    }
    iterator.stepForward();
    return iterator.getCurrentTokenRow() !== cursor.row ||
        this.$matchTokenType(iterator.getCurrentToken() || &quot;text&quot;, SAFE_INSERT_BEFORE_TOKENS);
};
CstyleBehaviour.$matchTokenType = function (token, types) {
    return types.indexOf(token.type || token) &gt; -1;
};
CstyleBehaviour.recordAutoInsert = function (editor, session, bracket) {
    var cursor = editor.getCursorPosition();
    var line = session.doc.getLine(cursor.row);
    if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0]))
        context.autoInsertedBrackets = 0;
    context.autoInsertedRow = cursor.row;
    context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
    context.autoInsertedBrackets++;
};
CstyleBehaviour.recordMaybeInsert = function (editor, session, bracket) {
    var cursor = editor.getCursorPosition();
    var line = session.doc.getLine(cursor.row);
    if (!this.isMaybeInsertedClosing(cursor, line))
        context.maybeInsertedBrackets = 0;
    context.maybeInsertedRow = cursor.row;
    context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
    context.maybeInsertedLineEnd = line.substr(cursor.column);
    context.maybeInsertedBrackets++;
};
CstyleBehaviour.isAutoInsertedClosing = function (cursor, line, bracket) {
    return context.autoInsertedBrackets &gt; 0 &amp;&amp;
        cursor.row === context.autoInsertedRow &amp;&amp;
        bracket === context.autoInsertedLineEnd[0] &amp;&amp;
        line.substr(cursor.column) === context.autoInsertedLineEnd;
};
CstyleBehaviour.isMaybeInsertedClosing = function (cursor, line) {
    return context.maybeInsertedBrackets &gt; 0 &amp;&amp;
        cursor.row === context.maybeInsertedRow &amp;&amp;
        line.substr(cursor.column) === context.maybeInsertedLineEnd &amp;&amp;
        line.substr(0, cursor.column) == context.maybeInsertedLineStart;
};
CstyleBehaviour.popAutoInsertedClosing = function () {
    context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
    context.autoInsertedBrackets--;
};
CstyleBehaviour.clearMaybeInsertedClosing = function () {
    if (context) {
        context.maybeInsertedBrackets = 0;
        context.maybeInsertedRow = -1;
    }
};
oop.inherits(CstyleBehaviour, Behaviour);
exports.CstyleBehaviour = CstyleBehaviour;

});

define(&quot;ace/unicode&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;], function(require, exports, module){&quot;use strict&quot;;
var wordChars = [48, 9, 8, 25, 5, 0, 2, 25, 48, 0, 11, 0, 5, 0, 6, 22, 2, 30, 2, 457, 5, 11, 15, 4, 8, 0, 2, 0, 18, 116, 2, 1, 3, 3, 9, 0, 2, 2, 2, 0, 2, 19, 2, 82, 2, 138, 2, 4, 3, 155, 12, 37, 3, 0, 8, 38, 10, 44, 2, 0, 2, 1, 2, 1, 2, 0, 9, 26, 6, 2, 30, 10, 7, 61, 2, 9, 5, 101, 2, 7, 3, 9, 2, 18, 3, 0, 17, 58, 3, 100, 15, 53, 5, 0, 6, 45, 211, 57, 3, 18, 2, 5, 3, 11, 3, 9, 2, 1, 7, 6, 2, 2, 2, 7, 3, 1, 3, 21, 2, 6, 2, 0, 4, 3, 3, 8, 3, 1, 3, 3, 9, 0, 5, 1, 2, 4, 3, 11, 16, 2, 2, 5, 5, 1, 3, 21, 2, 6, 2, 1, 2, 1, 2, 1, 3, 0, 2, 4, 5, 1, 3, 2, 4, 0, 8, 3, 2, 0, 8, 15, 12, 2, 2, 8, 2, 2, 2, 21, 2, 6, 2, 1, 2, 4, 3, 9, 2, 2, 2, 2, 3, 0, 16, 3, 3, 9, 18, 2, 2, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 3, 8, 3, 1, 3, 2, 9, 1, 5, 1, 2, 4, 3, 9, 2, 0, 17, 1, 2, 5, 4, 2, 2, 3, 4, 1, 2, 0, 2, 1, 4, 1, 4, 2, 4, 11, 5, 4, 4, 2, 2, 3, 3, 0, 7, 0, 15, 9, 18, 2, 2, 7, 2, 2, 2, 22, 2, 9, 2, 4, 4, 7, 2, 2, 2, 3, 8, 1, 2, 1, 7, 3, 3, 9, 19, 1, 2, 7, 2, 2, 2, 22, 2, 9, 2, 4, 3, 8, 2, 2, 2, 3, 8, 1, 8, 0, 2, 3, 3, 9, 19, 1, 2, 7, 2, 2, 2, 22, 2, 15, 4, 7, 2, 2, 2, 3, 10, 0, 9, 3, 3, 9, 11, 5, 3, 1, 2, 17, 4, 23, 2, 8, 2, 0, 3, 6, 4, 0, 5, 5, 2, 0, 2, 7, 19, 1, 14, 57, 6, 14, 2, 9, 40, 1, 2, 0, 3, 1, 2, 0, 3, 0, 7, 3, 2, 6, 2, 2, 2, 0, 2, 0, 3, 1, 2, 12, 2, 2, 3, 4, 2, 0, 2, 5, 3, 9, 3, 1, 35, 0, 24, 1, 7, 9, 12, 0, 2, 0, 2, 0, 5, 9, 2, 35, 5, 19, 2, 5, 5, 7, 2, 35, 10, 0, 58, 73, 7, 77, 3, 37, 11, 42, 2, 0, 4, 328, 2, 3, 3, 6, 2, 0, 2, 3, 3, 40, 2, 3, 3, 32, 2, 3, 3, 6, 2, 0, 2, 3, 3, 14, 2, 56, 2, 3, 3, 66, 5, 0, 33, 15, 17, 84, 13, 619, 3, 16, 2, 25, 6, 74, 22, 12, 2, 6, 12, 20, 12, 19, 13, 12, 2, 2, 2, 1, 13, 51, 3, 29, 4, 0, 5, 1, 3, 9, 34, 2, 3, 9, 7, 87, 9, 42, 6, 69, 11, 28, 4, 11, 5, 11, 11, 39, 3, 4, 12, 43, 5, 25, 7, 10, 38, 27, 5, 62, 2, 28, 3, 10, 7, 9, 14, 0, 89, 75, 5, 9, 18, 8, 13, 42, 4, 11, 71, 55, 9, 9, 4, 48, 83, 2, 2, 30, 14, 230, 23, 280, 3, 5, 3, 37, 3, 5, 3, 7, 2, 0, 2, 0, 2, 0, 2, 30, 3, 52, 2, 6, 2, 0, 4, 2, 2, 6, 4, 3, 3, 5, 5, 12, 6, 2, 2, 6, 67, 1, 20, 0, 29, 0, 14, 0, 17, 4, 60, 12, 5, 0, 4, 11, 18, 0, 5, 0, 3, 9, 2, 0, 4, 4, 7, 0, 2, 0, 2, 0, 2, 3, 2, 10, 3, 3, 6, 4, 5, 0, 53, 1, 2684, 46, 2, 46, 2, 132, 7, 6, 15, 37, 11, 53, 10, 0, 17, 22, 10, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 31, 48, 0, 470, 1, 36, 5, 2, 4, 6, 1, 5, 85, 3, 1, 3, 2, 2, 89, 2, 3, 6, 40, 4, 93, 18, 23, 57, 15, 513, 6581, 75, 20939, 53, 1164, 68, 45, 3, 268, 4, 27, 21, 31, 3, 13, 13, 1, 2, 24, 9, 69, 11, 1, 38, 8, 3, 102, 3, 1, 111, 44, 25, 51, 13, 68, 12, 9, 7, 23, 4, 0, 5, 45, 3, 35, 13, 28, 4, 64, 15, 10, 39, 54, 10, 13, 3, 9, 7, 22, 4, 1, 5, 66, 25, 2, 227, 42, 2, 1, 3, 9, 7, 11171, 13, 22, 5, 48, 8453, 301, 3, 61, 3, 105, 39, 6, 13, 4, 6, 11, 2, 12, 2, 4, 2, 0, 2, 1, 2, 1, 2, 107, 34, 362, 19, 63, 3, 53, 41, 11, 5, 15, 17, 6, 13, 1, 25, 2, 33, 4, 2, 134, 20, 9, 8, 25, 5, 0, 2, 25, 12, 88, 4, 5, 3, 5, 3, 5, 3, 2];
var code = 0;
var str = [];
for (var i = 0; i &lt; wordChars.length; i += 2) {
    str.push(code += wordChars[i]);
    if (wordChars[i + 1])
        str.push(45, code += wordChars[i + 1]);
}
exports.wordChars = String.fromCharCode.apply(null, str);

});

define(&quot;ace/mode/text&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/config&quot;,&quot;ace/tokenizer&quot;,&quot;ace/mode/text_highlight_rules&quot;,&quot;ace/mode/behaviour/cstyle&quot;,&quot;ace/unicode&quot;,&quot;ace/lib/lang&quot;,&quot;ace/token_iterator&quot;,&quot;ace/range&quot;], function(require, exports, module){&quot;use strict&quot;;
var config = require(&quot;../config&quot;);
var Tokenizer = require(&quot;../tokenizer&quot;).Tokenizer;
var TextHighlightRules = require(&quot;./text_highlight_rules&quot;).TextHighlightRules;
var CstyleBehaviour = require(&quot;./behaviour/cstyle&quot;).CstyleBehaviour;
var unicode = require(&quot;../unicode&quot;);
var lang = require(&quot;../lib/lang&quot;);
var TokenIterator = require(&quot;../token_iterator&quot;).TokenIterator;
var Range = require(&quot;../range&quot;).Range;
var Mode = function () {
    this.HighlightRules = TextHighlightRules;
};
(function () {
    this.$defaultBehaviour = new CstyleBehaviour();
    this.tokenRe = new RegExp(&quot;^[&quot; + unicode.wordChars + &quot;\\$_]+&quot;, &quot;g&quot;);
    this.nonTokenRe = new RegExp(&quot;^(?:[^&quot; + unicode.wordChars + &quot;\\$_]|\\s])+&quot;, &quot;g&quot;);
    this.getTokenizer = function () {
        if (!this.$tokenizer) {
            this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);
            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
        }
        return this.$tokenizer;
    };
    this.lineCommentStart = &quot;&quot;;
    this.blockComment = &quot;&quot;;
    this.toggleCommentLines = function (state, session, startRow, endRow) {
        var doc = session.doc;
        var ignoreBlankLines = true;
        var shouldRemove = true;
        var minIndent = Infinity;
        var tabSize = session.getTabSize();
        var insertAtTabStop = false;
        if (!this.lineCommentStart) {
            if (!this.blockComment)
                return false;
            var lineCommentStart = this.blockComment.start;
            var lineCommentEnd = this.blockComment.end;
            var regexpStart = new RegExp(&quot;^(\\s*)(?:&quot; + lang.escapeRegExp(lineCommentStart) + &quot;)&quot;);
            var regexpEnd = new RegExp(&quot;(?:&quot; + lang.escapeRegExp(lineCommentEnd) + &quot;)\\s*$&quot;);
            var comment = function (line, i) {
                if (testRemove(line, i))
                    return;
                if (!ignoreBlankLines || /\S/.test(line)) {
                    doc.insertInLine({ row: i, column: line.length }, lineCommentEnd);
                    doc.insertInLine({ row: i, column: minIndent }, lineCommentStart);
                }
            };
            var uncomment = function (line, i) {
                var m;
                if (m = line.match(regexpEnd))
                    doc.removeInLine(i, line.length - m[0].length, line.length);
                if (m = line.match(regexpStart))
                    doc.removeInLine(i, m[1].length, m[0].length);
            };
            var testRemove = function (line, row) {
                if (regexpStart.test(line))
                    return true;
                var tokens = session.getTokens(row);
                for (var i = 0; i &lt; tokens.length; i++) {
                    if (tokens[i].type === &quot;comment&quot;)
                        return true;
                }
            };
        }
        else {
            if (Array.isArray(this.lineCommentStart)) {
                var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join(&quot;|&quot;);
                var lineCommentStart = this.lineCommentStart[0];
            }
            else {
                var regexpStart = lang.escapeRegExp(this.lineCommentStart);
                var lineCommentStart = this.lineCommentStart;
            }
            regexpStart = new RegExp(&quot;^(\\s*)(?:&quot; + regexpStart + &quot;) ?&quot;);
            insertAtTabStop = session.getUseSoftTabs();
            var uncomment = function (line, i) {
                var m = line.match(regexpStart);
                if (!m)
                    return;
                var start = m[1].length, end = m[0].length;
                if (!shouldInsertSpace(line, start, end) &amp;&amp; m[0][end - 1] == &quot; &quot;)
                    end--;
                doc.removeInLine(i, start, end);
            };
            var commentWithSpace = lineCommentStart + &quot; &quot;;
            var comment = function (line, i) {
                if (!ignoreBlankLines || /\S/.test(line)) {
                    if (shouldInsertSpace(line, minIndent, minIndent))
                        doc.insertInLine({ row: i, column: minIndent }, commentWithSpace);
                    else
                        doc.insertInLine({ row: i, column: minIndent }, lineCommentStart);
                }
            };
            var testRemove = function (line, i) {
                return regexpStart.test(line);
            };
            var shouldInsertSpace = function (line, before, after) {
                var spaces = 0;
                while (before-- &amp;&amp; line.charAt(before) == &quot; &quot;)
                    spaces++;
                if (spaces % tabSize != 0)
                    return false;
                var spaces = 0;
                while (line.charAt(after++) == &quot; &quot;)
                    spaces++;
                if (tabSize &gt; 2)
                    return spaces % tabSize != tabSize - 1;
                else
                    return spaces % tabSize == 0;
            };
        }
        function iter(fun) {
            for (var i = startRow; i &lt;= endRow; i++)
                fun(doc.getLine(i), i);
        }
        var minEmptyLength = Infinity;
        iter(function (line, i) {
            var indent = line.search(/\S/);
            if (indent !== -1) {
                if (indent &lt; minIndent)
                    minIndent = indent;
                if (shouldRemove &amp;&amp; !testRemove(line, i))
                    shouldRemove = false;
            }
            else if (minEmptyLength &gt; line.length) {
                minEmptyLength = line.length;
            }
        });
        if (minIndent == Infinity) {
            minIndent = minEmptyLength;
            ignoreBlankLines = false;
            shouldRemove = false;
        }
        if (insertAtTabStop &amp;&amp; minIndent % tabSize != 0)
            minIndent = Math.floor(minIndent / tabSize) * tabSize;
        iter(shouldRemove ? uncomment : comment);
    };
    this.toggleBlockComment = function (state, session, range, cursor) {
        var comment = this.blockComment;
        if (!comment)
            return;
        if (!comment.start &amp;&amp; comment[0])
            comment = comment[0];
        var iterator = new TokenIterator(session, cursor.row, cursor.column);
        var token = iterator.getCurrentToken();
        var sel = session.selection;
        var initialRange = session.selection.toOrientedRange();
        var startRow, colDiff;
        if (token &amp;&amp; /comment/.test(token.type)) {
            var startRange, endRange;
            while (token &amp;&amp; /comment/.test(token.type)) {
                var i = token.value.indexOf(comment.start);
                if (i != -1) {
                    var row = iterator.getCurrentTokenRow();
                    var column = iterator.getCurrentTokenColumn() + i;
                    startRange = new Range(row, column, row, column + comment.start.length);
                    break;
                }
                token = iterator.stepBackward();
            }
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            while (token &amp;&amp; /comment/.test(token.type)) {
                var i = token.value.indexOf(comment.end);
                if (i != -1) {
                    var row = iterator.getCurrentTokenRow();
                    var column = iterator.getCurrentTokenColumn() + i;
                    endRange = new Range(row, column, row, column + comment.end.length);
                    break;
                }
                token = iterator.stepForward();
            }
            if (endRange)
                session.remove(endRange);
            if (startRange) {
                session.remove(startRange);
                startRow = startRange.start.row;
                colDiff = -comment.start.length;
            }
        }
        else {
            colDiff = comment.start.length;
            startRow = range.start.row;
            session.insert(range.end, comment.end);
            session.insert(range.start, comment.start);
        }
        if (initialRange.start.row == startRow)
            initialRange.start.column += colDiff;
        if (initialRange.end.row == startRow)
            initialRange.end.column += colDiff;
        session.selection.fromOrientedRange(initialRange);
    };
    this.getNextLineIndent = function (state, line, tab) {
        return this.$getIndent(line);
    };
    this.checkOutdent = function (state, line, input) {
        return false;
    };
    this.autoOutdent = function (state, doc, row) {
    };
    this.$getIndent = function (line) {
        return line.match(/^\s*/)[0];
    };
    this.createWorker = function (session) {
        return null;
    };
    this.createModeDelegates = function (mapping) {
        this.$embeds = [];
        this.$modes = {};
        for (var i in mapping) {
            if (mapping[i]) {
                var Mode = mapping[i];
                var id = Mode.prototype.$id;
                var mode = config.$modes[id];
                if (!mode)
                    config.$modes[id] = mode = new Mode();
                if (!config.$modes[i])
                    config.$modes[i] = mode;
                this.$embeds.push(i);
                this.$modes[i] = mode;
            }
        }
        var delegations = [&quot;toggleBlockComment&quot;, &quot;toggleCommentLines&quot;, &quot;getNextLineIndent&quot;,
            &quot;checkOutdent&quot;, &quot;autoOutdent&quot;, &quot;transformAction&quot;, &quot;getCompletions&quot;];
        for (var i = 0; i &lt; delegations.length; i++) {
            (function (scope) {
                var functionName = delegations[i];
                var defaultHandler = scope[functionName];
                scope[delegations[i]] = function () {
                    return this.$delegator(functionName, arguments, defaultHandler);
                };
            }(this));
        }
    };
    this.$delegator = function (method, args, defaultHandler) {
        var state = args[0] || &quot;start&quot;;
        if (typeof state != &quot;string&quot;) {
            if (Array.isArray(state[2])) {
                var language = state[2][state[2].length - 1];
                var mode = this.$modes[language];
                if (mode)
                    return mode[method].apply(mode, [state[1]].concat([].slice.call(args, 1)));
            }
            state = state[0] || &quot;start&quot;;
        }
        for (var i = 0; i &lt; this.$embeds.length; i++) {
            if (!this.$modes[this.$embeds[i]])
                continue;
            var split = state.split(this.$embeds[i]);
            if (!split[0] &amp;&amp; split[1]) {
                args[0] = split[1];
                var mode = this.$modes[this.$embeds[i]];
                return mode[method].apply(mode, args);
            }
        }
        var ret = defaultHandler.apply(this, args);
        return defaultHandler ? ret : undefined;
    };
    this.transformAction = function (state, action, editor, session, param) {
        if (this.$behaviour) {
            var behaviours = this.$behaviour.getBehaviours();
            for (var key in behaviours) {
                if (behaviours[key][action]) {
                    var ret = behaviours[key][action].apply(this, arguments);
                    if (ret) {
                        return ret;
                    }
                }
            }
        }
    };
    this.getKeywords = function (append) {
        if (!this.completionKeywords) {
            var rules = this.$tokenizer.rules;
            var completionKeywords = [];
            for (var rule in rules) {
                var ruleItr = rules[rule];
                for (var r = 0, l = ruleItr.length; r &lt; l; r++) {
                    if (typeof ruleItr[r].token === &quot;string&quot;) {
                        if (/keyword|support|storage/.test(ruleItr[r].token))
                            completionKeywords.push(ruleItr[r].regex);
                    }
                    else if (typeof ruleItr[r].token === &quot;object&quot;) {
                        for (var a = 0, aLength = ruleItr[r].token.length; a &lt; aLength; a++) {
                            if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
                                var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
                                completionKeywords.push(rule.substr(1, rule.length - 2));
                            }
                        }
                    }
                }
            }
            this.completionKeywords = completionKeywords;
        }
        if (!append)
            return this.$keywordList;
        return completionKeywords.concat(this.$keywordList || []);
    };
    this.$createKeywordList = function () {
        if (!this.$highlightRules)
            this.getTokenizer();
        return this.$keywordList = this.$highlightRules.$keywordList || [];
    };
    this.getCompletions = function (state, session, pos, prefix) {
        var keywords = this.$keywordList || this.$createKeywordList();
        return keywords.map(function (word) {
            return {
                name: word,
                value: word,
                score: 0,
                meta: &quot;keyword&quot;
            };
        });
    };
    this.$id = &quot;ace/mode/text&quot;;
}).call(Mode.prototype);
exports.Mode = Mode;

});

define(&quot;ace/apply_delta&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;], function(require, exports, module){&quot;use strict&quot;;
function throwDeltaError(delta, errorText) {
    console.log(&quot;Invalid Delta:&quot;, delta);
    throw &quot;Invalid Delta: &quot; + errorText;
}
function positionInDocument(docLines, position) {
    return position.row &gt;= 0 &amp;&amp; position.row &lt; docLines.length &amp;&amp;
        position.column &gt;= 0 &amp;&amp; position.column &lt;= docLines[position.row].length;
}
function validateDelta(docLines, delta) {
    if (delta.action != &quot;insert&quot; &amp;&amp; delta.action != &quot;remove&quot;)
        throwDeltaError(delta, &quot;delta.action must be &#039;insert&#039; or &#039;remove&#039;&quot;);
    if (!(delta.lines instanceof Array))
        throwDeltaError(delta, &quot;delta.lines must be an Array&quot;);
    if (!delta.start || !delta.end)
        throwDeltaError(delta, &quot;delta.start/end must be an present&quot;);
    var start = delta.start;
    if (!positionInDocument(docLines, delta.start))
        throwDeltaError(delta, &quot;delta.start must be contained in document&quot;);
    var end = delta.end;
    if (delta.action == &quot;remove&quot; &amp;&amp; !positionInDocument(docLines, end))
        throwDeltaError(delta, &quot;delta.end must contained in document for &#039;remove&#039; actions&quot;);
    var numRangeRows = end.row - start.row;
    var numRangeLastLineChars = (end.column - (numRangeRows == 0 ? start.column : 0));
    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars)
        throwDeltaError(delta, &quot;delta.range must match delta lines&quot;);
}
exports.applyDelta = function (docLines, delta, doNotValidate) {
    var row = delta.start.row;
    var startColumn = delta.start.column;
    var line = docLines[row] || &quot;&quot;;
    switch (delta.action) {
        case &quot;insert&quot;:
            var lines = delta.lines;
            if (lines.length === 1) {
                docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
            }
            else {
                var args = [row, 1].concat(delta.lines);
                docLines.splice.apply(docLines, args);
                docLines[row] = line.substring(0, startColumn) + docLines[row];
                docLines[row + delta.lines.length - 1] += line.substring(startColumn);
            }
            break;
        case &quot;remove&quot;:
            var endColumn = delta.end.column;
            var endRow = delta.end.row;
            if (row === endRow) {
                docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
            }
            else {
                docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));
            }
            break;
    }
};

});

define(&quot;ace/anchor&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/event_emitter&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;./lib/oop&quot;);
var EventEmitter = require(&quot;./lib/event_emitter&quot;).EventEmitter;
var Anchor = exports.Anchor = function (doc, row, column) {
    this.$onChange = this.onChange.bind(this);
    this.attach(doc);
    if (typeof column == &quot;undefined&quot;)
        this.setPosition(row.row, row.column);
    else
        this.setPosition(row, column);
};
(function () {
    oop.implement(this, EventEmitter);
    this.getPosition = function () {
        return this.$clipPositionToDocument(this.row, this.column);
    };
    this.getDocument = function () {
        return this.document;
    };
    this.$insertRight = false;
    this.onChange = function (delta) {
        if (delta.start.row == delta.end.row &amp;&amp; delta.start.row != this.row)
            return;
        if (delta.start.row &gt; this.row)
            return;
        var point = $getTransformedPoint(delta, { row: this.row, column: this.column }, this.$insertRight);
        this.setPosition(point.row, point.column, true);
    };
    function $pointsInOrder(point1, point2, equalPointsInOrder) {
        var bColIsAfter = equalPointsInOrder ? point1.column &lt;= point2.column : point1.column &lt; point2.column;
        return (point1.row &lt; point2.row) || (point1.row == point2.row &amp;&amp; bColIsAfter);
    }
    function $getTransformedPoint(delta, point, moveIfEqual) {
        var deltaIsInsert = delta.action == &quot;insert&quot;;
        var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);
        var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
        var deltaStart = delta.start;
        var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.
        if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
            return {
                row: point.row,
                column: point.column
            };
        }
        if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
            return {
                row: point.row + deltaRowShift,
                column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
            };
        }
        return {
            row: deltaStart.row,
            column: deltaStart.column
        };
    }
    this.setPosition = function (row, column, noClip) {
        var pos;
        if (noClip) {
            pos = {
                row: row,
                column: column
            };
        }
        else {
            pos = this.$clipPositionToDocument(row, column);
        }
        if (this.row == pos.row &amp;&amp; this.column == pos.column)
            return;
        var old = {
            row: this.row,
            column: this.column
        };
        this.row = pos.row;
        this.column = pos.column;
        this._signal(&quot;change&quot;, {
            old: old,
            value: pos
        });
    };
    this.detach = function () {
        this.document.off(&quot;change&quot;, this.$onChange);
    };
    this.attach = function (doc) {
        this.document = doc || this.document;
        this.document.on(&quot;change&quot;, this.$onChange);
    };
    this.$clipPositionToDocument = function (row, column) {
        var pos = {};
        if (row &gt;= this.document.getLength()) {
            pos.row = Math.max(0, this.document.getLength() - 1);
            pos.column = this.document.getLine(pos.row).length;
        }
        else if (row &lt; 0) {
            pos.row = 0;
            pos.column = 0;
        }
        else {
            pos.row = row;
            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
        }
        if (column &lt; 0)
            pos.column = 0;
        return pos;
    };
}).call(Anchor.prototype);

});

define(&quot;ace/document&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/apply_delta&quot;,&quot;ace/lib/event_emitter&quot;,&quot;ace/range&quot;,&quot;ace/anchor&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;./lib/oop&quot;);
var applyDelta = require(&quot;./apply_delta&quot;).applyDelta;
var EventEmitter = require(&quot;./lib/event_emitter&quot;).EventEmitter;
var Range = require(&quot;./range&quot;).Range;
var Anchor = require(&quot;./anchor&quot;).Anchor;
var Document = function (textOrLines) {
    this.$lines = [&quot;&quot;];
    if (textOrLines.length === 0) {
        this.$lines = [&quot;&quot;];
    }
    else if (Array.isArray(textOrLines)) {
        this.insertMergedLines({ row: 0, column: 0 }, textOrLines);
    }
    else {
        this.insert({ row: 0, column: 0 }, textOrLines);
    }
};
(function () {
    oop.implement(this, EventEmitter);
    this.setValue = function (text) {
        var len = this.getLength() - 1;
        this.remove(new Range(0, 0, len, this.getLine(len).length));
        this.insert({ row: 0, column: 0 }, text || &quot;&quot;);
    };
    this.getValue = function () {
        return this.getAllLines().join(this.getNewLineCharacter());
    };
    this.createAnchor = function (row, column) {
        return new Anchor(this, row, column);
    };
    if (&quot;aaa&quot;.split(/a/).length === 0) {
        this.$split = function (text) {
            return text.replace(/\r\n|\r/g, &quot;\n&quot;).split(&quot;\n&quot;);
        };
    }
    else {
        this.$split = function (text) {
            return text.split(/\r\n|\r|\n/);
        };
    }
    this.$detectNewLine = function (text) {
        var match = text.match(/^.*?(\r\n|\r|\n)/m);
        this.$autoNewLine = match ? match[1] : &quot;\n&quot;;
        this._signal(&quot;changeNewLineMode&quot;);
    };
    this.getNewLineCharacter = function () {
        switch (this.$newLineMode) {
            case &quot;windows&quot;:
                return &quot;\r\n&quot;;
            case &quot;unix&quot;:
                return &quot;\n&quot;;
            default:
                return this.$autoNewLine || &quot;\n&quot;;
        }
    };
    this.$autoNewLine = &quot;&quot;;
    this.$newLineMode = &quot;auto&quot;;
    this.setNewLineMode = function (newLineMode) {
        if (this.$newLineMode === newLineMode)
            return;
        this.$newLineMode = newLineMode;
        this._signal(&quot;changeNewLineMode&quot;);
    };
    this.getNewLineMode = function () {
        return this.$newLineMode;
    };
    this.isNewLine = function (text) {
        return (text == &quot;\r\n&quot; || text == &quot;\r&quot; || text == &quot;\n&quot;);
    };
    this.getLine = function (row) {
        return this.$lines[row] || &quot;&quot;;
    };
    this.getLines = function (firstRow, lastRow) {
        return this.$lines.slice(firstRow, lastRow + 1);
    };
    this.getAllLines = function () {
        return this.getLines(0, this.getLength());
    };
    this.getLength = function () {
        return this.$lines.length;
    };
    this.getTextRange = function (range) {
        return this.getLinesForRange(range).join(this.getNewLineCharacter());
    };
    this.getLinesForRange = function (range) {
        var lines;
        if (range.start.row === range.end.row) {
            lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
        }
        else {
            lines = this.getLines(range.start.row, range.end.row);
            lines[0] = (lines[0] || &quot;&quot;).substring(range.start.column);
            var l = lines.length - 1;
            if (range.end.row - range.start.row == l)
                lines[l] = lines[l].substring(0, range.end.column);
        }
        return lines;
    };
    this.insertLines = function (row, lines) {
        console.warn(&quot;Use of document.insertLines is deprecated. Use the insertFullLines method instead.&quot;);
        return this.insertFullLines(row, lines);
    };
    this.removeLines = function (firstRow, lastRow) {
        console.warn(&quot;Use of document.removeLines is deprecated. Use the removeFullLines method instead.&quot;);
        return this.removeFullLines(firstRow, lastRow);
    };
    this.insertNewLine = function (position) {
        console.warn(&quot;Use of document.insertNewLine is deprecated. Use insertMergedLines(position, [&#039;&#039;, &#039;&#039;]) instead.&quot;);
        return this.insertMergedLines(position, [&quot;&quot;, &quot;&quot;]);
    };
    this.insert = function (position, text) {
        if (this.getLength() &lt;= 1)
            this.$detectNewLine(text);
        return this.insertMergedLines(position, this.$split(text));
    };
    this.insertInLine = function (position, text) {
        var start = this.clippedPos(position.row, position.column);
        var end = this.pos(position.row, position.column + text.length);
        this.applyDelta({
            start: start,
            end: end,
            action: &quot;insert&quot;,
            lines: [text]
        }, true);
        return this.clonePos(end);
    };
    this.clippedPos = function (row, column) {
        var length = this.getLength();
        if (row === undefined) {
            row = length;
        }
        else if (row &lt; 0) {
            row = 0;
        }
        else if (row &gt;= length) {
            row = length - 1;
            column = undefined;
        }
        var line = this.getLine(row);
        if (column == undefined)
            column = line.length;
        column = Math.min(Math.max(column, 0), line.length);
        return { row: row, column: column };
    };
    this.clonePos = function (pos) {
        return { row: pos.row, column: pos.column };
    };
    this.pos = function (row, column) {
        return { row: row, column: column };
    };
    this.$clipPosition = function (position) {
        var length = this.getLength();
        if (position.row &gt;= length) {
            position.row = Math.max(0, length - 1);
            position.column = this.getLine(length - 1).length;
        }
        else {
            position.row = Math.max(0, position.row);
            position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
        }
        return position;
    };
    this.insertFullLines = function (row, lines) {
        row = Math.min(Math.max(row, 0), this.getLength());
        var column = 0;
        if (row &lt; this.getLength()) {
            lines = lines.concat([&quot;&quot;]);
            column = 0;
        }
        else {
            lines = [&quot;&quot;].concat(lines);
            row--;
            column = this.$lines[row].length;
        }
        this.insertMergedLines({ row: row, column: column }, lines);
    };
    this.insertMergedLines = function (position, lines) {
        var start = this.clippedPos(position.row, position.column);
        var end = {
            row: start.row + lines.length - 1,
            column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
        };
        this.applyDelta({
            start: start,
            end: end,
            action: &quot;insert&quot;,
            lines: lines
        });
        return this.clonePos(end);
    };
    this.remove = function (range) {
        var start = this.clippedPos(range.start.row, range.start.column);
        var end = this.clippedPos(range.end.row, range.end.column);
        this.applyDelta({
            start: start,
            end: end,
            action: &quot;remove&quot;,
            lines: this.getLinesForRange({ start: start, end: end })
        });
        return this.clonePos(start);
    };
    this.removeInLine = function (row, startColumn, endColumn) {
        var start = this.clippedPos(row, startColumn);
        var end = this.clippedPos(row, endColumn);
        this.applyDelta({
            start: start,
            end: end,
            action: &quot;remove&quot;,
            lines: this.getLinesForRange({ start: start, end: end })
        }, true);
        return this.clonePos(start);
    };
    this.removeFullLines = function (firstRow, lastRow) {
        firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
        lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);
        var deleteFirstNewLine = lastRow == this.getLength() - 1 &amp;&amp; firstRow &gt; 0;
        var deleteLastNewLine = lastRow &lt; this.getLength() - 1;
        var startRow = (deleteFirstNewLine ? firstRow - 1 : firstRow);
        var startCol = (deleteFirstNewLine ? this.getLine(startRow).length : 0);
        var endRow = (deleteLastNewLine ? lastRow + 1 : lastRow);
        var endCol = (deleteLastNewLine ? 0 : this.getLine(endRow).length);
        var range = new Range(startRow, startCol, endRow, endCol);
        var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
        this.applyDelta({
            start: range.start,
            end: range.end,
            action: &quot;remove&quot;,
            lines: this.getLinesForRange(range)
        });
        return deletedLines;
    };
    this.removeNewLine = function (row) {
        if (row &lt; this.getLength() - 1 &amp;&amp; row &gt;= 0) {
            this.applyDelta({
                start: this.pos(row, this.getLine(row).length),
                end: this.pos(row + 1, 0),
                action: &quot;remove&quot;,
                lines: [&quot;&quot;, &quot;&quot;]
            });
        }
    };
    this.replace = function (range, text) {
        if (!(range instanceof Range))
            range = Range.fromPoints(range.start, range.end);
        if (text.length === 0 &amp;&amp; range.isEmpty())
            return range.start;
        if (text == this.getTextRange(range))
            return range.end;
        this.remove(range);
        var end;
        if (text) {
            end = this.insert(range.start, text);
        }
        else {
            end = range.start;
        }
        return end;
    };
    this.applyDeltas = function (deltas) {
        for (var i = 0; i &lt; deltas.length; i++) {
            this.applyDelta(deltas[i]);
        }
    };
    this.revertDeltas = function (deltas) {
        for (var i = deltas.length - 1; i &gt;= 0; i--) {
            this.revertDelta(deltas[i]);
        }
    };
    this.applyDelta = function (delta, doNotValidate) {
        var isInsert = delta.action == &quot;insert&quot;;
        if (isInsert ? delta.lines.length &lt;= 1 &amp;&amp; !delta.lines[0]
            : !Range.comparePoints(delta.start, delta.end)) {
            return;
        }
        if (isInsert &amp;&amp; delta.lines.length &gt; 20000) {
            this.$splitAndapplyLargeDelta(delta, 20000);
        }
        else {
            applyDelta(this.$lines, delta, doNotValidate);
            this._signal(&quot;change&quot;, delta);
        }
    };
    this.$safeApplyDelta = function (delta) {
        var docLength = this.$lines.length;
        if (delta.action == &quot;remove&quot; &amp;&amp; delta.start.row &lt; docLength &amp;&amp; delta.end.row &lt; docLength
            || delta.action == &quot;insert&quot; &amp;&amp; delta.start.row &lt;= docLength) {
            this.applyDelta(delta);
        }
    };
    this.$splitAndapplyLargeDelta = function (delta, MAX) {
        var lines = delta.lines;
        var l = lines.length - MAX + 1;
        var row = delta.start.row;
        var column = delta.start.column;
        for (var from = 0, to = 0; from &lt; l; from = to) {
            to += MAX - 1;
            var chunk = lines.slice(from, to);
            chunk.push(&quot;&quot;);
            this.applyDelta({
                start: this.pos(row + from, column),
                end: this.pos(row + to, column = 0),
                action: delta.action,
                lines: chunk
            }, true);
        }
        delta.lines = lines.slice(from);
        delta.start.row = row + from;
        delta.start.column = column;
        this.applyDelta(delta, true);
    };
    this.revertDelta = function (delta) {
        this.$safeApplyDelta({
            start: this.clonePos(delta.start),
            end: this.clonePos(delta.end),
            action: (delta.action == &quot;insert&quot; ? &quot;remove&quot; : &quot;insert&quot;),
            lines: delta.lines.slice()
        });
    };
    this.indexToPosition = function (index, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        for (var i = startRow || 0, l = lines.length; i &lt; l; i++) {
            index -= lines[i].length + newlineLength;
            if (index &lt; 0)
                return { row: i, column: index + lines[i].length + newlineLength };
        }
        return { row: l - 1, column: index + lines[l - 1].length + newlineLength };
    };
    this.positionToIndex = function (pos, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        var index = 0;
        var row = Math.min(pos.row, lines.length);
        for (var i = startRow || 0; i &lt; row; ++i)
            index += lines[i].length + newlineLength;
        return index + pos.column;
    };
}).call(Document.prototype);
exports.Document = Document;

});

define(&quot;ace/background_tokenizer&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/event_emitter&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;./lib/oop&quot;);
var EventEmitter = require(&quot;./lib/event_emitter&quot;).EventEmitter;
var BackgroundTokenizer = function (tokenizer, editor) {
    this.running = false;
    this.lines = [];
    this.states = [];
    this.currentLine = 0;
    this.tokenizer = tokenizer;
    var self = this;
    this.$worker = function () {
        if (!self.running) {
            return;
        }
        var workerStart = new Date();
        var currentLine = self.currentLine;
        var endLine = -1;
        var doc = self.doc;
        var startLine = currentLine;
        while (self.lines[currentLine])
            currentLine++;
        var len = doc.getLength();
        var processedLines = 0;
        self.running = false;
        while (currentLine &lt; len) {
            self.$tokenizeRow(currentLine);
            endLine = currentLine;
            do {
                currentLine++;
            } while (self.lines[currentLine]);
            processedLines++;
            if ((processedLines % 5 === 0) &amp;&amp; (new Date() - workerStart) &gt; 20) {
                self.running = setTimeout(self.$worker, 20);
                break;
            }
        }
        self.currentLine = currentLine;
        if (endLine == -1)
            endLine = currentLine;
        if (startLine &lt;= endLine)
            self.fireUpdateEvent(startLine, endLine);
    };
};
(function () {
    oop.implement(this, EventEmitter);
    this.setTokenizer = function (tokenizer) {
        this.tokenizer = tokenizer;
        this.lines = [];
        this.states = [];
        this.start(0);
    };
    this.setDocument = function (doc) {
        this.doc = doc;
        this.lines = [];
        this.states = [];
        this.stop();
    };
    this.fireUpdateEvent = function (firstRow, lastRow) {
        var data = {
            first: firstRow,
            last: lastRow
        };
        this._signal(&quot;update&quot;, { data: data });
    };
    this.start = function (startRow) {
        this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
        this.lines.splice(this.currentLine, this.lines.length);
        this.states.splice(this.currentLine, this.states.length);
        this.stop();
        this.running = setTimeout(this.$worker, 700);
    };
    this.scheduleStart = function () {
        if (!this.running)
            this.running = setTimeout(this.$worker, 700);
    };
    this.$updateOnChange = function (delta) {
        var startRow = delta.start.row;
        var len = delta.end.row - startRow;
        if (len === 0) {
            this.lines[startRow] = null;
        }
        else if (delta.action == &quot;remove&quot;) {
            this.lines.splice(startRow, len + 1, null);
            this.states.splice(startRow, len + 1, null);
        }
        else {
            var args = Array(len + 1);
            args.unshift(startRow, 1);
            this.lines.splice.apply(this.lines, args);
            this.states.splice.apply(this.states, args);
        }
        this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());
        this.stop();
    };
    this.stop = function () {
        if (this.running)
            clearTimeout(this.running);
        this.running = false;
    };
    this.getTokens = function (row) {
        return this.lines[row] || this.$tokenizeRow(row);
    };
    this.getState = function (row) {
        if (this.currentLine == row)
            this.$tokenizeRow(row);
        return this.states[row] || &quot;start&quot;;
    };
    this.$tokenizeRow = function (row) {
        var line = this.doc.getLine(row);
        var state = this.states[row - 1];
        var data = this.tokenizer.getLineTokens(line, state, row);
        if (this.states[row] + &quot;&quot; !== data.state + &quot;&quot;) {
            this.states[row] = data.state;
            this.lines[row + 1] = null;
            if (this.currentLine &gt; row + 1)
                this.currentLine = row + 1;
        }
        else if (this.currentLine == row) {
            this.currentLine = row + 1;
        }
        return this.lines[row] = data.tokens;
    };
    this.cleanup = function () {
        this.running = false;
        this.lines = [];
        this.states = [];
        this.currentLine = 0;
        this.removeAllListeners();
    };
}).call(BackgroundTokenizer.prototype);
exports.BackgroundTokenizer = BackgroundTokenizer;

});

define(&quot;ace/search_highlight&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/lang&quot;,&quot;ace/lib/oop&quot;,&quot;ace/range&quot;], function(require, exports, module){&quot;use strict&quot;;
var lang = require(&quot;./lib/lang&quot;);
var oop = require(&quot;./lib/oop&quot;);
var Range = require(&quot;./range&quot;).Range;
var SearchHighlight = function (regExp, clazz, type) {
    this.setRegexp(regExp);
    this.clazz = clazz;
    this.type = type || &quot;text&quot;;
};
(function () {
    this.MAX_RANGES = 500;
    this.setRegexp = function (regExp) {
        if (this.regExp + &quot;&quot; == regExp + &quot;&quot;)
            return;
        this.regExp = regExp;
        this.cache = [];
    };
    this.update = function (html, markerLayer, session, config) {
        if (!this.regExp)
            return;
        var start = config.firstRow, end = config.lastRow;
        var renderedMarkerRanges = {};
        for (var i = start; i &lt;= end; i++) {
            var ranges = this.cache[i];
            if (ranges == null) {
                ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
                if (ranges.length &gt; this.MAX_RANGES)
                    ranges = ranges.slice(0, this.MAX_RANGES);
                ranges = ranges.map(function (match) {
                    return new Range(i, match.offset, i, match.offset + match.length);
                });
                this.cache[i] = ranges.length ? ranges : &quot;&quot;;
            }
            for (var j = ranges.length; j--;) {
                var rangeToAddMarkerTo = ranges[j].toScreenRange(session);
                var rangeAsString = rangeToAddMarkerTo.toString();
                if (renderedMarkerRanges[rangeAsString])
                    continue;
                renderedMarkerRanges[rangeAsString] = true;
                markerLayer.drawSingleLineMarker(html, rangeToAddMarkerTo, this.clazz, config);
            }
        }
    };
}).call(SearchHighlight.prototype);
exports.SearchHighlight = SearchHighlight;

});

define(&quot;ace/edit_session/fold_line&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/range&quot;], function(require, exports, module){&quot;use strict&quot;;
var Range = require(&quot;../range&quot;).Range;
function FoldLine(foldData, folds) {
    this.foldData = foldData;
    if (Array.isArray(folds)) {
        this.folds = folds;
    }
    else {
        folds = this.folds = [folds];
    }
    var last = folds[folds.length - 1];
    this.range = new Range(folds[0].start.row, folds[0].start.column, last.end.row, last.end.column);
    this.start = this.range.start;
    this.end = this.range.end;
    this.folds.forEach(function (fold) {
        fold.setFoldLine(this);
    }, this);
}
(function () {
    this.shiftRow = function (shift) {
        this.start.row += shift;
        this.end.row += shift;
        this.folds.forEach(function (fold) {
            fold.start.row += shift;
            fold.end.row += shift;
        });
    };
    this.addFold = function (fold) {
        if (fold.sameRow) {
            if (fold.start.row &lt; this.startRow || fold.endRow &gt; this.endRow) {
                throw new Error(&quot;Can&#039;t add a fold to this FoldLine as it has no connection&quot;);
            }
            this.folds.push(fold);
            this.folds.sort(function (a, b) {
                return -a.range.compareEnd(b.start.row, b.start.column);
            });
            if (this.range.compareEnd(fold.start.row, fold.start.column) &gt; 0) {
                this.end.row = fold.end.row;
                this.end.column = fold.end.column;
            }
            else if (this.range.compareStart(fold.end.row, fold.end.column) &lt; 0) {
                this.start.row = fold.start.row;
                this.start.column = fold.start.column;
            }
        }
        else if (fold.start.row == this.end.row) {
            this.folds.push(fold);
            this.end.row = fold.end.row;
            this.end.column = fold.end.column;
        }
        else if (fold.end.row == this.start.row) {
            this.folds.unshift(fold);
            this.start.row = fold.start.row;
            this.start.column = fold.start.column;
        }
        else {
            throw new Error(&quot;Trying to add fold to FoldRow that doesn&#039;t have a matching row&quot;);
        }
        fold.foldLine = this;
    };
    this.containsRow = function (row) {
        return row &gt;= this.start.row &amp;&amp; row &lt;= this.end.row;
    };
    this.walk = function (callback, endRow, endColumn) {
        var lastEnd = 0, folds = this.folds, fold, cmp, stop, isNewRow = true;
        if (endRow == null) {
            endRow = this.end.row;
            endColumn = this.end.column;
        }
        for (var i = 0; i &lt; folds.length; i++) {
            fold = folds[i];
            cmp = fold.range.compareStart(endRow, endColumn);
            if (cmp == -1) {
                callback(null, endRow, endColumn, lastEnd, isNewRow);
                return;
            }
            stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
            stop = !stop &amp;&amp; callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
            if (stop || cmp === 0) {
                return;
            }
            isNewRow = !fold.sameRow;
            lastEnd = fold.end.column;
        }
        callback(null, endRow, endColumn, lastEnd, isNewRow);
    };
    this.getNextFoldTo = function (row, column) {
        var fold, cmp;
        for (var i = 0; i &lt; this.folds.length; i++) {
            fold = this.folds[i];
            cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
                return {
                    fold: fold,
                    kind: &quot;after&quot;
                };
            }
            else if (cmp === 0) {
                return {
                    fold: fold,
                    kind: &quot;inside&quot;
                };
            }
        }
        return null;
    };
    this.addRemoveChars = function (row, column, len) {
        var ret = this.getNextFoldTo(row, column), fold, folds;
        if (ret) {
            fold = ret.fold;
            if (ret.kind == &quot;inside&quot;
                &amp;&amp; fold.start.column != column
                &amp;&amp; fold.start.row != row) {
                window.console &amp;&amp; window.console.log(row, column, fold);
            }
            else if (fold.start.row == row) {
                folds = this.folds;
                var i = folds.indexOf(fold);
                if (i === 0) {
                    this.start.column += len;
                }
                for (i; i &lt; folds.length; i++) {
                    fold = folds[i];
                    fold.start.column += len;
                    if (!fold.sameRow) {
                        return;
                    }
                    fold.end.column += len;
                }
                this.end.column += len;
            }
        }
    };
    this.split = function (row, column) {
        var pos = this.getNextFoldTo(row, column);
        if (!pos || pos.kind == &quot;inside&quot;)
            return null;
        var fold = pos.fold;
        var folds = this.folds;
        var foldData = this.foldData;
        var i = folds.indexOf(fold);
        var foldBefore = folds[i - 1];
        this.end.row = foldBefore.end.row;
        this.end.column = foldBefore.end.column;
        folds = folds.splice(i, folds.length - i);
        var newFoldLine = new FoldLine(foldData, folds);
        foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
        return newFoldLine;
    };
    this.merge = function (foldLineNext) {
        var folds = foldLineNext.folds;
        for (var i = 0; i &lt; folds.length; i++) {
            this.addFold(folds[i]);
        }
        var foldData = this.foldData;
        foldData.splice(foldData.indexOf(foldLineNext), 1);
    };
    this.toString = function () {
        var ret = [this.range.toString() + &quot;: [&quot;];
        this.folds.forEach(function (fold) {
            ret.push(&quot;  &quot; + fold.toString());
        });
        ret.push(&quot;]&quot;);
        return ret.join(&quot;\n&quot;);
    };
    this.idxToPosition = function (idx) {
        var lastFoldEndColumn = 0;
        for (var i = 0; i &lt; this.folds.length; i++) {
            var fold = this.folds[i];
            idx -= fold.start.column - lastFoldEndColumn;
            if (idx &lt; 0) {
                return {
                    row: fold.start.row,
                    column: fold.start.column + idx
                };
            }
            idx -= fold.placeholder.length;
            if (idx &lt; 0) {
                return fold.start;
            }
            lastFoldEndColumn = fold.end.column;
        }
        return {
            row: this.end.row,
            column: this.end.column + idx
        };
    };
}).call(FoldLine.prototype);
exports.FoldLine = FoldLine;

});

define(&quot;ace/range_list&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/range&quot;], function(require, exports, module){&quot;use strict&quot;;
var Range = require(&quot;./range&quot;).Range;
var comparePoints = Range.comparePoints;
var RangeList = function () {
    this.ranges = [];
    this.$bias = 1;
};
(function () {
    this.comparePoints = comparePoints;
    this.pointIndex = function (pos, excludeEdges, startIndex) {
        var list = this.ranges;
        for (var i = startIndex || 0; i &lt; list.length; i++) {
            var range = list[i];
            var cmpEnd = comparePoints(pos, range.end);
            if (cmpEnd &gt; 0)
                continue;
            var cmpStart = comparePoints(pos, range.start);
            if (cmpEnd === 0)
                return excludeEdges &amp;&amp; cmpStart !== 0 ? -i - 2 : i;
            if (cmpStart &gt; 0 || (cmpStart === 0 &amp;&amp; !excludeEdges))
                return i;
            return -i - 1;
        }
        return -i - 1;
    };
    this.add = function (range) {
        var excludeEdges = !range.isEmpty();
        var startIndex = this.pointIndex(range.start, excludeEdges);
        if (startIndex &lt; 0)
            startIndex = -startIndex - 1;
        var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);
        if (endIndex &lt; 0)
            endIndex = -endIndex - 1;
        else
            endIndex++;
        return this.ranges.splice(startIndex, endIndex - startIndex, range);
    };
    this.addList = function (list) {
        var removed = [];
        for (var i = list.length; i--;) {
            removed.push.apply(removed, this.add(list[i]));
        }
        return removed;
    };
    this.substractPoint = function (pos) {
        var i = this.pointIndex(pos);
        if (i &gt;= 0)
            return this.ranges.splice(i, 1);
    };
    this.merge = function () {
        var removed = [];
        var list = this.ranges;
        list = list.sort(function (a, b) {
            return comparePoints(a.start, b.start);
        });
        var next = list[0], range;
        for (var i = 1; i &lt; list.length; i++) {
            range = next;
            next = list[i];
            var cmp = comparePoints(range.end, next.start);
            if (cmp &lt; 0)
                continue;
            if (cmp == 0 &amp;&amp; !range.isEmpty() &amp;&amp; !next.isEmpty())
                continue;
            if (comparePoints(range.end, next.end) &lt; 0) {
                range.end.row = next.end.row;
                range.end.column = next.end.column;
            }
            list.splice(i, 1);
            removed.push(next);
            next = range;
            i--;
        }
        this.ranges = list;
        return removed;
    };
    this.contains = function (row, column) {
        return this.pointIndex({ row: row, column: column }) &gt;= 0;
    };
    this.containsPoint = function (pos) {
        return this.pointIndex(pos) &gt;= 0;
    };
    this.rangeAtPoint = function (pos) {
        var i = this.pointIndex(pos);
        if (i &gt;= 0)
            return this.ranges[i];
    };
    this.clipRows = function (startRow, endRow) {
        var list = this.ranges;
        if (list[0].start.row &gt; endRow || list[list.length - 1].start.row &lt; startRow)
            return [];
        var startIndex = this.pointIndex({ row: startRow, column: 0 });
        if (startIndex &lt; 0)
            startIndex = -startIndex - 1;
        var endIndex = this.pointIndex({ row: endRow, column: 0 }, startIndex);
        if (endIndex &lt; 0)
            endIndex = -endIndex - 1;
        var clipped = [];
        for (var i = startIndex; i &lt; endIndex; i++) {
            clipped.push(list[i]);
        }
        return clipped;
    };
    this.removeAll = function () {
        return this.ranges.splice(0, this.ranges.length);
    };
    this.attach = function (session) {
        if (this.session)
            this.detach();
        this.session = session;
        this.onChange = this.$onChange.bind(this);
        this.session.on(&#039;change&#039;, this.onChange);
    };
    this.detach = function () {
        if (!this.session)
            return;
        this.session.removeListener(&#039;change&#039;, this.onChange);
        this.session = null;
    };
    this.$onChange = function (delta) {
        var start = delta.start;
        var end = delta.end;
        var startRow = start.row;
        var endRow = end.row;
        var ranges = this.ranges;
        for (var i = 0, n = ranges.length; i &lt; n; i++) {
            var r = ranges[i];
            if (r.end.row &gt;= startRow)
                break;
        }
        if (delta.action == &quot;insert&quot;) {
            var lineDif = endRow - startRow;
            var colDiff = -start.column + end.column;
            for (; i &lt; n; i++) {
                var r = ranges[i];
                if (r.start.row &gt; startRow)
                    break;
                if (r.start.row == startRow &amp;&amp; r.start.column &gt;= start.column) {
                    if (r.start.column == start.column &amp;&amp; this.$bias &lt;= 0) {
                    }
                    else {
                        r.start.column += colDiff;
                        r.start.row += lineDif;
                    }
                }
                if (r.end.row == startRow &amp;&amp; r.end.column &gt;= start.column) {
                    if (r.end.column == start.column &amp;&amp; this.$bias &lt; 0) {
                        continue;
                    }
                    if (r.end.column == start.column &amp;&amp; colDiff &gt; 0 &amp;&amp; i &lt; n - 1) {
                        if (r.end.column &gt; r.start.column &amp;&amp; r.end.column == ranges[i + 1].start.column)
                            r.end.column -= colDiff;
                    }
                    r.end.column += colDiff;
                    r.end.row += lineDif;
                }
            }
        }
        else {
            var lineDif = startRow - endRow;
            var colDiff = start.column - end.column;
            for (; i &lt; n; i++) {
                var r = ranges[i];
                if (r.start.row &gt; endRow)
                    break;
                if (r.end.row &lt; endRow
                    &amp;&amp; (startRow &lt; r.end.row
                        || startRow == r.end.row &amp;&amp; start.column &lt; r.end.column)) {
                    r.end.row = startRow;
                    r.end.column = start.column;
                }
                else if (r.end.row == endRow) {
                    if (r.end.column &lt;= end.column) {
                        if (lineDif || r.end.column &gt; start.column) {
                            r.end.column = start.column;
                            r.end.row = start.row;
                        }
                    }
                    else {
                        r.end.column += colDiff;
                        r.end.row += lineDif;
                    }
                }
                else if (r.end.row &gt; endRow) {
                    r.end.row += lineDif;
                }
                if (r.start.row &lt; endRow
                    &amp;&amp; (startRow &lt; r.start.row
                        || startRow == r.start.row &amp;&amp; start.column &lt; r.start.column)) {
                    r.start.row = startRow;
                    r.start.column = start.column;
                }
                else if (r.start.row == endRow) {
                    if (r.start.column &lt;= end.column) {
                        if (lineDif || r.start.column &gt; start.column) {
                            r.start.column = start.column;
                            r.start.row = start.row;
                        }
                    }
                    else {
                        r.start.column += colDiff;
                        r.start.row += lineDif;
                    }
                }
                else if (r.start.row &gt; endRow) {
                    r.start.row += lineDif;
                }
            }
        }
        if (lineDif != 0 &amp;&amp; i &lt; n) {
            for (; i &lt; n; i++) {
                var r = ranges[i];
                r.start.row += lineDif;
                r.end.row += lineDif;
            }
        }
    };
}).call(RangeList.prototype);
exports.RangeList = RangeList;

});

define(&quot;ace/edit_session/fold&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/range_list&quot;,&quot;ace/lib/oop&quot;], function(require, exports, module){&quot;use strict&quot;;
var RangeList = require(&quot;../range_list&quot;).RangeList;
var oop = require(&quot;../lib/oop&quot;);
var Fold = exports.Fold = function (range, placeholder) {
    this.foldLine = null;
    this.placeholder = placeholder;
    this.range = range;
    this.start = range.start;
    this.end = range.end;
    this.sameRow = range.start.row == range.end.row;
    this.subFolds = this.ranges = [];
};
oop.inherits(Fold, RangeList);
(function () {
    this.toString = function () {
        return &#039;&quot;&#039; + this.placeholder + &#039;&quot; &#039; + this.range.toString();
    };
    this.setFoldLine = function (foldLine) {
        this.foldLine = foldLine;
        this.subFolds.forEach(function (fold) {
            fold.setFoldLine(foldLine);
        });
    };
    this.clone = function () {
        var range = this.range.clone();
        var fold = new Fold(range, this.placeholder);
        this.subFolds.forEach(function (subFold) {
            fold.subFolds.push(subFold.clone());
        });
        fold.collapseChildren = this.collapseChildren;
        return fold;
    };
    this.addSubFold = function (fold) {
        if (this.range.isEqual(fold))
            return;
        consumeRange(fold, this.start);
        var row = fold.start.row, column = fold.start.column;
        for (var i = 0, cmp = -1; i &lt; this.subFolds.length; i++) {
            cmp = this.subFolds[i].range.compare(row, column);
            if (cmp != 1)
                break;
        }
        var afterStart = this.subFolds[i];
        var firstConsumed = 0;
        if (cmp == 0) {
            if (afterStart.range.containsRange(fold))
                return afterStart.addSubFold(fold);
            else
                firstConsumed = 1;
        }
        var row = fold.range.end.row, column = fold.range.end.column;
        for (var j = i, cmp = -1; j &lt; this.subFolds.length; j++) {
            cmp = this.subFolds[j].range.compare(row, column);
            if (cmp != 1)
                break;
        }
        if (cmp == 0)
            j++;
        var consumedFolds = this.subFolds.splice(i, j - i, fold);
        var last = cmp == 0 ? consumedFolds.length - 1 : consumedFolds.length;
        for (var k = firstConsumed; k &lt; last; k++) {
            fold.addSubFold(consumedFolds[k]);
        }
        fold.setFoldLine(this.foldLine);
        return fold;
    };
    this.restoreRange = function (range) {
        return restoreRange(range, this.start);
    };
}).call(Fold.prototype);
function consumePoint(point, anchor) {
    point.row -= anchor.row;
    if (point.row == 0)
        point.column -= anchor.column;
}
function consumeRange(range, anchor) {
    consumePoint(range.start, anchor);
    consumePoint(range.end, anchor);
}
function restorePoint(point, anchor) {
    if (point.row == 0)
        point.column += anchor.column;
    point.row += anchor.row;
}
function restoreRange(range, anchor) {
    restorePoint(range.start, anchor);
    restorePoint(range.end, anchor);
}

});

define(&quot;ace/edit_session/folding&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/range&quot;,&quot;ace/edit_session/fold_line&quot;,&quot;ace/edit_session/fold&quot;,&quot;ace/token_iterator&quot;], function(require, exports, module){&quot;use strict&quot;;
var Range = require(&quot;../range&quot;).Range;
var FoldLine = require(&quot;./fold_line&quot;).FoldLine;
var Fold = require(&quot;./fold&quot;).Fold;
var TokenIterator = require(&quot;../token_iterator&quot;).TokenIterator;
function Folding() {
    this.getFoldAt = function (row, column, side) {
        var foldLine = this.getFoldLine(row);
        if (!foldLine)
            return null;
        var folds = foldLine.folds;
        for (var i = 0; i &lt; folds.length; i++) {
            var range = folds[i].range;
            if (range.contains(row, column)) {
                if (side == 1 &amp;&amp; range.isEnd(row, column) &amp;&amp; !range.isEmpty()) {
                    continue;
                }
                else if (side == -1 &amp;&amp; range.isStart(row, column) &amp;&amp; !range.isEmpty()) {
                    continue;
                }
                return folds[i];
            }
        }
    };
    this.getFoldsInRange = function (range) {
        var start = range.start;
        var end = range.end;
        var foldLines = this.$foldData;
        var foundFolds = [];
        start.column += 1;
        end.column -= 1;
        for (var i = 0; i &lt; foldLines.length; i++) {
            var cmp = foldLines[i].range.compareRange(range);
            if (cmp == 2) {
                continue;
            }
            else if (cmp == -2) {
                break;
            }
            var folds = foldLines[i].folds;
            for (var j = 0; j &lt; folds.length; j++) {
                var fold = folds[j];
                cmp = fold.range.compareRange(range);
                if (cmp == -2) {
                    break;
                }
                else if (cmp == 2) {
                    continue;
                }
                else 
                if (cmp == 42) {
                    break;
                }
                foundFolds.push(fold);
            }
        }
        start.column -= 1;
        end.column += 1;
        return foundFolds;
    };
    this.getFoldsInRangeList = function (ranges) {
        if (Array.isArray(ranges)) {
            var folds = [];
            ranges.forEach(function (range) {
                folds = folds.concat(this.getFoldsInRange(range));
            }, this);
        }
        else {
            var folds = this.getFoldsInRange(ranges);
        }
        return folds;
    };
    this.getAllFolds = function () {
        var folds = [];
        var foldLines = this.$foldData;
        for (var i = 0; i &lt; foldLines.length; i++)
            for (var j = 0; j &lt; foldLines[i].folds.length; j++)
                folds.push(foldLines[i].folds[j]);
        return folds;
    };
    this.getFoldStringAt = function (row, column, trim, foldLine) {
        foldLine = foldLine || this.getFoldLine(row);
        if (!foldLine)
            return null;
        var lastFold = {
            end: { column: 0 }
        };
        var str, fold;
        for (var i = 0; i &lt; foldLine.folds.length; i++) {
            fold = foldLine.folds[i];
            var cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
                str = this
                    .getLine(fold.start.row)
                    .substring(lastFold.end.column, fold.start.column);
                break;
            }
            else if (cmp === 0) {
                return null;
            }
            lastFold = fold;
        }
        if (!str)
            str = this.getLine(fold.start.row).substring(lastFold.end.column);
        if (trim == -1)
            return str.substring(0, column - lastFold.end.column);
        else if (trim == 1)
            return str.substring(column - lastFold.end.column);
        else
            return str;
    };
    this.getFoldLine = function (docRow, startFoldLine) {
        var foldData = this.$foldData;
        var i = 0;
        if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
        if (i == -1)
            i = 0;
        for (i; i &lt; foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.start.row &lt;= docRow &amp;&amp; foldLine.end.row &gt;= docRow) {
                return foldLine;
            }
            else if (foldLine.end.row &gt; docRow) {
                return null;
            }
        }
        return null;
    };
    this.getNextFoldLine = function (docRow, startFoldLine) {
        var foldData = this.$foldData;
        var i = 0;
        if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
        if (i == -1)
            i = 0;
        for (i; i &lt; foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.end.row &gt;= docRow) {
                return foldLine;
            }
        }
        return null;
    };
    this.getFoldedRowCount = function (first, last) {
        var foldData = this.$foldData, rowCount = last - first + 1;
        for (var i = 0; i &lt; foldData.length; i++) {
            var foldLine = foldData[i], end = foldLine.end.row, start = foldLine.start.row;
            if (end &gt;= last) {
                if (start &lt; last) {
                    if (start &gt;= first)
                        rowCount -= last - start;
                    else
                        rowCount = 0; // in one fold
                }
                break;
            }
            else if (end &gt;= first) {
                if (start &gt;= first) // fold inside range
                    rowCount -= end - start;
                else
                    rowCount -= end - first + 1;
            }
        }
        return rowCount;
    };
    this.$addFoldLine = function (foldLine) {
        this.$foldData.push(foldLine);
        this.$foldData.sort(function (a, b) {
            return a.start.row - b.start.row;
        });
        return foldLine;
    };
    this.addFold = function (placeholder, range) {
        var foldData = this.$foldData;
        var added = false;
        var fold;
        if (placeholder instanceof Fold)
            fold = placeholder;
        else {
            fold = new Fold(range, placeholder);
            fold.collapseChildren = range.collapseChildren;
        }
        this.$clipRangeToDocument(fold.range);
        var startRow = fold.start.row;
        var startColumn = fold.start.column;
        var endRow = fold.end.row;
        var endColumn = fold.end.column;
        var startFold = this.getFoldAt(startRow, startColumn, 1);
        var endFold = this.getFoldAt(endRow, endColumn, -1);
        if (startFold &amp;&amp; endFold == startFold)
            return startFold.addSubFold(fold);
        if (startFold &amp;&amp; !startFold.range.isStart(startRow, startColumn))
            this.removeFold(startFold);
        if (endFold &amp;&amp; !endFold.range.isEnd(endRow, endColumn))
            this.removeFold(endFold);
        var folds = this.getFoldsInRange(fold.range);
        if (folds.length &gt; 0) {
            this.removeFolds(folds);
            if (!fold.collapseChildren) {
                folds.forEach(function (subFold) {
                    fold.addSubFold(subFold);
                });
            }
        }
        for (var i = 0; i &lt; foldData.length; i++) {
            var foldLine = foldData[i];
            if (endRow == foldLine.start.row) {
                foldLine.addFold(fold);
                added = true;
                break;
            }
            else if (startRow == foldLine.end.row) {
                foldLine.addFold(fold);
                added = true;
                if (!fold.sameRow) {
                    var foldLineNext = foldData[i + 1];
                    if (foldLineNext &amp;&amp; foldLineNext.start.row == endRow) {
                        foldLine.merge(foldLineNext);
                        break;
                    }
                }
                break;
            }
            else if (endRow &lt;= foldLine.start.row) {
                break;
            }
        }
        if (!added)
            foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));
        if (this.$useWrapMode)
            this.$updateWrapData(foldLine.start.row, foldLine.start.row);
        else
            this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
        this.$modified = true;
        this._signal(&quot;changeFold&quot;, { data: fold, action: &quot;add&quot; });
        return fold;
    };
    this.addFolds = function (folds) {
        folds.forEach(function (fold) {
            this.addFold(fold);
        }, this);
    };
    this.removeFold = function (fold) {
        var foldLine = fold.foldLine;
        var startRow = foldLine.start.row;
        var endRow = foldLine.end.row;
        var foldLines = this.$foldData;
        var folds = foldLine.folds;
        if (folds.length == 1) {
            foldLines.splice(foldLines.indexOf(foldLine), 1);
        }
        else 
        if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
            folds.pop();
            foldLine.end.row = folds[folds.length - 1].end.row;
            foldLine.end.column = folds[folds.length - 1].end.column;
        }
        else 
        if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
            folds.shift();
            foldLine.start.row = folds[0].start.row;
            foldLine.start.column = folds[0].start.column;
        }
        else 
        if (fold.sameRow) {
            folds.splice(folds.indexOf(fold), 1);
        }
        else 
        {
            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
            folds = newFoldLine.folds;
            folds.shift();
            newFoldLine.start.row = folds[0].start.row;
            newFoldLine.start.column = folds[0].start.column;
        }
        if (!this.$updating) {
            if (this.$useWrapMode)
                this.$updateWrapData(startRow, endRow);
            else
                this.$updateRowLengthCache(startRow, endRow);
        }
        this.$modified = true;
        this._signal(&quot;changeFold&quot;, { data: fold, action: &quot;remove&quot; });
    };
    this.removeFolds = function (folds) {
        var cloneFolds = [];
        for (var i = 0; i &lt; folds.length; i++) {
            cloneFolds.push(folds[i]);
        }
        cloneFolds.forEach(function (fold) {
            this.removeFold(fold);
        }, this);
        this.$modified = true;
    };
    this.expandFold = function (fold) {
        this.removeFold(fold);
        fold.subFolds.forEach(function (subFold) {
            fold.restoreRange(subFold);
            this.addFold(subFold);
        }, this);
        if (fold.collapseChildren &gt; 0) {
            this.foldAll(fold.start.row + 1, fold.end.row, fold.collapseChildren - 1);
        }
        fold.subFolds = [];
    };
    this.expandFolds = function (folds) {
        folds.forEach(function (fold) {
            this.expandFold(fold);
        }, this);
    };
    this.unfold = function (location, expandInner) {
        var range, folds;
        if (location == null) {
            range = new Range(0, 0, this.getLength(), 0);
            if (expandInner == null)
                expandInner = true;
        }
        else if (typeof location == &quot;number&quot;) {
            range = new Range(location, 0, location, this.getLine(location).length);
        }
        else if (&quot;row&quot; in location) {
            range = Range.fromPoints(location, location);
        }
        else if (Array.isArray(location)) {
            folds = [];
            location.forEach(function (range) {
                folds = folds.concat(this.unfold(range));
            }, this);
            return folds;
        }
        else {
            range = location;
        }
        folds = this.getFoldsInRangeList(range);
        var outermostFolds = folds;
        while (folds.length == 1
            &amp;&amp; Range.comparePoints(folds[0].start, range.start) &lt; 0
            &amp;&amp; Range.comparePoints(folds[0].end, range.end) &gt; 0) {
            this.expandFolds(folds);
            folds = this.getFoldsInRangeList(range);
        }
        if (expandInner != false) {
            this.removeFolds(folds);
        }
        else {
            this.expandFolds(folds);
        }
        if (outermostFolds.length)
            return outermostFolds;
    };
    this.isRowFolded = function (docRow, startFoldRow) {
        return !!this.getFoldLine(docRow, startFoldRow);
    };
    this.getRowFoldEnd = function (docRow, startFoldRow) {
        var foldLine = this.getFoldLine(docRow, startFoldRow);
        return foldLine ? foldLine.end.row : docRow;
    };
    this.getRowFoldStart = function (docRow, startFoldRow) {
        var foldLine = this.getFoldLine(docRow, startFoldRow);
        return foldLine ? foldLine.start.row : docRow;
    };
    this.getFoldDisplayLine = function (foldLine, endRow, endColumn, startRow, startColumn) {
        if (startRow == null)
            startRow = foldLine.start.row;
        if (startColumn == null)
            startColumn = 0;
        if (endRow == null)
            endRow = foldLine.end.row;
        if (endColumn == null)
            endColumn = this.getLine(endRow).length;
        var doc = this.doc;
        var textLine = &quot;&quot;;
        foldLine.walk(function (placeholder, row, column, lastColumn) {
            if (row &lt; startRow)
                return;
            if (row == startRow) {
                if (column &lt; startColumn)
                    return;
                lastColumn = Math.max(startColumn, lastColumn);
            }
            if (placeholder != null) {
                textLine += placeholder;
            }
            else {
                textLine += doc.getLine(row).substring(lastColumn, column);
            }
        }, endRow, endColumn);
        return textLine;
    };
    this.getDisplayLine = function (row, endColumn, startRow, startColumn) {
        var foldLine = this.getFoldLine(row);
        if (!foldLine) {
            var line;
            line = this.doc.getLine(row);
            return line.substring(startColumn || 0, endColumn || line.length);
        }
        else {
            return this.getFoldDisplayLine(foldLine, row, endColumn, startRow, startColumn);
        }
    };
    this.$cloneFoldData = function () {
        var fd = [];
        fd = this.$foldData.map(function (foldLine) {
            var folds = foldLine.folds.map(function (fold) {
                return fold.clone();
            });
            return new FoldLine(fd, folds);
        });
        return fd;
    };
    this.toggleFold = function (tryToUnfold) {
        var selection = this.selection;
        var range = selection.getRange();
        var fold;
        var bracketPos;
        if (range.isEmpty()) {
            var cursor = range.start;
            fold = this.getFoldAt(cursor.row, cursor.column);
            if (fold) {
                this.expandFold(fold);
                return;
            }
            else if (bracketPos = this.findMatchingBracket(cursor)) {
                if (range.comparePoint(bracketPos) == 1) {
                    range.end = bracketPos;
                }
                else {
                    range.start = bracketPos;
                    range.start.column++;
                    range.end.column--;
                }
            }
            else if (bracketPos = this.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 })) {
                if (range.comparePoint(bracketPos) == 1)
                    range.end = bracketPos;
                else
                    range.start = bracketPos;
                range.start.column++;
            }
            else {
                range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
            }
        }
        else {
            var folds = this.getFoldsInRange(range);
            if (tryToUnfold &amp;&amp; folds.length) {
                this.expandFolds(folds);
                return;
            }
            else if (folds.length == 1) {
                fold = folds[0];
            }
        }
        if (!fold)
            fold = this.getFoldAt(range.start.row, range.start.column);
        if (fold &amp;&amp; fold.range.toString() == range.toString()) {
            this.expandFold(fold);
            return;
        }
        var placeholder = &quot;...&quot;;
        if (!range.isMultiLine()) {
            placeholder = this.getTextRange(range);
            if (placeholder.length &lt; 4)
                return;
            placeholder = placeholder.trim().substring(0, 2) + &quot;..&quot;;
        }
        this.addFold(placeholder, range);
    };
    this.getCommentFoldRange = function (row, column, dir) {
        var iterator = new TokenIterator(this, row, column);
        var token = iterator.getCurrentToken();
        var type = token &amp;&amp; token.type;
        if (token &amp;&amp; /^comment|string/.test(type)) {
            type = type.match(/comment|string/)[0];
            if (type == &quot;comment&quot;)
                type += &quot;|doc-start&quot;;
            var re = new RegExp(type);
            var range = new Range();
            if (dir != 1) {
                do {
                    token = iterator.stepBackward();
                } while (token &amp;&amp; re.test(token.type) &amp;&amp; !/^comment.end/.test(token.type));
                token = iterator.stepForward();
            }
            range.start.row = iterator.getCurrentTokenRow();
            range.start.column = iterator.getCurrentTokenColumn() + (/^comment.start/.test(token.type) ? token.value.length : 2);
            iterator = new TokenIterator(this, row, column);
            if (dir != -1) {
                var lastRow = -1;
                do {
                    token = iterator.stepForward();
                    if (lastRow == -1) {
                        var state = this.getState(iterator.$row);
                        if (!re.test(state))
                            lastRow = iterator.$row;
                    }
                    else if (iterator.$row &gt; lastRow) {
                        break;
                    }
                } while (token &amp;&amp; re.test(token.type) &amp;&amp; !/^comment.start/.test(token.type));
                token = iterator.stepBackward();
            }
            else
                token = iterator.getCurrentToken();
            range.end.row = iterator.getCurrentTokenRow();
            range.end.column = iterator.getCurrentTokenColumn();
            if (!/^comment.end/.test(token.type)) {
                range.end.column += token.value.length - 2;
            }
            return range;
        }
    };
    this.foldAll = function (startRow, endRow, depth, test) {
        if (depth == undefined)
            depth = 100000; // JSON.stringify doesn&#039;t hanle Infinity
        var foldWidgets = this.foldWidgets;
        if (!foldWidgets)
            return; // mode doesn&#039;t support folding
        endRow = endRow || this.getLength();
        startRow = startRow || 0;
        for (var row = startRow; row &lt; endRow; row++) {
            if (foldWidgets[row] == null)
                foldWidgets[row] = this.getFoldWidget(row);
            if (foldWidgets[row] != &quot;start&quot;)
                continue;
            if (test &amp;&amp; !test(row))
                continue;
            var range = this.getFoldWidgetRange(row);
            if (range &amp;&amp; range.isMultiLine()
                &amp;&amp; range.end.row &lt;= endRow
                &amp;&amp; range.start.row &gt;= startRow) {
                row = range.end.row;
                range.collapseChildren = depth;
                this.addFold(&quot;...&quot;, range);
            }
        }
    };
    this.foldToLevel = function (level) {
        this.foldAll();
        while (level-- &gt; 0)
            this.unfold(null, false);
    };
    this.foldAllComments = function () {
        var session = this;
        this.foldAll(null, null, null, function (row) {
            var tokens = session.getTokens(row);
            for (var i = 0; i &lt; tokens.length; i++) {
                var token = tokens[i];
                if (token.type == &quot;text&quot; &amp;&amp; /^\s+$/.test(token.value))
                    continue;
                if (/comment/.test(token.type))
                    return true;
                return false;
            }
        });
    };
    this.$foldStyles = {
        &quot;manual&quot;: 1,
        &quot;markbegin&quot;: 1,
        &quot;markbeginend&quot;: 1
    };
    this.$foldStyle = &quot;markbegin&quot;;
    this.setFoldStyle = function (style) {
        if (!this.$foldStyles[style])
            throw new Error(&quot;invalid fold style: &quot; + style + &quot;[&quot; + Object.keys(this.$foldStyles).join(&quot;, &quot;) + &quot;]&quot;);
        if (this.$foldStyle == style)
            return;
        this.$foldStyle = style;
        if (style == &quot;manual&quot;)
            this.unfold();
        var mode = this.$foldMode;
        this.$setFolding(null);
        this.$setFolding(mode);
    };
    this.$setFolding = function (foldMode) {
        if (this.$foldMode == foldMode)
            return;
        this.$foldMode = foldMode;
        this.off(&#039;change&#039;, this.$updateFoldWidgets);
        this.off(&#039;tokenizerUpdate&#039;, this.$tokenizerUpdateFoldWidgets);
        this._signal(&quot;changeAnnotation&quot;);
        if (!foldMode || this.$foldStyle == &quot;manual&quot;) {
            this.foldWidgets = null;
            return;
        }
        this.foldWidgets = [];
        this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
        this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
        this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
        this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
        this.on(&#039;change&#039;, this.$updateFoldWidgets);
        this.on(&#039;tokenizerUpdate&#039;, this.$tokenizerUpdateFoldWidgets);
    };
    this.getParentFoldRangeData = function (row, ignoreCurrent) {
        var fw = this.foldWidgets;
        if (!fw || (ignoreCurrent &amp;&amp; fw[row]))
            return {};
        var i = row - 1, firstRange;
        while (i &gt;= 0) {
            var c = fw[i];
            if (c == null)
                c = fw[i] = this.getFoldWidget(i);
            if (c == &quot;start&quot;) {
                var range = this.getFoldWidgetRange(i);
                if (!firstRange)
                    firstRange = range;
                if (range &amp;&amp; range.end.row &gt;= row)
                    break;
            }
            i--;
        }
        return {
            range: i !== -1 &amp;&amp; range,
            firstRange: firstRange
        };
    };
    this.onFoldWidgetClick = function (row, e) {
        e = e.domEvent;
        var options = {
            children: e.shiftKey,
            all: e.ctrlKey || e.metaKey,
            siblings: e.altKey
        };
        var range = this.$toggleFoldWidget(row, options);
        if (!range) {
            var el = (e.target || e.srcElement);
            if (el &amp;&amp; /ace_fold-widget/.test(el.className))
                el.className += &quot; ace_invalid&quot;;
        }
    };
    this.$toggleFoldWidget = function (row, options) {
        if (!this.getFoldWidget)
            return;
        var type = this.getFoldWidget(row);
        var line = this.getLine(row);
        var dir = type === &quot;end&quot; ? -1 : 1;
        var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);
        if (fold) {
            if (options.children || options.all)
                this.removeFold(fold);
            else
                this.expandFold(fold);
            return fold;
        }
        var range = this.getFoldWidgetRange(row, true);
        if (range &amp;&amp; !range.isMultiLine()) {
            fold = this.getFoldAt(range.start.row, range.start.column, 1);
            if (fold &amp;&amp; range.isEqual(fold.range)) {
                this.removeFold(fold);
                return fold;
            }
        }
        if (options.siblings) {
            var data = this.getParentFoldRangeData(row);
            if (data.range) {
                var startRow = data.range.start.row + 1;
                var endRow = data.range.end.row;
            }
            this.foldAll(startRow, endRow, options.all ? 10000 : 0);
        }
        else if (options.children) {
            endRow = range ? range.end.row : this.getLength();
            this.foldAll(row + 1, endRow, options.all ? 10000 : 0);
        }
        else if (range) {
            if (options.all)
                range.collapseChildren = 10000;
            this.addFold(&quot;...&quot;, range);
        }
        return range;
    };
    this.toggleFoldWidget = function (toggleParent) {
        var row = this.selection.getCursor().row;
        row = this.getRowFoldStart(row);
        var range = this.$toggleFoldWidget(row, {});
        if (range)
            return;
        var data = this.getParentFoldRangeData(row, true);
        range = data.range || data.firstRange;
        if (range) {
            row = range.start.row;
            var fold = this.getFoldAt(row, this.getLine(row).length, 1);
            if (fold) {
                this.removeFold(fold);
            }
            else {
                this.addFold(&quot;...&quot;, range);
            }
        }
    };
    this.updateFoldWidgets = function (delta) {
        var firstRow = delta.start.row;
        var len = delta.end.row - firstRow;
        if (len === 0) {
            this.foldWidgets[firstRow] = null;
        }
        else if (delta.action == &#039;remove&#039;) {
            this.foldWidgets.splice(firstRow, len + 1, null);
        }
        else {
            var args = Array(len + 1);
            args.unshift(firstRow, 1);
            this.foldWidgets.splice.apply(this.foldWidgets, args);
        }
    };
    this.tokenizerUpdateFoldWidgets = function (e) {
        var rows = e.data;
        if (rows.first != rows.last) {
            if (this.foldWidgets.length &gt; rows.first)
                this.foldWidgets.splice(rows.first, this.foldWidgets.length);
        }
    };
}
exports.Folding = Folding;

});

define(&quot;ace/edit_session/bracket_match&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/token_iterator&quot;,&quot;ace/range&quot;], function(require, exports, module){&quot;use strict&quot;;
var TokenIterator = require(&quot;../token_iterator&quot;).TokenIterator;
var Range = require(&quot;../range&quot;).Range;
function BracketMatch() {
    this.findMatchingBracket = function (position, chr) {
        if (position.column == 0)
            return null;
        var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column - 1);
        if (charBeforeCursor == &quot;&quot;)
            return null;
        var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
        if (!match)
            return null;
        if (match[1])
            return this.$findClosingBracket(match[1], position);
        else
            return this.$findOpeningBracket(match[2], position);
    };
    this.getBracketRange = function (pos) {
        var line = this.getLine(pos.row);
        var before = true, range;
        var chr = line.charAt(pos.column - 1);
        var match = chr &amp;&amp; chr.match(/([\(\[\{])|([\)\]\}])/);
        if (!match) {
            chr = line.charAt(pos.column);
            pos = { row: pos.row, column: pos.column + 1 };
            match = chr &amp;&amp; chr.match(/([\(\[\{])|([\)\]\}])/);
            before = false;
        }
        if (!match)
            return null;
        if (match[1]) {
            var bracketPos = this.$findClosingBracket(match[1], pos);
            if (!bracketPos)
                return null;
            range = Range.fromPoints(pos, bracketPos);
            if (!before) {
                range.end.column++;
                range.start.column--;
            }
            range.cursor = range.end;
        }
        else {
            var bracketPos = this.$findOpeningBracket(match[2], pos);
            if (!bracketPos)
                return null;
            range = Range.fromPoints(bracketPos, pos);
            if (!before) {
                range.start.column++;
                range.end.column--;
            }
            range.cursor = range.start;
        }
        return range;
    };
    this.getMatchingBracketRanges = function (pos, isBackwards) {
        var line = this.getLine(pos.row);
        var bracketsRegExp = /([\(\[\{])|([\)\]\}])/;
        var chr = !isBackwards &amp;&amp; line.charAt(pos.column - 1);
        var match = chr &amp;&amp; chr.match(bracketsRegExp);
        if (!match) {
            chr = (isBackwards === undefined || isBackwards) &amp;&amp; line.charAt(pos.column);
            pos = {
                row: pos.row,
                column: pos.column + 1
            };
            match = chr &amp;&amp; chr.match(bracketsRegExp);
        }
        if (!match)
            return null;
        var startRange = new Range(pos.row, pos.column - 1, pos.row, pos.column);
        var bracketPos = match[1] ? this.$findClosingBracket(match[1], pos)
            : this.$findOpeningBracket(match[2], pos);
        if (!bracketPos)
            return [startRange];
        var endRange = new Range(bracketPos.row, bracketPos.column, bracketPos.row, bracketPos.column + 1);
        return [startRange, endRange];
    };
    this.$brackets = {
        &quot;)&quot;: &quot;(&quot;,
        &quot;(&quot;: &quot;)&quot;,
        &quot;]&quot;: &quot;[&quot;,
        &quot;[&quot;: &quot;]&quot;,
        &quot;{&quot;: &quot;}&quot;,
        &quot;}&quot;: &quot;{&quot;,
        &quot;&lt;&quot;: &quot;&gt;&quot;,
        &quot;&gt;&quot;: &quot;&lt;&quot;
    };
    this.$findOpeningBracket = function (bracket, position, typeRe) {
        var openBracket = this.$brackets[bracket];
        var depth = 1;
        var iterator = new TokenIterator(this, position.row, position.column);
        var token = iterator.getCurrentToken();
        if (!token)
            token = iterator.stepForward();
        if (!token)
            return;
        if (!typeRe) {
            typeRe = new RegExp(&quot;(\\.?&quot; +
                token.type.replace(&quot;.&quot;, &quot;\\.&quot;).replace(&quot;rparen&quot;, &quot;.paren&quot;)
                    .replace(/\b(?:end)\b/, &quot;(?:start|begin|end)&quot;)
                + &quot;)+&quot;);
        }
        var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
        var value = token.value;
        while (true) {
            while (valueIndex &gt;= 0) {
                var chr = value.charAt(valueIndex);
                if (chr == openBracket) {
                    depth -= 1;
                    if (depth == 0) {
                        return { row: iterator.getCurrentTokenRow(),
                            column: valueIndex + iterator.getCurrentTokenColumn() };
                    }
                }
                else if (chr == bracket) {
                    depth += 1;
                }
                valueIndex -= 1;
            }
            do {
                token = iterator.stepBackward();
            } while (token &amp;&amp; !typeRe.test(token.type));
            if (token == null)
                break;
            value = token.value;
            valueIndex = value.length - 1;
        }
        return null;
    };
    this.$findClosingBracket = function (bracket, position, typeRe) {
        var closingBracket = this.$brackets[bracket];
        var depth = 1;
        var iterator = new TokenIterator(this, position.row, position.column);
        var token = iterator.getCurrentToken();
        if (!token)
            token = iterator.stepForward();
        if (!token)
            return;
        if (!typeRe) {
            typeRe = new RegExp(&quot;(\\.?&quot; +
                token.type.replace(&quot;.&quot;, &quot;\\.&quot;).replace(&quot;lparen&quot;, &quot;.paren&quot;)
                    .replace(/\b(?:start|begin)\b/, &quot;(?:start|begin|end)&quot;)
                + &quot;)+&quot;);
        }
        var valueIndex = position.column - iterator.getCurrentTokenColumn();
        while (true) {
            var value = token.value;
            var valueLength = value.length;
            while (valueIndex &lt; valueLength) {
                var chr = value.charAt(valueIndex);
                if (chr == closingBracket) {
                    depth -= 1;
                    if (depth == 0) {
                        return { row: iterator.getCurrentTokenRow(),
                            column: valueIndex + iterator.getCurrentTokenColumn() };
                    }
                }
                else if (chr == bracket) {
                    depth += 1;
                }
                valueIndex += 1;
            }
            do {
                token = iterator.stepForward();
            } while (token &amp;&amp; !typeRe.test(token.type));
            if (token == null)
                break;
            valueIndex = 0;
        }
        return null;
    };
    this.getMatchingTags = function (pos) {
        var iterator = new TokenIterator(this, pos.row, pos.column);
        var token = this.$findTagName(iterator);
        if (!token)
            return;
        var prevToken = iterator.stepBackward();
        if (prevToken.value === &#039;&lt;&#039;) {
            return this.$findClosingTag(iterator, token);
        }
        else {
            return this.$findOpeningTag(iterator, token);
        }
    };
    this.$findTagName = function (iterator) {
        var token = iterator.getCurrentToken();
        var found = false;
        var backward = false;
        if (token &amp;&amp; token.type.indexOf(&#039;tag-name&#039;) === -1) {
            do {
                if (backward)
                    token = iterator.stepBackward();
                else
                    token = iterator.stepForward();
                if (token) {
                    if (token.value === &quot;/&gt;&quot;) {
                        backward = true;
                    }
                    else if (token.type.indexOf(&#039;tag-name&#039;) !== -1) {
                        found = true;
                    }
                }
            } while (token &amp;&amp; !found);
        }
        return token;
    };
    this.$findClosingTag = function (iterator, token) {
        var prevToken;
        var currentTag = token.value;
        var tag = token.value;
        var depth = 0;
        var openTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
        token = iterator.stepForward();
        var openTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
        var foundOpenTagEnd = false;
        do {
            prevToken = token;
            token = iterator.stepForward();
            if (token) {
                if (token.value === &#039;&gt;&#039; &amp;&amp; !foundOpenTagEnd) {
                    var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for `&gt;`
                    foundOpenTagEnd = true;
                }
                if (token.type.indexOf(&#039;tag-name&#039;) !== -1) {
                    currentTag = token.value;
                    if (tag === currentTag) {
                        if (prevToken.value === &#039;&lt;&#039;) {
                            depth++;
                        }
                        else if (prevToken.value === &#039;&lt;/&#039;) {
                            depth--;
                            if (depth &lt; 0) { //found closing tag
                                iterator.stepBackward();
                                var closeTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 2); //Range for &lt;/
                                token = iterator.stepForward();
                                var closeTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
                                token = iterator.stepForward();
                                if (token &amp;&amp; token.value === &#039;&gt;&#039;) {
                                    var closeTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for &gt;
                                }
                                else {
                                    return;
                                }
                            }
                        }
                    }
                }
                else if (tag === currentTag &amp;&amp; token.value === &#039;/&gt;&#039;) { // self-closing tag
                    depth--;
                    if (depth &lt; 0) { //found self-closing tag end
                        var closeTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 2);
                        var closeTagName = closeTagStart;
                        var closeTagEnd = closeTagName;
                        var openTagEnd = new Range(openTagName.end.row, openTagName.end.column, openTagName.end.row, openTagName.end.column + 1);
                    }
                }
            }
        } while (token &amp;&amp; depth &gt;= 0);
        if (openTagStart &amp;&amp; openTagEnd &amp;&amp; closeTagStart &amp;&amp; closeTagEnd &amp;&amp; openTagName &amp;&amp; closeTagName) {
            return {
                openTag: new Range(openTagStart.start.row, openTagStart.start.column, openTagEnd.end.row, openTagEnd.end.column),
                closeTag: new Range(closeTagStart.start.row, closeTagStart.start.column, closeTagEnd.end.row, closeTagEnd.end.column),
                openTagName: openTagName,
                closeTagName: closeTagName
            };
        }
    };
    this.$findOpeningTag = function (iterator, token) {
        var prevToken = iterator.getCurrentToken();
        var tag = token.value;
        var depth = 0;
        var startRow = iterator.getCurrentTokenRow();
        var startColumn = iterator.getCurrentTokenColumn();
        var endColumn = startColumn + 2;
        var closeTagStart = new Range(startRow, startColumn, startRow, endColumn); //Range for &lt;/
        iterator.stepForward();
        var closeTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
        token = iterator.stepForward();
        if (!token || token.value !== &quot;&gt;&quot;)
            return;
        var closeTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for &gt;
        iterator.stepBackward();
        iterator.stepBackward();
        do {
            token = prevToken;
            startRow = iterator.getCurrentTokenRow();
            startColumn = iterator.getCurrentTokenColumn();
            endColumn = startColumn + token.value.length;
            prevToken = iterator.stepBackward();
            if (token) {
                if (token.type.indexOf(&#039;tag-name&#039;) !== -1) {
                    if (tag === token.value) {
                        if (prevToken.value === &#039;&lt;&#039;) {
                            depth++;
                            if (depth &gt; 0) { //found opening tag
                                var openTagName = new Range(startRow, startColumn, startRow, endColumn);
                                var openTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for &lt;
                                do {
                                    token = iterator.stepForward();
                                } while (token &amp;&amp; token.value !== &#039;&gt;&#039;);
                                var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for &gt;
                            }
                        }
                        else if (prevToken.value === &#039;&lt;/&#039;) {
                            depth--;
                        }
                    }
                }
                else if (token.value === &#039;/&gt;&#039;) { // self-closing tag
                    var stepCount = 0;
                    var tmpToken = prevToken;
                    while (tmpToken) {
                        if (tmpToken.type.indexOf(&#039;tag-name&#039;) !== -1 &amp;&amp; tmpToken.value === tag) {
                            depth--;
                            break;
                        }
                        else if (tmpToken.value === &#039;&lt;&#039;) {
                            break;
                        }
                        tmpToken = iterator.stepBackward();
                        stepCount++;
                    }
                    for (var i = 0; i &lt; stepCount; i++) {
                        iterator.stepForward();
                    }
                }
            }
        } while (prevToken &amp;&amp; depth &lt;= 0);
        if (openTagStart &amp;&amp; openTagEnd &amp;&amp; closeTagStart &amp;&amp; closeTagEnd &amp;&amp; openTagName &amp;&amp; closeTagName) {
            return {
                openTag: new Range(openTagStart.start.row, openTagStart.start.column, openTagEnd.end.row, openTagEnd.end.column),
                closeTag: new Range(closeTagStart.start.row, closeTagStart.start.column, closeTagEnd.end.row, closeTagEnd.end.column),
                openTagName: openTagName,
                closeTagName: closeTagName
            };
        }
    };
}
exports.BracketMatch = BracketMatch;

});

define(&quot;ace/edit_session&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/lang&quot;,&quot;ace/bidihandler&quot;,&quot;ace/config&quot;,&quot;ace/lib/event_emitter&quot;,&quot;ace/selection&quot;,&quot;ace/mode/text&quot;,&quot;ace/range&quot;,&quot;ace/document&quot;,&quot;ace/background_tokenizer&quot;,&quot;ace/search_highlight&quot;,&quot;ace/edit_session/folding&quot;,&quot;ace/edit_session/bracket_match&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;./lib/oop&quot;);
var lang = require(&quot;./lib/lang&quot;);
var BidiHandler = require(&quot;./bidihandler&quot;).BidiHandler;
var config = require(&quot;./config&quot;);
var EventEmitter = require(&quot;./lib/event_emitter&quot;).EventEmitter;
var Selection = require(&quot;./selection&quot;).Selection;
var TextMode = require(&quot;./mode/text&quot;).Mode;
var Range = require(&quot;./range&quot;).Range;
var Document = require(&quot;./document&quot;).Document;
var BackgroundTokenizer = require(&quot;./background_tokenizer&quot;).BackgroundTokenizer;
var SearchHighlight = require(&quot;./search_highlight&quot;).SearchHighlight;
var EditSession = function (text, mode) {
    this.$breakpoints = [];
    this.$decorations = [];
    this.$frontMarkers = {};
    this.$backMarkers = {};
    this.$markerId = 1;
    this.$undoSelect = true;
    this.$foldData = [];
    this.id = &quot;session&quot; + (++EditSession.$uid);
    this.$foldData.toString = function () {
        return this.join(&quot;\n&quot;);
    };
    this.bgTokenizer = new BackgroundTokenizer((new TextMode()).getTokenizer(), this);
    var _self = this;
    this.bgTokenizer.on(&quot;update&quot;, function (e) {
        _self._signal(&quot;tokenizerUpdate&quot;, e);
    });
    this.on(&quot;changeFold&quot;, this.onChangeFold.bind(this));
    this.$onChange = this.onChange.bind(this);
    if (typeof text != &quot;object&quot; || !text.getLine)
        text = new Document(text);
    this.setDocument(text);
    this.selection = new Selection(this);
    this.$bidiHandler = new BidiHandler(this);
    config.resetOptions(this);
    this.setMode(mode);
    config._signal(&quot;session&quot;, this);
    this.destroyed = false;
};
EditSession.$uid = 0;
(function () {
    oop.implement(this, EventEmitter);
    this.setDocument = function (doc) {
        if (this.doc)
            this.doc.off(&quot;change&quot;, this.$onChange);
        this.doc = doc;
        doc.on(&quot;change&quot;, this.$onChange, true);
        this.bgTokenizer.setDocument(this.getDocument());
        this.resetCaches();
    };
    this.getDocument = function () {
        return this.doc;
    };
    this.$resetRowCache = function (docRow) {
        if (!docRow) {
            this.$docRowCache = [];
            this.$screenRowCache = [];
            return;
        }
        var l = this.$docRowCache.length;
        var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
        if (l &gt; i) {
            this.$docRowCache.splice(i, l);
            this.$screenRowCache.splice(i, l);
        }
    };
    this.$getRowCacheIndex = function (cacheArray, val) {
        var low = 0;
        var hi = cacheArray.length - 1;
        while (low &lt;= hi) {
            var mid = (low + hi) &gt;&gt; 1;
            var c = cacheArray[mid];
            if (val &gt; c)
                low = mid + 1;
            else if (val &lt; c)
                hi = mid - 1;
            else
                return mid;
        }
        return low - 1;
    };
    this.resetCaches = function () {
        this.$modified = true;
        this.$wrapData = [];
        this.$rowLengthCache = [];
        this.$resetRowCache(0);
        if (!this.destroyed)
            this.bgTokenizer.start(0);
    };
    this.onChangeFold = function (e) {
        var fold = e.data;
        this.$resetRowCache(fold.start.row);
    };
    this.onChange = function (delta) {
        this.$modified = true;
        this.$bidiHandler.onChange(delta);
        this.$resetRowCache(delta.start.row);
        var removedFolds = this.$updateInternalDataOnChange(delta);
        if (!this.$fromUndo &amp;&amp; this.$undoManager) {
            if (removedFolds &amp;&amp; removedFolds.length) {
                this.$undoManager.add({
                    action: &quot;removeFolds&quot;,
                    folds: removedFolds
                }, this.mergeUndoDeltas);
                this.mergeUndoDeltas = true;
            }
            this.$undoManager.add(delta, this.mergeUndoDeltas);
            this.mergeUndoDeltas = true;
            this.$informUndoManager.schedule();
        }
        this.bgTokenizer.$updateOnChange(delta);
        this._signal(&quot;change&quot;, delta);
    };
    this.setValue = function (text) {
        this.doc.setValue(text);
        this.selection.moveTo(0, 0);
        this.$resetRowCache(0);
        this.setUndoManager(this.$undoManager);
        this.getUndoManager().reset();
    };
    this.getValue =
        this.toString = function () {
            return this.doc.getValue();
        };
    this.getSelection = function () {
        return this.selection;
    };
    this.getState = function (row) {
        return this.bgTokenizer.getState(row);
    };
    this.getTokens = function (row) {
        return this.bgTokenizer.getTokens(row);
    };
    this.getTokenAt = function (row, column) {
        var tokens = this.bgTokenizer.getTokens(row);
        var token, c = 0;
        if (column == null) {
            var i = tokens.length - 1;
            c = this.getLine(row).length;
        }
        else {
            for (var i = 0; i &lt; tokens.length; i++) {
                c += tokens[i].value.length;
                if (c &gt;= column)
                    break;
            }
        }
        token = tokens[i];
        if (!token)
            return null;
        token.index = i;
        token.start = c - token.value.length;
        return token;
    };
    this.setUndoManager = function (undoManager) {
        this.$undoManager = undoManager;
        if (this.$informUndoManager)
            this.$informUndoManager.cancel();
        if (undoManager) {
            var self = this;
            undoManager.addSession(this);
            this.$syncInformUndoManager = function () {
                self.$informUndoManager.cancel();
                self.mergeUndoDeltas = false;
            };
            this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
        }
        else {
            this.$syncInformUndoManager = function () { };
        }
    };
    this.markUndoGroup = function () {
        if (this.$syncInformUndoManager)
            this.$syncInformUndoManager();
    };
    this.$defaultUndoManager = {
        undo: function () { },
        redo: function () { },
        hasUndo: function () { },
        hasRedo: function () { },
        reset: function () { },
        add: function () { },
        addSelection: function () { },
        startNewGroup: function () { },
        addSession: function () { }
    };
    this.getUndoManager = function () {
        return this.$undoManager || this.$defaultUndoManager;
    };
    this.getTabString = function () {
        if (this.getUseSoftTabs()) {
            return lang.stringRepeat(&quot; &quot;, this.getTabSize());
        }
        else {
            return &quot;\t&quot;;
        }
    };
    this.setUseSoftTabs = function (val) {
        this.setOption(&quot;useSoftTabs&quot;, val);
    };
    this.getUseSoftTabs = function () {
        return this.$useSoftTabs &amp;&amp; !this.$mode.$indentWithTabs;
    };
    this.setTabSize = function (tabSize) {
        this.setOption(&quot;tabSize&quot;, tabSize);
    };
    this.getTabSize = function () {
        return this.$tabSize;
    };
    this.isTabStop = function (position) {
        return this.$useSoftTabs &amp;&amp; (position.column % this.$tabSize === 0);
    };
    this.setNavigateWithinSoftTabs = function (navigateWithinSoftTabs) {
        this.setOption(&quot;navigateWithinSoftTabs&quot;, navigateWithinSoftTabs);
    };
    this.getNavigateWithinSoftTabs = function () {
        return this.$navigateWithinSoftTabs;
    };
    this.$overwrite = false;
    this.setOverwrite = function (overwrite) {
        this.setOption(&quot;overwrite&quot;, overwrite);
    };
    this.getOverwrite = function () {
        return this.$overwrite;
    };
    this.toggleOverwrite = function () {
        this.setOverwrite(!this.$overwrite);
    };
    this.addGutterDecoration = function (row, className) {
        if (!this.$decorations[row])
            this.$decorations[row] = &quot;&quot;;
        this.$decorations[row] += &quot; &quot; + className;
        this._signal(&quot;changeBreakpoint&quot;, {});
    };
    this.removeGutterDecoration = function (row, className) {
        this.$decorations[row] = (this.$decorations[row] || &quot;&quot;).replace(&quot; &quot; + className, &quot;&quot;);
        this._signal(&quot;changeBreakpoint&quot;, {});
    };
    this.getBreakpoints = function () {
        return this.$breakpoints;
    };
    this.setBreakpoints = function (rows) {
        this.$breakpoints = [];
        for (var i = 0; i &lt; rows.length; i++) {
            this.$breakpoints[rows[i]] = &quot;ace_breakpoint&quot;;
        }
        this._signal(&quot;changeBreakpoint&quot;, {});
    };
    this.clearBreakpoints = function () {
        this.$breakpoints = [];
        this._signal(&quot;changeBreakpoint&quot;, {});
    };
    this.setBreakpoint = function (row, className) {
        if (className === undefined)
            className = &quot;ace_breakpoint&quot;;
        if (className)
            this.$breakpoints[row] = className;
        else
            delete this.$breakpoints[row];
        this._signal(&quot;changeBreakpoint&quot;, {});
    };
    this.clearBreakpoint = function (row) {
        delete this.$breakpoints[row];
        this._signal(&quot;changeBreakpoint&quot;, {});
    };
    this.addMarker = function (range, clazz, type, inFront) {
        var id = this.$markerId++;
        var marker = {
            range: range,
            type: type || &quot;line&quot;,
            renderer: typeof type == &quot;function&quot; ? type : null,
            clazz: clazz,
            inFront: !!inFront,
            id: id
        };
        if (inFront) {
            this.$frontMarkers[id] = marker;
            this._signal(&quot;changeFrontMarker&quot;);
        }
        else {
            this.$backMarkers[id] = marker;
            this._signal(&quot;changeBackMarker&quot;);
        }
        return id;
    };
    this.addDynamicMarker = function (marker, inFront) {
        if (!marker.update)
            return;
        var id = this.$markerId++;
        marker.id = id;
        marker.inFront = !!inFront;
        if (inFront) {
            this.$frontMarkers[id] = marker;
            this._signal(&quot;changeFrontMarker&quot;);
        }
        else {
            this.$backMarkers[id] = marker;
            this._signal(&quot;changeBackMarker&quot;);
        }
        return marker;
    };
    this.removeMarker = function (markerId) {
        var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
        if (!marker)
            return;
        var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
        delete (markers[markerId]);
        this._signal(marker.inFront ? &quot;changeFrontMarker&quot; : &quot;changeBackMarker&quot;);
    };
    this.getMarkers = function (inFront) {
        return inFront ? this.$frontMarkers : this.$backMarkers;
    };
    this.highlight = function (re) {
        if (!this.$searchHighlight) {
            var highlight = new SearchHighlight(null, &quot;ace_selected-word&quot;, &quot;text&quot;);
            this.$searchHighlight = this.addDynamicMarker(highlight);
        }
        this.$searchHighlight.setRegexp(re);
    };
    this.highlightLines = function (startRow, endRow, clazz, inFront) {
        if (typeof endRow != &quot;number&quot;) {
            clazz = endRow;
            endRow = startRow;
        }
        if (!clazz)
            clazz = &quot;ace_step&quot;;
        var range = new Range(startRow, 0, endRow, Infinity);
        range.id = this.addMarker(range, clazz, &quot;fullLine&quot;, inFront);
        return range;
    };
    this.setAnnotations = function (annotations) {
        this.$annotations = annotations;
        this._signal(&quot;changeAnnotation&quot;, {});
    };
    this.getAnnotations = function () {
        return this.$annotations || [];
    };
    this.clearAnnotations = function () {
        this.setAnnotations([]);
    };
    this.$detectNewLine = function (text) {
        var match = text.match(/^.*?(\r?\n)/m);
        if (match) {
            this.$autoNewLine = match[1];
        }
        else {
            this.$autoNewLine = &quot;\n&quot;;
        }
    };
    this.getWordRange = function (row, column) {
        var line = this.getLine(row);
        var inToken = false;
        if (column &gt; 0)
            inToken = !!line.charAt(column - 1).match(this.tokenRe);
        if (!inToken)
            inToken = !!line.charAt(column).match(this.tokenRe);
        if (inToken)
            var re = this.tokenRe;
        else if (/^\s+$/.test(line.slice(column - 1, column + 1)))
            var re = /\s/;
        else
            var re = this.nonTokenRe;
        var start = column;
        if (start &gt; 0) {
            do {
                start--;
            } while (start &gt;= 0 &amp;&amp; line.charAt(start).match(re));
            start++;
        }
        var end = column;
        while (end &lt; line.length &amp;&amp; line.charAt(end).match(re)) {
            end++;
        }
        return new Range(row, start, row, end);
    };
    this.getAWordRange = function (row, column) {
        var wordRange = this.getWordRange(row, column);
        var line = this.getLine(wordRange.end.row);
        while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
            wordRange.end.column += 1;
        }
        return wordRange;
    };
    this.setNewLineMode = function (newLineMode) {
        this.doc.setNewLineMode(newLineMode);
    };
    this.getNewLineMode = function () {
        return this.doc.getNewLineMode();
    };
    this.setUseWorker = function (useWorker) { this.setOption(&quot;useWorker&quot;, useWorker); };
    this.getUseWorker = function () { return this.$useWorker; };
    this.onReloadTokenizer = function (e) {
        var rows = e.data;
        this.bgTokenizer.start(rows.first);
        this._signal(&quot;tokenizerUpdate&quot;, e);
    };
    this.$modes = config.$modes;
    this.$mode = null;
    this.$modeId = null;
    this.setMode = function (mode, cb) {
        if (mode &amp;&amp; typeof mode === &quot;object&quot;) {
            if (mode.getTokenizer)
                return this.$onChangeMode(mode);
            var options = mode;
            var path = options.path;
        }
        else {
            path = mode || &quot;ace/mode/text&quot;;
        }
        if (!this.$modes[&quot;ace/mode/text&quot;])
            this.$modes[&quot;ace/mode/text&quot;] = new TextMode();
        if (this.$modes[path] &amp;&amp; !options) {
            this.$onChangeMode(this.$modes[path]);
            cb &amp;&amp; cb();
            return;
        }
        this.$modeId = path;
        config.loadModule([&quot;mode&quot;, path], function (m) {
            if (this.$modeId !== path)
                return cb &amp;&amp; cb();
            if (this.$modes[path] &amp;&amp; !options) {
                this.$onChangeMode(this.$modes[path]);
            }
            else if (m &amp;&amp; m.Mode) {
                m = new m.Mode(options);
                if (!options) {
                    this.$modes[path] = m;
                    m.$id = path;
                }
                this.$onChangeMode(m);
            }
            cb &amp;&amp; cb();
        }.bind(this));
        if (!this.$mode)
            this.$onChangeMode(this.$modes[&quot;ace/mode/text&quot;], true);
    };
    this.$onChangeMode = function (mode, $isPlaceholder) {
        if (!$isPlaceholder)
            this.$modeId = mode.$id;
        if (this.$mode === mode)
            return;
        var oldMode = this.$mode;
        this.$mode = mode;
        this.$stopWorker();
        if (this.$useWorker)
            this.$startWorker();
        var tokenizer = mode.getTokenizer();
        if (tokenizer.on !== undefined) {
            var onReloadTokenizer = this.onReloadTokenizer.bind(this);
            tokenizer.on(&quot;update&quot;, onReloadTokenizer);
        }
        this.bgTokenizer.setTokenizer(tokenizer);
        this.bgTokenizer.setDocument(this.getDocument());
        this.tokenRe = mode.tokenRe;
        this.nonTokenRe = mode.nonTokenRe;
        if (!$isPlaceholder) {
            if (mode.attachToSession)
                mode.attachToSession(this);
            this.$options.wrapMethod.set.call(this, this.$wrapMethod);
            this.$setFolding(mode.foldingRules);
            this.bgTokenizer.start(0);
            this._emit(&quot;changeMode&quot;, { oldMode: oldMode, mode: mode });
        }
    };
    this.$stopWorker = function () {
        if (this.$worker) {
            this.$worker.terminate();
            this.$worker = null;
        }
    };
    this.$startWorker = function () {
        try {
            this.$worker = this.$mode.createWorker(this);
        }
        catch (e) {
            config.warn(&quot;Could not load worker&quot;, e);
            this.$worker = null;
        }
    };
    this.getMode = function () {
        return this.$mode;
    };
    this.$scrollTop = 0;
    this.setScrollTop = function (scrollTop) {
        if (this.$scrollTop === scrollTop || isNaN(scrollTop))
            return;
        this.$scrollTop = scrollTop;
        this._signal(&quot;changeScrollTop&quot;, scrollTop);
    };
    this.getScrollTop = function () {
        return this.$scrollTop;
    };
    this.$scrollLeft = 0;
    this.setScrollLeft = function (scrollLeft) {
        if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
            return;
        this.$scrollLeft = scrollLeft;
        this._signal(&quot;changeScrollLeft&quot;, scrollLeft);
    };
    this.getScrollLeft = function () {
        return this.$scrollLeft;
    };
    this.getScreenWidth = function () {
        this.$computeWidth();
        if (this.lineWidgets)
            return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
        return this.screenWidth;
    };
    this.getLineWidgetMaxWidth = function () {
        if (this.lineWidgetsWidth != null)
            return this.lineWidgetsWidth;
        var width = 0;
        this.lineWidgets.forEach(function (w) {
            if (w &amp;&amp; w.screenWidth &gt; width)
                width = w.screenWidth;
        });
        return this.lineWidgetWidth = width;
    };
    this.$computeWidth = function (force) {
        if (this.$modified || force) {
            this.$modified = false;
            if (this.$useWrapMode)
                return this.screenWidth = this.$wrapLimit;
            var lines = this.doc.getAllLines();
            var cache = this.$rowLengthCache;
            var longestScreenLine = 0;
            var foldIndex = 0;
            var foldLine = this.$foldData[foldIndex];
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            var len = lines.length;
            for (var i = 0; i &lt; len; i++) {
                if (i &gt; foldStart) {
                    i = foldLine.end.row + 1;
                    if (i &gt;= len)
                        break;
                    foldLine = this.$foldData[foldIndex++];
                    foldStart = foldLine ? foldLine.start.row : Infinity;
                }
                if (cache[i] == null)
                    cache[i] = this.$getStringScreenWidth(lines[i])[0];
                if (cache[i] &gt; longestScreenLine)
                    longestScreenLine = cache[i];
            }
            this.screenWidth = longestScreenLine;
        }
    };
    this.getLine = function (row) {
        return this.doc.getLine(row);
    };
    this.getLines = function (firstRow, lastRow) {
        return this.doc.getLines(firstRow, lastRow);
    };
    this.getLength = function () {
        return this.doc.getLength();
    };
    this.getTextRange = function (range) {
        return this.doc.getTextRange(range || this.selection.getRange());
    };
    this.insert = function (position, text) {
        return this.doc.insert(position, text);
    };
    this.remove = function (range) {
        return this.doc.remove(range);
    };
    this.removeFullLines = function (firstRow, lastRow) {
        return this.doc.removeFullLines(firstRow, lastRow);
    };
    this.undoChanges = function (deltas, dontSelect) {
        if (!deltas.length)
            return;
        this.$fromUndo = true;
        for (var i = deltas.length - 1; i != -1; i--) {
            var delta = deltas[i];
            if (delta.action == &quot;insert&quot; || delta.action == &quot;remove&quot;) {
                this.doc.revertDelta(delta);
            }
            else if (delta.folds) {
                this.addFolds(delta.folds);
            }
        }
        if (!dontSelect &amp;&amp; this.$undoSelect) {
            if (deltas.selectionBefore)
                this.selection.fromJSON(deltas.selectionBefore);
            else
                this.selection.setRange(this.$getUndoSelection(deltas, true));
        }
        this.$fromUndo = false;
    };
    this.redoChanges = function (deltas, dontSelect) {
        if (!deltas.length)
            return;
        this.$fromUndo = true;
        for (var i = 0; i &lt; deltas.length; i++) {
            var delta = deltas[i];
            if (delta.action == &quot;insert&quot; || delta.action == &quot;remove&quot;) {
                this.doc.$safeApplyDelta(delta);
            }
        }
        if (!dontSelect &amp;&amp; this.$undoSelect) {
            if (deltas.selectionAfter)
                this.selection.fromJSON(deltas.selectionAfter);
            else
                this.selection.setRange(this.$getUndoSelection(deltas, false));
        }
        this.$fromUndo = false;
    };
    this.setUndoSelect = function (enable) {
        this.$undoSelect = enable;
    };
    this.$getUndoSelection = function (deltas, isUndo) {
        function isInsert(delta) {
            return isUndo ? delta.action !== &quot;insert&quot; : delta.action === &quot;insert&quot;;
        }
        var range, point;
        for (var i = 0; i &lt; deltas.length; i++) {
            var delta = deltas[i];
            if (!delta.start)
                continue; // skip folds
            if (!range) {
                if (isInsert(delta)) {
                    range = Range.fromPoints(delta.start, delta.end);
                }
                else {
                    range = Range.fromPoints(delta.start, delta.start);
                }
                continue;
            }
            if (isInsert(delta)) {
                point = delta.start;
                if (range.compare(point.row, point.column) == -1) {
                    range.setStart(point);
                }
                point = delta.end;
                if (range.compare(point.row, point.column) == 1) {
                    range.setEnd(point);
                }
            }
            else {
                point = delta.start;
                if (range.compare(point.row, point.column) == -1) {
                    range = Range.fromPoints(delta.start, delta.start);
                }
            }
        }
        return range;
    };
    this.replace = function (range, text) {
        return this.doc.replace(range, text);
    };
    this.moveText = function (fromRange, toPosition, copy) {
        var text = this.getTextRange(fromRange);
        var folds = this.getFoldsInRange(fromRange);
        var toRange = Range.fromPoints(toPosition, toPosition);
        if (!copy) {
            this.remove(fromRange);
            var rowDiff = fromRange.start.row - fromRange.end.row;
            var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
            if (collDiff) {
                if (toRange.start.row == fromRange.end.row &amp;&amp; toRange.start.column &gt; fromRange.end.column)
                    toRange.start.column += collDiff;
                if (toRange.end.row == fromRange.end.row &amp;&amp; toRange.end.column &gt; fromRange.end.column)
                    toRange.end.column += collDiff;
            }
            if (rowDiff &amp;&amp; toRange.start.row &gt;= fromRange.end.row) {
                toRange.start.row += rowDiff;
                toRange.end.row += rowDiff;
            }
        }
        toRange.end = this.insert(toRange.start, text);
        if (folds.length) {
            var oldStart = fromRange.start;
            var newStart = toRange.start;
            var rowDiff = newStart.row - oldStart.row;
            var collDiff = newStart.column - oldStart.column;
            this.addFolds(folds.map(function (x) {
                x = x.clone();
                if (x.start.row == oldStart.row)
                    x.start.column += collDiff;
                if (x.end.row == oldStart.row)
                    x.end.column += collDiff;
                x.start.row += rowDiff;
                x.end.row += rowDiff;
                return x;
            }));
        }
        return toRange;
    };
    this.indentRows = function (startRow, endRow, indentString) {
        indentString = indentString.replace(/\t/g, this.getTabString());
        for (var row = startRow; row &lt;= endRow; row++)
            this.doc.insertInLine({ row: row, column: 0 }, indentString);
    };
    this.outdentRows = function (range) {
        var rowRange = range.collapseRows();
        var deleteRange = new Range(0, 0, 0, 0);
        var size = this.getTabSize();
        for (var i = rowRange.start.row; i &lt;= rowRange.end.row; ++i) {
            var line = this.getLine(i);
            deleteRange.start.row = i;
            deleteRange.end.row = i;
            for (var j = 0; j &lt; size; ++j)
                if (line.charAt(j) != &#039; &#039;)
                    break;
            if (j &lt; size &amp;&amp; line.charAt(j) == &#039;\t&#039;) {
                deleteRange.start.column = j;
                deleteRange.end.column = j + 1;
            }
            else {
                deleteRange.start.column = 0;
                deleteRange.end.column = j;
            }
            this.remove(deleteRange);
        }
    };
    this.$moveLines = function (firstRow, lastRow, dir) {
        firstRow = this.getRowFoldStart(firstRow);
        lastRow = this.getRowFoldEnd(lastRow);
        if (dir &lt; 0) {
            var row = this.getRowFoldStart(firstRow + dir);
            if (row &lt; 0)
                return 0;
            var diff = row - firstRow;
        }
        else if (dir &gt; 0) {
            var row = this.getRowFoldEnd(lastRow + dir);
            if (row &gt; this.doc.getLength() - 1)
                return 0;
            var diff = row - lastRow;
        }
        else {
            firstRow = this.$clipRowToDocument(firstRow);
            lastRow = this.$clipRowToDocument(lastRow);
            var diff = lastRow - firstRow + 1;
        }
        var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
        var folds = this.getFoldsInRange(range).map(function (x) {
            x = x.clone();
            x.start.row += diff;
            x.end.row += diff;
            return x;
        });
        var lines = dir == 0
            ? this.doc.getLines(firstRow, lastRow)
            : this.doc.removeFullLines(firstRow, lastRow);
        this.doc.insertFullLines(firstRow + diff, lines);
        folds.length &amp;&amp; this.addFolds(folds);
        return diff;
    };
    this.moveLinesUp = function (firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, -1);
    };
    this.moveLinesDown = function (firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, 1);
    };
    this.duplicateLines = function (firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, 0);
    };
    this.$clipRowToDocument = function (row) {
        return Math.max(0, Math.min(row, this.doc.getLength() - 1));
    };
    this.$clipColumnToRow = function (row, column) {
        if (column &lt; 0)
            return 0;
        return Math.min(this.doc.getLine(row).length, column);
    };
    this.$clipPositionToDocument = function (row, column) {
        column = Math.max(0, column);
        if (row &lt; 0) {
            row = 0;
            column = 0;
        }
        else {
            var len = this.doc.getLength();
            if (row &gt;= len) {
                row = len - 1;
                column = this.doc.getLine(len - 1).length;
            }
            else {
                column = Math.min(this.doc.getLine(row).length, column);
            }
        }
        return {
            row: row,
            column: column
        };
    };
    this.$clipRangeToDocument = function (range) {
        if (range.start.row &lt; 0) {
            range.start.row = 0;
            range.start.column = 0;
        }
        else {
            range.start.column = this.$clipColumnToRow(range.start.row, range.start.column);
        }
        var len = this.doc.getLength() - 1;
        if (range.end.row &gt; len) {
            range.end.row = len;
            range.end.column = this.doc.getLine(len).length;
        }
        else {
            range.end.column = this.$clipColumnToRow(range.end.row, range.end.column);
        }
        return range;
    };
    this.$wrapLimit = 80;
    this.$useWrapMode = false;
    this.$wrapLimitRange = {
        min: null,
        max: null
    };
    this.setUseWrapMode = function (useWrapMode) {
        if (useWrapMode != this.$useWrapMode) {
            this.$useWrapMode = useWrapMode;
            this.$modified = true;
            this.$resetRowCache(0);
            if (useWrapMode) {
                var len = this.getLength();
                this.$wrapData = Array(len);
                this.$updateWrapData(0, len - 1);
            }
            this._signal(&quot;changeWrapMode&quot;);
        }
    };
    this.getUseWrapMode = function () {
        return this.$useWrapMode;
    };
    this.setWrapLimitRange = function (min, max) {
        if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
            this.$wrapLimitRange = { min: min, max: max };
            this.$modified = true;
            this.$bidiHandler.markAsDirty();
            if (this.$useWrapMode)
                this._signal(&quot;changeWrapMode&quot;);
        }
    };
    this.adjustWrapLimit = function (desiredLimit, $printMargin) {
        var limits = this.$wrapLimitRange;
        if (limits.max &lt; 0)
            limits = { min: $printMargin, max: $printMargin };
        var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
        if (wrapLimit != this.$wrapLimit &amp;&amp; wrapLimit &gt; 1) {
            this.$wrapLimit = wrapLimit;
            this.$modified = true;
            if (this.$useWrapMode) {
                this.$updateWrapData(0, this.getLength() - 1);
                this.$resetRowCache(0);
                this._signal(&quot;changeWrapLimit&quot;);
            }
            return true;
        }
        return false;
    };
    this.$constrainWrapLimit = function (wrapLimit, min, max) {
        if (min)
            wrapLimit = Math.max(min, wrapLimit);
        if (max)
            wrapLimit = Math.min(max, wrapLimit);
        return wrapLimit;
    };
    this.getWrapLimit = function () {
        return this.$wrapLimit;
    };
    this.setWrapLimit = function (limit) {
        this.setWrapLimitRange(limit, limit);
    };
    this.getWrapLimitRange = function () {
        return {
            min: this.$wrapLimitRange.min,
            max: this.$wrapLimitRange.max
        };
    };
    this.$updateInternalDataOnChange = function (delta) {
        var useWrapMode = this.$useWrapMode;
        var action = delta.action;
        var start = delta.start;
        var end = delta.end;
        var firstRow = start.row;
        var lastRow = end.row;
        var len = lastRow - firstRow;
        var removedFolds = null;
        this.$updating = true;
        if (len != 0) {
            if (action === &quot;remove&quot;) {
                this[useWrapMode ? &quot;$wrapData&quot; : &quot;$rowLengthCache&quot;].splice(firstRow, len);
                var foldLines = this.$foldData;
                removedFolds = this.getFoldsInRange(delta);
                this.removeFolds(removedFolds);
                var foldLine = this.getFoldLine(end.row);
                var idx = 0;
                if (foldLine) {
                    foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                    foldLine.shiftRow(-len);
                    var foldLineBefore = this.getFoldLine(firstRow);
                    if (foldLineBefore &amp;&amp; foldLineBefore !== foldLine) {
                        foldLineBefore.merge(foldLine);
                        foldLine = foldLineBefore;
                    }
                    idx = foldLines.indexOf(foldLine) + 1;
                }
                for (idx; idx &lt; foldLines.length; idx++) {
                    var foldLine = foldLines[idx];
                    if (foldLine.start.row &gt;= end.row) {
                        foldLine.shiftRow(-len);
                    }
                }
                lastRow = firstRow;
            }
            else {
                var args = Array(len);
                args.unshift(firstRow, 0);
                var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;
                arr.splice.apply(arr, args);
                var foldLines = this.$foldData;
                var foldLine = this.getFoldLine(firstRow);
                var idx = 0;
                if (foldLine) {
                    var cmp = foldLine.range.compareInside(start.row, start.column);
                    if (cmp == 0) {
                        foldLine = foldLine.split(start.row, start.column);
                        if (foldLine) {
                            foldLine.shiftRow(len);
                            foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
                        }
                    }
                    else 
                    if (cmp == -1) {
                        foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                        foldLine.shiftRow(len);
                    }
                    idx = foldLines.indexOf(foldLine) + 1;
                }
                for (idx; idx &lt; foldLines.length; idx++) {
                    var foldLine = foldLines[idx];
                    if (foldLine.start.row &gt;= firstRow) {
                        foldLine.shiftRow(len);
                    }
                }
            }
        }
        else {
            len = Math.abs(delta.start.column - delta.end.column);
            if (action === &quot;remove&quot;) {
                removedFolds = this.getFoldsInRange(delta);
                this.removeFolds(removedFolds);
                len = -len;
            }
            var foldLine = this.getFoldLine(firstRow);
            if (foldLine) {
                foldLine.addRemoveChars(firstRow, start.column, len);
            }
        }
        if (useWrapMode &amp;&amp; this.$wrapData.length != this.doc.getLength()) {
            console.error(&quot;doc.getLength() and $wrapData.length have to be the same!&quot;);
        }
        this.$updating = false;
        if (useWrapMode)
            this.$updateWrapData(firstRow, lastRow);
        else
            this.$updateRowLengthCache(firstRow, lastRow);
        return removedFolds;
    };
    this.$updateRowLengthCache = function (firstRow, lastRow, b) {
        this.$rowLengthCache[firstRow] = null;
        this.$rowLengthCache[lastRow] = null;
    };
    this.$updateWrapData = function (firstRow, lastRow) {
        var lines = this.doc.getAllLines();
        var tabSize = this.getTabSize();
        var wrapData = this.$wrapData;
        var wrapLimit = this.$wrapLimit;
        var tokens;
        var foldLine;
        var row = firstRow;
        lastRow = Math.min(lastRow, lines.length - 1);
        while (row &lt;= lastRow) {
            foldLine = this.getFoldLine(row, foldLine);
            if (!foldLine) {
                tokens = this.$getDisplayTokens(lines[row]);
                wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row++;
            }
            else {
                tokens = [];
                foldLine.walk(function (placeholder, row, column, lastColumn) {
                    var walkTokens;
                    if (placeholder != null) {
                        walkTokens = this.$getDisplayTokens(placeholder, tokens.length);
                        walkTokens[0] = PLACEHOLDER_START;
                        for (var i = 1; i &lt; walkTokens.length; i++) {
                            walkTokens[i] = PLACEHOLDER_BODY;
                        }
                    }
                    else {
                        walkTokens = this.$getDisplayTokens(lines[row].substring(lastColumn, column), tokens.length);
                    }
                    tokens = tokens.concat(walkTokens);
                }.bind(this), foldLine.end.row, lines[foldLine.end.row].length + 1);
                wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row = foldLine.end.row + 1;
            }
        }
    };
    var CHAR = 1, CHAR_EXT = 2, PLACEHOLDER_START = 3, PLACEHOLDER_BODY = 4, PUNCTUATION = 9, SPACE = 10, TAB = 11, TAB_SPACE = 12;
    this.$computeWrapSplits = function (tokens, wrapLimit, tabSize) {
        if (tokens.length == 0) {
            return [];
        }
        var splits = [];
        var displayLength = tokens.length;
        var lastSplit = 0, lastDocSplit = 0;
        var isCode = this.$wrapAsCode;
        var indentedSoftWrap = this.$indentedSoftWrap;
        var maxIndent = wrapLimit &lt;= Math.max(2 * tabSize, 8)
            || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);
        function getWrapIndent() {
            var indentation = 0;
            if (maxIndent === 0)
                return indentation;
            if (indentedSoftWrap) {
                for (var i = 0; i &lt; tokens.length; i++) {
                    var token = tokens[i];
                    if (token == SPACE)
                        indentation += 1;
                    else if (token == TAB)
                        indentation += tabSize;
                    else if (token == TAB_SPACE)
                        continue;
                    else
                        break;
                }
            }
            if (isCode &amp;&amp; indentedSoftWrap !== false)
                indentation += tabSize;
            return Math.min(indentation, maxIndent);
        }
        function addSplit(screenPos) {
            var len = screenPos - lastSplit;
            for (var i = lastSplit; i &lt; screenPos; i++) {
                var ch = tokens[i];
                if (ch === 12 || ch === 2)
                    len -= 1;
            }
            if (!splits.length) {
                indent = getWrapIndent();
                splits.indent = indent;
            }
            lastDocSplit += len;
            splits.push(lastDocSplit);
            lastSplit = screenPos;
        }
        var indent = 0;
        while (displayLength - lastSplit &gt; wrapLimit - indent) {
            var split = lastSplit + wrapLimit - indent;
            if (tokens[split - 1] &gt;= SPACE &amp;&amp; tokens[split] &gt;= SPACE) {
                addSplit(split);
                continue;
            }
            if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
                for (split; split != lastSplit - 1; split--) {
                    if (tokens[split] == PLACEHOLDER_START) {
                        break;
                    }
                }
                if (split &gt; lastSplit) {
                    addSplit(split);
                    continue;
                }
                split = lastSplit + wrapLimit;
                for (split; split &lt; tokens.length; split++) {
                    if (tokens[split] != PLACEHOLDER_BODY) {
                        break;
                    }
                }
                if (split == tokens.length) {
                    break; // Breaks the while-loop.
                }
                addSplit(split);
                continue;
            }
            var minSplit = Math.max(split - (wrapLimit - (wrapLimit &gt;&gt; 2)), lastSplit - 1);
            while (split &gt; minSplit &amp;&amp; tokens[split] &lt; PLACEHOLDER_START) {
                split--;
            }
            if (isCode) {
                while (split &gt; minSplit &amp;&amp; tokens[split] &lt; PLACEHOLDER_START) {
                    split--;
                }
                while (split &gt; minSplit &amp;&amp; tokens[split] == PUNCTUATION) {
                    split--;
                }
            }
            else {
                while (split &gt; minSplit &amp;&amp; tokens[split] &lt; SPACE) {
                    split--;
                }
            }
            if (split &gt; minSplit) {
                addSplit(++split);
                continue;
            }
            split = lastSplit + wrapLimit;
            if (tokens[split] == CHAR_EXT)
                split--;
            addSplit(split - indent);
        }
        return splits;
    };
    this.$getDisplayTokens = function (str, offset) {
        var arr = [];
        var tabSize;
        offset = offset || 0;
        for (var i = 0; i &lt; str.length; i++) {
            var c = str.charCodeAt(i);
            if (c == 9) {
                tabSize = this.getScreenTabSize(arr.length + offset);
                arr.push(TAB);
                for (var n = 1; n &lt; tabSize; n++) {
                    arr.push(TAB_SPACE);
                }
            }
            else if (c == 32) {
                arr.push(SPACE);
            }
            else if ((c &gt; 39 &amp;&amp; c &lt; 48) || (c &gt; 57 &amp;&amp; c &lt; 64)) {
                arr.push(PUNCTUATION);
            }
            else if (c &gt;= 0x1100 &amp;&amp; isFullWidth(c)) {
                arr.push(CHAR, CHAR_EXT);
            }
            else {
                arr.push(CHAR);
            }
        }
        return arr;
    };
    this.$getStringScreenWidth = function (str, maxScreenColumn, screenColumn) {
        if (maxScreenColumn == 0)
            return [0, 0];
        if (maxScreenColumn == null)
            maxScreenColumn = Infinity;
        screenColumn = screenColumn || 0;
        var c, column;
        for (column = 0; column &lt; str.length; column++) {
            c = str.charCodeAt(column);
            if (c == 9) {
                screenColumn += this.getScreenTabSize(screenColumn);
            }
            else if (c &gt;= 0x1100 &amp;&amp; isFullWidth(c)) {
                screenColumn += 2;
            }
            else {
                screenColumn += 1;
            }
            if (screenColumn &gt; maxScreenColumn) {
                break;
            }
        }
        return [screenColumn, column];
    };
    this.lineWidgets = null;
    this.getRowLength = function (row) {
        var h = 1;
        if (this.lineWidgets)
            h += this.lineWidgets[row] &amp;&amp; this.lineWidgets[row].rowCount || 0;
        if (!this.$useWrapMode || !this.$wrapData[row])
            return h;
        else
            return this.$wrapData[row].length + h;
    };
    this.getRowLineCount = function (row) {
        if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1;
        }
        else {
            return this.$wrapData[row].length + 1;
        }
    };
    this.getRowWrapIndent = function (screenRow) {
        if (this.$useWrapMode) {
            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
            var splits = this.$wrapData[pos.row];
            return splits.length &amp;&amp; splits[0] &lt; pos.column ? splits.indent : 0;
        }
        else {
            return 0;
        }
    };
    this.getScreenLastRowColumn = function (screenRow) {
        var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
        return this.documentToScreenColumn(pos.row, pos.column);
    };
    this.getDocumentLastRowColumn = function (docRow, docColumn) {
        var screenRow = this.documentToScreenRow(docRow, docColumn);
        return this.getScreenLastRowColumn(screenRow);
    };
    this.getDocumentLastRowColumnPosition = function (docRow, docColumn) {
        var screenRow = this.documentToScreenRow(docRow, docColumn);
        return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
    };
    this.getRowSplitData = function (row) {
        if (!this.$useWrapMode) {
            return undefined;
        }
        else {
            return this.$wrapData[row];
        }
    };
    this.getScreenTabSize = function (screenColumn) {
        return this.$tabSize - (screenColumn % this.$tabSize | 0);
    };
    this.screenToDocumentRow = function (screenRow, screenColumn) {
        return this.screenToDocumentPosition(screenRow, screenColumn).row;
    };
    this.screenToDocumentColumn = function (screenRow, screenColumn) {
        return this.screenToDocumentPosition(screenRow, screenColumn).column;
    };
    this.screenToDocumentPosition = function (screenRow, screenColumn, offsetX) {
        if (screenRow &lt; 0)
            return { row: 0, column: 0 };
        var line;
        var docRow = 0;
        var docColumn = 0;
        var column;
        var row = 0;
        var rowLength = 0;
        var rowCache = this.$screenRowCache;
        var i = this.$getRowCacheIndex(rowCache, screenRow);
        var l = rowCache.length;
        if (l &amp;&amp; i &gt;= 0) {
            var row = rowCache[i];
            var docRow = this.$docRowCache[i];
            var doCache = screenRow &gt; rowCache[l - 1];
        }
        else {
            var doCache = !l;
        }
        var maxRow = this.getLength() - 1;
        var foldLine = this.getNextFoldLine(docRow);
        var foldStart = foldLine ? foldLine.start.row : Infinity;
        while (row &lt;= screenRow) {
            rowLength = this.getRowLength(docRow);
            if (row + rowLength &gt; screenRow || docRow &gt;= maxRow) {
                break;
            }
            else {
                row += rowLength;
                docRow++;
                if (docRow &gt; foldStart) {
                    docRow = foldLine.end.row + 1;
                    foldLine = this.getNextFoldLine(docRow, foldLine);
                    foldStart = foldLine ? foldLine.start.row : Infinity;
                }
            }
            if (doCache) {
                this.$docRowCache.push(docRow);
                this.$screenRowCache.push(row);
            }
        }
        if (foldLine &amp;&amp; foldLine.start.row &lt;= docRow) {
            line = this.getFoldDisplayLine(foldLine);
            docRow = foldLine.start.row;
        }
        else if (row + rowLength &lt;= screenRow || docRow &gt; maxRow) {
            return {
                row: maxRow,
                column: this.getLine(maxRow).length
            };
        }
        else {
            line = this.getLine(docRow);
            foldLine = null;
        }
        var wrapIndent = 0, splitIndex = Math.floor(screenRow - row);
        if (this.$useWrapMode) {
            var splits = this.$wrapData[docRow];
            if (splits) {
                column = splits[splitIndex];
                if (splitIndex &gt; 0 &amp;&amp; splits.length) {
                    wrapIndent = splits.indent;
                    docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
                    line = line.substring(docColumn);
                }
            }
        }
        if (offsetX !== undefined &amp;&amp; this.$bidiHandler.isBidiRow(row + splitIndex, docRow, splitIndex))
            screenColumn = this.$bidiHandler.offsetToCol(offsetX);
        docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];
        if (this.$useWrapMode &amp;&amp; docColumn &gt;= column)
            docColumn = column - 1;
        if (foldLine)
            return foldLine.idxToPosition(docColumn);
        return { row: docRow, column: docColumn };
    };
    this.documentToScreenPosition = function (docRow, docColumn) {
        if (typeof docColumn === &quot;undefined&quot;)
            var pos = this.$clipPositionToDocument(docRow.row, docRow.column);
        else
            pos = this.$clipPositionToDocument(docRow, docColumn);
        docRow = pos.row;
        docColumn = pos.column;
        var screenRow = 0;
        var foldStartRow = null;
        var fold = null;
        fold = this.getFoldAt(docRow, docColumn, 1);
        if (fold) {
            docRow = fold.start.row;
            docColumn = fold.start.column;
        }
        var rowEnd, row = 0;
        var rowCache = this.$docRowCache;
        var i = this.$getRowCacheIndex(rowCache, docRow);
        var l = rowCache.length;
        if (l &amp;&amp; i &gt;= 0) {
            var row = rowCache[i];
            var screenRow = this.$screenRowCache[i];
            var doCache = docRow &gt; rowCache[l - 1];
        }
        else {
            var doCache = !l;
        }
        var foldLine = this.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;
        while (row &lt; docRow) {
            if (row &gt;= foldStart) {
                rowEnd = foldLine.end.row + 1;
                if (rowEnd &gt; docRow)
                    break;
                foldLine = this.getNextFoldLine(rowEnd, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            else {
                rowEnd = row + 1;
            }
            screenRow += this.getRowLength(row);
            row = rowEnd;
            if (doCache) {
                this.$docRowCache.push(row);
                this.$screenRowCache.push(screenRow);
            }
        }
        var textLine = &quot;&quot;;
        if (foldLine &amp;&amp; row &gt;= foldStart) {
            textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
            foldStartRow = foldLine.start.row;
        }
        else {
            textLine = this.getLine(docRow).substring(0, docColumn);
            foldStartRow = docRow;
        }
        var wrapIndent = 0;
        if (this.$useWrapMode) {
            var wrapRow = this.$wrapData[foldStartRow];
            if (wrapRow) {
                var screenRowOffset = 0;
                while (textLine.length &gt;= wrapRow[screenRowOffset]) {
                    screenRow++;
                    screenRowOffset++;
                }
                textLine = textLine.substring(wrapRow[screenRowOffset - 1] || 0, textLine.length);
                wrapIndent = screenRowOffset &gt; 0 ? wrapRow.indent : 0;
            }
        }
        if (this.lineWidgets &amp;&amp; this.lineWidgets[row] &amp;&amp; this.lineWidgets[row].rowsAbove)
            screenRow += this.lineWidgets[row].rowsAbove;
        return {
            row: screenRow,
            column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
        };
    };
    this.documentToScreenColumn = function (row, docColumn) {
        return this.documentToScreenPosition(row, docColumn).column;
    };
    this.documentToScreenRow = function (docRow, docColumn) {
        return this.documentToScreenPosition(docRow, docColumn).row;
    };
    this.getScreenLength = function () {
        var screenRows = 0;
        var fold = null;
        if (!this.$useWrapMode) {
            screenRows = this.getLength();
            var foldData = this.$foldData;
            for (var i = 0; i &lt; foldData.length; i++) {
                fold = foldData[i];
                screenRows -= fold.end.row - fold.start.row;
            }
        }
        else {
            var lastRow = this.$wrapData.length;
            var row = 0, i = 0;
            var fold = this.$foldData[i++];
            var foldStart = fold ? fold.start.row : Infinity;
            while (row &lt; lastRow) {
                var splits = this.$wrapData[row];
                screenRows += splits ? splits.length + 1 : 1;
                row++;
                if (row &gt; foldStart) {
                    row = fold.end.row + 1;
                    fold = this.$foldData[i++];
                    foldStart = fold ? fold.start.row : Infinity;
                }
            }
        }
        if (this.lineWidgets)
            screenRows += this.$getWidgetScreenLength();
        return screenRows;
    };
    this.$setFontMetrics = function (fm) {
        if (!this.$enableVarChar)
            return;
        this.$getStringScreenWidth = function (str, maxScreenColumn, screenColumn) {
            if (maxScreenColumn === 0)
                return [0, 0];
            if (!maxScreenColumn)
                maxScreenColumn = Infinity;
            screenColumn = screenColumn || 0;
            var c, column;
            for (column = 0; column &lt; str.length; column++) {
                c = str.charAt(column);
                if (c === &quot;\t&quot;) {
                    screenColumn += this.getScreenTabSize(screenColumn);
                }
                else {
                    screenColumn += fm.getCharacterWidth(c);
                }
                if (screenColumn &gt; maxScreenColumn) {
                    break;
                }
            }
            return [screenColumn, column];
        };
    };
    this.destroy = function () {
        if (!this.destroyed) {
            this.bgTokenizer.setDocument(null);
            this.bgTokenizer.cleanup();
            this.destroyed = true;
        }
        this.$stopWorker();
        this.removeAllListeners();
        if (this.doc) {
            this.doc.off(&quot;change&quot;, this.$onChange);
        }
        this.selection.detach();
    };
    this.isFullWidth = isFullWidth;
    function isFullWidth(c) {
        if (c &lt; 0x1100)
            return false;
        return c &gt;= 0x1100 &amp;&amp; c &lt;= 0x115F ||
            c &gt;= 0x11A3 &amp;&amp; c &lt;= 0x11A7 ||
            c &gt;= 0x11FA &amp;&amp; c &lt;= 0x11FF ||
            c &gt;= 0x2329 &amp;&amp; c &lt;= 0x232A ||
            c &gt;= 0x2E80 &amp;&amp; c &lt;= 0x2E99 ||
            c &gt;= 0x2E9B &amp;&amp; c &lt;= 0x2EF3 ||
            c &gt;= 0x2F00 &amp;&amp; c &lt;= 0x2FD5 ||
            c &gt;= 0x2FF0 &amp;&amp; c &lt;= 0x2FFB ||
            c &gt;= 0x3000 &amp;&amp; c &lt;= 0x303E ||
            c &gt;= 0x3041 &amp;&amp; c &lt;= 0x3096 ||
            c &gt;= 0x3099 &amp;&amp; c &lt;= 0x30FF ||
            c &gt;= 0x3105 &amp;&amp; c &lt;= 0x312D ||
            c &gt;= 0x3131 &amp;&amp; c &lt;= 0x318E ||
            c &gt;= 0x3190 &amp;&amp; c &lt;= 0x31BA ||
            c &gt;= 0x31C0 &amp;&amp; c &lt;= 0x31E3 ||
            c &gt;= 0x31F0 &amp;&amp; c &lt;= 0x321E ||
            c &gt;= 0x3220 &amp;&amp; c &lt;= 0x3247 ||
            c &gt;= 0x3250 &amp;&amp; c &lt;= 0x32FE ||
            c &gt;= 0x3300 &amp;&amp; c &lt;= 0x4DBF ||
            c &gt;= 0x4E00 &amp;&amp; c &lt;= 0xA48C ||
            c &gt;= 0xA490 &amp;&amp; c &lt;= 0xA4C6 ||
            c &gt;= 0xA960 &amp;&amp; c &lt;= 0xA97C ||
            c &gt;= 0xAC00 &amp;&amp; c &lt;= 0xD7A3 ||
            c &gt;= 0xD7B0 &amp;&amp; c &lt;= 0xD7C6 ||
            c &gt;= 0xD7CB &amp;&amp; c &lt;= 0xD7FB ||
            c &gt;= 0xF900 &amp;&amp; c &lt;= 0xFAFF ||
            c &gt;= 0xFE10 &amp;&amp; c &lt;= 0xFE19 ||
            c &gt;= 0xFE30 &amp;&amp; c &lt;= 0xFE52 ||
            c &gt;= 0xFE54 &amp;&amp; c &lt;= 0xFE66 ||
            c &gt;= 0xFE68 &amp;&amp; c &lt;= 0xFE6B ||
            c &gt;= 0xFF01 &amp;&amp; c &lt;= 0xFF60 ||
            c &gt;= 0xFFE0 &amp;&amp; c &lt;= 0xFFE6;
    }
}).call(EditSession.prototype);
require(&quot;./edit_session/folding&quot;).Folding.call(EditSession.prototype);
require(&quot;./edit_session/bracket_match&quot;).BracketMatch.call(EditSession.prototype);
config.defineOptions(EditSession.prototype, &quot;session&quot;, {
    wrap: {
        set: function (value) {
            if (!value || value == &quot;off&quot;)
                value = false;
            else if (value == &quot;free&quot;)
                value = true;
            else if (value == &quot;printMargin&quot;)
                value = -1;
            else if (typeof value == &quot;string&quot;)
                value = parseInt(value, 10) || false;
            if (this.$wrap == value)
                return;
            this.$wrap = value;
            if (!value) {
                this.setUseWrapMode(false);
            }
            else {
                var col = typeof value == &quot;number&quot; ? value : null;
                this.setWrapLimitRange(col, col);
                this.setUseWrapMode(true);
            }
        },
        get: function () {
            if (this.getUseWrapMode()) {
                if (this.$wrap == -1)
                    return &quot;printMargin&quot;;
                if (!this.getWrapLimitRange().min)
                    return &quot;free&quot;;
                return this.$wrap;
            }
            return &quot;off&quot;;
        },
        handlesSet: true
    },
    wrapMethod: {
        set: function (val) {
            val = val == &quot;auto&quot;
                ? this.$mode.type != &quot;text&quot;
                : val != &quot;text&quot;;
            if (val != this.$wrapAsCode) {
                this.$wrapAsCode = val;
                if (this.$useWrapMode) {
                    this.$useWrapMode = false;
                    this.setUseWrapMode(true);
                }
            }
        },
        initialValue: &quot;auto&quot;
    },
    indentedSoftWrap: {
        set: function () {
            if (this.$useWrapMode) {
                this.$useWrapMode = false;
                this.setUseWrapMode(true);
            }
        },
        initialValue: true
    },
    firstLineNumber: {
        set: function () { this._signal(&quot;changeBreakpoint&quot;); },
        initialValue: 1
    },
    useWorker: {
        set: function (useWorker) {
            this.$useWorker = useWorker;
            this.$stopWorker();
            if (useWorker)
                this.$startWorker();
        },
        initialValue: true
    },
    useSoftTabs: { initialValue: true },
    tabSize: {
        set: function (tabSize) {
            tabSize = parseInt(tabSize);
            if (tabSize &gt; 0 &amp;&amp; this.$tabSize !== tabSize) {
                this.$modified = true;
                this.$rowLengthCache = [];
                this.$tabSize = tabSize;
                this._signal(&quot;changeTabSize&quot;);
            }
        },
        initialValue: 4,
        handlesSet: true
    },
    navigateWithinSoftTabs: { initialValue: false },
    foldStyle: {
        set: function (val) { this.setFoldStyle(val); },
        handlesSet: true
    },
    overwrite: {
        set: function (val) { this._signal(&quot;changeOverwrite&quot;); },
        initialValue: false
    },
    newLineMode: {
        set: function (val) { this.doc.setNewLineMode(val); },
        get: function () { return this.doc.getNewLineMode(); },
        handlesSet: true
    },
    mode: {
        set: function (val) { this.setMode(val); },
        get: function () { return this.$modeId; },
        handlesSet: true
    }
});
exports.EditSession = EditSession;

});

define(&quot;ace/search&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/lang&quot;,&quot;ace/lib/oop&quot;,&quot;ace/range&quot;], function(require, exports, module){&quot;use strict&quot;;
var lang = require(&quot;./lib/lang&quot;);
var oop = require(&quot;./lib/oop&quot;);
var Range = require(&quot;./range&quot;).Range;
var Search = function () {
    this.$options = {};
};
(function () {
    this.set = function (options) {
        oop.mixin(this.$options, options);
        return this;
    };
    this.getOptions = function () {
        return lang.copyObject(this.$options);
    };
    this.setOptions = function (options) {
        this.$options = options;
    };
    this.find = function (session) {
        var options = this.$options;
        var iterator = this.$matchIterator(session, options);
        if (!iterator)
            return false;
        var firstRange = null;
        iterator.forEach(function (sr, sc, er, ec) {
            firstRange = new Range(sr, sc, er, ec);
            if (sc == ec &amp;&amp; options.start &amp;&amp; options.start.start
                &amp;&amp; options.skipCurrent != false &amp;&amp; firstRange.isEqual(options.start)) {
                firstRange = null;
                return false;
            }
            return true;
        });
        return firstRange;
    };
    this.findAll = function (session) {
        var options = this.$options;
        if (!options.needle)
            return [];
        this.$assembleRegExp(options);
        var range = options.range;
        var lines = range
            ? session.getLines(range.start.row, range.end.row)
            : session.doc.getAllLines();
        var ranges = [];
        var re = options.re;
        if (options.$isMultiLine) {
            var len = re.length;
            var maxRow = lines.length - len;
            var prevRange;
            outer: for (var row = re.offset || 0; row &lt;= maxRow; row++) {
                for (var j = 0; j &lt; len; j++)
                    if (lines[row + j].search(re[j]) == -1)
                        continue outer;
                var startLine = lines[row];
                var line = lines[row + len - 1];
                var startIndex = startLine.length - startLine.match(re[0])[0].length;
                var endIndex = line.match(re[len - 1])[0].length;
                if (prevRange &amp;&amp; prevRange.end.row === row &amp;&amp;
                    prevRange.end.column &gt; startIndex) {
                    continue;
                }
                ranges.push(prevRange = new Range(row, startIndex, row + len - 1, endIndex));
                if (len &gt; 2)
                    row = row + len - 2;
            }
        }
        else {
            for (var i = 0; i &lt; lines.length; i++) {
                var matches = lang.getMatchOffsets(lines[i], re);
                for (var j = 0; j &lt; matches.length; j++) {
                    var match = matches[j];
                    ranges.push(new Range(i, match.offset, i, match.offset + match.length));
                }
            }
        }
        if (range) {
            var startColumn = range.start.column;
            var endColumn = range.end.column;
            var i = 0, j = ranges.length - 1;
            while (i &lt; j &amp;&amp; ranges[i].start.column &lt; startColumn &amp;&amp; ranges[i].start.row == 0)
                i++;
            var endRow = range.end.row - range.start.row;
            while (i &lt; j &amp;&amp; ranges[j].end.column &gt; endColumn &amp;&amp; ranges[j].end.row == endRow)
                j--;
            ranges = ranges.slice(i, j + 1);
            for (i = 0, j = ranges.length; i &lt; j; i++) {
                ranges[i].start.row += range.start.row;
                ranges[i].end.row += range.start.row;
            }
        }
        return ranges;
    };
    this.replace = function (input, replacement) {
        var options = this.$options;
        var re = this.$assembleRegExp(options);
        if (options.$isMultiLine)
            return replacement;
        if (!re)
            return;
        var match = re.exec(input);
        if (!match || match[0].length != input.length)
            return null;
        replacement = input.replace(re, replacement);
        if (options.preserveCase) {
            replacement = replacement.split(&quot;&quot;);
            for (var i = Math.min(input.length, input.length); i--;) {
                var ch = input[i];
                if (ch &amp;&amp; ch.toLowerCase() != ch)
                    replacement[i] = replacement[i].toUpperCase();
                else
                    replacement[i] = replacement[i].toLowerCase();
            }
            replacement = replacement.join(&quot;&quot;);
        }
        return replacement;
    };
    this.$assembleRegExp = function (options, $disableFakeMultiline) {
        if (options.needle instanceof RegExp)
            return options.re = options.needle;
        var needle = options.needle;
        if (!options.needle)
            return options.re = false;
        if (!options.regExp)
            needle = lang.escapeRegExp(needle);
        if (options.wholeWord)
            needle = addWordBoundary(needle, options);
        var modifier = options.caseSensitive ? &quot;gm&quot; : &quot;gmi&quot;;
        options.$isMultiLine = !$disableFakeMultiline &amp;&amp; /[\n\r]/.test(needle);
        if (options.$isMultiLine)
            return options.re = this.$assembleMultilineRegExp(needle, modifier);
        try {
            var re = new RegExp(needle, modifier);
        }
        catch (e) {
            re = false;
        }
        return options.re = re;
    };
    this.$assembleMultilineRegExp = function (needle, modifier) {
        var parts = needle.replace(/\r\n|\r|\n/g, &quot;$\n^&quot;).split(&quot;\n&quot;);
        var re = [];
        for (var i = 0; i &lt; parts.length; i++)
            try {
                re.push(new RegExp(parts[i], modifier));
            }
            catch (e) {
                return false;
            }
        return re;
    };
    this.$matchIterator = function (session, options) {
        var re = this.$assembleRegExp(options);
        if (!re)
            return false;
        var backwards = options.backwards == true;
        var skipCurrent = options.skipCurrent != false;
        var range = options.range;
        var start = options.start;
        if (!start)
            start = range ? range[backwards ? &quot;end&quot; : &quot;start&quot;] : session.selection.getRange();
        if (start.start)
            start = start[skipCurrent != backwards ? &quot;end&quot; : &quot;start&quot;];
        var firstRow = range ? range.start.row : 0;
        var lastRow = range ? range.end.row : session.getLength() - 1;
        if (backwards) {
            var forEach = function (callback) {
                var row = start.row;
                if (forEachInLine(row, start.column, callback))
                    return;
                for (row--; row &gt;= firstRow; row--)
                    if (forEachInLine(row, Number.MAX_VALUE, callback))
                        return;
                if (options.wrap == false)
                    return;
                for (row = lastRow, firstRow = start.row; row &gt;= firstRow; row--)
                    if (forEachInLine(row, Number.MAX_VALUE, callback))
                        return;
            };
        }
        else {
            var forEach = function (callback) {
                var row = start.row;
                if (forEachInLine(row, start.column, callback))
                    return;
                for (row = row + 1; row &lt;= lastRow; row++)
                    if (forEachInLine(row, 0, callback))
                        return;
                if (options.wrap == false)
                    return;
                for (row = firstRow, lastRow = start.row; row &lt;= lastRow; row++)
                    if (forEachInLine(row, 0, callback))
                        return;
            };
        }
        if (options.$isMultiLine) {
            var len = re.length;
            var forEachInLine = function (row, offset, callback) {
                var startRow = backwards ? row - len + 1 : row;
                if (startRow &lt; 0 || startRow + len &gt; session.getLength())
                    return;
                var line = session.getLine(startRow);
                var startIndex = line.search(re[0]);
                if (!backwards &amp;&amp; startIndex &lt; offset || startIndex === -1)
                    return;
                for (var i = 1; i &lt; len; i++) {
                    line = session.getLine(startRow + i);
                    if (line.search(re[i]) == -1)
                        return;
                }
                var endIndex = line.match(re[len - 1])[0].length;
                if (backwards &amp;&amp; endIndex &gt; offset)
                    return;
                if (callback(startRow, startIndex, startRow + len - 1, endIndex))
                    return true;
            };
        }
        else if (backwards) {
            var forEachInLine = function (row, endIndex, callback) {
                var line = session.getLine(row);
                var matches = [];
                var m, last = 0;
                re.lastIndex = 0;
                while ((m = re.exec(line))) {
                    var length = m[0].length;
                    last = m.index;
                    if (!length) {
                        if (last &gt;= line.length)
                            break;
                        re.lastIndex = last += 1;
                    }
                    if (m.index + length &gt; endIndex)
                        break;
                    matches.push(m.index, length);
                }
                for (var i = matches.length - 1; i &gt;= 0; i -= 2) {
                    var column = matches[i - 1];
                    var length = matches[i];
                    if (callback(row, column, row, column + length))
                        return true;
                }
            };
        }
        else {
            var forEachInLine = function (row, startIndex, callback) {
                var line = session.getLine(row);
                var last;
                var m;
                re.lastIndex = startIndex;
                while ((m = re.exec(line))) {
                    var length = m[0].length;
                    last = m.index;
                    if (callback(row, last, row, last + length))
                        return true;
                    if (!length) {
                        re.lastIndex = last += 1;
                        if (last &gt;= line.length)
                            return false;
                    }
                }
            };
        }
        return { forEach: forEach };
    };
}).call(Search.prototype);
function addWordBoundary(needle, options) {
    function wordBoundary(c) {
        if (/\w/.test(c) || options.regExp)
            return &quot;\\b&quot;;
        return &quot;&quot;;
    }
    return wordBoundary(needle[0]) + needle
        + wordBoundary(needle[needle.length - 1]);
}
exports.Search = Search;

});

define(&quot;ace/keyboard/hash_handler&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/keys&quot;,&quot;ace/lib/useragent&quot;], function(require, exports, module){&quot;use strict&quot;;
var keyUtil = require(&quot;../lib/keys&quot;);
var useragent = require(&quot;../lib/useragent&quot;);
var KEY_MODS = keyUtil.KEY_MODS;
function HashHandler(config, platform) {
    this.platform = platform || (useragent.isMac ? &quot;mac&quot; : &quot;win&quot;);
    this.commands = {};
    this.commandKeyBinding = {};
    this.addCommands(config);
    this.$singleCommand = true;
}
function MultiHashHandler(config, platform) {
    HashHandler.call(this, config, platform);
    this.$singleCommand = false;
}
MultiHashHandler.prototype = HashHandler.prototype;
(function () {
    this.addCommand = function (command) {
        if (this.commands[command.name])
            this.removeCommand(command);
        this.commands[command.name] = command;
        if (command.bindKey)
            this._buildKeyHash(command);
    };
    this.removeCommand = function (command, keepCommand) {
        var name = command &amp;&amp; (typeof command === &#039;string&#039; ? command : command.name);
        command = this.commands[name];
        if (!keepCommand)
            delete this.commands[name];
        var ckb = this.commandKeyBinding;
        for (var keyId in ckb) {
            var cmdGroup = ckb[keyId];
            if (cmdGroup == command) {
                delete ckb[keyId];
            }
            else if (Array.isArray(cmdGroup)) {
                var i = cmdGroup.indexOf(command);
                if (i != -1) {
                    cmdGroup.splice(i, 1);
                    if (cmdGroup.length == 1)
                        ckb[keyId] = cmdGroup[0];
                }
            }
        }
    };
    this.bindKey = function (key, command, position) {
        if (typeof key == &quot;object&quot; &amp;&amp; key) {
            if (position == undefined)
                position = key.position;
            key = key[this.platform];
        }
        if (!key)
            return;
        if (typeof command == &quot;function&quot;)
            return this.addCommand({ exec: command, bindKey: key, name: command.name || key });
        key.split(&quot;|&quot;).forEach(function (keyPart) {
            var chain = &quot;&quot;;
            if (keyPart.indexOf(&quot; &quot;) != -1) {
                var parts = keyPart.split(/\s+/);
                keyPart = parts.pop();
                parts.forEach(function (keyPart) {
                    var binding = this.parseKeys(keyPart);
                    var id = KEY_MODS[binding.hashId] + binding.key;
                    chain += (chain ? &quot; &quot; : &quot;&quot;) + id;
                    this._addCommandToBinding(chain, &quot;chainKeys&quot;);
                }, this);
                chain += &quot; &quot;;
            }
            var binding = this.parseKeys(keyPart);
            var id = KEY_MODS[binding.hashId] + binding.key;
            this._addCommandToBinding(chain + id, command, position);
        }, this);
    };
    function getPosition(command) {
        return typeof command == &quot;object&quot; &amp;&amp; command.bindKey
            &amp;&amp; command.bindKey.position
            || (command.isDefault ? -100 : 0);
    }
    this._addCommandToBinding = function (keyId, command, position) {
        var ckb = this.commandKeyBinding, i;
        if (!command) {
            delete ckb[keyId];
        }
        else if (!ckb[keyId] || this.$singleCommand) {
            ckb[keyId] = command;
        }
        else {
            if (!Array.isArray(ckb[keyId])) {
                ckb[keyId] = [ckb[keyId]];
            }
            else if ((i = ckb[keyId].indexOf(command)) != -1) {
                ckb[keyId].splice(i, 1);
            }
            if (typeof position != &quot;number&quot;) {
                position = getPosition(command);
            }
            var commands = ckb[keyId];
            for (i = 0; i &lt; commands.length; i++) {
                var other = commands[i];
                var otherPos = getPosition(other);
                if (otherPos &gt; position)
                    break;
            }
            commands.splice(i, 0, command);
        }
    };
    this.addCommands = function (commands) {
        commands &amp;&amp; Object.keys(commands).forEach(function (name) {
            var command = commands[name];
            if (!command)
                return;
            if (typeof command === &quot;string&quot;)
                return this.bindKey(command, name);
            if (typeof command === &quot;function&quot;)
                command = { exec: command };
            if (typeof command !== &quot;object&quot;)
                return;
            if (!command.name)
                command.name = name;
            this.addCommand(command);
        }, this);
    };
    this.removeCommands = function (commands) {
        Object.keys(commands).forEach(function (name) {
            this.removeCommand(commands[name]);
        }, this);
    };
    this.bindKeys = function (keyList) {
        Object.keys(keyList).forEach(function (key) {
            this.bindKey(key, keyList[key]);
        }, this);
    };
    this._buildKeyHash = function (command) {
        this.bindKey(command.bindKey, command);
    };
    this.parseKeys = function (keys) {
        var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function (x) { return x; });
        var key = parts.pop();
        var keyCode = keyUtil[key];
        if (keyUtil.FUNCTION_KEYS[keyCode])
            key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
        else if (!parts.length)
            return { key: key, hashId: -1 };
        else if (parts.length == 1 &amp;&amp; parts[0] == &quot;shift&quot;)
            return { key: key.toUpperCase(), hashId: -1 };
        var hashId = 0;
        for (var i = parts.length; i--;) {
            var modifier = keyUtil.KEY_MODS[parts[i]];
            if (modifier == null) {
                if (typeof console != &quot;undefined&quot;)
                    console.error(&quot;invalid modifier &quot; + parts[i] + &quot; in &quot; + keys);
                return false;
            }
            hashId |= modifier;
        }
        return { key: key, hashId: hashId };
    };
    this.findKeyCommand = function findKeyCommand(hashId, keyString) {
        var key = KEY_MODS[hashId] + keyString;
        return this.commandKeyBinding[key];
    };
    this.handleKeyboard = function (data, hashId, keyString, keyCode) {
        if (keyCode &lt; 0)
            return;
        var key = KEY_MODS[hashId] + keyString;
        var command = this.commandKeyBinding[key];
        if (data.$keyChain) {
            data.$keyChain += &quot; &quot; + key;
            command = this.commandKeyBinding[data.$keyChain] || command;
        }
        if (command) {
            if (command == &quot;chainKeys&quot; || command[command.length - 1] == &quot;chainKeys&quot;) {
                data.$keyChain = data.$keyChain || key;
                return { command: &quot;null&quot; };
            }
        }
        if (data.$keyChain) {
            if ((!hashId || hashId == 4) &amp;&amp; keyString.length == 1)
                data.$keyChain = data.$keyChain.slice(0, -key.length - 1); // wait for input
            else if (hashId == -1 || keyCode &gt; 0)
                data.$keyChain = &quot;&quot;; // reset keyChain
        }
        return { command: command };
    };
    this.getStatusText = function (editor, data) {
        return data.$keyChain || &quot;&quot;;
    };
}).call(HashHandler.prototype);
exports.HashHandler = HashHandler;
exports.MultiHashHandler = MultiHashHandler;

});

define(&quot;ace/commands/command_manager&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/keyboard/hash_handler&quot;,&quot;ace/lib/event_emitter&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;../lib/oop&quot;);
var MultiHashHandler = require(&quot;../keyboard/hash_handler&quot;).MultiHashHandler;
var EventEmitter = require(&quot;../lib/event_emitter&quot;).EventEmitter;
var CommandManager = function (platform, commands) {
    MultiHashHandler.call(this, commands, platform);
    this.byName = this.commands;
    this.setDefaultHandler(&quot;exec&quot;, function (e) {
        if (!e.args) {
            return e.command.exec(e.editor, {}, e.event, true);
        }
        return e.command.exec(e.editor, e.args, e.event, false);
    });
};
oop.inherits(CommandManager, MultiHashHandler);
(function () {
    oop.implement(this, EventEmitter);
    this.exec = function (command, editor, args) {
        if (Array.isArray(command)) {
            for (var i = command.length; i--;) {
                if (this.exec(command[i], editor, args))
                    return true;
            }
            return false;
        }
        if (typeof command === &quot;string&quot;)
            command = this.commands[command];
        if (!command)
            return false;
        if (editor &amp;&amp; editor.$readOnly &amp;&amp; !command.readOnly)
            return false;
        if (this.$checkCommandState != false &amp;&amp; command.isAvailable &amp;&amp; !command.isAvailable(editor))
            return false;
        var e = { editor: editor, command: command, args: args };
        e.returnValue = this._emit(&quot;exec&quot;, e);
        this._signal(&quot;afterExec&quot;, e);
        return e.returnValue === false ? false : true;
    };
    this.toggleRecording = function (editor) {
        if (this.$inReplay)
            return;
        editor &amp;&amp; editor._emit(&quot;changeStatus&quot;);
        if (this.recording) {
            this.macro.pop();
            this.off(&quot;exec&quot;, this.$addCommandToMacro);
            if (!this.macro.length)
                this.macro = this.oldMacro;
            return this.recording = false;
        }
        if (!this.$addCommandToMacro) {
            this.$addCommandToMacro = function (e) {
                this.macro.push([e.command, e.args]);
            }.bind(this);
        }
        this.oldMacro = this.macro;
        this.macro = [];
        this.on(&quot;exec&quot;, this.$addCommandToMacro);
        return this.recording = true;
    };
    this.replay = function (editor) {
        if (this.$inReplay || !this.macro)
            return;
        if (this.recording)
            return this.toggleRecording(editor);
        try {
            this.$inReplay = true;
            this.macro.forEach(function (x) {
                if (typeof x == &quot;string&quot;)
                    this.exec(x, editor);
                else
                    this.exec(x[0], editor, x[1]);
            }, this);
        }
        finally {
            this.$inReplay = false;
        }
    };
    this.trimMacro = function (m) {
        return m.map(function (x) {
            if (typeof x[0] != &quot;string&quot;)
                x[0] = x[0].name;
            if (!x[1])
                x = x[0];
            return x;
        });
    };
}).call(CommandManager.prototype);
exports.CommandManager = CommandManager;

});

define(&quot;ace/commands/default_commands&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/lang&quot;,&quot;ace/config&quot;,&quot;ace/range&quot;], function(require, exports, module){&quot;use strict&quot;;
var lang = require(&quot;../lib/lang&quot;);
var config = require(&quot;../config&quot;);
var Range = require(&quot;../range&quot;).Range;
function bindKey(win, mac) {
    return { win: win, mac: mac };
}
exports.commands = [{
        name: &quot;showSettingsMenu&quot;,
        description: &quot;Show settings menu&quot;,
        bindKey: bindKey(&quot;Ctrl-,&quot;, &quot;Command-,&quot;),
        exec: function (editor) {
            config.loadModule(&quot;ace/ext/settings_menu&quot;, function (module) {
                module.init(editor);
                editor.showSettingsMenu();
            });
        },
        readOnly: true
    }, {
        name: &quot;goToNextError&quot;,
        description: &quot;Go to next error&quot;,
        bindKey: bindKey(&quot;Alt-E&quot;, &quot;F4&quot;),
        exec: function (editor) {
            config.loadModule(&quot;./ext/error_marker&quot;, function (module) {
                module.showErrorMarker(editor, 1);
            });
        },
        scrollIntoView: &quot;animate&quot;,
        readOnly: true
    }, {
        name: &quot;goToPreviousError&quot;,
        description: &quot;Go to previous error&quot;,
        bindKey: bindKey(&quot;Alt-Shift-E&quot;, &quot;Shift-F4&quot;),
        exec: function (editor) {
            config.loadModule(&quot;./ext/error_marker&quot;, function (module) {
                module.showErrorMarker(editor, -1);
            });
        },
        scrollIntoView: &quot;animate&quot;,
        readOnly: true
    }, {
        name: &quot;selectall&quot;,
        description: &quot;Select all&quot;,
        bindKey: bindKey(&quot;Ctrl-A&quot;, &quot;Command-A&quot;),
        exec: function (editor) { editor.selectAll(); },
        readOnly: true
    }, {
        name: &quot;centerselection&quot;,
        description: &quot;Center selection&quot;,
        bindKey: bindKey(null, &quot;Ctrl-L&quot;),
        exec: function (editor) { editor.centerSelection(); },
        readOnly: true
    }, {
        name: &quot;gotoline&quot;,
        description: &quot;Go to line...&quot;,
        bindKey: bindKey(&quot;Ctrl-L&quot;, &quot;Command-L&quot;),
        exec: function (editor, line) {
            if (typeof line === &quot;number&quot; &amp;&amp; !isNaN(line))
                editor.gotoLine(line);
            editor.prompt({ $type: &quot;gotoLine&quot; });
        },
        readOnly: true
    }, {
        name: &quot;fold&quot;,
        bindKey: bindKey(&quot;Alt-L|Ctrl-F1&quot;, &quot;Command-Alt-L|Command-F1&quot;),
        exec: function (editor) { editor.session.toggleFold(false); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;center&quot;,
        readOnly: true
    }, {
        name: &quot;unfold&quot;,
        bindKey: bindKey(&quot;Alt-Shift-L|Ctrl-Shift-F1&quot;, &quot;Command-Alt-Shift-L|Command-Shift-F1&quot;),
        exec: function (editor) { editor.session.toggleFold(true); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;center&quot;,
        readOnly: true
    }, {
        name: &quot;toggleFoldWidget&quot;,
        description: &quot;Toggle fold widget&quot;,
        bindKey: bindKey(&quot;F2&quot;, &quot;F2&quot;),
        exec: function (editor) { editor.session.toggleFoldWidget(); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;center&quot;,
        readOnly: true
    }, {
        name: &quot;toggleParentFoldWidget&quot;,
        description: &quot;Toggle parent fold widget&quot;,
        bindKey: bindKey(&quot;Alt-F2&quot;, &quot;Alt-F2&quot;),
        exec: function (editor) { editor.session.toggleFoldWidget(true); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;center&quot;,
        readOnly: true
    }, {
        name: &quot;foldall&quot;,
        description: &quot;Fold all&quot;,
        bindKey: bindKey(null, &quot;Ctrl-Command-Option-0&quot;),
        exec: function (editor) { editor.session.foldAll(); },
        scrollIntoView: &quot;center&quot;,
        readOnly: true
    }, {
        name: &quot;foldAllComments&quot;,
        description: &quot;Fold all comments&quot;,
        bindKey: bindKey(null, &quot;Ctrl-Command-Option-0&quot;),
        exec: function (editor) { editor.session.foldAllComments(); },
        scrollIntoView: &quot;center&quot;,
        readOnly: true
    }, {
        name: &quot;foldOther&quot;,
        description: &quot;Fold other&quot;,
        bindKey: bindKey(&quot;Alt-0&quot;, &quot;Command-Option-0&quot;),
        exec: function (editor) {
            editor.session.foldAll();
            editor.session.unfold(editor.selection.getAllRanges());
        },
        scrollIntoView: &quot;center&quot;,
        readOnly: true
    }, {
        name: &quot;unfoldall&quot;,
        description: &quot;Unfold all&quot;,
        bindKey: bindKey(&quot;Alt-Shift-0&quot;, &quot;Command-Option-Shift-0&quot;),
        exec: function (editor) { editor.session.unfold(); },
        scrollIntoView: &quot;center&quot;,
        readOnly: true
    }, {
        name: &quot;findnext&quot;,
        description: &quot;Find next&quot;,
        bindKey: bindKey(&quot;Ctrl-K&quot;, &quot;Command-G&quot;),
        exec: function (editor) { editor.findNext(); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;center&quot;,
        readOnly: true
    }, {
        name: &quot;findprevious&quot;,
        description: &quot;Find previous&quot;,
        bindKey: bindKey(&quot;Ctrl-Shift-K&quot;, &quot;Command-Shift-G&quot;),
        exec: function (editor) { editor.findPrevious(); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;center&quot;,
        readOnly: true
    }, {
        name: &quot;selectOrFindNext&quot;,
        description: &quot;Select or find next&quot;,
        bindKey: bindKey(&quot;Alt-K&quot;, &quot;Ctrl-G&quot;),
        exec: function (editor) {
            if (editor.selection.isEmpty())
                editor.selection.selectWord();
            else
                editor.findNext();
        },
        readOnly: true
    }, {
        name: &quot;selectOrFindPrevious&quot;,
        description: &quot;Select or find previous&quot;,
        bindKey: bindKey(&quot;Alt-Shift-K&quot;, &quot;Ctrl-Shift-G&quot;),
        exec: function (editor) {
            if (editor.selection.isEmpty())
                editor.selection.selectWord();
            else
                editor.findPrevious();
        },
        readOnly: true
    }, {
        name: &quot;find&quot;,
        description: &quot;Find&quot;,
        bindKey: bindKey(&quot;Ctrl-F&quot;, &quot;Command-F&quot;),
        exec: function (editor) {
            config.loadModule(&quot;ace/ext/searchbox&quot;, function (e) { e.Search(editor); });
        },
        readOnly: true
    }, {
        name: &quot;overwrite&quot;,
        description: &quot;Overwrite&quot;,
        bindKey: &quot;Insert&quot;,
        exec: function (editor) { editor.toggleOverwrite(); },
        readOnly: true
    }, {
        name: &quot;selecttostart&quot;,
        description: &quot;Select to start&quot;,
        bindKey: bindKey(&quot;Ctrl-Shift-Home&quot;, &quot;Command-Shift-Home|Command-Shift-Up&quot;),
        exec: function (editor) { editor.getSelection().selectFileStart(); },
        multiSelectAction: &quot;forEach&quot;,
        readOnly: true,
        scrollIntoView: &quot;animate&quot;,
        aceCommandGroup: &quot;fileJump&quot;
    }, {
        name: &quot;gotostart&quot;,
        description: &quot;Go to start&quot;,
        bindKey: bindKey(&quot;Ctrl-Home&quot;, &quot;Command-Home|Command-Up&quot;),
        exec: function (editor) { editor.navigateFileStart(); },
        multiSelectAction: &quot;forEach&quot;,
        readOnly: true,
        scrollIntoView: &quot;animate&quot;,
        aceCommandGroup: &quot;fileJump&quot;
    }, {
        name: &quot;selectup&quot;,
        description: &quot;Select up&quot;,
        bindKey: bindKey(&quot;Shift-Up&quot;, &quot;Shift-Up|Ctrl-Shift-P&quot;),
        exec: function (editor) { editor.getSelection().selectUp(); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;,
        readOnly: true
    }, {
        name: &quot;golineup&quot;,
        description: &quot;Go line up&quot;,
        bindKey: bindKey(&quot;Up&quot;, &quot;Up|Ctrl-P&quot;),
        exec: function (editor, args) { editor.navigateUp(args.times); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;,
        readOnly: true
    }, {
        name: &quot;selecttoend&quot;,
        description: &quot;Select to end&quot;,
        bindKey: bindKey(&quot;Ctrl-Shift-End&quot;, &quot;Command-Shift-End|Command-Shift-Down&quot;),
        exec: function (editor) { editor.getSelection().selectFileEnd(); },
        multiSelectAction: &quot;forEach&quot;,
        readOnly: true,
        scrollIntoView: &quot;animate&quot;,
        aceCommandGroup: &quot;fileJump&quot;
    }, {
        name: &quot;gotoend&quot;,
        description: &quot;Go to end&quot;,
        bindKey: bindKey(&quot;Ctrl-End&quot;, &quot;Command-End|Command-Down&quot;),
        exec: function (editor) { editor.navigateFileEnd(); },
        multiSelectAction: &quot;forEach&quot;,
        readOnly: true,
        scrollIntoView: &quot;animate&quot;,
        aceCommandGroup: &quot;fileJump&quot;
    }, {
        name: &quot;selectdown&quot;,
        description: &quot;Select down&quot;,
        bindKey: bindKey(&quot;Shift-Down&quot;, &quot;Shift-Down|Ctrl-Shift-N&quot;),
        exec: function (editor) { editor.getSelection().selectDown(); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;,
        readOnly: true
    }, {
        name: &quot;golinedown&quot;,
        description: &quot;Go line down&quot;,
        bindKey: bindKey(&quot;Down&quot;, &quot;Down|Ctrl-N&quot;),
        exec: function (editor, args) { editor.navigateDown(args.times); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;,
        readOnly: true
    }, {
        name: &quot;selectwordleft&quot;,
        description: &quot;Select word left&quot;,
        bindKey: bindKey(&quot;Ctrl-Shift-Left&quot;, &quot;Option-Shift-Left&quot;),
        exec: function (editor) { editor.getSelection().selectWordLeft(); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;,
        readOnly: true
    }, {
        name: &quot;gotowordleft&quot;,
        description: &quot;Go to word left&quot;,
        bindKey: bindKey(&quot;Ctrl-Left&quot;, &quot;Option-Left&quot;),
        exec: function (editor) { editor.navigateWordLeft(); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;,
        readOnly: true
    }, {
        name: &quot;selecttolinestart&quot;,
        description: &quot;Select to line start&quot;,
        bindKey: bindKey(&quot;Alt-Shift-Left&quot;, &quot;Command-Shift-Left|Ctrl-Shift-A&quot;),
        exec: function (editor) { editor.getSelection().selectLineStart(); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;,
        readOnly: true
    }, {
        name: &quot;gotolinestart&quot;,
        description: &quot;Go to line start&quot;,
        bindKey: bindKey(&quot;Alt-Left|Home&quot;, &quot;Command-Left|Home|Ctrl-A&quot;),
        exec: function (editor) { editor.navigateLineStart(); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;,
        readOnly: true
    }, {
        name: &quot;selectleft&quot;,
        description: &quot;Select left&quot;,
        bindKey: bindKey(&quot;Shift-Left&quot;, &quot;Shift-Left|Ctrl-Shift-B&quot;),
        exec: function (editor) { editor.getSelection().selectLeft(); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;,
        readOnly: true
    }, {
        name: &quot;gotoleft&quot;,
        description: &quot;Go to left&quot;,
        bindKey: bindKey(&quot;Left&quot;, &quot;Left|Ctrl-B&quot;),
        exec: function (editor, args) { editor.navigateLeft(args.times); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;,
        readOnly: true
    }, {
        name: &quot;selectwordright&quot;,
        description: &quot;Select word right&quot;,
        bindKey: bindKey(&quot;Ctrl-Shift-Right&quot;, &quot;Option-Shift-Right&quot;),
        exec: function (editor) { editor.getSelection().selectWordRight(); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;,
        readOnly: true
    }, {
        name: &quot;gotowordright&quot;,
        description: &quot;Go to word right&quot;,
        bindKey: bindKey(&quot;Ctrl-Right&quot;, &quot;Option-Right&quot;),
        exec: function (editor) { editor.navigateWordRight(); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;,
        readOnly: true
    }, {
        name: &quot;selecttolineend&quot;,
        description: &quot;Select to line end&quot;,
        bindKey: bindKey(&quot;Alt-Shift-Right&quot;, &quot;Command-Shift-Right|Shift-End|Ctrl-Shift-E&quot;),
        exec: function (editor) { editor.getSelection().selectLineEnd(); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;,
        readOnly: true
    }, {
        name: &quot;gotolineend&quot;,
        description: &quot;Go to line end&quot;,
        bindKey: bindKey(&quot;Alt-Right|End&quot;, &quot;Command-Right|End|Ctrl-E&quot;),
        exec: function (editor) { editor.navigateLineEnd(); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;,
        readOnly: true
    }, {
        name: &quot;selectright&quot;,
        description: &quot;Select right&quot;,
        bindKey: bindKey(&quot;Shift-Right&quot;, &quot;Shift-Right&quot;),
        exec: function (editor) { editor.getSelection().selectRight(); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;,
        readOnly: true
    }, {
        name: &quot;gotoright&quot;,
        description: &quot;Go to right&quot;,
        bindKey: bindKey(&quot;Right&quot;, &quot;Right|Ctrl-F&quot;),
        exec: function (editor, args) { editor.navigateRight(args.times); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;,
        readOnly: true
    }, {
        name: &quot;selectpagedown&quot;,
        description: &quot;Select page down&quot;,
        bindKey: &quot;Shift-PageDown&quot;,
        exec: function (editor) { editor.selectPageDown(); },
        readOnly: true
    }, {
        name: &quot;pagedown&quot;,
        description: &quot;Page down&quot;,
        bindKey: bindKey(null, &quot;Option-PageDown&quot;),
        exec: function (editor) { editor.scrollPageDown(); },
        readOnly: true
    }, {
        name: &quot;gotopagedown&quot;,
        description: &quot;Go to page down&quot;,
        bindKey: bindKey(&quot;PageDown&quot;, &quot;PageDown|Ctrl-V&quot;),
        exec: function (editor) { editor.gotoPageDown(); },
        readOnly: true
    }, {
        name: &quot;selectpageup&quot;,
        description: &quot;Select page up&quot;,
        bindKey: &quot;Shift-PageUp&quot;,
        exec: function (editor) { editor.selectPageUp(); },
        readOnly: true
    }, {
        name: &quot;pageup&quot;,
        description: &quot;Page up&quot;,
        bindKey: bindKey(null, &quot;Option-PageUp&quot;),
        exec: function (editor) { editor.scrollPageUp(); },
        readOnly: true
    }, {
        name: &quot;gotopageup&quot;,
        description: &quot;Go to page up&quot;,
        bindKey: &quot;PageUp&quot;,
        exec: function (editor) { editor.gotoPageUp(); },
        readOnly: true
    }, {
        name: &quot;scrollup&quot;,
        description: &quot;Scroll up&quot;,
        bindKey: bindKey(&quot;Ctrl-Up&quot;, null),
        exec: function (e) { e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight); },
        readOnly: true
    }, {
        name: &quot;scrolldown&quot;,
        description: &quot;Scroll down&quot;,
        bindKey: bindKey(&quot;Ctrl-Down&quot;, null),
        exec: function (e) { e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight); },
        readOnly: true
    }, {
        name: &quot;selectlinestart&quot;,
        description: &quot;Select line start&quot;,
        bindKey: &quot;Shift-Home&quot;,
        exec: function (editor) { editor.getSelection().selectLineStart(); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;,
        readOnly: true
    }, {
        name: &quot;selectlineend&quot;,
        description: &quot;Select line end&quot;,
        bindKey: &quot;Shift-End&quot;,
        exec: function (editor) { editor.getSelection().selectLineEnd(); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;,
        readOnly: true
    }, {
        name: &quot;togglerecording&quot;,
        description: &quot;Toggle recording&quot;,
        bindKey: bindKey(&quot;Ctrl-Alt-E&quot;, &quot;Command-Option-E&quot;),
        exec: function (editor) { editor.commands.toggleRecording(editor); },
        readOnly: true
    }, {
        name: &quot;replaymacro&quot;,
        description: &quot;Replay macro&quot;,
        bindKey: bindKey(&quot;Ctrl-Shift-E&quot;, &quot;Command-Shift-E&quot;),
        exec: function (editor) { editor.commands.replay(editor); },
        readOnly: true
    }, {
        name: &quot;jumptomatching&quot;,
        description: &quot;Jump to matching&quot;,
        bindKey: bindKey(&quot;Ctrl-\\|Ctrl-P&quot;, &quot;Command-\\&quot;),
        exec: function (editor) { editor.jumpToMatching(); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;animate&quot;,
        readOnly: true
    }, {
        name: &quot;selecttomatching&quot;,
        description: &quot;Select to matching&quot;,
        bindKey: bindKey(&quot;Ctrl-Shift-\\|Ctrl-Shift-P&quot;, &quot;Command-Shift-\\&quot;),
        exec: function (editor) { editor.jumpToMatching(true); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;animate&quot;,
        readOnly: true
    }, {
        name: &quot;expandToMatching&quot;,
        description: &quot;Expand to matching&quot;,
        bindKey: bindKey(&quot;Ctrl-Shift-M&quot;, &quot;Ctrl-Shift-M&quot;),
        exec: function (editor) { editor.jumpToMatching(true, true); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;animate&quot;,
        readOnly: true
    }, {
        name: &quot;passKeysToBrowser&quot;,
        description: &quot;Pass keys to browser&quot;,
        bindKey: bindKey(null, null),
        exec: function () { },
        passEvent: true,
        readOnly: true
    }, {
        name: &quot;copy&quot;,
        description: &quot;Copy&quot;,
        exec: function (editor) {
        },
        readOnly: true
    },
    {
        name: &quot;cut&quot;,
        description: &quot;Cut&quot;,
        exec: function (editor) {
            var cutLine = editor.$copyWithEmptySelection &amp;&amp; editor.selection.isEmpty();
            var range = cutLine ? editor.selection.getLineRange() : editor.selection.getRange();
            editor._emit(&quot;cut&quot;, range);
            if (!range.isEmpty())
                editor.session.remove(range);
            editor.clearSelection();
        },
        scrollIntoView: &quot;cursor&quot;,
        multiSelectAction: &quot;forEach&quot;
    }, {
        name: &quot;paste&quot;,
        description: &quot;Paste&quot;,
        exec: function (editor, args) {
            editor.$handlePaste(args);
        },
        scrollIntoView: &quot;cursor&quot;
    }, {
        name: &quot;removeline&quot;,
        description: &quot;Remove line&quot;,
        bindKey: bindKey(&quot;Ctrl-D&quot;, &quot;Command-D&quot;),
        exec: function (editor) { editor.removeLines(); },
        scrollIntoView: &quot;cursor&quot;,
        multiSelectAction: &quot;forEachLine&quot;
    }, {
        name: &quot;duplicateSelection&quot;,
        description: &quot;Duplicate selection&quot;,
        bindKey: bindKey(&quot;Ctrl-Shift-D&quot;, &quot;Command-Shift-D&quot;),
        exec: function (editor) { editor.duplicateSelection(); },
        scrollIntoView: &quot;cursor&quot;,
        multiSelectAction: &quot;forEach&quot;
    }, {
        name: &quot;sortlines&quot;,
        description: &quot;Sort lines&quot;,
        bindKey: bindKey(&quot;Ctrl-Alt-S&quot;, &quot;Command-Alt-S&quot;),
        exec: function (editor) { editor.sortLines(); },
        scrollIntoView: &quot;selection&quot;,
        multiSelectAction: &quot;forEachLine&quot;
    }, {
        name: &quot;togglecomment&quot;,
        description: &quot;Toggle comment&quot;,
        bindKey: bindKey(&quot;Ctrl-/&quot;, &quot;Command-/&quot;),
        exec: function (editor) { editor.toggleCommentLines(); },
        multiSelectAction: &quot;forEachLine&quot;,
        scrollIntoView: &quot;selectionPart&quot;
    }, {
        name: &quot;toggleBlockComment&quot;,
        description: &quot;Toggle block comment&quot;,
        bindKey: bindKey(&quot;Ctrl-Shift-/&quot;, &quot;Command-Shift-/&quot;),
        exec: function (editor) { editor.toggleBlockComment(); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;selectionPart&quot;
    }, {
        name: &quot;modifyNumberUp&quot;,
        description: &quot;Modify number up&quot;,
        bindKey: bindKey(&quot;Ctrl-Shift-Up&quot;, &quot;Alt-Shift-Up&quot;),
        exec: function (editor) { editor.modifyNumber(1); },
        scrollIntoView: &quot;cursor&quot;,
        multiSelectAction: &quot;forEach&quot;
    }, {
        name: &quot;modifyNumberDown&quot;,
        description: &quot;Modify number down&quot;,
        bindKey: bindKey(&quot;Ctrl-Shift-Down&quot;, &quot;Alt-Shift-Down&quot;),
        exec: function (editor) { editor.modifyNumber(-1); },
        scrollIntoView: &quot;cursor&quot;,
        multiSelectAction: &quot;forEach&quot;
    }, {
        name: &quot;replace&quot;,
        description: &quot;Replace&quot;,
        bindKey: bindKey(&quot;Ctrl-H&quot;, &quot;Command-Option-F&quot;),
        exec: function (editor) {
            config.loadModule(&quot;ace/ext/searchbox&quot;, function (e) { e.Search(editor, true); });
        }
    }, {
        name: &quot;undo&quot;,
        description: &quot;Undo&quot;,
        bindKey: bindKey(&quot;Ctrl-Z&quot;, &quot;Command-Z&quot;),
        exec: function (editor) { editor.undo(); }
    }, {
        name: &quot;redo&quot;,
        description: &quot;Redo&quot;,
        bindKey: bindKey(&quot;Ctrl-Shift-Z|Ctrl-Y&quot;, &quot;Command-Shift-Z|Command-Y&quot;),
        exec: function (editor) { editor.redo(); }
    }, {
        name: &quot;copylinesup&quot;,
        description: &quot;Copy lines up&quot;,
        bindKey: bindKey(&quot;Alt-Shift-Up&quot;, &quot;Command-Option-Up&quot;),
        exec: function (editor) { editor.copyLinesUp(); },
        scrollIntoView: &quot;cursor&quot;
    }, {
        name: &quot;movelinesup&quot;,
        description: &quot;Move lines up&quot;,
        bindKey: bindKey(&quot;Alt-Up&quot;, &quot;Option-Up&quot;),
        exec: function (editor) { editor.moveLinesUp(); },
        scrollIntoView: &quot;cursor&quot;
    }, {
        name: &quot;copylinesdown&quot;,
        description: &quot;Copy lines down&quot;,
        bindKey: bindKey(&quot;Alt-Shift-Down&quot;, &quot;Command-Option-Down&quot;),
        exec: function (editor) { editor.copyLinesDown(); },
        scrollIntoView: &quot;cursor&quot;
    }, {
        name: &quot;movelinesdown&quot;,
        description: &quot;Move lines down&quot;,
        bindKey: bindKey(&quot;Alt-Down&quot;, &quot;Option-Down&quot;),
        exec: function (editor) { editor.moveLinesDown(); },
        scrollIntoView: &quot;cursor&quot;
    }, {
        name: &quot;del&quot;,
        description: &quot;Delete&quot;,
        bindKey: bindKey(&quot;Delete&quot;, &quot;Delete|Ctrl-D|Shift-Delete&quot;),
        exec: function (editor) { editor.remove(&quot;right&quot;); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;
    }, {
        name: &quot;backspace&quot;,
        description: &quot;Backspace&quot;,
        bindKey: bindKey(&quot;Shift-Backspace|Backspace&quot;, &quot;Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H&quot;),
        exec: function (editor) { editor.remove(&quot;left&quot;); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;
    }, {
        name: &quot;cut_or_delete&quot;,
        description: &quot;Cut or delete&quot;,
        bindKey: bindKey(&quot;Shift-Delete&quot;, null),
        exec: function (editor) {
            if (editor.selection.isEmpty()) {
                editor.remove(&quot;left&quot;);
            }
            else {
                return false;
            }
        },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;
    }, {
        name: &quot;removetolinestart&quot;,
        description: &quot;Remove to line start&quot;,
        bindKey: bindKey(&quot;Alt-Backspace&quot;, &quot;Command-Backspace&quot;),
        exec: function (editor) { editor.removeToLineStart(); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;
    }, {
        name: &quot;removetolineend&quot;,
        description: &quot;Remove to line end&quot;,
        bindKey: bindKey(&quot;Alt-Delete&quot;, &quot;Ctrl-K|Command-Delete&quot;),
        exec: function (editor) { editor.removeToLineEnd(); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;
    }, {
        name: &quot;removetolinestarthard&quot;,
        description: &quot;Remove to line start hard&quot;,
        bindKey: bindKey(&quot;Ctrl-Shift-Backspace&quot;, null),
        exec: function (editor) {
            var range = editor.selection.getRange();
            range.start.column = 0;
            editor.session.remove(range);
        },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;
    }, {
        name: &quot;removetolineendhard&quot;,
        description: &quot;Remove to line end hard&quot;,
        bindKey: bindKey(&quot;Ctrl-Shift-Delete&quot;, null),
        exec: function (editor) {
            var range = editor.selection.getRange();
            range.end.column = Number.MAX_VALUE;
            editor.session.remove(range);
        },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;
    }, {
        name: &quot;removewordleft&quot;,
        description: &quot;Remove word left&quot;,
        bindKey: bindKey(&quot;Ctrl-Backspace&quot;, &quot;Alt-Backspace|Ctrl-Alt-Backspace&quot;),
        exec: function (editor) { editor.removeWordLeft(); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;
    }, {
        name: &quot;removewordright&quot;,
        description: &quot;Remove word right&quot;,
        bindKey: bindKey(&quot;Ctrl-Delete&quot;, &quot;Alt-Delete&quot;),
        exec: function (editor) { editor.removeWordRight(); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;
    }, {
        name: &quot;outdent&quot;,
        description: &quot;Outdent&quot;,
        bindKey: bindKey(&quot;Shift-Tab&quot;, &quot;Shift-Tab&quot;),
        exec: function (editor) { editor.blockOutdent(); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;selectionPart&quot;
    }, {
        name: &quot;indent&quot;,
        description: &quot;Indent&quot;,
        bindKey: bindKey(&quot;Tab&quot;, &quot;Tab&quot;),
        exec: function (editor) { editor.indent(); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;selectionPart&quot;
    }, {
        name: &quot;blockoutdent&quot;,
        description: &quot;Block outdent&quot;,
        bindKey: bindKey(&quot;Ctrl-[&quot;, &quot;Ctrl-[&quot;),
        exec: function (editor) { editor.blockOutdent(); },
        multiSelectAction: &quot;forEachLine&quot;,
        scrollIntoView: &quot;selectionPart&quot;
    }, {
        name: &quot;blockindent&quot;,
        description: &quot;Block indent&quot;,
        bindKey: bindKey(&quot;Ctrl-]&quot;, &quot;Ctrl-]&quot;),
        exec: function (editor) { editor.blockIndent(); },
        multiSelectAction: &quot;forEachLine&quot;,
        scrollIntoView: &quot;selectionPart&quot;
    }, {
        name: &quot;insertstring&quot;,
        description: &quot;Insert string&quot;,
        exec: function (editor, str) { editor.insert(str); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;
    }, {
        name: &quot;inserttext&quot;,
        description: &quot;Insert text&quot;,
        exec: function (editor, args) {
            editor.insert(lang.stringRepeat(args.text || &quot;&quot;, args.times || 1));
        },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;
    }, {
        name: &quot;splitline&quot;,
        description: &quot;Split line&quot;,
        bindKey: bindKey(null, &quot;Ctrl-O&quot;),
        exec: function (editor) { editor.splitLine(); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;
    }, {
        name: &quot;transposeletters&quot;,
        description: &quot;Transpose letters&quot;,
        bindKey: bindKey(&quot;Alt-Shift-X&quot;, &quot;Ctrl-T&quot;),
        exec: function (editor) { editor.transposeLetters(); },
        multiSelectAction: function (editor) { editor.transposeSelections(1); },
        scrollIntoView: &quot;cursor&quot;
    }, {
        name: &quot;touppercase&quot;,
        description: &quot;To uppercase&quot;,
        bindKey: bindKey(&quot;Ctrl-U&quot;, &quot;Ctrl-U&quot;),
        exec: function (editor) { editor.toUpperCase(); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;
    }, {
        name: &quot;tolowercase&quot;,
        description: &quot;To lowercase&quot;,
        bindKey: bindKey(&quot;Ctrl-Shift-U&quot;, &quot;Ctrl-Shift-U&quot;),
        exec: function (editor) { editor.toLowerCase(); },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;
    }, {
        name: &quot;autoindent&quot;,
        description: &quot;Auto Indent&quot;,
        bindKey: bindKey(null, null),
        exec: function (editor) { editor.autoIndent(); },
        multiSelectAction: &quot;forEachLine&quot;,
        scrollIntoView: &quot;animate&quot;
    }, {
        name: &quot;expandtoline&quot;,
        description: &quot;Expand to line&quot;,
        bindKey: bindKey(&quot;Ctrl-Shift-L&quot;, &quot;Command-Shift-L&quot;),
        exec: function (editor) {
            var range = editor.selection.getRange();
            range.start.column = range.end.column = 0;
            range.end.row++;
            editor.selection.setRange(range, false);
        },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;,
        readOnly: true
    }, {
        name: &quot;openlink&quot;,
        bindKey: bindKey(&quot;Ctrl+F3&quot;, &quot;F3&quot;),
        exec: function (editor) { editor.openLink(); }
    }, {
        name: &quot;joinlines&quot;,
        description: &quot;Join lines&quot;,
        bindKey: bindKey(null, null),
        exec: function (editor) {
            var isBackwards = editor.selection.isBackwards();
            var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
            var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
            var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
            var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
            var selectedCount = selectedText.replace(/\n\s*/, &quot; &quot;).length;
            var insertLine = editor.session.doc.getLine(selectionStart.row);
            for (var i = selectionStart.row + 1; i &lt;= selectionEnd.row + 1; i++) {
                var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));
                if (curLine.length !== 0) {
                    curLine = &quot; &quot; + curLine;
                }
                insertLine += curLine;
            }
            if (selectionEnd.row + 1 &lt; (editor.session.doc.getLength() - 1)) {
                insertLine += editor.session.doc.getNewLineCharacter();
            }
            editor.clearSelection();
            editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);
            if (selectedCount &gt; 0) {
                editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
                editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
            }
            else {
                firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length &gt; firstLineEndCol ? (firstLineEndCol + 1) : firstLineEndCol;
                editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
            }
        },
        multiSelectAction: &quot;forEach&quot;,
        readOnly: true
    }, {
        name: &quot;invertSelection&quot;,
        description: &quot;Invert selection&quot;,
        bindKey: bindKey(null, null),
        exec: function (editor) {
            var endRow = editor.session.doc.getLength() - 1;
            var endCol = editor.session.doc.getLine(endRow).length;
            var ranges = editor.selection.rangeList.ranges;
            var newRanges = [];
            if (ranges.length &lt; 1) {
                ranges = [editor.selection.getRange()];
            }
            for (var i = 0; i &lt; ranges.length; i++) {
                if (i == (ranges.length - 1)) {
                    if (!(ranges[i].end.row === endRow &amp;&amp; ranges[i].end.column === endCol)) {
                        newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));
                    }
                }
                if (i === 0) {
                    if (!(ranges[i].start.row === 0 &amp;&amp; ranges[i].start.column === 0)) {
                        newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));
                    }
                }
                else {
                    newRanges.push(new Range(ranges[i - 1].end.row, ranges[i - 1].end.column, ranges[i].start.row, ranges[i].start.column));
                }
            }
            editor.exitMultiSelectMode();
            editor.clearSelection();
            for (var i = 0; i &lt; newRanges.length; i++) {
                editor.selection.addRange(newRanges[i], false);
            }
        },
        readOnly: true,
        scrollIntoView: &quot;none&quot;
    }, {
        name: &quot;addLineAfter&quot;,
        description: &quot;Add new line after the current line&quot;,
        exec: function (editor) {
            editor.selection.clearSelection();
            editor.navigateLineEnd();
            editor.insert(&quot;\n&quot;);
        },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;
    }, {
        name: &quot;addLineBefore&quot;,
        description: &quot;Add new line before the current line&quot;,
        exec: function (editor) {
            editor.selection.clearSelection();
            var cursor = editor.getCursorPosition();
            editor.selection.moveTo(cursor.row - 1, Number.MAX_VALUE);
            editor.insert(&quot;\n&quot;);
            if (cursor.row === 0)
                editor.navigateUp();
        },
        multiSelectAction: &quot;forEach&quot;,
        scrollIntoView: &quot;cursor&quot;
    }, {
        name: &quot;openCommandPallete&quot;,
        description: &quot;Open command palette&quot;,
        bindKey: bindKey(&quot;F1&quot;, &quot;F1&quot;),
        exec: function (editor) {
            editor.prompt({ $type: &quot;commands&quot; });
        },
        readOnly: true
    }, {
        name: &quot;modeSelect&quot;,
        description: &quot;Change language mode...&quot;,
        bindKey: bindKey(null, null),
        exec: function (editor) {
            editor.prompt({ $type: &quot;modes&quot; });
        },
        readOnly: true
    }];
for (var i = 1; i &lt; 9; i++) {
    exports.commands.push({
        name: &quot;foldToLevel&quot; + i,
        description: &quot;Fold To Level &quot; + i,
        level: i,
        exec: function (editor) { editor.session.foldToLevel(this.level); },
        scrollIntoView: &quot;center&quot;,
        readOnly: true
    });
}

});

define(&quot;ace/editor&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/dom&quot;,&quot;ace/lib/lang&quot;,&quot;ace/lib/useragent&quot;,&quot;ace/keyboard/textinput&quot;,&quot;ace/mouse/mouse_handler&quot;,&quot;ace/mouse/fold_handler&quot;,&quot;ace/keyboard/keybinding&quot;,&quot;ace/edit_session&quot;,&quot;ace/search&quot;,&quot;ace/range&quot;,&quot;ace/lib/event_emitter&quot;,&quot;ace/commands/command_manager&quot;,&quot;ace/commands/default_commands&quot;,&quot;ace/config&quot;,&quot;ace/token_iterator&quot;,&quot;ace/clipboard&quot;], function(require, exports, module){&quot;use strict&quot;;
var __values = (this &amp;&amp; this.__values) || function(o) {
    var s = typeof Symbol === &quot;function&quot; &amp;&amp; Symbol.iterator, m = s &amp;&amp; o[s], i = 0;
    if (m) return m.call(o);
    if (o &amp;&amp; typeof o.length === &quot;number&quot;) return {
        next: function () {
            if (o &amp;&amp; i &gt;= o.length) o = void 0;
            return { value: o &amp;&amp; o[i++], done: !o };
        }
    };
    throw new TypeError(s ? &quot;Object is not iterable.&quot; : &quot;Symbol.iterator is not defined.&quot;);
};
var oop = require(&quot;./lib/oop&quot;);
var dom = require(&quot;./lib/dom&quot;);
var lang = require(&quot;./lib/lang&quot;);
var useragent = require(&quot;./lib/useragent&quot;);
var TextInput = require(&quot;./keyboard/textinput&quot;).TextInput;
var MouseHandler = require(&quot;./mouse/mouse_handler&quot;).MouseHandler;
var FoldHandler = require(&quot;./mouse/fold_handler&quot;).FoldHandler;
var KeyBinding = require(&quot;./keyboard/keybinding&quot;).KeyBinding;
var EditSession = require(&quot;./edit_session&quot;).EditSession;
var Search = require(&quot;./search&quot;).Search;
var Range = require(&quot;./range&quot;).Range;
var EventEmitter = require(&quot;./lib/event_emitter&quot;).EventEmitter;
var CommandManager = require(&quot;./commands/command_manager&quot;).CommandManager;
var defaultCommands = require(&quot;./commands/default_commands&quot;).commands;
var config = require(&quot;./config&quot;);
var TokenIterator = require(&quot;./token_iterator&quot;).TokenIterator;
var clipboard = require(&quot;./clipboard&quot;);
var Editor = function (renderer, session, options) {
    this.$toDestroy = [];
    var container = renderer.getContainerElement();
    this.container = container;
    this.renderer = renderer;
    this.id = &quot;editor&quot; + (++Editor.$uid);
    this.commands = new CommandManager(useragent.isMac ? &quot;mac&quot; : &quot;win&quot;, defaultCommands);
    if (typeof document == &quot;object&quot;) {
        this.textInput = new TextInput(renderer.getTextAreaContainer(), this);
        this.renderer.textarea = this.textInput.getElement();
        this.$mouseHandler = new MouseHandler(this);
        new FoldHandler(this);
    }
    this.keyBinding = new KeyBinding(this);
    this.$search = new Search().set({
        wrap: true
    });
    this.$historyTracker = this.$historyTracker.bind(this);
    this.commands.on(&quot;exec&quot;, this.$historyTracker);
    this.$initOperationListeners();
    this._$emitInputEvent = lang.delayedCall(function () {
        this._signal(&quot;input&quot;, {});
        if (this.session &amp;&amp; !this.session.destroyed)
            this.session.bgTokenizer.scheduleStart();
    }.bind(this));
    this.on(&quot;change&quot;, function (_, _self) {
        _self._$emitInputEvent.schedule(31);
    });
    this.setSession(session || options &amp;&amp; options.session || new EditSession(&quot;&quot;));
    config.resetOptions(this);
    if (options)
        this.setOptions(options);
    config._signal(&quot;editor&quot;, this);
};
Editor.$uid = 0;
(function () {
    oop.implement(this, EventEmitter);
    this.$initOperationListeners = function () {
        this.commands.on(&quot;exec&quot;, this.startOperation.bind(this), true);
        this.commands.on(&quot;afterExec&quot;, this.endOperation.bind(this), true);
        this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this, true));
        this.on(&quot;change&quot;, function () {
            if (!this.curOp) {
                this.startOperation();
                this.curOp.selectionBefore = this.$lastSel;
            }
            this.curOp.docChanged = true;
        }.bind(this), true);
        this.on(&quot;changeSelection&quot;, function () {
            if (!this.curOp) {
                this.startOperation();
                this.curOp.selectionBefore = this.$lastSel;
            }
            this.curOp.selectionChanged = true;
        }.bind(this), true);
    };
    this.curOp = null;
    this.prevOp = {};
    this.startOperation = function (commandEvent) {
        if (this.curOp) {
            if (!commandEvent || this.curOp.command)
                return;
            this.prevOp = this.curOp;
        }
        if (!commandEvent) {
            this.previousCommand = null;
            commandEvent = {};
        }
        this.$opResetTimer.schedule();
        this.curOp = this.session.curOp = {
            command: commandEvent.command || {},
            args: commandEvent.args,
            scrollTop: this.renderer.scrollTop
        };
        this.curOp.selectionBefore = this.selection.toJSON();
    };
    this.endOperation = function (e) {
        if (this.curOp &amp;&amp; this.session) {
            if (e &amp;&amp; e.returnValue === false || !this.session)
                return (this.curOp = null);
            if (e == true &amp;&amp; this.curOp.command &amp;&amp; this.curOp.command.name == &quot;mouse&quot;)
                return;
            this._signal(&quot;beforeEndOperation&quot;);
            if (!this.curOp)
                return;
            var command = this.curOp.command;
            var scrollIntoView = command &amp;&amp; command.scrollIntoView;
            if (scrollIntoView) {
                switch (scrollIntoView) {
                    case &quot;center-animate&quot;:
                        scrollIntoView = &quot;animate&quot;;
                    case &quot;center&quot;:
                        this.renderer.scrollCursorIntoView(null, 0.5);
                        break;
                    case &quot;animate&quot;:
                    case &quot;cursor&quot;:
                        this.renderer.scrollCursorIntoView();
                        break;
                    case &quot;selectionPart&quot;:
                        var range = this.selection.getRange();
                        var config = this.renderer.layerConfig;
                        if (range.start.row &gt;= config.lastRow || range.end.row &lt;= config.firstRow) {
                            this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                        }
                        break;
                    default:
                        break;
                }
                if (scrollIntoView == &quot;animate&quot;)
                    this.renderer.animateScrolling(this.curOp.scrollTop);
            }
            var sel = this.selection.toJSON();
            this.curOp.selectionAfter = sel;
            this.$lastSel = this.selection.toJSON();
            this.session.getUndoManager().addSelection(sel);
            this.prevOp = this.curOp;
            this.curOp = null;
        }
    };
    this.$mergeableCommands = [&quot;backspace&quot;, &quot;del&quot;, &quot;insertstring&quot;];
    this.$historyTracker = function (e) {
        if (!this.$mergeUndoDeltas)
            return;
        var prev = this.prevOp;
        var mergeableCommands = this.$mergeableCommands;
        var shouldMerge = prev.command &amp;&amp; (e.command.name == prev.command.name);
        if (e.command.name == &quot;insertstring&quot;) {
            var text = e.args;
            if (this.mergeNextCommand === undefined)
                this.mergeNextCommand = true;
            shouldMerge = shouldMerge
                &amp;&amp; this.mergeNextCommand // previous command allows to coalesce with
                &amp;&amp; (!/\s/.test(text) || /\s/.test(prev.args)); // previous insertion was of same type
            this.mergeNextCommand = true;
        }
        else {
            shouldMerge = shouldMerge
                &amp;&amp; mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable
        }
        if (this.$mergeUndoDeltas != &quot;always&quot;
            &amp;&amp; Date.now() - this.sequenceStartTime &gt; 2000) {
            shouldMerge = false; // the sequence is too long
        }
        if (shouldMerge)
            this.session.mergeUndoDeltas = true;
        else if (mergeableCommands.indexOf(e.command.name) !== -1)
            this.sequenceStartTime = Date.now();
    };
    this.setKeyboardHandler = function (keyboardHandler, cb) {
        if (keyboardHandler &amp;&amp; typeof keyboardHandler === &quot;string&quot; &amp;&amp; keyboardHandler != &quot;ace&quot;) {
            this.$keybindingId = keyboardHandler;
            var _self = this;
            config.loadModule([&quot;keybinding&quot;, keyboardHandler], function (module) {
                if (_self.$keybindingId == keyboardHandler)
                    _self.keyBinding.setKeyboardHandler(module &amp;&amp; module.handler);
                cb &amp;&amp; cb();
            });
        }
        else {
            this.$keybindingId = null;
            this.keyBinding.setKeyboardHandler(keyboardHandler);
            cb &amp;&amp; cb();
        }
    };
    this.getKeyboardHandler = function () {
        return this.keyBinding.getKeyboardHandler();
    };
    this.setSession = function (session) {
        if (this.session == session)
            return;
        if (this.curOp)
            this.endOperation();
        this.curOp = {};
        var oldSession = this.session;
        if (oldSession) {
            this.session.off(&quot;change&quot;, this.$onDocumentChange);
            this.session.off(&quot;changeMode&quot;, this.$onChangeMode);
            this.session.off(&quot;tokenizerUpdate&quot;, this.$onTokenizerUpdate);
            this.session.off(&quot;changeTabSize&quot;, this.$onChangeTabSize);
            this.session.off(&quot;changeWrapLimit&quot;, this.$onChangeWrapLimit);
            this.session.off(&quot;changeWrapMode&quot;, this.$onChangeWrapMode);
            this.session.off(&quot;changeFold&quot;, this.$onChangeFold);
            this.session.off(&quot;changeFrontMarker&quot;, this.$onChangeFrontMarker);
            this.session.off(&quot;changeBackMarker&quot;, this.$onChangeBackMarker);
            this.session.off(&quot;changeBreakpoint&quot;, this.$onChangeBreakpoint);
            this.session.off(&quot;changeAnnotation&quot;, this.$onChangeAnnotation);
            this.session.off(&quot;changeOverwrite&quot;, this.$onCursorChange);
            this.session.off(&quot;changeScrollTop&quot;, this.$onScrollTopChange);
            this.session.off(&quot;changeScrollLeft&quot;, this.$onScrollLeftChange);
            var selection = this.session.getSelection();
            selection.off(&quot;changeCursor&quot;, this.$onCursorChange);
            selection.off(&quot;changeSelection&quot;, this.$onSelectionChange);
        }
        this.session = session;
        if (session) {
            this.$onDocumentChange = this.onDocumentChange.bind(this);
            session.on(&quot;change&quot;, this.$onDocumentChange);
            this.renderer.setSession(session);
            this.$onChangeMode = this.onChangeMode.bind(this);
            session.on(&quot;changeMode&quot;, this.$onChangeMode);
            this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
            session.on(&quot;tokenizerUpdate&quot;, this.$onTokenizerUpdate);
            this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
            session.on(&quot;changeTabSize&quot;, this.$onChangeTabSize);
            this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
            session.on(&quot;changeWrapLimit&quot;, this.$onChangeWrapLimit);
            this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
            session.on(&quot;changeWrapMode&quot;, this.$onChangeWrapMode);
            this.$onChangeFold = this.onChangeFold.bind(this);
            session.on(&quot;changeFold&quot;, this.$onChangeFold);
            this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
            this.session.on(&quot;changeFrontMarker&quot;, this.$onChangeFrontMarker);
            this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
            this.session.on(&quot;changeBackMarker&quot;, this.$onChangeBackMarker);
            this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
            this.session.on(&quot;changeBreakpoint&quot;, this.$onChangeBreakpoint);
            this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
            this.session.on(&quot;changeAnnotation&quot;, this.$onChangeAnnotation);
            this.$onCursorChange = this.onCursorChange.bind(this);
            this.session.on(&quot;changeOverwrite&quot;, this.$onCursorChange);
            this.$onScrollTopChange = this.onScrollTopChange.bind(this);
            this.session.on(&quot;changeScrollTop&quot;, this.$onScrollTopChange);
            this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
            this.session.on(&quot;changeScrollLeft&quot;, this.$onScrollLeftChange);
            this.selection = session.getSelection();
            this.selection.on(&quot;changeCursor&quot;, this.$onCursorChange);
            this.$onSelectionChange = this.onSelectionChange.bind(this);
            this.selection.on(&quot;changeSelection&quot;, this.$onSelectionChange);
            this.onChangeMode();
            this.onCursorChange();
            this.onScrollTopChange();
            this.onScrollLeftChange();
            this.onSelectionChange();
            this.onChangeFrontMarker();
            this.onChangeBackMarker();
            this.onChangeBreakpoint();
            this.onChangeAnnotation();
            this.session.getUseWrapMode() &amp;&amp; this.renderer.adjustWrapLimit();
            this.renderer.updateFull();
        }
        else {
            this.selection = null;
            this.renderer.setSession(session);
        }
        this._signal(&quot;changeSession&quot;, {
            session: session,
            oldSession: oldSession
        });
        this.curOp = null;
        oldSession &amp;&amp; oldSession._signal(&quot;changeEditor&quot;, { oldEditor: this });
        session &amp;&amp; session._signal(&quot;changeEditor&quot;, { editor: this });
        if (session &amp;&amp; !session.destroyed)
            session.bgTokenizer.scheduleStart();
    };
    this.getSession = function () {
        return this.session;
    };
    this.setValue = function (val, cursorPos) {
        this.session.doc.setValue(val);
        if (!cursorPos)
            this.selectAll();
        else if (cursorPos == 1)
            this.navigateFileEnd();
        else if (cursorPos == -1)
            this.navigateFileStart();
        return val;
    };
    this.getValue = function () {
        return this.session.getValue();
    };
    this.getSelection = function () {
        return this.selection;
    };
    this.resize = function (force) {
        this.renderer.onResize(force);
    };
    this.setTheme = function (theme, cb) {
        this.renderer.setTheme(theme, cb);
    };
    this.getTheme = function () {
        return this.renderer.getTheme();
    };
    this.setStyle = function (style) {
        this.renderer.setStyle(style);
    };
    this.unsetStyle = function (style) {
        this.renderer.unsetStyle(style);
    };
    this.getFontSize = function () {
        return this.getOption(&quot;fontSize&quot;) ||
            dom.computedStyle(this.container).fontSize;
    };
    this.setFontSize = function (size) {
        this.setOption(&quot;fontSize&quot;, size);
    };
    this.$highlightBrackets = function () {
        if (this.$highlightPending) {
            return;
        }
        var self = this;
        this.$highlightPending = true;
        setTimeout(function () {
            self.$highlightPending = false;
            var session = self.session;
            if (!session || session.destroyed)
                return;
            if (session.$bracketHighlight) {
                session.$bracketHighlight.markerIds.forEach(function (id) {
                    session.removeMarker(id);
                });
                session.$bracketHighlight = null;
            }
            var pos = self.getCursorPosition();
            var handler = self.getKeyboardHandler();
            var isBackwards = handler &amp;&amp; handler.$getDirectionForHighlight &amp;&amp; handler.$getDirectionForHighlight(self);
            var ranges = session.getMatchingBracketRanges(pos, isBackwards);
            if (!ranges) {
                var iterator = new TokenIterator(session, pos.row, pos.column);
                var token = iterator.getCurrentToken();
                if (token &amp;&amp; /\b(?:tag-open|tag-name)/.test(token.type)) {
                    var tagNamesRanges = session.getMatchingTags(pos);
                    if (tagNamesRanges)
                        ranges = [tagNamesRanges.openTagName, tagNamesRanges.closeTagName];
                }
            }
            if (!ranges &amp;&amp; session.$mode.getMatching)
                ranges = session.$mode.getMatching(self.session);
            if (!ranges) {
                if (self.getHighlightIndentGuides())
                    self.renderer.$textLayer.$highlightIndentGuide();
                return;
            }
            var markerType = &quot;ace_bracket&quot;;
            if (!Array.isArray(ranges)) {
                ranges = [ranges];
            }
            else if (ranges.length == 1) {
                markerType = &quot;ace_error_bracket&quot;;
            }
            if (ranges.length == 2) {
                if (Range.comparePoints(ranges[0].end, ranges[1].start) == 0)
                    ranges = [Range.fromPoints(ranges[0].start, ranges[1].end)];
                else if (Range.comparePoints(ranges[0].start, ranges[1].end) == 0)
                    ranges = [Range.fromPoints(ranges[1].start, ranges[0].end)];
            }
            session.$bracketHighlight = {
                ranges: ranges,
                markerIds: ranges.map(function (range) {
                    return session.addMarker(range, markerType, &quot;text&quot;);
                })
            };
            if (self.getHighlightIndentGuides())
                self.renderer.$textLayer.$highlightIndentGuide();
        }, 50);
    };
    this.focus = function () {
        this.textInput.focus();
    };
    this.isFocused = function () {
        return this.textInput.isFocused();
    };
    this.blur = function () {
        this.textInput.blur();
    };
    this.onFocus = function (e) {
        if (this.$isFocused)
            return;
        this.$isFocused = true;
        this.renderer.showCursor();
        this.renderer.visualizeFocus();
        this._emit(&quot;focus&quot;, e);
    };
    this.onBlur = function (e) {
        if (!this.$isFocused)
            return;
        this.$isFocused = false;
        this.renderer.hideCursor();
        this.renderer.visualizeBlur();
        this._emit(&quot;blur&quot;, e);
    };
    this.$cursorChange = function () {
        this.renderer.updateCursor();
        this.$highlightBrackets();
        this.$updateHighlightActiveLine();
    };
    this.onDocumentChange = function (delta) {
        var wrap = this.session.$useWrapMode;
        var lastRow = (delta.start.row == delta.end.row ? delta.end.row : Infinity);
        this.renderer.updateLines(delta.start.row, lastRow, wrap);
        this._signal(&quot;change&quot;, delta);
        this.$cursorChange();
    };
    this.onTokenizerUpdate = function (e) {
        var rows = e.data;
        this.renderer.updateLines(rows.first, rows.last);
    };
    this.onScrollTopChange = function () {
        this.renderer.scrollToY(this.session.getScrollTop());
    };
    this.onScrollLeftChange = function () {
        this.renderer.scrollToX(this.session.getScrollLeft());
    };
    this.onCursorChange = function () {
        this.$cursorChange();
        this._signal(&quot;changeSelection&quot;);
    };
    this.$updateHighlightActiveLine = function () {
        var session = this.getSession();
        var highlight;
        if (this.$highlightActiveLine) {
            if (this.$selectionStyle != &quot;line&quot; || !this.selection.isMultiLine())
                highlight = this.getCursorPosition();
            if (this.renderer.theme &amp;&amp; this.renderer.theme.$selectionColorConflict &amp;&amp; !this.selection.isEmpty())
                highlight = false;
            if (this.renderer.$maxLines &amp;&amp; this.session.getLength() === 1 &amp;&amp; !(this.renderer.$minLines &gt; 1))
                highlight = false;
        }
        if (session.$highlightLineMarker &amp;&amp; !highlight) {
            session.removeMarker(session.$highlightLineMarker.id);
            session.$highlightLineMarker = null;
        }
        else if (!session.$highlightLineMarker &amp;&amp; highlight) {
            var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
            range.id = session.addMarker(range, &quot;ace_active-line&quot;, &quot;screenLine&quot;);
            session.$highlightLineMarker = range;
        }
        else if (highlight) {
            session.$highlightLineMarker.start.row = highlight.row;
            session.$highlightLineMarker.end.row = highlight.row;
            session.$highlightLineMarker.start.column = highlight.column;
            session._signal(&quot;changeBackMarker&quot;);
        }
    };
    this.onSelectionChange = function (e) {
        var session = this.session;
        if (session.$selectionMarker) {
            session.removeMarker(session.$selectionMarker);
        }
        session.$selectionMarker = null;
        if (!this.selection.isEmpty()) {
            var range = this.selection.getRange();
            var style = this.getSelectionStyle();
            session.$selectionMarker = session.addMarker(range, &quot;ace_selection&quot;, style);
        }
        else {
            this.$updateHighlightActiveLine();
        }
        var re = this.$highlightSelectedWord &amp;&amp; this.$getSelectionHighLightRegexp();
        this.session.highlight(re);
        this._signal(&quot;changeSelection&quot;);
    };
    this.$getSelectionHighLightRegexp = function () {
        var session = this.session;
        var selection = this.getSelectionRange();
        if (selection.isEmpty() || selection.isMultiLine())
            return;
        var startColumn = selection.start.column;
        var endColumn = selection.end.column;
        var line = session.getLine(selection.start.row);
        var needle = line.substring(startColumn, endColumn);
        if (needle.length &gt; 5000 || !/[\w\d]/.test(needle))
            return;
        var re = this.$search.$assembleRegExp({
            wholeWord: true,
            caseSensitive: true,
            needle: needle
        });
        var wordWithBoundary = line.substring(startColumn - 1, endColumn + 1);
        if (!re.test(wordWithBoundary))
            return;
        return re;
    };
    this.onChangeFrontMarker = function () {
        this.renderer.updateFrontMarkers();
    };
    this.onChangeBackMarker = function () {
        this.renderer.updateBackMarkers();
    };
    this.onChangeBreakpoint = function () {
        this.renderer.updateBreakpoints();
    };
    this.onChangeAnnotation = function () {
        this.renderer.setAnnotations(this.session.getAnnotations());
    };
    this.onChangeMode = function (e) {
        this.renderer.updateText();
        this._emit(&quot;changeMode&quot;, e);
    };
    this.onChangeWrapLimit = function () {
        this.renderer.updateFull();
    };
    this.onChangeWrapMode = function () {
        this.renderer.onResize(true);
    };
    this.onChangeFold = function () {
        this.$updateHighlightActiveLine();
        this.renderer.updateFull();
    };
    this.getSelectedText = function () {
        return this.session.getTextRange(this.getSelectionRange());
    };
    this.getCopyText = function () {
        var text = this.getSelectedText();
        var nl = this.session.doc.getNewLineCharacter();
        var copyLine = false;
        if (!text &amp;&amp; this.$copyWithEmptySelection) {
            copyLine = true;
            var ranges = this.selection.getAllRanges();
            for (var i = 0; i &lt; ranges.length; i++) {
                var range = ranges[i];
                if (i &amp;&amp; ranges[i - 1].start.row == range.start.row)
                    continue;
                text += this.session.getLine(range.start.row) + nl;
            }
        }
        var e = { text: text };
        this._signal(&quot;copy&quot;, e);
        clipboard.lineMode = copyLine ? e.text : false;
        return e.text;
    };
    this.onCopy = function () {
        this.commands.exec(&quot;copy&quot;, this);
    };
    this.onCut = function () {
        this.commands.exec(&quot;cut&quot;, this);
    };
    this.onPaste = function (text, event) {
        var e = { text: text, event: event };
        this.commands.exec(&quot;paste&quot;, this, e);
    };
    this.$handlePaste = function (e) {
        if (typeof e == &quot;string&quot;)
            e = { text: e };
        this._signal(&quot;paste&quot;, e);
        var text = e.text;
        var lineMode = text === clipboard.lineMode;
        var session = this.session;
        if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
            if (lineMode)
                session.insert({ row: this.selection.lead.row, column: 0 }, text);
            else
                this.insert(text);
        }
        else if (lineMode) {
            this.selection.rangeList.ranges.forEach(function (range) {
                session.insert({ row: range.start.row, column: 0 }, text);
            });
        }
        else {
            var lines = text.split(/\r\n|\r|\n/);
            var ranges = this.selection.rangeList.ranges;
            var isFullLine = lines.length == 2 &amp;&amp; (!lines[0] || !lines[1]);
            if (lines.length != ranges.length || isFullLine)
                return this.commands.exec(&quot;insertstring&quot;, this, text);
            for (var i = ranges.length; i--;) {
                var range = ranges[i];
                if (!range.isEmpty())
                    session.remove(range);
                session.insert(range.start, lines[i]);
            }
        }
    };
    this.execCommand = function (command, args) {
        return this.commands.exec(command, this, args);
    };
    this.insert = function (text, pasted) {
        var session = this.session;
        var mode = session.getMode();
        var cursor = this.getCursorPosition();
        if (this.getBehavioursEnabled() &amp;&amp; !pasted) {
            var transform = mode.transformAction(session.getState(cursor.row), &#039;insertion&#039;, this, session, text);
            if (transform) {
                if (text !== transform.text) {
                    if (!this.inVirtualSelectionMode) {
                        this.session.mergeUndoDeltas = false;
                        this.mergeNextCommand = false;
                    }
                }
                text = transform.text;
            }
        }
        if (text == &quot;\t&quot;)
            text = this.session.getTabString();
        if (!this.selection.isEmpty()) {
            var range = this.getSelectionRange();
            cursor = this.session.remove(range);
            this.clearSelection();
        }
        else if (this.session.getOverwrite() &amp;&amp; text.indexOf(&quot;\n&quot;) == -1) {
            var range = new Range.fromPoints(cursor, cursor);
            range.end.column += text.length;
            this.session.remove(range);
        }
        if (text == &quot;\n&quot; || text == &quot;\r\n&quot;) {
            var line = session.getLine(cursor.row);
            if (cursor.column &gt; line.search(/\S|$/)) {
                var d = line.substr(cursor.column).search(/\S|$/);
                session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
            }
        }
        this.clearSelection();
        var start = cursor.column;
        var lineState = session.getState(cursor.row);
        var line = session.getLine(cursor.row);
        var shouldOutdent = mode.checkOutdent(lineState, line, text);
        session.insert(cursor, text);
        if (transform &amp;&amp; transform.selection) {
            if (transform.selection.length == 2) { // Transform relative to the current column
                this.selection.setSelectionRange(new Range(cursor.row, start + transform.selection[0], cursor.row, start + transform.selection[1]));
            }
            else { // Transform relative to the current row.
                this.selection.setSelectionRange(new Range(cursor.row + transform.selection[0], transform.selection[1], cursor.row + transform.selection[2], transform.selection[3]));
            }
        }
        if (this.$enableAutoIndent) {
            if (session.getDocument().isNewLine(text)) {
                var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());
                session.insert({ row: cursor.row + 1, column: 0 }, lineIndent);
            }
            if (shouldOutdent)
                mode.autoOutdent(lineState, session, cursor.row);
        }
    };
    this.autoIndent = function () {
        var session = this.session;
        var mode = session.getMode();
        var startRow, endRow;
        if (this.selection.isEmpty()) {
            startRow = 0;
            endRow = session.doc.getLength() - 1;
        }
        else {
            var selectedRange = this.getSelectionRange();
            startRow = selectedRange.start.row;
            endRow = selectedRange.end.row;
        }
        var prevLineState = &quot;&quot;;
        var prevLine = &quot;&quot;;
        var lineIndent = &quot;&quot;;
        var line, currIndent, range;
        var tab = session.getTabString();
        for (var row = startRow; row &lt;= endRow; row++) {
            if (row &gt; 0) {
                prevLineState = session.getState(row - 1);
                prevLine = session.getLine(row - 1);
                lineIndent = mode.getNextLineIndent(prevLineState, prevLine, tab);
            }
            line = session.getLine(row);
            currIndent = mode.$getIndent(line);
            if (lineIndent !== currIndent) {
                if (currIndent.length &gt; 0) {
                    range = new Range(row, 0, row, currIndent.length);
                    session.remove(range);
                }
                if (lineIndent.length &gt; 0) {
                    session.insert({ row: row, column: 0 }, lineIndent);
                }
            }
            mode.autoOutdent(prevLineState, session, row);
        }
    };
    this.onTextInput = function (text, composition) {
        if (!composition)
            return this.keyBinding.onTextInput(text);
        this.startOperation({ command: { name: &quot;insertstring&quot; } });
        var applyComposition = this.applyComposition.bind(this, text, composition);
        if (this.selection.rangeCount)
            this.forEachSelection(applyComposition);
        else
            applyComposition();
        this.endOperation();
    };
    this.applyComposition = function (text, composition) {
        if (composition.extendLeft || composition.extendRight) {
            var r = this.selection.getRange();
            r.start.column -= composition.extendLeft;
            r.end.column += composition.extendRight;
            if (r.start.column &lt; 0) {
                r.start.row--;
                r.start.column += this.session.getLine(r.start.row).length + 1;
            }
            this.selection.setRange(r);
            if (!text &amp;&amp; !r.isEmpty())
                this.remove();
        }
        if (text || !this.selection.isEmpty())
            this.insert(text, true);
        if (composition.restoreStart || composition.restoreEnd) {
            var r = this.selection.getRange();
            r.start.column -= composition.restoreStart;
            r.end.column -= composition.restoreEnd;
            this.selection.setRange(r);
        }
    };
    this.onCommandKey = function (e, hashId, keyCode) {
        return this.keyBinding.onCommandKey(e, hashId, keyCode);
    };
    this.setOverwrite = function (overwrite) {
        this.session.setOverwrite(overwrite);
    };
    this.getOverwrite = function () {
        return this.session.getOverwrite();
    };
    this.toggleOverwrite = function () {
        this.session.toggleOverwrite();
    };
    this.setScrollSpeed = function (speed) {
        this.setOption(&quot;scrollSpeed&quot;, speed);
    };
    this.getScrollSpeed = function () {
        return this.getOption(&quot;scrollSpeed&quot;);
    };
    this.setDragDelay = function (dragDelay) {
        this.setOption(&quot;dragDelay&quot;, dragDelay);
    };
    this.getDragDelay = function () {
        return this.getOption(&quot;dragDelay&quot;);
    };
    this.setSelectionStyle = function (val) {
        this.setOption(&quot;selectionStyle&quot;, val);
    };
    this.getSelectionStyle = function () {
        return this.getOption(&quot;selectionStyle&quot;);
    };
    this.setHighlightActiveLine = function (shouldHighlight) {
        this.setOption(&quot;highlightActiveLine&quot;, shouldHighlight);
    };
    this.getHighlightActiveLine = function () {
        return this.getOption(&quot;highlightActiveLine&quot;);
    };
    this.setHighlightGutterLine = function (shouldHighlight) {
        this.setOption(&quot;highlightGutterLine&quot;, shouldHighlight);
    };
    this.getHighlightGutterLine = function () {
        return this.getOption(&quot;highlightGutterLine&quot;);
    };
    this.setHighlightSelectedWord = function (shouldHighlight) {
        this.setOption(&quot;highlightSelectedWord&quot;, shouldHighlight);
    };
    this.getHighlightSelectedWord = function () {
        return this.$highlightSelectedWord;
    };
    this.setAnimatedScroll = function (shouldAnimate) {
        this.renderer.setAnimatedScroll(shouldAnimate);
    };
    this.getAnimatedScroll = function () {
        return this.renderer.getAnimatedScroll();
    };
    this.setShowInvisibles = function (showInvisibles) {
        this.renderer.setShowInvisibles(showInvisibles);
    };
    this.getShowInvisibles = function () {
        return this.renderer.getShowInvisibles();
    };
    this.setDisplayIndentGuides = function (display) {
        this.renderer.setDisplayIndentGuides(display);
    };
    this.getDisplayIndentGuides = function () {
        return this.renderer.getDisplayIndentGuides();
    };
    this.setHighlightIndentGuides = function (highlight) {
        this.renderer.setHighlightIndentGuides(highlight);
    };
    this.getHighlightIndentGuides = function () {
        return this.renderer.getHighlightIndentGuides();
    };
    this.setShowPrintMargin = function (showPrintMargin) {
        this.renderer.setShowPrintMargin(showPrintMargin);
    };
    this.getShowPrintMargin = function () {
        return this.renderer.getShowPrintMargin();
    };
    this.setPrintMarginColumn = function (showPrintMargin) {
        this.renderer.setPrintMarginColumn(showPrintMargin);
    };
    this.getPrintMarginColumn = function () {
        return this.renderer.getPrintMarginColumn();
    };
    this.setReadOnly = function (readOnly) {
        this.setOption(&quot;readOnly&quot;, readOnly);
    };
    this.getReadOnly = function () {
        return this.getOption(&quot;readOnly&quot;);
    };
    this.setBehavioursEnabled = function (enabled) {
        this.setOption(&quot;behavioursEnabled&quot;, enabled);
    };
    this.getBehavioursEnabled = function () {
        return this.getOption(&quot;behavioursEnabled&quot;);
    };
    this.setWrapBehavioursEnabled = function (enabled) {
        this.setOption(&quot;wrapBehavioursEnabled&quot;, enabled);
    };
    this.getWrapBehavioursEnabled = function () {
        return this.getOption(&quot;wrapBehavioursEnabled&quot;);
    };
    this.setShowFoldWidgets = function (show) {
        this.setOption(&quot;showFoldWidgets&quot;, show);
    };
    this.getShowFoldWidgets = function () {
        return this.getOption(&quot;showFoldWidgets&quot;);
    };
    this.setFadeFoldWidgets = function (fade) {
        this.setOption(&quot;fadeFoldWidgets&quot;, fade);
    };
    this.getFadeFoldWidgets = function () {
        return this.getOption(&quot;fadeFoldWidgets&quot;);
    };
    this.remove = function (dir) {
        if (this.selection.isEmpty()) {
            if (dir == &quot;left&quot;)
                this.selection.selectLeft();
            else
                this.selection.selectRight();
        }
        var range = this.getSelectionRange();
        if (this.getBehavioursEnabled()) {
            var session = this.session;
            var state = session.getState(range.start.row);
            var new_range = session.getMode().transformAction(state, &#039;deletion&#039;, this, session, range);
            if (range.end.column === 0) {
                var text = session.getTextRange(range);
                if (text[text.length - 1] == &quot;\n&quot;) {
                    var line = session.getLine(range.end.row);
                    if (/^\s+$/.test(line)) {
                        range.end.column = line.length;
                    }
                }
            }
            if (new_range)
                range = new_range;
        }
        this.session.remove(range);
        this.clearSelection();
    };
    this.removeWordRight = function () {
        if (this.selection.isEmpty())
            this.selection.selectWordRight();
        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    };
    this.removeWordLeft = function () {
        if (this.selection.isEmpty())
            this.selection.selectWordLeft();
        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    };
    this.removeToLineStart = function () {
        if (this.selection.isEmpty())
            this.selection.selectLineStart();
        if (this.selection.isEmpty())
            this.selection.selectLeft();
        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    };
    this.removeToLineEnd = function () {
        if (this.selection.isEmpty())
            this.selection.selectLineEnd();
        var range = this.getSelectionRange();
        if (range.start.column == range.end.column &amp;&amp; range.start.row == range.end.row) {
            range.end.column = 0;
            range.end.row++;
        }
        this.session.remove(range);
        this.clearSelection();
    };
    this.splitLine = function () {
        if (!this.selection.isEmpty()) {
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
        }
        var cursor = this.getCursorPosition();
        this.insert(&quot;\n&quot;);
        this.moveCursorToPosition(cursor);
    };
    this.transposeLetters = function () {
        if (!this.selection.isEmpty()) {
            return;
        }
        var cursor = this.getCursorPosition();
        var column = cursor.column;
        if (column === 0)
            return;
        var line = this.session.getLine(cursor.row);
        var swap, range;
        if (column &lt; line.length) {
            swap = line.charAt(column) + line.charAt(column - 1);
            range = new Range(cursor.row, column - 1, cursor.row, column + 1);
        }
        else {
            swap = line.charAt(column - 1) + line.charAt(column - 2);
            range = new Range(cursor.row, column - 2, cursor.row, column);
        }
        this.session.replace(range, swap);
        this.session.selection.moveToPosition(range.end);
    };
    this.toLowerCase = function () {
        var originalRange = this.getSelectionRange();
        if (this.selection.isEmpty()) {
            this.selection.selectWord();
        }
        var range = this.getSelectionRange();
        var text = this.session.getTextRange(range);
        this.session.replace(range, text.toLowerCase());
        this.selection.setSelectionRange(originalRange);
    };
    this.toUpperCase = function () {
        var originalRange = this.getSelectionRange();
        if (this.selection.isEmpty()) {
            this.selection.selectWord();
        }
        var range = this.getSelectionRange();
        var text = this.session.getTextRange(range);
        this.session.replace(range, text.toUpperCase());
        this.selection.setSelectionRange(originalRange);
    };
    this.indent = function () {
        var session = this.session;
        var range = this.getSelectionRange();
        if (range.start.row &lt; range.end.row) {
            var rows = this.$getSelectedRows();
            session.indentRows(rows.first, rows.last, &quot;\t&quot;);
            return;
        }
        else if (range.start.column &lt; range.end.column) {
            var text = session.getTextRange(range);
            if (!/^\s+$/.test(text)) {
                var rows = this.$getSelectedRows();
                session.indentRows(rows.first, rows.last, &quot;\t&quot;);
                return;
            }
        }
        var line = session.getLine(range.start.row);
        var position = range.start;
        var size = session.getTabSize();
        var column = session.documentToScreenColumn(position.row, position.column);
        if (this.session.getUseSoftTabs()) {
            var count = (size - column % size);
            var indentString = lang.stringRepeat(&quot; &quot;, count);
        }
        else {
            var count = column % size;
            while (line[range.start.column - 1] == &quot; &quot; &amp;&amp; count) {
                range.start.column--;
                count--;
            }
            this.selection.setSelectionRange(range);
            indentString = &quot;\t&quot;;
        }
        return this.insert(indentString);
    };
    this.blockIndent = function () {
        var rows = this.$getSelectedRows();
        this.session.indentRows(rows.first, rows.last, &quot;\t&quot;);
    };
    this.blockOutdent = function () {
        var selection = this.session.getSelection();
        this.session.outdentRows(selection.getRange());
    };
    this.sortLines = function () {
        var rows = this.$getSelectedRows();
        var session = this.session;
        var lines = [];
        for (var i = rows.first; i &lt;= rows.last; i++)
            lines.push(session.getLine(i));
        lines.sort(function (a, b) {
            if (a.toLowerCase() &lt; b.toLowerCase())
                return -1;
            if (a.toLowerCase() &gt; b.toLowerCase())
                return 1;
            return 0;
        });
        var deleteRange = new Range(0, 0, 0, 0);
        for (var i = rows.first; i &lt;= rows.last; i++) {
            var line = session.getLine(i);
            deleteRange.start.row = i;
            deleteRange.end.row = i;
            deleteRange.end.column = line.length;
            session.replace(deleteRange, lines[i - rows.first]);
        }
    };
    this.toggleCommentLines = function () {
        var state = this.session.getState(this.getCursorPosition().row);
        var rows = this.$getSelectedRows();
        this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
    };
    this.toggleBlockComment = function () {
        var cursor = this.getCursorPosition();
        var state = this.session.getState(cursor.row);
        var range = this.getSelectionRange();
        this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
    };
    this.getNumberAt = function (row, column) {
        var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
        _numberRx.lastIndex = 0;
        var s = this.session.getLine(row);
        while (_numberRx.lastIndex &lt; column) {
            var m = _numberRx.exec(s);
            if (m.index &lt;= column &amp;&amp; m.index + m[0].length &gt;= column) {
                var number = {
                    value: m[0],
                    start: m.index,
                    end: m.index + m[0].length
                };
                return number;
            }
        }
        return null;
    };
    this.modifyNumber = function (amount) {
        var row = this.selection.getCursor().row;
        var column = this.selection.getCursor().column;
        var charRange = new Range(row, column - 1, row, column);
        var c = this.session.getTextRange(charRange);
        if (!isNaN(parseFloat(c)) &amp;&amp; isFinite(c)) {
            var nr = this.getNumberAt(row, column);
            if (nr) {
                var fp = nr.value.indexOf(&quot;.&quot;) &gt;= 0 ? nr.start + nr.value.indexOf(&quot;.&quot;) + 1 : nr.end;
                var decimals = nr.start + nr.value.length - fp;
                var t = parseFloat(nr.value);
                t *= Math.pow(10, decimals);
                if (fp !== nr.end &amp;&amp; column &lt; fp) {
                    amount *= Math.pow(10, nr.end - column - 1);
                }
                else {
                    amount *= Math.pow(10, nr.end - column);
                }
                t += amount;
                t /= Math.pow(10, decimals);
                var nnr = t.toFixed(decimals);
                var replaceRange = new Range(row, nr.start, row, nr.end);
                this.session.replace(replaceRange, nnr);
                this.moveCursorTo(row, Math.max(nr.start + 1, column + nnr.length - nr.value.length));
            }
        }
        else {
            this.toggleWord();
        }
    };
    this.$toggleWordPairs = [
        [&quot;first&quot;, &quot;last&quot;],
        [&quot;true&quot;, &quot;false&quot;],
        [&quot;yes&quot;, &quot;no&quot;],
        [&quot;width&quot;, &quot;height&quot;],
        [&quot;top&quot;, &quot;bottom&quot;],
        [&quot;right&quot;, &quot;left&quot;],
        [&quot;on&quot;, &quot;off&quot;],
        [&quot;x&quot;, &quot;y&quot;],
        [&quot;get&quot;, &quot;set&quot;],
        [&quot;max&quot;, &quot;min&quot;],
        [&quot;horizontal&quot;, &quot;vertical&quot;],
        [&quot;show&quot;, &quot;hide&quot;],
        [&quot;add&quot;, &quot;remove&quot;],
        [&quot;up&quot;, &quot;down&quot;],
        [&quot;before&quot;, &quot;after&quot;],
        [&quot;even&quot;, &quot;odd&quot;],
        [&quot;in&quot;, &quot;out&quot;],
        [&quot;inside&quot;, &quot;outside&quot;],
        [&quot;next&quot;, &quot;previous&quot;],
        [&quot;increase&quot;, &quot;decrease&quot;],
        [&quot;attach&quot;, &quot;detach&quot;],
        [&quot;&amp;&amp;&quot;, &quot;||&quot;],
        [&quot;==&quot;, &quot;!=&quot;]
    ];
    this.toggleWord = function () {
        var row = this.selection.getCursor().row;
        var column = this.selection.getCursor().column;
        this.selection.selectWord();
        var currentState = this.getSelectedText();
        var currWordStart = this.selection.getWordRange().start.column;
        var wordParts = currentState.replace(/([a-z]+|[A-Z]+)(?=[A-Z_]|$)/g, &#039;$1 &#039;).split(/\s/);
        var delta = column - currWordStart - 1;
        if (delta &lt; 0)
            delta = 0;
        var curLength = 0, itLength = 0;
        var that = this;
        if (currentState.match(/[A-Za-z0-9_]+/)) {
            wordParts.forEach(function (item, i) {
                itLength = curLength + item.length;
                if (delta &gt;= curLength &amp;&amp; delta &lt;= itLength) {
                    currentState = item;
                    that.selection.clearSelection();
                    that.moveCursorTo(row, curLength + currWordStart);
                    that.selection.selectTo(row, itLength + currWordStart);
                }
                curLength = itLength;
            });
        }
        var wordPairs = this.$toggleWordPairs;
        var reg;
        for (var i = 0; i &lt; wordPairs.length; i++) {
            var item = wordPairs[i];
            for (var j = 0; j &lt;= 1; j++) {
                var negate = +!j;
                var firstCondition = currentState.match(new RegExp(&#039;^\\s?_?(&#039; + lang.escapeRegExp(item[j]) + &#039;)\\s?$&#039;, &#039;i&#039;));
                if (firstCondition) {
                    var secondCondition = currentState.match(new RegExp(&#039;([_]|^|\\s)(&#039; + lang.escapeRegExp(firstCondition[1]) + &#039;)($|\\s)&#039;, &#039;g&#039;));
                    if (secondCondition) {
                        reg = currentState.replace(new RegExp(lang.escapeRegExp(item[j]), &#039;i&#039;), function (result) {
                            var res = item[negate];
                            if (result.toUpperCase() == result) {
                                res = res.toUpperCase();
                            }
                            else if (result.charAt(0).toUpperCase() == result.charAt(0)) {
                                res = res.substr(0, 0) + item[negate].charAt(0).toUpperCase() + res.substr(1);
                            }
                            return res;
                        });
                        this.insert(reg);
                        reg = &quot;&quot;;
                    }
                }
            }
        }
    };
    this.findLinkAt = function (row, column) {
        var e_1, _a;
        var line = this.session.getLine(row);
        var wordParts = line.split(/((?:https?|ftp):\/\/[\S]+)/);
        var columnPosition = column;
        if (columnPosition &lt; 0)
            columnPosition = 0;
        var previousPosition = 0, currentPosition = 0, match;
        try {
            for (var wordParts_1 = __values(wordParts), wordParts_1_1 = wordParts_1.next(); !wordParts_1_1.done; wordParts_1_1 = wordParts_1.next()) {
                var item = wordParts_1_1.value;
                currentPosition = previousPosition + item.length;
                if (columnPosition &gt;= previousPosition &amp;&amp; columnPosition &lt;= currentPosition) {
                    if (item.match(/((?:https?|ftp):\/\/[\S]+)/)) {
                        match = item.replace(/[\s:.,&#039;&quot;;}\]]+$/, &quot;&quot;);
                        break;
                    }
                }
                previousPosition = currentPosition;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (wordParts_1_1 &amp;&amp; !wordParts_1_1.done &amp;&amp; (_a = wordParts_1.return)) _a.call(wordParts_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return match;
    };
    this.openLink = function () {
        var cursor = this.selection.getCursor();
        var url = this.findLinkAt(cursor.row, cursor.column);
        if (url)
            window.open(url, &#039;_blank&#039;);
        return url != null;
    };
    this.removeLines = function () {
        var rows = this.$getSelectedRows();
        this.session.removeFullLines(rows.first, rows.last);
        this.clearSelection();
    };
    this.duplicateSelection = function () {
        var sel = this.selection;
        var doc = this.session;
        var range = sel.getRange();
        var reverse = sel.isBackwards();
        if (range.isEmpty()) {
            var row = range.start.row;
            doc.duplicateLines(row, row);
        }
        else {
            var point = reverse ? range.start : range.end;
            var endPoint = doc.insert(point, doc.getTextRange(range), false);
            range.start = point;
            range.end = endPoint;
            sel.setSelectionRange(range, reverse);
        }
    };
    this.moveLinesDown = function () {
        this.$moveLines(1, false);
    };
    this.moveLinesUp = function () {
        this.$moveLines(-1, false);
    };
    this.moveText = function (range, toPosition, copy) {
        return this.session.moveText(range, toPosition, copy);
    };
    this.copyLinesUp = function () {
        this.$moveLines(-1, true);
    };
    this.copyLinesDown = function () {
        this.$moveLines(1, true);
    };
    this.$moveLines = function (dir, copy) {
        var rows, moved;
        var selection = this.selection;
        if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
            var range = selection.toOrientedRange();
            rows = this.$getSelectedRows(range);
            moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
            if (copy &amp;&amp; dir == -1)
                moved = 0;
            range.moveBy(moved, 0);
            selection.fromOrientedRange(range);
        }
        else {
            var ranges = selection.rangeList.ranges;
            selection.rangeList.detach(this.session);
            this.inVirtualSelectionMode = true;
            var diff = 0;
            var totalDiff = 0;
            var l = ranges.length;
            for (var i = 0; i &lt; l; i++) {
                var rangeIndex = i;
                ranges[i].moveBy(diff, 0);
                rows = this.$getSelectedRows(ranges[i]);
                var first = rows.first;
                var last = rows.last;
                while (++i &lt; l) {
                    if (totalDiff)
                        ranges[i].moveBy(totalDiff, 0);
                    var subRows = this.$getSelectedRows(ranges[i]);
                    if (copy &amp;&amp; subRows.first != last)
                        break;
                    else if (!copy &amp;&amp; subRows.first &gt; last + 1)
                        break;
                    last = subRows.last;
                }
                i--;
                diff = this.session.$moveLines(first, last, copy ? 0 : dir);
                if (copy &amp;&amp; dir == -1)
                    rangeIndex = i + 1;
                while (rangeIndex &lt;= i) {
                    ranges[rangeIndex].moveBy(diff, 0);
                    rangeIndex++;
                }
                if (!copy)
                    diff = 0;
                totalDiff += diff;
            }
            selection.fromOrientedRange(selection.ranges[0]);
            selection.rangeList.attach(this.session);
            this.inVirtualSelectionMode = false;
        }
    };
    this.$getSelectedRows = function (range) {
        range = (range || this.getSelectionRange()).collapseRows();
        return {
            first: this.session.getRowFoldStart(range.start.row),
            last: this.session.getRowFoldEnd(range.end.row)
        };
    };
    this.onCompositionStart = function (compositionState) {
        this.renderer.showComposition(compositionState);
    };
    this.onCompositionUpdate = function (text) {
        this.renderer.setCompositionText(text);
    };
    this.onCompositionEnd = function () {
        this.renderer.hideComposition();
    };
    this.getFirstVisibleRow = function () {
        return this.renderer.getFirstVisibleRow();
    };
    this.getLastVisibleRow = function () {
        return this.renderer.getLastVisibleRow();
    };
    this.isRowVisible = function (row) {
        return (row &gt;= this.getFirstVisibleRow() &amp;&amp; row &lt;= this.getLastVisibleRow());
    };
    this.isRowFullyVisible = function (row) {
        return (row &gt;= this.renderer.getFirstFullyVisibleRow() &amp;&amp; row &lt;= this.renderer.getLastFullyVisibleRow());
    };
    this.$getVisibleRowCount = function () {
        return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
    };
    this.$moveByPage = function (dir, select) {
        var renderer = this.renderer;
        var config = this.renderer.layerConfig;
        var rows = dir * Math.floor(config.height / config.lineHeight);
        if (select === true) {
            this.selection.$moveSelection(function () {
                this.moveCursorBy(rows, 0);
            });
        }
        else if (select === false) {
            this.selection.moveCursorBy(rows, 0);
            this.selection.clearSelection();
        }
        var scrollTop = renderer.scrollTop;
        renderer.scrollBy(0, rows * config.lineHeight);
        if (select != null)
            renderer.scrollCursorIntoView(null, 0.5);
        renderer.animateScrolling(scrollTop);
    };
    this.selectPageDown = function () {
        this.$moveByPage(1, true);
    };
    this.selectPageUp = function () {
        this.$moveByPage(-1, true);
    };
    this.gotoPageDown = function () {
        this.$moveByPage(1, false);
    };
    this.gotoPageUp = function () {
        this.$moveByPage(-1, false);
    };
    this.scrollPageDown = function () {
        this.$moveByPage(1);
    };
    this.scrollPageUp = function () {
        this.$moveByPage(-1);
    };
    this.scrollToRow = function (row) {
        this.renderer.scrollToRow(row);
    };
    this.scrollToLine = function (line, center, animate, callback) {
        this.renderer.scrollToLine(line, center, animate, callback);
    };
    this.centerSelection = function () {
        var range = this.getSelectionRange();
        var pos = {
            row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
            column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
        };
        this.renderer.alignCursor(pos, 0.5);
    };
    this.getCursorPosition = function () {
        return this.selection.getCursor();
    };
    this.getCursorPositionScreen = function () {
        return this.session.documentToScreenPosition(this.getCursorPosition());
    };
    this.getSelectionRange = function () {
        return this.selection.getRange();
    };
    this.selectAll = function () {
        this.selection.selectAll();
    };
    this.clearSelection = function () {
        this.selection.clearSelection();
    };
    this.moveCursorTo = function (row, column) {
        this.selection.moveCursorTo(row, column);
    };
    this.moveCursorToPosition = function (pos) {
        this.selection.moveCursorToPosition(pos);
    };
    this.jumpToMatching = function (select, expand) {
        var cursor = this.getCursorPosition();
        var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
        var prevToken = iterator.getCurrentToken();
        var tokenCount = 0;
        if (prevToken &amp;&amp; prevToken.type.indexOf(&#039;tag-name&#039;) !== -1) {
            prevToken = iterator.stepBackward();
        }
        var token = prevToken || iterator.stepForward();
        if (!token)
            return;
        var matchType;
        var found = false;
        var depth = {};
        var i = cursor.column - token.start;
        var bracketType;
        var brackets = {
            &quot;)&quot;: &quot;(&quot;,
            &quot;(&quot;: &quot;(&quot;,
            &quot;]&quot;: &quot;[&quot;,
            &quot;[&quot;: &quot;[&quot;,
            &quot;{&quot;: &quot;{&quot;,
            &quot;}&quot;: &quot;{&quot;
        };
        do {
            if (token.value.match(/[{}()\[\]]/g)) {
                for (; i &lt; token.value.length &amp;&amp; !found; i++) {
                    if (!brackets[token.value[i]]) {
                        continue;
                    }
                    bracketType = brackets[token.value[i]] + &#039;.&#039; + token.type.replace(&quot;rparen&quot;, &quot;lparen&quot;);
                    if (isNaN(depth[bracketType])) {
                        depth[bracketType] = 0;
                    }
                    switch (token.value[i]) {
                        case &#039;(&#039;:
                        case &#039;[&#039;:
                        case &#039;{&#039;:
                            depth[bracketType]++;
                            break;
                        case &#039;)&#039;:
                        case &#039;]&#039;:
                        case &#039;}&#039;:
                            depth[bracketType]--;
                            if (depth[bracketType] === -1) {
                                matchType = &#039;bracket&#039;;
                                found = true;
                            }
                            break;
                    }
                }
            }
            else if (token.type.indexOf(&#039;tag-name&#039;) !== -1) {
                if (isNaN(depth[token.value])) {
                    depth[token.value] = 0;
                }
                if (prevToken.value === &#039;&lt;&#039; &amp;&amp; tokenCount &gt; 1) {
                    depth[token.value]++;
                }
                else if (prevToken.value === &#039;&lt;/&#039;) {
                    depth[token.value]--;
                }
                if (depth[token.value] === -1) {
                    matchType = &#039;tag&#039;;
                    found = true;
                }
            }
            if (!found) {
                prevToken = token;
                tokenCount++;
                token = iterator.stepForward();
                i = 0;
            }
        } while (token &amp;&amp; !found);
        if (!matchType)
            return;
        var range, pos;
        if (matchType === &#039;bracket&#039;) {
            range = this.session.getBracketRange(cursor);
            if (!range) {
                range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1);
                pos = range.start;
                if (expand || pos.row === cursor.row &amp;&amp; Math.abs(pos.column - cursor.column)
                    &lt; 2)
                    range = this.session.getBracketRange(pos);
            }
        }
        else if (matchType === &#039;tag&#039;) {
            if (!token || token.type.indexOf(&#039;tag-name&#039;) === -1)
                return;
            range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2);
            if (range.compare(cursor.row, cursor.column) === 0) {
                var tagsRanges = this.session.getMatchingTags(cursor);
                if (tagsRanges) {
                    if (tagsRanges.openTag.contains(cursor.row, cursor.column)) {
                        range = tagsRanges.closeTag;
                        pos = range.start;
                    }
                    else {
                        range = tagsRanges.openTag;
                        if (tagsRanges.closeTag.start.row === cursor.row &amp;&amp; tagsRanges.closeTag.start.column
                            === cursor.column)
                            pos = range.end;
                        else
                            pos = range.start;
                    }
                }
            }
            pos = pos || range.start;
        }
        pos = range &amp;&amp; range.cursor || pos;
        if (pos) {
            if (select) {
                if (range &amp;&amp; expand) {
                    this.selection.setRange(range);
                }
                else if (range &amp;&amp; range.isEqual(this.getSelectionRange())) {
                    this.clearSelection();
                }
                else {
                    this.selection.selectTo(pos.row, pos.column);
                }
            }
            else {
                this.selection.moveTo(pos.row, pos.column);
            }
        }
    };
    this.gotoLine = function (lineNumber, column, animate) {
        this.selection.clearSelection();
        this.session.unfold({ row: lineNumber - 1, column: column || 0 });
        this.exitMultiSelectMode &amp;&amp; this.exitMultiSelectMode();
        this.moveCursorTo(lineNumber - 1, column || 0);
        if (!this.isRowFullyVisible(lineNumber - 1))
            this.scrollToLine(lineNumber - 1, true, animate);
    };
    this.navigateTo = function (row, column) {
        this.selection.moveTo(row, column);
    };
    this.navigateUp = function (times) {
        if (this.selection.isMultiLine() &amp;&amp; !this.selection.isBackwards()) {
            var selectionStart = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(selectionStart);
        }
        this.selection.clearSelection();
        this.selection.moveCursorBy(-times || -1, 0);
    };
    this.navigateDown = function (times) {
        if (this.selection.isMultiLine() &amp;&amp; this.selection.isBackwards()) {
            var selectionEnd = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(selectionEnd);
        }
        this.selection.clearSelection();
        this.selection.moveCursorBy(times || 1, 0);
    };
    this.navigateLeft = function (times) {
        if (!this.selection.isEmpty()) {
            var selectionStart = this.getSelectionRange().start;
            this.moveCursorToPosition(selectionStart);
        }
        else {
            times = times || 1;
            while (times--) {
                this.selection.moveCursorLeft();
            }
        }
        this.clearSelection();
    };
    this.navigateRight = function (times) {
        if (!this.selection.isEmpty()) {
            var selectionEnd = this.getSelectionRange().end;
            this.moveCursorToPosition(selectionEnd);
        }
        else {
            times = times || 1;
            while (times--) {
                this.selection.moveCursorRight();
            }
        }
        this.clearSelection();
    };
    this.navigateLineStart = function () {
        this.selection.moveCursorLineStart();
        this.clearSelection();
    };
    this.navigateLineEnd = function () {
        this.selection.moveCursorLineEnd();
        this.clearSelection();
    };
    this.navigateFileEnd = function () {
        this.selection.moveCursorFileEnd();
        this.clearSelection();
    };
    this.navigateFileStart = function () {
        this.selection.moveCursorFileStart();
        this.clearSelection();
    };
    this.navigateWordRight = function () {
        this.selection.moveCursorWordRight();
        this.clearSelection();
    };
    this.navigateWordLeft = function () {
        this.selection.moveCursorWordLeft();
        this.clearSelection();
    };
    this.replace = function (replacement, options) {
        if (options)
            this.$search.set(options);
        var range = this.$search.find(this.session);
        var replaced = 0;
        if (!range)
            return replaced;
        if (this.$tryReplace(range, replacement)) {
            replaced = 1;
        }
        this.selection.setSelectionRange(range);
        this.renderer.scrollSelectionIntoView(range.start, range.end);
        return replaced;
    };
    this.replaceAll = function (replacement, options) {
        if (options) {
            this.$search.set(options);
        }
        var ranges = this.$search.findAll(this.session);
        var replaced = 0;
        if (!ranges.length)
            return replaced;
        var selection = this.getSelectionRange();
        this.selection.moveTo(0, 0);
        for (var i = ranges.length - 1; i &gt;= 0; --i) {
            if (this.$tryReplace(ranges[i], replacement)) {
                replaced++;
            }
        }
        this.selection.setSelectionRange(selection);
        return replaced;
    };
    this.$tryReplace = function (range, replacement) {
        var input = this.session.getTextRange(range);
        replacement = this.$search.replace(input, replacement);
        if (replacement !== null) {
            range.end = this.session.replace(range, replacement);
            return range;
        }
        else {
            return null;
        }
    };
    this.getLastSearchOptions = function () {
        return this.$search.getOptions();
    };
    this.find = function (needle, options, animate) {
        if (!options)
            options = {};
        if (typeof needle == &quot;string&quot; || needle instanceof RegExp)
            options.needle = needle;
        else if (typeof needle == &quot;object&quot;)
            oop.mixin(options, needle);
        var range = this.selection.getRange();
        if (options.needle == null) {
            needle = this.session.getTextRange(range)
                || this.$search.$options.needle;
            if (!needle) {
                range = this.session.getWordRange(range.start.row, range.start.column);
                needle = this.session.getTextRange(range);
            }
            this.$search.set({ needle: needle });
        }
        this.$search.set(options);
        if (!options.start)
            this.$search.set({ start: range });
        var newRange = this.$search.find(this.session);
        if (options.preventScroll)
            return newRange;
        if (newRange) {
            this.revealRange(newRange, animate);
            return newRange;
        }
        if (options.backwards)
            range.start = range.end;
        else
            range.end = range.start;
        this.selection.setRange(range);
    };
    this.findNext = function (options, animate) {
        this.find({ skipCurrent: true, backwards: false }, options, animate);
    };
    this.findPrevious = function (options, animate) {
        this.find(options, { skipCurrent: true, backwards: true }, animate);
    };
    this.revealRange = function (range, animate) {
        this.session.unfold(range);
        this.selection.setSelectionRange(range);
        var scrollTop = this.renderer.scrollTop;
        this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
        if (animate !== false)
            this.renderer.animateScrolling(scrollTop);
    };
    this.undo = function () {
        this.session.getUndoManager().undo(this.session);
        this.renderer.scrollCursorIntoView(null, 0.5);
    };
    this.redo = function () {
        this.session.getUndoManager().redo(this.session);
        this.renderer.scrollCursorIntoView(null, 0.5);
    };
    this.destroy = function () {
        if (this.$toDestroy) {
            this.$toDestroy.forEach(function (el) {
                el.destroy();
            });
            this.$toDestroy = null;
        }
        if (this.$mouseHandler)
            this.$mouseHandler.destroy();
        this.renderer.destroy();
        this._signal(&quot;destroy&quot;, this);
        if (this.session)
            this.session.destroy();
        if (this._$emitInputEvent)
            this._$emitInputEvent.cancel();
        this.removeAllListeners();
    };
    this.setAutoScrollEditorIntoView = function (enable) {
        if (!enable)
            return;
        var rect;
        var self = this;
        var shouldScroll = false;
        if (!this.$scrollAnchor)
            this.$scrollAnchor = document.createElement(&quot;div&quot;);
        var scrollAnchor = this.$scrollAnchor;
        scrollAnchor.style.cssText = &quot;position:absolute&quot;;
        this.container.insertBefore(scrollAnchor, this.container.firstChild);
        var onChangeSelection = this.on(&quot;changeSelection&quot;, function () {
            shouldScroll = true;
        });
        var onBeforeRender = this.renderer.on(&quot;beforeRender&quot;, function () {
            if (shouldScroll)
                rect = self.renderer.container.getBoundingClientRect();
        });
        var onAfterRender = this.renderer.on(&quot;afterRender&quot;, function () {
            if (shouldScroll &amp;&amp; rect &amp;&amp; (self.isFocused()
                || self.searchBox &amp;&amp; self.searchBox.isFocused())) {
                var renderer = self.renderer;
                var pos = renderer.$cursorLayer.$pixelPos;
                var config = renderer.layerConfig;
                var top = pos.top - config.offset;
                if (pos.top &gt;= 0 &amp;&amp; top + rect.top &lt; 0) {
                    shouldScroll = true;
                }
                else if (pos.top &lt; config.height &amp;&amp;
                    pos.top + rect.top + config.lineHeight &gt; window.innerHeight) {
                    shouldScroll = false;
                }
                else {
                    shouldScroll = null;
                }
                if (shouldScroll != null) {
                    scrollAnchor.style.top = top + &quot;px&quot;;
                    scrollAnchor.style.left = pos.left + &quot;px&quot;;
                    scrollAnchor.style.height = config.lineHeight + &quot;px&quot;;
                    scrollAnchor.scrollIntoView(shouldScroll);
                }
                shouldScroll = rect = null;
            }
        });
        this.setAutoScrollEditorIntoView = function (enable) {
            if (enable)
                return;
            delete this.setAutoScrollEditorIntoView;
            this.off(&quot;changeSelection&quot;, onChangeSelection);
            this.renderer.off(&quot;afterRender&quot;, onAfterRender);
            this.renderer.off(&quot;beforeRender&quot;, onBeforeRender);
        };
    };
    this.$resetCursorStyle = function () {
        var style = this.$cursorStyle || &quot;ace&quot;;
        var cursorLayer = this.renderer.$cursorLayer;
        if (!cursorLayer)
            return;
        cursorLayer.setSmoothBlinking(/smooth/.test(style));
        cursorLayer.isBlinking = !this.$readOnly &amp;&amp; style != &quot;wide&quot;;
        dom.setCssClass(cursorLayer.element, &quot;ace_slim-cursors&quot;, /slim/.test(style));
    };
    this.prompt = function (message, options, callback) {
        var editor = this;
        config.loadModule(&quot;./ext/prompt&quot;, function (module) {
            module.prompt(editor, message, options, callback);
        });
    };
}).call(Editor.prototype);
config.defineOptions(Editor.prototype, &quot;editor&quot;, {
    selectionStyle: {
        set: function (style) {
            this.onSelectionChange();
            this._signal(&quot;changeSelectionStyle&quot;, { data: style });
        },
        initialValue: &quot;line&quot;
    },
    highlightActiveLine: {
        set: function () { this.$updateHighlightActiveLine(); },
        initialValue: true
    },
    highlightSelectedWord: {
        set: function (shouldHighlight) { this.$onSelectionChange(); },
        initialValue: true
    },
    readOnly: {
        set: function (readOnly) {
            this.textInput.setReadOnly(readOnly);
            this.$resetCursorStyle();
        },
        initialValue: false
    },
    copyWithEmptySelection: {
        set: function (value) {
            this.textInput.setCopyWithEmptySelection(value);
        },
        initialValue: false
    },
    cursorStyle: {
        set: function (val) { this.$resetCursorStyle(); },
        values: [&quot;ace&quot;, &quot;slim&quot;, &quot;smooth&quot;, &quot;wide&quot;],
        initialValue: &quot;ace&quot;
    },
    mergeUndoDeltas: {
        values: [false, true, &quot;always&quot;],
        initialValue: true
    },
    behavioursEnabled: { initialValue: true },
    wrapBehavioursEnabled: { initialValue: true },
    enableAutoIndent: { initialValue: true },
    autoScrollEditorIntoView: {
        set: function (val) { this.setAutoScrollEditorIntoView(val); }
    },
    keyboardHandler: {
        set: function (val) { this.setKeyboardHandler(val); },
        get: function () { return this.$keybindingId; },
        handlesSet: true
    },
    value: {
        set: function (val) { this.session.setValue(val); },
        get: function () { return this.getValue(); },
        handlesSet: true,
        hidden: true
    },
    session: {
        set: function (val) { this.setSession(val); },
        get: function () { return this.session; },
        handlesSet: true,
        hidden: true
    },
    showLineNumbers: {
        set: function (show) {
            this.renderer.$gutterLayer.setShowLineNumbers(show);
            this.renderer.$loop.schedule(this.renderer.CHANGE_GUTTER);
            if (show &amp;&amp; this.$relativeLineNumbers)
                relativeNumberRenderer.attach(this);
            else
                relativeNumberRenderer.detach(this);
        },
        initialValue: true
    },
    relativeLineNumbers: {
        set: function (value) {
            if (this.$showLineNumbers &amp;&amp; value)
                relativeNumberRenderer.attach(this);
            else
                relativeNumberRenderer.detach(this);
        }
    },
    placeholder: {
        set: function (message) {
            if (!this.$updatePlaceholder) {
                this.$updatePlaceholder = function () {
                    var value = this.session &amp;&amp; (this.renderer.$composition || this.getValue());
                    if (value &amp;&amp; this.renderer.placeholderNode) {
                        this.renderer.off(&quot;afterRender&quot;, this.$updatePlaceholder);
                        dom.removeCssClass(this.container, &quot;ace_hasPlaceholder&quot;);
                        this.renderer.placeholderNode.remove();
                        this.renderer.placeholderNode = null;
                    }
                    else if (!value &amp;&amp; !this.renderer.placeholderNode) {
                        this.renderer.on(&quot;afterRender&quot;, this.$updatePlaceholder);
                        dom.addCssClass(this.container, &quot;ace_hasPlaceholder&quot;);
                        var el = dom.createElement(&quot;div&quot;);
                        el.className = &quot;ace_placeholder&quot;;
                        el.textContent = this.$placeholder || &quot;&quot;;
                        this.renderer.placeholderNode = el;
                        this.renderer.content.appendChild(this.renderer.placeholderNode);
                    }
                    else if (!value &amp;&amp; this.renderer.placeholderNode) {
                        this.renderer.placeholderNode.textContent = this.$placeholder || &quot;&quot;;
                    }
                }.bind(this);
                this.on(&quot;input&quot;, this.$updatePlaceholder);
            }
            this.$updatePlaceholder();
        }
    },
    customScrollbar: &quot;renderer&quot;,
    hScrollBarAlwaysVisible: &quot;renderer&quot;,
    vScrollBarAlwaysVisible: &quot;renderer&quot;,
    highlightGutterLine: &quot;renderer&quot;,
    animatedScroll: &quot;renderer&quot;,
    showInvisibles: &quot;renderer&quot;,
    showPrintMargin: &quot;renderer&quot;,
    printMarginColumn: &quot;renderer&quot;,
    printMargin: &quot;renderer&quot;,
    fadeFoldWidgets: &quot;renderer&quot;,
    showFoldWidgets: &quot;renderer&quot;,
    displayIndentGuides: &quot;renderer&quot;,
    highlightIndentGuides: &quot;renderer&quot;,
    showGutter: &quot;renderer&quot;,
    fontSize: &quot;renderer&quot;,
    fontFamily: &quot;renderer&quot;,
    maxLines: &quot;renderer&quot;,
    minLines: &quot;renderer&quot;,
    scrollPastEnd: &quot;renderer&quot;,
    fixedWidthGutter: &quot;renderer&quot;,
    theme: &quot;renderer&quot;,
    hasCssTransforms: &quot;renderer&quot;,
    maxPixelHeight: &quot;renderer&quot;,
    useTextareaForIME: &quot;renderer&quot;,
    scrollSpeed: &quot;$mouseHandler&quot;,
    dragDelay: &quot;$mouseHandler&quot;,
    dragEnabled: &quot;$mouseHandler&quot;,
    focusTimeout: &quot;$mouseHandler&quot;,
    tooltipFollowsMouse: &quot;$mouseHandler&quot;,
    firstLineNumber: &quot;session&quot;,
    overwrite: &quot;session&quot;,
    newLineMode: &quot;session&quot;,
    useWorker: &quot;session&quot;,
    useSoftTabs: &quot;session&quot;,
    navigateWithinSoftTabs: &quot;session&quot;,
    tabSize: &quot;session&quot;,
    wrap: &quot;session&quot;,
    indentedSoftWrap: &quot;session&quot;,
    foldStyle: &quot;session&quot;,
    mode: &quot;session&quot;
});
var relativeNumberRenderer = {
    getText: function (session, row) {
        return (Math.abs(session.selection.lead.row - row) || (row + 1 + (row &lt; 9 ? &quot;\xb7&quot; : &quot;&quot;))) + &quot;&quot;;
    },
    getWidth: function (session, lastLineNumber, config) {
        return Math.max(lastLineNumber.toString().length, (config.lastRow + 1).toString().length, 2) * config.characterWidth;
    },
    update: function (e, editor) {
        editor.renderer.$loop.schedule(editor.renderer.CHANGE_GUTTER);
    },
    attach: function (editor) {
        editor.renderer.$gutterLayer.$renderer = this;
        editor.on(&quot;changeSelection&quot;, this.update);
        this.update(null, editor);
    },
    detach: function (editor) {
        if (editor.renderer.$gutterLayer.$renderer == this)
            editor.renderer.$gutterLayer.$renderer = null;
        editor.off(&quot;changeSelection&quot;, this.update);
        this.update(null, editor);
    }
};
exports.Editor = Editor;

});

define(&quot;ace/undomanager&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/range&quot;], function(require, exports, module){&quot;use strict&quot;;
var UndoManager = function () {
    this.$maxRev = 0;
    this.$fromUndo = false;
    this.$undoDepth = Infinity;
    this.reset();
};
(function () {
    this.addSession = function (session) {
        this.$session = session;
    };
    this.add = function (delta, allowMerge, session) {
        if (this.$fromUndo)
            return;
        if (delta == this.$lastDelta)
            return;
        if (!this.$keepRedoStack)
            this.$redoStack.length = 0;
        if (allowMerge === false || !this.lastDeltas) {
            this.lastDeltas = [];
            var undoStackLength = this.$undoStack.length;
            if (undoStackLength &gt; this.$undoDepth - 1) {
                this.$undoStack.splice(0, undoStackLength - this.$undoDepth + 1);
            }
            this.$undoStack.push(this.lastDeltas);
            delta.id = this.$rev = ++this.$maxRev;
        }
        if (delta.action == &quot;remove&quot; || delta.action == &quot;insert&quot;)
            this.$lastDelta = delta;
        this.lastDeltas.push(delta);
    };
    this.addSelection = function (selection, rev) {
        this.selections.push({
            value: selection,
            rev: rev || this.$rev
        });
    };
    this.startNewGroup = function () {
        this.lastDeltas = null;
        return this.$rev;
    };
    this.markIgnored = function (from, to) {
        if (to == null)
            to = this.$rev + 1;
        var stack = this.$undoStack;
        for (var i = stack.length; i--;) {
            var delta = stack[i][0];
            if (delta.id &lt;= from)
                break;
            if (delta.id &lt; to)
                delta.ignore = true;
        }
        this.lastDeltas = null;
    };
    this.getSelection = function (rev, after) {
        var stack = this.selections;
        for (var i = stack.length; i--;) {
            var selection = stack[i];
            if (selection.rev &lt; rev) {
                if (after)
                    selection = stack[i + 1];
                return selection;
            }
        }
    };
    this.getRevision = function () {
        return this.$rev;
    };
    this.getDeltas = function (from, to) {
        if (to == null)
            to = this.$rev + 1;
        var stack = this.$undoStack;
        var end = null, start = 0;
        for (var i = stack.length; i--;) {
            var delta = stack[i][0];
            if (delta.id &lt; to &amp;&amp; !end)
                end = i + 1;
            if (delta.id &lt;= from) {
                start = i + 1;
                break;
            }
        }
        return stack.slice(start, end);
    };
    this.getChangedRanges = function (from, to) {
        if (to == null)
            to = this.$rev + 1;
    };
    this.getChangedLines = function (from, to) {
        if (to == null)
            to = this.$rev + 1;
    };
    this.undo = function (session, dontSelect) {
        this.lastDeltas = null;
        var stack = this.$undoStack;
        if (!rearrangeUndoStack(stack, stack.length))
            return;
        if (!session)
            session = this.$session;
        if (this.$redoStackBaseRev !== this.$rev &amp;&amp; this.$redoStack.length)
            this.$redoStack = [];
        this.$fromUndo = true;
        var deltaSet = stack.pop();
        var undoSelectionRange = null;
        if (deltaSet) {
            undoSelectionRange = session.undoChanges(deltaSet, dontSelect);
            this.$redoStack.push(deltaSet);
            this.$syncRev();
        }
        this.$fromUndo = false;
        return undoSelectionRange;
    };
    this.redo = function (session, dontSelect) {
        this.lastDeltas = null;
        if (!session)
            session = this.$session;
        this.$fromUndo = true;
        if (this.$redoStackBaseRev != this.$rev) {
            var diff = this.getDeltas(this.$redoStackBaseRev, this.$rev + 1);
            rebaseRedoStack(this.$redoStack, diff);
            this.$redoStackBaseRev = this.$rev;
            this.$redoStack.forEach(function (x) {
                x[0].id = ++this.$maxRev;
            }, this);
        }
        var deltaSet = this.$redoStack.pop();
        var redoSelectionRange = null;
        if (deltaSet) {
            redoSelectionRange = session.redoChanges(deltaSet, dontSelect);
            this.$undoStack.push(deltaSet);
            this.$syncRev();
        }
        this.$fromUndo = false;
        return redoSelectionRange;
    };
    this.$syncRev = function () {
        var stack = this.$undoStack;
        var nextDelta = stack[stack.length - 1];
        var id = nextDelta &amp;&amp; nextDelta[0].id || 0;
        this.$redoStackBaseRev = id;
        this.$rev = id;
    };
    this.reset = function () {
        this.lastDeltas = null;
        this.$lastDelta = null;
        this.$undoStack = [];
        this.$redoStack = [];
        this.$rev = 0;
        this.mark = 0;
        this.$redoStackBaseRev = this.$rev;
        this.selections = [];
    };
    this.canUndo = function () {
        return this.$undoStack.length &gt; 0;
    };
    this.canRedo = function () {
        return this.$redoStack.length &gt; 0;
    };
    this.bookmark = function (rev) {
        if (rev == undefined)
            rev = this.$rev;
        this.mark = rev;
    };
    this.isAtBookmark = function () {
        return this.$rev === this.mark;
    };
    this.toJSON = function () {
    };
    this.fromJSON = function () {
    };
    this.hasUndo = this.canUndo;
    this.hasRedo = this.canRedo;
    this.isClean = this.isAtBookmark;
    this.markClean = this.bookmark;
    this.$prettyPrint = function (delta) {
        if (delta)
            return stringifyDelta(delta);
        return stringifyDelta(this.$undoStack) + &quot;\n---\n&quot; + stringifyDelta(this.$redoStack);
    };
}).call(UndoManager.prototype);
function rearrangeUndoStack(stack, pos) {
    for (var i = pos; i--;) {
        var deltaSet = stack[i];
        if (deltaSet &amp;&amp; !deltaSet[0].ignore) {
            while (i &lt; pos - 1) {
                var swapped = swapGroups(stack[i], stack[i + 1]);
                stack[i] = swapped[0];
                stack[i + 1] = swapped[1];
                i++;
            }
            return true;
        }
    }
}
var Range = require(&quot;./range&quot;).Range;
var cmp = Range.comparePoints;
var comparePoints = Range.comparePoints;
function $updateMarkers(delta) {
    var isInsert = delta.action == &quot;insert&quot;;
    var start = delta.start;
    var end = delta.end;
    var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);
    var colShift = (end.column - start.column) * (isInsert ? 1 : -1);
    if (isInsert)
        end = start;
    for (var i in this.marks) {
        var point = this.marks[i];
        var cmp = comparePoints(point, start);
        if (cmp &lt; 0) {
            continue; // delta starts after the range
        }
        if (cmp === 0) {
            if (isInsert) {
                if (point.bias == 1) {
                    cmp = 1;
                }
                else {
                    point.bias == -1;
                    continue;
                }
            }
        }
        var cmp2 = isInsert ? cmp : comparePoints(point, end);
        if (cmp2 &gt; 0) {
            point.row += rowShift;
            point.column += point.row == end.row ? colShift : 0;
            continue;
        }
        if (!isInsert &amp;&amp; cmp2 &lt;= 0) {
            point.row = start.row;
            point.column = start.column;
            if (cmp2 === 0)
                point.bias = 1;
        }
    }
}
function clonePos(pos) {
    return { row: pos.row, column: pos.column };
}
function cloneDelta(d) {
    return {
        start: clonePos(d.start),
        end: clonePos(d.end),
        action: d.action,
        lines: d.lines.slice()
    };
}
function stringifyDelta(d) {
    d = d || this;
    if (Array.isArray(d)) {
        return d.map(stringifyDelta).join(&quot;\n&quot;);
    }
    var type = &quot;&quot;;
    if (d.action) {
        type = d.action == &quot;insert&quot; ? &quot;+&quot; : &quot;-&quot;;
        type += &quot;[&quot; + d.lines + &quot;]&quot;;
    }
    else if (d.value) {
        if (Array.isArray(d.value)) {
            type = d.value.map(stringifyRange).join(&quot;\n&quot;);
        }
        else {
            type = stringifyRange(d.value);
        }
    }
    if (d.start) {
        type += stringifyRange(d);
    }
    if (d.id || d.rev) {
        type += &quot;\t(&quot; + (d.id || d.rev) + &quot;)&quot;;
    }
    return type;
}
function stringifyRange(r) {
    return r.start.row + &quot;:&quot; + r.start.column
        + &quot;=&gt;&quot; + r.end.row + &quot;:&quot; + r.end.column;
}
function swap(d1, d2) {
    var i1 = d1.action == &quot;insert&quot;;
    var i2 = d2.action == &quot;insert&quot;;
    if (i1 &amp;&amp; i2) {
        if (cmp(d2.start, d1.end) &gt;= 0) {
            shift(d2, d1, -1);
        }
        else if (cmp(d2.start, d1.start) &lt;= 0) {
            shift(d1, d2, +1);
        }
        else {
            return null;
        }
    }
    else if (i1 &amp;&amp; !i2) {
        if (cmp(d2.start, d1.end) &gt;= 0) {
            shift(d2, d1, -1);
        }
        else if (cmp(d2.end, d1.start) &lt;= 0) {
            shift(d1, d2, -1);
        }
        else {
            return null;
        }
    }
    else if (!i1 &amp;&amp; i2) {
        if (cmp(d2.start, d1.start) &gt;= 0) {
            shift(d2, d1, +1);
        }
        else if (cmp(d2.start, d1.start) &lt;= 0) {
            shift(d1, d2, +1);
        }
        else {
            return null;
        }
    }
    else if (!i1 &amp;&amp; !i2) {
        if (cmp(d2.start, d1.start) &gt;= 0) {
            shift(d2, d1, +1);
        }
        else if (cmp(d2.end, d1.start) &lt;= 0) {
            shift(d1, d2, -1);
        }
        else {
            return null;
        }
    }
    return [d2, d1];
}
function swapGroups(ds1, ds2) {
    for (var i = ds1.length; i--;) {
        for (var j = 0; j &lt; ds2.length; j++) {
            if (!swap(ds1[i], ds2[j])) {
                while (i &lt; ds1.length) {
                    while (j--) {
                        swap(ds2[j], ds1[i]);
                    }
                    j = ds2.length;
                    i++;
                }
                return [ds1, ds2];
            }
        }
    }
    ds1.selectionBefore = ds2.selectionBefore =
        ds1.selectionAfter = ds2.selectionAfter = null;
    return [ds2, ds1];
}
function xform(d1, c1) {
    var i1 = d1.action == &quot;insert&quot;;
    var i2 = c1.action == &quot;insert&quot;;
    if (i1 &amp;&amp; i2) {
        if (cmp(d1.start, c1.start) &lt; 0) {
            shift(c1, d1, 1);
        }
        else {
            shift(d1, c1, 1);
        }
    }
    else if (i1 &amp;&amp; !i2) {
        if (cmp(d1.start, c1.end) &gt;= 0) {
            shift(d1, c1, -1);
        }
        else if (cmp(d1.start, c1.start) &lt;= 0) {
            shift(c1, d1, +1);
        }
        else {
            shift(d1, Range.fromPoints(c1.start, d1.start), -1);
            shift(c1, d1, +1);
        }
    }
    else if (!i1 &amp;&amp; i2) {
        if (cmp(c1.start, d1.end) &gt;= 0) {
            shift(c1, d1, -1);
        }
        else if (cmp(c1.start, d1.start) &lt;= 0) {
            shift(d1, c1, +1);
        }
        else {
            shift(c1, Range.fromPoints(d1.start, c1.start), -1);
            shift(d1, c1, +1);
        }
    }
    else if (!i1 &amp;&amp; !i2) {
        if (cmp(c1.start, d1.end) &gt;= 0) {
            shift(c1, d1, -1);
        }
        else if (cmp(c1.end, d1.start) &lt;= 0) {
            shift(d1, c1, -1);
        }
        else {
            var before, after;
            if (cmp(d1.start, c1.start) &lt; 0) {
                before = d1;
                d1 = splitDelta(d1, c1.start);
            }
            if (cmp(d1.end, c1.end) &gt; 0) {
                after = splitDelta(d1, c1.end);
            }
            shiftPos(c1.end, d1.start, d1.end, -1);
            if (after &amp;&amp; !before) {
                d1.lines = after.lines;
                d1.start = after.start;
                d1.end = after.end;
                after = d1;
            }
            return [c1, before, after].filter(Boolean);
        }
    }
    return [c1, d1];
}
function shift(d1, d2, dir) {
    shiftPos(d1.start, d2.start, d2.end, dir);
    shiftPos(d1.end, d2.start, d2.end, dir);
}
function shiftPos(pos, start, end, dir) {
    if (pos.row == (dir == 1 ? start : end).row) {
        pos.column += dir * (end.column - start.column);
    }
    pos.row += dir * (end.row - start.row);
}
function splitDelta(c, pos) {
    var lines = c.lines;
    var end = c.end;
    c.end = clonePos(pos);
    var rowsBefore = c.end.row - c.start.row;
    var otherLines = lines.splice(rowsBefore, lines.length);
    var col = rowsBefore ? pos.column : pos.column - c.start.column;
    lines.push(otherLines[0].substring(0, col));
    otherLines[0] = otherLines[0].substr(col);
    var rest = {
        start: clonePos(pos),
        end: end,
        lines: otherLines,
        action: c.action
    };
    return rest;
}
function moveDeltasByOne(redoStack, d) {
    d = cloneDelta(d);
    for (var j = redoStack.length; j--;) {
        var deltaSet = redoStack[j];
        for (var i = 0; i &lt; deltaSet.length; i++) {
            var x = deltaSet[i];
            var xformed = xform(x, d);
            d = xformed[0];
            if (xformed.length != 2) {
                if (xformed[2]) {
                    deltaSet.splice(i + 1, 1, xformed[1], xformed[2]);
                    i++;
                }
                else if (!xformed[1]) {
                    deltaSet.splice(i, 1);
                    i--;
                }
            }
        }
        if (!deltaSet.length) {
            redoStack.splice(j, 1);
        }
    }
    return redoStack;
}
function rebaseRedoStack(redoStack, deltaSets) {
    for (var i = 0; i &lt; deltaSets.length; i++) {
        var deltas = deltaSets[i];
        for (var j = 0; j &lt; deltas.length; j++) {
            moveDeltasByOne(redoStack, deltas[j]);
        }
    }
}
exports.UndoManager = UndoManager;

});

define(&quot;ace/layer/lines&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/dom&quot;], function(require, exports, module){&quot;use strict&quot;;
var dom = require(&quot;../lib/dom&quot;);
var Lines = function (element, canvasHeight) {
    this.element = element;
    this.canvasHeight = canvasHeight || 500000;
    this.element.style.height = (this.canvasHeight * 2) + &quot;px&quot;;
    this.cells = [];
    this.cellCache = [];
    this.$offsetCoefficient = 0;
};
(function () {
    this.moveContainer = function (config) {
        dom.translate(this.element, 0, -((config.firstRowScreen * config.lineHeight) % this.canvasHeight) - config.offset * this.$offsetCoefficient);
    };
    this.pageChanged = function (oldConfig, newConfig) {
        return (Math.floor((oldConfig.firstRowScreen * oldConfig.lineHeight) / this.canvasHeight) !==
            Math.floor((newConfig.firstRowScreen * newConfig.lineHeight) / this.canvasHeight));
    };
    this.computeLineTop = function (row, config, session) {
        var screenTop = config.firstRowScreen * config.lineHeight;
        var screenPage = Math.floor(screenTop / this.canvasHeight);
        var lineTop = session.documentToScreenRow(row, 0) * config.lineHeight;
        return lineTop - (screenPage * this.canvasHeight);
    };
    this.computeLineHeight = function (row, config, session) {
        return config.lineHeight * session.getRowLineCount(row);
    };
    this.getLength = function () {
        return this.cells.length;
    };
    this.get = function (index) {
        return this.cells[index];
    };
    this.shift = function () {
        this.$cacheCell(this.cells.shift());
    };
    this.pop = function () {
        this.$cacheCell(this.cells.pop());
    };
    this.push = function (cell) {
        if (Array.isArray(cell)) {
            this.cells.push.apply(this.cells, cell);
            var fragment = dom.createFragment(this.element);
            for (var i = 0; i &lt; cell.length; i++) {
                fragment.appendChild(cell[i].element);
            }
            this.element.appendChild(fragment);
        }
        else {
            this.cells.push(cell);
            this.element.appendChild(cell.element);
        }
    };
    this.unshift = function (cell) {
        if (Array.isArray(cell)) {
            this.cells.unshift.apply(this.cells, cell);
            var fragment = dom.createFragment(this.element);
            for (var i = 0; i &lt; cell.length; i++) {
                fragment.appendChild(cell[i].element);
            }
            if (this.element.firstChild)
                this.element.insertBefore(fragment, this.element.firstChild);
            else
                this.element.appendChild(fragment);
        }
        else {
            this.cells.unshift(cell);
            this.element.insertAdjacentElement(&quot;afterbegin&quot;, cell.element);
        }
    };
    this.last = function () {
        if (this.cells.length)
            return this.cells[this.cells.length - 1];
        else
            return null;
    };
    this.$cacheCell = function (cell) {
        if (!cell)
            return;
        cell.element.remove();
        this.cellCache.push(cell);
    };
    this.createCell = function (row, config, session, initElement) {
        var cell = this.cellCache.pop();
        if (!cell) {
            var element = dom.createElement(&quot;div&quot;);
            if (initElement)
                initElement(element);
            this.element.appendChild(element);
            cell = {
                element: element,
                text: &quot;&quot;,
                row: row
            };
        }
        cell.row = row;
        return cell;
    };
}).call(Lines.prototype);
exports.Lines = Lines;

});

define(&quot;ace/layer/gutter&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/dom&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/lang&quot;,&quot;ace/lib/event_emitter&quot;,&quot;ace/layer/lines&quot;], function(require, exports, module){&quot;use strict&quot;;
var dom = require(&quot;../lib/dom&quot;);
var oop = require(&quot;../lib/oop&quot;);
var lang = require(&quot;../lib/lang&quot;);
var EventEmitter = require(&quot;../lib/event_emitter&quot;).EventEmitter;
var Lines = require(&quot;./lines&quot;).Lines;
var Gutter = function (parentEl) {
    this.element = dom.createElement(&quot;div&quot;);
    this.element.className = &quot;ace_layer ace_gutter-layer&quot;;
    parentEl.appendChild(this.element);
    this.setShowFoldWidgets(this.$showFoldWidgets);
    this.gutterWidth = 0;
    this.$annotations = [];
    this.$updateAnnotations = this.$updateAnnotations.bind(this);
    this.$lines = new Lines(this.element);
    this.$lines.$offsetCoefficient = 1;
};
(function () {
    oop.implement(this, EventEmitter);
    this.setSession = function (session) {
        if (this.session)
            this.session.off(&quot;change&quot;, this.$updateAnnotations);
        this.session = session;
        if (session)
            session.on(&quot;change&quot;, this.$updateAnnotations);
    };
    this.addGutterDecoration = function (row, className) {
        if (window.console)
            console.warn &amp;&amp; console.warn(&quot;deprecated use session.addGutterDecoration&quot;);
        this.session.addGutterDecoration(row, className);
    };
    this.removeGutterDecoration = function (row, className) {
        if (window.console)
            console.warn &amp;&amp; console.warn(&quot;deprecated use session.removeGutterDecoration&quot;);
        this.session.removeGutterDecoration(row, className);
    };
    this.setAnnotations = function (annotations) {
        this.$annotations = [];
        for (var i = 0; i &lt; annotations.length; i++) {
            var annotation = annotations[i];
            var row = annotation.row;
            var rowInfo = this.$annotations[row];
            if (!rowInfo)
                rowInfo = this.$annotations[row] = { text: [] };
            var annoText = annotation.text;
            annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || &quot;&quot;;
            if (rowInfo.text.indexOf(annoText) === -1)
                rowInfo.text.push(annoText);
            var type = annotation.type;
            var className = annotation.className;
            if (className)
                rowInfo.className = className;
            else if (type == &quot;error&quot;)
                rowInfo.className = &quot; ace_error&quot;;
            else if (type == &quot;warning&quot; &amp;&amp; rowInfo.className != &quot; ace_error&quot;)
                rowInfo.className = &quot; ace_warning&quot;;
            else if (type == &quot;info&quot; &amp;&amp; (!rowInfo.className))
                rowInfo.className = &quot; ace_info&quot;;
        }
    };
    this.$updateAnnotations = function (delta) {
        if (!this.$annotations.length)
            return;
        var firstRow = delta.start.row;
        var len = delta.end.row - firstRow;
        if (len === 0) {
        }
        else if (delta.action == &#039;remove&#039;) {
            this.$annotations.splice(firstRow, len + 1, null);
        }
        else {
            var args = new Array(len + 1);
            args.unshift(firstRow, 1);
            this.$annotations.splice.apply(this.$annotations, args);
        }
    };
    this.update = function (config) {
        this.config = config;
        var session = this.session;
        var firstRow = config.firstRow;
        var lastRow = Math.min(config.lastRow + config.gutterOffset, // needed to compensate for hor scollbar
        session.getLength() - 1);
        this.oldLastRow = lastRow;
        this.config = config;
        this.$lines.moveContainer(config);
        this.$updateCursorRow();
        var fold = session.getNextFoldLine(firstRow);
        var foldStart = fold ? fold.start.row : Infinity;
        var cell = null;
        var index = -1;
        var row = firstRow;
        while (true) {
            if (row &gt; foldStart) {
                row = fold.end.row + 1;
                fold = session.getNextFoldLine(row, fold);
                foldStart = fold ? fold.start.row : Infinity;
            }
            if (row &gt; lastRow) {
                while (this.$lines.getLength() &gt; index + 1)
                    this.$lines.pop();
                break;
            }
            cell = this.$lines.get(++index);
            if (cell) {
                cell.row = row;
            }
            else {
                cell = this.$lines.createCell(row, config, this.session, onCreateCell);
                this.$lines.push(cell);
            }
            this.$renderCell(cell, config, fold, row);
            row++;
        }
        this._signal(&quot;afterRender&quot;);
        this.$updateGutterWidth(config);
    };
    this.$updateGutterWidth = function (config) {
        var session = this.session;
        var gutterRenderer = session.gutterRenderer || this.$renderer;
        var firstLineNumber = session.$firstLineNumber;
        var lastLineText = this.$lines.last() ? this.$lines.last().text : &quot;&quot;;
        if (this.$fixedWidth || session.$useWrapMode)
            lastLineText = session.getLength() + firstLineNumber - 1;
        var gutterWidth = gutterRenderer
            ? gutterRenderer.getWidth(session, lastLineText, config)
            : lastLineText.toString().length * config.characterWidth;
        var padding = this.$padding || this.$computePadding();
        gutterWidth += padding.left + padding.right;
        if (gutterWidth !== this.gutterWidth &amp;&amp; !isNaN(gutterWidth)) {
            this.gutterWidth = gutterWidth;
            this.element.parentNode.style.width =
                this.element.style.width = Math.ceil(this.gutterWidth) + &quot;px&quot;;
            this._signal(&quot;changeGutterWidth&quot;, gutterWidth);
        }
    };
    this.$updateCursorRow = function () {
        if (!this.$highlightGutterLine)
            return;
        var position = this.session.selection.getCursor();
        if (this.$cursorRow === position.row)
            return;
        this.$cursorRow = position.row;
    };
    this.updateLineHighlight = function () {
        if (!this.$highlightGutterLine)
            return;
        var row = this.session.selection.cursor.row;
        this.$cursorRow = row;
        if (this.$cursorCell &amp;&amp; this.$cursorCell.row == row)
            return;
        if (this.$cursorCell)
            this.$cursorCell.element.className = this.$cursorCell.element.className.replace(&quot;ace_gutter-active-line &quot;, &quot;&quot;);
        var cells = this.$lines.cells;
        this.$cursorCell = null;
        for (var i = 0; i &lt; cells.length; i++) {
            var cell = cells[i];
            if (cell.row &gt;= this.$cursorRow) {
                if (cell.row &gt; this.$cursorRow) {
                    var fold = this.session.getFoldLine(this.$cursorRow);
                    if (i &gt; 0 &amp;&amp; fold &amp;&amp; fold.start.row == cells[i - 1].row)
                        cell = cells[i - 1];
                    else
                        break;
                }
                cell.element.className = &quot;ace_gutter-active-line &quot; + cell.element.className;
                this.$cursorCell = cell;
                break;
            }
        }
    };
    this.scrollLines = function (config) {
        var oldConfig = this.config;
        this.config = config;
        this.$updateCursorRow();
        if (this.$lines.pageChanged(oldConfig, config))
            return this.update(config);
        this.$lines.moveContainer(config);
        var lastRow = Math.min(config.lastRow + config.gutterOffset, // needed to compensate for hor scollbar
        this.session.getLength() - 1);
        var oldLastRow = this.oldLastRow;
        this.oldLastRow = lastRow;
        if (!oldConfig || oldLastRow &lt; config.firstRow)
            return this.update(config);
        if (lastRow &lt; oldConfig.firstRow)
            return this.update(config);
        if (oldConfig.firstRow &lt; config.firstRow)
            for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row &gt; 0; row--)
                this.$lines.shift();
        if (oldLastRow &gt; lastRow)
            for (var row = this.session.getFoldedRowCount(lastRow + 1, oldLastRow); row &gt; 0; row--)
                this.$lines.pop();
        if (config.firstRow &lt; oldConfig.firstRow) {
            this.$lines.unshift(this.$renderLines(config, config.firstRow, oldConfig.firstRow - 1));
        }
        if (lastRow &gt; oldLastRow) {
            this.$lines.push(this.$renderLines(config, oldLastRow + 1, lastRow));
        }
        this.updateLineHighlight();
        this._signal(&quot;afterRender&quot;);
        this.$updateGutterWidth(config);
    };
    this.$renderLines = function (config, firstRow, lastRow) {
        var fragment = [];
        var row = firstRow;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;
        while (true) {
            if (row &gt; foldStart) {
                row = foldLine.end.row + 1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            if (row &gt; lastRow)
                break;
            var cell = this.$lines.createCell(row, config, this.session, onCreateCell);
            this.$renderCell(cell, config, foldLine, row);
            fragment.push(cell);
            row++;
        }
        return fragment;
    };
    this.$renderCell = function (cell, config, fold, row) {
        var element = cell.element;
        var session = this.session;
        var textNode = element.childNodes[0];
        var foldWidget = element.childNodes[1];
        var firstLineNumber = session.$firstLineNumber;
        var breakpoints = session.$breakpoints;
        var decorations = session.$decorations;
        var gutterRenderer = session.gutterRenderer || this.$renderer;
        var foldWidgets = this.$showFoldWidgets &amp;&amp; session.foldWidgets;
        var foldStart = fold ? fold.start.row : Number.MAX_VALUE;
        var className = &quot;ace_gutter-cell &quot;;
        if (this.$highlightGutterLine) {
            if (row == this.$cursorRow || (fold &amp;&amp; row &lt; this.$cursorRow &amp;&amp; row &gt;= foldStart &amp;&amp; this.$cursorRow &lt;= fold.end.row)) {
                className += &quot;ace_gutter-active-line &quot;;
                if (this.$cursorCell != cell) {
                    if (this.$cursorCell)
                        this.$cursorCell.element.className = this.$cursorCell.element.className.replace(&quot;ace_gutter-active-line &quot;, &quot;&quot;);
                    this.$cursorCell = cell;
                }
            }
        }
        if (breakpoints[row])
            className += breakpoints[row];
        if (decorations[row])
            className += decorations[row];
        if (this.$annotations[row])
            className += this.$annotations[row].className;
        if (element.className != className)
            element.className = className;
        if (foldWidgets) {
            var c = foldWidgets[row];
            if (c == null)
                c = foldWidgets[row] = session.getFoldWidget(row);
        }
        if (c) {
            var className = &quot;ace_fold-widget ace_&quot; + c;
            if (c == &quot;start&quot; &amp;&amp; row == foldStart &amp;&amp; row &lt; fold.end.row)
                className += &quot; ace_closed&quot;;
            else
                className += &quot; ace_open&quot;;
            if (foldWidget.className != className)
                foldWidget.className = className;
            var foldHeight = config.lineHeight + &quot;px&quot;;
            dom.setStyle(foldWidget.style, &quot;height&quot;, foldHeight);
            dom.setStyle(foldWidget.style, &quot;display&quot;, &quot;inline-block&quot;);
        }
        else {
            if (foldWidget) {
                dom.setStyle(foldWidget.style, &quot;display&quot;, &quot;none&quot;);
            }
        }
        var text = (gutterRenderer
            ? gutterRenderer.getText(session, row)
            : row + firstLineNumber).toString();
        if (text !== textNode.data) {
            textNode.data = text;
        }
        dom.setStyle(cell.element.style, &quot;height&quot;, this.$lines.computeLineHeight(row, config, session) + &quot;px&quot;);
        dom.setStyle(cell.element.style, &quot;top&quot;, this.$lines.computeLineTop(row, config, session) + &quot;px&quot;);
        cell.text = text;
        return cell;
    };
    this.$fixedWidth = false;
    this.$highlightGutterLine = true;
    this.$renderer = &quot;&quot;;
    this.setHighlightGutterLine = function (highlightGutterLine) {
        this.$highlightGutterLine = highlightGutterLine;
    };
    this.$showLineNumbers = true;
    this.$renderer = &quot;&quot;;
    this.setShowLineNumbers = function (show) {
        this.$renderer = !show &amp;&amp; {
            getWidth: function () { return 0; },
            getText: function () { return &quot;&quot;; }
        };
    };
    this.getShowLineNumbers = function () {
        return this.$showLineNumbers;
    };
    this.$showFoldWidgets = true;
    this.setShowFoldWidgets = function (show) {
        if (show)
            dom.addCssClass(this.element, &quot;ace_folding-enabled&quot;);
        else
            dom.removeCssClass(this.element, &quot;ace_folding-enabled&quot;);
        this.$showFoldWidgets = show;
        this.$padding = null;
    };
    this.getShowFoldWidgets = function () {
        return this.$showFoldWidgets;
    };
    this.$computePadding = function () {
        if (!this.element.firstChild)
            return { left: 0, right: 0 };
        var style = dom.computedStyle(this.element.firstChild);
        this.$padding = {};
        this.$padding.left = (parseInt(style.borderLeftWidth) || 0)
            + (parseInt(style.paddingLeft) || 0) + 1;
        this.$padding.right = (parseInt(style.borderRightWidth) || 0)
            + (parseInt(style.paddingRight) || 0);
        return this.$padding;
    };
    this.getRegion = function (point) {
        var padding = this.$padding || this.$computePadding();
        var rect = this.element.getBoundingClientRect();
        if (point.x &lt; padding.left + rect.left)
            return &quot;markers&quot;;
        if (this.$showFoldWidgets &amp;&amp; point.x &gt; rect.right - padding.right)
            return &quot;foldWidgets&quot;;
    };
}).call(Gutter.prototype);
function onCreateCell(element) {
    var textNode = document.createTextNode(&#039;&#039;);
    element.appendChild(textNode);
    var foldWidget = dom.createElement(&quot;span&quot;);
    element.appendChild(foldWidget);
    return element;
}
exports.Gutter = Gutter;

});

define(&quot;ace/layer/marker&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/range&quot;,&quot;ace/lib/dom&quot;], function(require, exports, module){&quot;use strict&quot;;
var Range = require(&quot;../range&quot;).Range;
var dom = require(&quot;../lib/dom&quot;);
var Marker = function (parentEl) {
    this.element = dom.createElement(&quot;div&quot;);
    this.element.className = &quot;ace_layer ace_marker-layer&quot;;
    parentEl.appendChild(this.element);
};
(function () {
    this.$padding = 0;
    this.setPadding = function (padding) {
        this.$padding = padding;
    };
    this.setSession = function (session) {
        this.session = session;
    };
    this.setMarkers = function (markers) {
        this.markers = markers;
    };
    this.elt = function (className, css) {
        var x = this.i != -1 &amp;&amp; this.element.childNodes[this.i];
        if (!x) {
            x = document.createElement(&quot;div&quot;);
            this.element.appendChild(x);
            this.i = -1;
        }
        else {
            this.i++;
        }
        x.style.cssText = css;
        x.className = className;
    };
    this.update = function (config) {
        if (!config)
            return;
        this.config = config;
        this.i = 0;
        var html;
        for (var key in this.markers) {
            var marker = this.markers[key];
            if (!marker.range) {
                marker.update(html, this, this.session, config);
                continue;
            }
            var range = marker.range.clipRows(config.firstRow, config.lastRow);
            if (range.isEmpty())
                continue;
            range = range.toScreenRange(this.session);
            if (marker.renderer) {
                var top = this.$getTop(range.start.row, config);
                var left = this.$padding + range.start.column * config.characterWidth;
                marker.renderer(html, range, left, top, config);
            }
            else if (marker.type == &quot;fullLine&quot;) {
                this.drawFullLineMarker(html, range, marker.clazz, config);
            }
            else if (marker.type == &quot;screenLine&quot;) {
                this.drawScreenLineMarker(html, range, marker.clazz, config);
            }
            else if (range.isMultiLine()) {
                if (marker.type == &quot;text&quot;)
                    this.drawTextMarker(html, range, marker.clazz, config);
                else
                    this.drawMultiLineMarker(html, range, marker.clazz, config);
            }
            else {
                this.drawSingleLineMarker(html, range, marker.clazz + &quot; ace_start&quot; + &quot; ace_br15&quot;, config);
            }
        }
        if (this.i != -1) {
            while (this.i &lt; this.element.childElementCount)
                this.element.removeChild(this.element.lastChild);
        }
    };
    this.$getTop = function (row, layerConfig) {
        return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
    };
    function getBorderClass(tl, tr, br, bl) {
        return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
    }
    this.drawTextMarker = function (stringBuilder, range, clazz, layerConfig, extraStyle) {
        var session = this.session;
        var start = range.start.row;
        var end = range.end.row;
        var row = start;
        var prev = 0;
        var curr = 0;
        var next = session.getScreenLastRowColumn(row);
        var lineRange = new Range(row, range.start.column, row, curr);
        for (; row &lt;= end; row++) {
            lineRange.start.row = lineRange.end.row = row;
            lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);
            lineRange.end.column = next;
            prev = curr;
            curr = next;
            next = row + 1 &lt; end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;
            this.drawSingleLineMarker(stringBuilder, lineRange, clazz + (row == start ? &quot; ace_start&quot; : &quot;&quot;) + &quot; ace_br&quot;
                + getBorderClass(row == start || row == start + 1 &amp;&amp; range.start.column, prev &lt; curr, curr &gt; next, row == end), layerConfig, row == end ? 0 : 1, extraStyle);
        }
    };
    this.drawMultiLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {
        var padding = this.$padding;
        var height = config.lineHeight;
        var top = this.$getTop(range.start.row, config);
        var left = padding + range.start.column * config.characterWidth;
        extraStyle = extraStyle || &quot;&quot;;
        if (this.session.$bidiHandler.isBidiRow(range.start.row)) {
            var range1 = range.clone();
            range1.end.row = range1.start.row;
            range1.end.column = this.session.getLine(range1.start.row).length;
            this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + &quot; ace_br1 ace_start&quot;, config, null, extraStyle);
        }
        else {
            this.elt(clazz + &quot; ace_br1 ace_start&quot;, &quot;height:&quot; + height + &quot;px;&quot; + &quot;right:0;&quot; + &quot;top:&quot; + top + &quot;px;left:&quot; + left + &quot;px;&quot; + (extraStyle || &quot;&quot;));
        }
        if (this.session.$bidiHandler.isBidiRow(range.end.row)) {
            var range1 = range.clone();
            range1.start.row = range1.end.row;
            range1.start.column = 0;
            this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + &quot; ace_br12&quot;, config, null, extraStyle);
        }
        else {
            top = this.$getTop(range.end.row, config);
            var width = range.end.column * config.characterWidth;
            this.elt(clazz + &quot; ace_br12&quot;, &quot;height:&quot; + height + &quot;px;&quot; +
                &quot;width:&quot; + width + &quot;px;&quot; +
                &quot;top:&quot; + top + &quot;px;&quot; +
                &quot;left:&quot; + padding + &quot;px;&quot; + (extraStyle || &quot;&quot;));
        }
        height = (range.end.row - range.start.row - 1) * config.lineHeight;
        if (height &lt;= 0)
            return;
        top = this.$getTop(range.start.row + 1, config);
        var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);
        this.elt(clazz + (radiusClass ? &quot; ace_br&quot; + radiusClass : &quot;&quot;), &quot;height:&quot; + height + &quot;px;&quot; +
            &quot;right:0;&quot; +
            &quot;top:&quot; + top + &quot;px;&quot; +
            &quot;left:&quot; + padding + &quot;px;&quot; + (extraStyle || &quot;&quot;));
    };
    this.drawSingleLineMarker = function (stringBuilder, range, clazz, config, extraLength, extraStyle) {
        if (this.session.$bidiHandler.isBidiRow(range.start.row))
            return this.drawBidiSingleLineMarker(stringBuilder, range, clazz, config, extraLength, extraStyle);
        var height = config.lineHeight;
        var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;
        var top = this.$getTop(range.start.row, config);
        var left = this.$padding + range.start.column * config.characterWidth;
        this.elt(clazz, &quot;height:&quot; + height + &quot;px;&quot; +
            &quot;width:&quot; + width + &quot;px;&quot; +
            &quot;top:&quot; + top + &quot;px;&quot; +
            &quot;left:&quot; + left + &quot;px;&quot; + (extraStyle || &quot;&quot;));
    };
    this.drawBidiSingleLineMarker = function (stringBuilder, range, clazz, config, extraLength, extraStyle) {
        var height = config.lineHeight, top = this.$getTop(range.start.row, config), padding = this.$padding;
        var selections = this.session.$bidiHandler.getSelections(range.start.column, range.end.column);
        selections.forEach(function (selection) {
            this.elt(clazz, &quot;height:&quot; + height + &quot;px;&quot; +
                &quot;width:&quot; + (selection.width + (extraLength || 0)) + &quot;px;&quot; +
                &quot;top:&quot; + top + &quot;px;&quot; +
                &quot;left:&quot; + (padding + selection.left) + &quot;px;&quot; + (extraStyle || &quot;&quot;));
        }, this);
    };
    this.drawFullLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {
        var top = this.$getTop(range.start.row, config);
        var height = config.lineHeight;
        if (range.start.row != range.end.row)
            height += this.$getTop(range.end.row, config) - top;
        this.elt(clazz, &quot;height:&quot; + height + &quot;px;&quot; +
            &quot;top:&quot; + top + &quot;px;&quot; +
            &quot;left:0;right:0;&quot; + (extraStyle || &quot;&quot;));
    };
    this.drawScreenLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {
        var top = this.$getTop(range.start.row, config);
        var height = config.lineHeight;
        this.elt(clazz, &quot;height:&quot; + height + &quot;px;&quot; +
            &quot;top:&quot; + top + &quot;px;&quot; +
            &quot;left:0;right:0;&quot; + (extraStyle || &quot;&quot;));
    };
}).call(Marker.prototype);
exports.Marker = Marker;

});

define(&quot;ace/layer/text&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/dom&quot;,&quot;ace/lib/lang&quot;,&quot;ace/layer/lines&quot;,&quot;ace/lib/event_emitter&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;../lib/oop&quot;);
var dom = require(&quot;../lib/dom&quot;);
var lang = require(&quot;../lib/lang&quot;);
var Lines = require(&quot;./lines&quot;).Lines;
var EventEmitter = require(&quot;../lib/event_emitter&quot;).EventEmitter;
var Text = function (parentEl) {
    this.dom = dom;
    this.element = this.dom.createElement(&quot;div&quot;);
    this.element.className = &quot;ace_layer ace_text-layer&quot;;
    parentEl.appendChild(this.element);
    this.$updateEolChar = this.$updateEolChar.bind(this);
    this.$lines = new Lines(this.element);
};
(function () {
    oop.implement(this, EventEmitter);
    this.EOF_CHAR = &quot;\xB6&quot;;
    this.EOL_CHAR_LF = &quot;\xAC&quot;;
    this.EOL_CHAR_CRLF = &quot;\xa4&quot;;
    this.EOL_CHAR = this.EOL_CHAR_LF;
    this.TAB_CHAR = &quot;\u2014&quot;; //&quot;\u21E5&quot;;
    this.SPACE_CHAR = &quot;\xB7&quot;;
    this.$padding = 0;
    this.MAX_LINE_LENGTH = 10000;
    this.MAX_CHUNK_LENGTH = 250;
    this.$updateEolChar = function () {
        var doc = this.session.doc;
        var unixMode = doc.getNewLineCharacter() == &quot;\n&quot; &amp;&amp; doc.getNewLineMode() != &quot;windows&quot;;
        var EOL_CHAR = unixMode ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;
        if (this.EOL_CHAR != EOL_CHAR) {
            this.EOL_CHAR = EOL_CHAR;
            return true;
        }
    };
    this.setPadding = function (padding) {
        this.$padding = padding;
        this.element.style.margin = &quot;0 &quot; + padding + &quot;px&quot;;
    };
    this.getLineHeight = function () {
        return this.$fontMetrics.$characterSize.height || 0;
    };
    this.getCharacterWidth = function () {
        return this.$fontMetrics.$characterSize.width || 0;
    };
    this.$setFontMetrics = function (measure) {
        this.$fontMetrics = measure;
        this.$fontMetrics.on(&quot;changeCharacterSize&quot;, function (e) {
            this._signal(&quot;changeCharacterSize&quot;, e);
        }.bind(this));
        this.$pollSizeChanges();
    };
    this.checkForSizeChanges = function () {
        this.$fontMetrics.checkForSizeChanges();
    };
    this.$pollSizeChanges = function () {
        return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
    };
    this.setSession = function (session) {
        this.session = session;
        if (session)
            this.$computeTabString();
    };
    this.showInvisibles = false;
    this.showSpaces = false;
    this.showTabs = false;
    this.showEOL = false;
    this.setShowInvisibles = function (showInvisibles) {
        if (this.showInvisibles == showInvisibles)
            return false;
        this.showInvisibles = showInvisibles;
        if (typeof showInvisibles == &quot;string&quot;) {
            this.showSpaces = /tab/i.test(showInvisibles);
            this.showTabs = /space/i.test(showInvisibles);
            this.showEOL = /eol/i.test(showInvisibles);
        }
        else {
            this.showSpaces = this.showTabs = this.showEOL = showInvisibles;
        }
        this.$computeTabString();
        return true;
    };
    this.displayIndentGuides = true;
    this.setDisplayIndentGuides = function (display) {
        if (this.displayIndentGuides == display)
            return false;
        this.displayIndentGuides = display;
        this.$computeTabString();
        return true;
    };
    this.$highlightIndentGuides = true;
    this.setHighlightIndentGuides = function (highlight) {
        if (this.$highlightIndentGuides === highlight)
            return false;
        this.$highlightIndentGuides = highlight;
        return highlight;
    };
    this.$tabStrings = [];
    this.onChangeTabSize =
        this.$computeTabString = function () {
            var tabSize = this.session.getTabSize();
            this.tabSize = tabSize;
            var tabStr = this.$tabStrings = [0];
            for (var i = 1; i &lt; tabSize + 1; i++) {
                if (this.showTabs) {
                    var span = this.dom.createElement(&quot;span&quot;);
                    span.className = &quot;ace_invisible ace_invisible_tab&quot;;
                    span.textContent = lang.stringRepeat(this.TAB_CHAR, i);
                    tabStr.push(span);
                }
                else {
                    tabStr.push(this.dom.createTextNode(lang.stringRepeat(&quot; &quot;, i), this.element));
                }
            }
            if (this.displayIndentGuides) {
                this.$indentGuideRe = /\s\S| \t|\t |\s$/;
                var className = &quot;ace_indent-guide&quot;;
                var spaceClass = this.showSpaces ? &quot; ace_invisible ace_invisible_space&quot; : &quot;&quot;;
                var spaceContent = this.showSpaces
                    ? lang.stringRepeat(this.SPACE_CHAR, this.tabSize)
                    : lang.stringRepeat(&quot; &quot;, this.tabSize);
                var tabClass = this.showTabs ? &quot; ace_invisible ace_invisible_tab&quot; : &quot;&quot;;
                var tabContent = this.showTabs
                    ? lang.stringRepeat(this.TAB_CHAR, this.tabSize)
                    : spaceContent;
                var span = this.dom.createElement(&quot;span&quot;);
                span.className = className + spaceClass;
                span.textContent = spaceContent;
                this.$tabStrings[&quot; &quot;] = span;
                var span = this.dom.createElement(&quot;span&quot;);
                span.className = className + tabClass;
                span.textContent = tabContent;
                this.$tabStrings[&quot;\t&quot;] = span;
            }
        };
    this.updateLines = function (config, firstRow, lastRow) {
        if (this.config.lastRow != config.lastRow ||
            this.config.firstRow != config.firstRow) {
            return this.update(config);
        }
        this.config = config;
        var first = Math.max(firstRow, config.firstRow);
        var last = Math.min(lastRow, config.lastRow);
        var lineElements = this.element.childNodes;
        var lineElementsIdx = 0;
        for (var row = config.firstRow; row &lt; first; row++) {
            var foldLine = this.session.getFoldLine(row);
            if (foldLine) {
                if (foldLine.containsRow(first)) {
                    first = foldLine.start.row;
                    break;
                }
                else {
                    row = foldLine.end.row;
                }
            }
            lineElementsIdx++;
        }
        var heightChanged = false;
        var row = first;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;
        while (true) {
            if (row &gt; foldStart) {
                row = foldLine.end.row + 1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            if (row &gt; last)
                break;
            var lineElement = lineElements[lineElementsIdx++];
            if (lineElement) {
                this.dom.removeChildren(lineElement);
                this.$renderLine(lineElement, row, row == foldStart ? foldLine : false);
                if (heightChanged)
                    lineElement.style.top = this.$lines.computeLineTop(row, config, this.session) + &quot;px&quot;;
                var height = (config.lineHeight * this.session.getRowLength(row)) + &quot;px&quot;;
                if (lineElement.style.height != height) {
                    heightChanged = true;
                    lineElement.style.height = height;
                }
            }
            row++;
        }
        if (heightChanged) {
            while (lineElementsIdx &lt; this.$lines.cells.length) {
                var cell = this.$lines.cells[lineElementsIdx++];
                cell.element.style.top = this.$lines.computeLineTop(cell.row, config, this.session) + &quot;px&quot;;
            }
        }
    };
    this.scrollLines = function (config) {
        var oldConfig = this.config;
        this.config = config;
        if (this.$lines.pageChanged(oldConfig, config))
            return this.update(config);
        this.$lines.moveContainer(config);
        var lastRow = config.lastRow;
        var oldLastRow = oldConfig ? oldConfig.lastRow : -1;
        if (!oldConfig || oldLastRow &lt; config.firstRow)
            return this.update(config);
        if (lastRow &lt; oldConfig.firstRow)
            return this.update(config);
        if (!oldConfig || oldConfig.lastRow &lt; config.firstRow)
            return this.update(config);
        if (config.lastRow &lt; oldConfig.firstRow)
            return this.update(config);
        if (oldConfig.firstRow &lt; config.firstRow)
            for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row &gt; 0; row--)
                this.$lines.shift();
        if (oldConfig.lastRow &gt; config.lastRow)
            for (var row = this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row &gt; 0; row--)
                this.$lines.pop();
        if (config.firstRow &lt; oldConfig.firstRow) {
            this.$lines.unshift(this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1));
        }
        if (config.lastRow &gt; oldConfig.lastRow) {
            this.$lines.push(this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow));
        }
        this.$highlightIndentGuide();
    };
    this.$renderLinesFragment = function (config, firstRow, lastRow) {
        var fragment = [];
        var row = firstRow;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;
        while (true) {
            if (row &gt; foldStart) {
                row = foldLine.end.row + 1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            if (row &gt; lastRow)
                break;
            var line = this.$lines.createCell(row, config, this.session);
            var lineEl = line.element;
            this.dom.removeChildren(lineEl);
            dom.setStyle(lineEl.style, &quot;height&quot;, this.$lines.computeLineHeight(row, config, this.session) + &quot;px&quot;);
            dom.setStyle(lineEl.style, &quot;top&quot;, this.$lines.computeLineTop(row, config, this.session) + &quot;px&quot;);
            this.$renderLine(lineEl, row, row == foldStart ? foldLine : false);
            if (this.$useLineGroups()) {
                lineEl.className = &quot;ace_line_group&quot;;
            }
            else {
                lineEl.className = &quot;ace_line&quot;;
                lineEl.setAttribute(&quot;role&quot;, &quot;option&quot;);
            }
            fragment.push(line);
            row++;
        }
        return fragment;
    };
    this.update = function (config) {
        this.$lines.moveContainer(config);
        this.config = config;
        var firstRow = config.firstRow;
        var lastRow = config.lastRow;
        var lines = this.$lines;
        while (lines.getLength())
            lines.pop();
        lines.push(this.$renderLinesFragment(config, firstRow, lastRow));
    };
    this.$textToken = {
        &quot;text&quot;: true,
        &quot;rparen&quot;: true,
        &quot;lparen&quot;: true
    };
    this.$renderTokenInChunks = function (parent, screenColumn, token, value) {
        var newScreenColumn;
        for (var i = 0; i &lt; value.length; i += this.MAX_CHUNK_LENGTH) {
            var valueChunk = value.substring(i, i + this.MAX_CHUNK_LENGTH);
            var tokenChunk = {
                type: token.type,
                value: valueChunk
            };
            newScreenColumn = this.$renderToken(parent, screenColumn + i, tokenChunk, valueChunk);
        }
        return newScreenColumn;
    };
    this.$renderToken = function (parent, screenColumn, token, value) {
        var self = this;
        var re = /(\t)|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\uFEFF\uFFF9-\uFFFC\u2066\u2067\u2068\u202A\u202B\u202D\u202E\u202C\u2069]+)|(\u3000)|([\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]|[\uD800-\uDBFF][\uDC00-\uDFFF])/g;
        var valueFragment = this.dom.createFragment(this.element);
        var m;
        var i = 0;
        while (m = re.exec(value)) {
            var tab = m[1];
            var simpleSpace = m[2];
            var controlCharacter = m[3];
            var cjkSpace = m[4];
            var cjk = m[5];
            if (!self.showSpaces &amp;&amp; simpleSpace)
                continue;
            var before = i != m.index ? value.slice(i, m.index) : &quot;&quot;;
            i = m.index + m[0].length;
            if (before) {
                valueFragment.appendChild(this.dom.createTextNode(before, this.element));
            }
            if (tab) {
                var tabSize = self.session.getScreenTabSize(screenColumn + m.index);
                valueFragment.appendChild(self.$tabStrings[tabSize].cloneNode(true));
                screenColumn += tabSize - 1;
            }
            else if (simpleSpace) {
                if (self.showSpaces) {
                    var span = this.dom.createElement(&quot;span&quot;);
                    span.className = &quot;ace_invisible ace_invisible_space&quot;;
                    span.textContent = lang.stringRepeat(self.SPACE_CHAR, simpleSpace.length);
                    valueFragment.appendChild(span);
                }
                else {
                    valueFragment.appendChild(this.com.createTextNode(simpleSpace, this.element));
                }
            }
            else if (controlCharacter) {
                var span = this.dom.createElement(&quot;span&quot;);
                span.className = &quot;ace_invisible ace_invisible_space ace_invalid&quot;;
                span.textContent = lang.stringRepeat(self.SPACE_CHAR, controlCharacter.length);
                valueFragment.appendChild(span);
            }
            else if (cjkSpace) {
                screenColumn += 1;
                var span = this.dom.createElement(&quot;span&quot;);
                span.style.width = (self.config.characterWidth * 2) + &quot;px&quot;;
                span.className = self.showSpaces ? &quot;ace_cjk ace_invisible ace_invisible_space&quot; : &quot;ace_cjk&quot;;
                span.textContent = self.showSpaces ? self.SPACE_CHAR : cjkSpace;
                valueFragment.appendChild(span);
            }
            else if (cjk) {
                screenColumn += 1;
                var span = this.dom.createElement(&quot;span&quot;);
                span.style.width = (self.config.characterWidth * 2) + &quot;px&quot;;
                span.className = &quot;ace_cjk&quot;;
                span.textContent = cjk;
                valueFragment.appendChild(span);
            }
        }
        valueFragment.appendChild(this.dom.createTextNode(i ? value.slice(i) : value, this.element));
        var span = this.dom.createElement(&quot;span&quot;);
        if (!this.$textToken[token.type]) {
            var classes = &quot;ace_&quot; + token.type.replace(/\./g, &quot; ace_&quot;);
            if (token.type == &quot;fold&quot;)
                span.style.width = (token.value.length * this.config.characterWidth) + &quot;px&quot;;
            span.className = classes;
        }
        span.appendChild(valueFragment);
        parent.appendChild(span);
        return screenColumn + value.length;
    };
    this.renderIndentGuide = function (parent, value, max) {
        var cols = value.search(this.$indentGuideRe);
        if (cols &lt;= 0 || cols &gt;= max)
            return value;
        if (value[0] == &quot; &quot;) {
            cols -= cols % this.tabSize;
            var count = cols / this.tabSize;
            for (var i = 0; i &lt; count; i++) {
                parent.appendChild(this.$tabStrings[&quot; &quot;].cloneNode(true));
            }
            this.$highlightIndentGuide();
            return value.substr(cols);
        }
        else if (value[0] == &quot;\t&quot;) {
            for (var i = 0; i &lt; cols; i++) {
                parent.appendChild(this.$tabStrings[&quot;\t&quot;].cloneNode(true));
            }
            this.$highlightIndentGuide();
            return value.substr(cols);
        }
        this.$highlightIndentGuide();
        return value;
    };
    this.$highlightIndentGuide = function () {
        if (!this.$highlightIndentGuides || !this.displayIndentGuides)
            return;
        this.$highlightIndentGuideMarker = {
            indentLevel: undefined,
            start: undefined,
            end: undefined,
            dir: undefined
        };
        var lines = this.session.doc.$lines;
        if (!lines)
            return;
        var cursor = this.session.selection.getCursor();
        var initialIndent = /^\s*/.exec(this.session.doc.getLine(cursor.row))[0].length;
        var elementIndentLevel = Math.floor(initialIndent / this.tabSize);
        this.$highlightIndentGuideMarker = {
            indentLevel: elementIndentLevel,
            start: cursor.row
        };
        var bracketHighlight = this.session.$bracketHighlight;
        if (bracketHighlight) {
            var ranges = this.session.$bracketHighlight.ranges;
            for (var i = 0; i &lt; ranges.length; i++) {
                if (cursor.row !== ranges[i].start.row) {
                    this.$highlightIndentGuideMarker.end = ranges[i].start.row;
                    if (cursor.row &gt; ranges[i].start.row) {
                        this.$highlightIndentGuideMarker.dir = -1;
                    }
                    else {
                        this.$highlightIndentGuideMarker.dir = 1;
                    }
                    break;
                }
            }
        }
        if (!this.$highlightIndentGuideMarker.end) {
            if (lines[cursor.row] !== &#039;&#039; &amp;&amp; cursor.column === lines[cursor.row].length) {
                this.$highlightIndentGuideMarker.dir = 1;
                for (var i = cursor.row + 1; i &lt; lines.length; i++) {
                    var line = lines[i];
                    var currentIndent = /^\s*/.exec(line)[0].length;
                    if (line !== &#039;&#039;) {
                        this.$highlightIndentGuideMarker.end = i;
                        if (currentIndent &lt;= initialIndent)
                            break;
                    }
                }
            }
        }
        this.$renderHighlightIndentGuide();
    };
    this.$clearActiveIndentGuide = function () {
        var cells = this.$lines.cells;
        for (var i = 0; i &lt; cells.length; i++) {
            var cell = cells[i];
            var childNodes = cell.element.childNodes;
            if (childNodes.length &gt; 0) {
                for (var j = 0; j &lt; childNodes.length; j++) {
                    if (childNodes[j].classList &amp;&amp; childNodes[j].classList.contains(&quot;ace_indent-guide-active&quot;)) {
                        childNodes[j].classList.remove(&quot;ace_indent-guide-active&quot;);
                        break;
                    }
                }
            }
        }
    };
    this.$setIndentGuideActive = function (cell, indentLevel) {
        var line = this.session.doc.getLine(cell.row);
        if (line !== &quot;&quot;) {
            var childNodes = cell.element.childNodes;
            if (childNodes) {
                var node = childNodes[indentLevel - 1];
                if (node &amp;&amp; node.classList &amp;&amp; node.classList.contains(&quot;ace_indent-guide&quot;))
                    node.classList.add(&quot;ace_indent-guide-active&quot;);
            }
        }
    };
    this.$renderHighlightIndentGuide = function () {
        if (!this.$lines)
            return;
        var cells = this.$lines.cells;
        this.$clearActiveIndentGuide();
        var indentLevel = this.$highlightIndentGuideMarker.indentLevel;
        if (indentLevel !== 0) {
            if (this.$highlightIndentGuideMarker.dir === 1) {
                for (var i = 0; i &lt; cells.length; i++) {
                    var cell = cells[i];
                    if (this.$highlightIndentGuideMarker.end &amp;&amp; cell.row &gt;= this.$highlightIndentGuideMarker.start
                        + 1) {
                        if (cell.row &gt;= this.$highlightIndentGuideMarker.end)
                            break;
                        this.$setIndentGuideActive(cell, indentLevel);
                    }
                }
            }
            else {
                for (var i = cells.length - 1; i &gt;= 0; i--) {
                    var cell = cells[i];
                    if (this.$highlightIndentGuideMarker.end &amp;&amp; cell.row &lt; this.$highlightIndentGuideMarker.start) {
                        if (cell.row &lt;= this.$highlightIndentGuideMarker.end)
                            break;
                        this.$setIndentGuideActive(cell, indentLevel);
                    }
                }
            }
        }
    };
    this.$createLineElement = function (parent) {
        var lineEl = this.dom.createElement(&quot;div&quot;);
        lineEl.className = &quot;ace_line&quot;;
        lineEl.style.height = this.config.lineHeight + &quot;px&quot;;
        return lineEl;
    };
    this.$renderWrappedLine = function (parent, tokens, splits) {
        var chars = 0;
        var split = 0;
        var splitChars = splits[0];
        var screenColumn = 0;
        var lineEl = this.$createLineElement();
        parent.appendChild(lineEl);
        for (var i = 0; i &lt; tokens.length; i++) {
            var token = tokens[i];
            var value = token.value;
            if (i == 0 &amp;&amp; this.displayIndentGuides) {
                chars = value.length;
                value = this.renderIndentGuide(lineEl, value, splitChars);
                if (!value)
                    continue;
                chars -= value.length;
            }
            if (chars + value.length &lt; splitChars) {
                screenColumn = this.$renderTokenInChunks(lineEl, screenColumn, token, value);
                chars += value.length;
            }
            else {
                while (chars + value.length &gt;= splitChars) {
                    screenColumn = this.$renderTokenInChunks(lineEl, screenColumn, token, value.substring(0, splitChars - chars));
                    value = value.substring(splitChars - chars);
                    chars = splitChars;
                    lineEl = this.$createLineElement();
                    parent.appendChild(lineEl);
                    lineEl.appendChild(this.dom.createTextNode(lang.stringRepeat(&quot;\xa0&quot;, splits.indent), this.element));
                    split++;
                    screenColumn = 0;
                    splitChars = splits[split] || Number.MAX_VALUE;
                }
                if (value.length != 0) {
                    chars += value.length;
                    screenColumn = this.$renderTokenInChunks(lineEl, screenColumn, token, value);
                }
            }
        }
        if (splits[splits.length - 1] &gt; this.MAX_LINE_LENGTH)
            this.$renderOverflowMessage(lineEl, screenColumn, null, &quot;&quot;, true);
    };
    this.$renderSimpleLine = function (parent, tokens) {
        var screenColumn = 0;
        for (var i = 0; i &lt; tokens.length; i++) {
            var token = tokens[i];
            var value = token.value;
            if (i == 0 &amp;&amp; this.displayIndentGuides) {
                value = this.renderIndentGuide(parent, value);
                if (!value)
                    continue;
            }
            if (screenColumn + value.length &gt; this.MAX_LINE_LENGTH) {
                this.$renderOverflowMessage(parent, screenColumn, token, value);
                return;
            }
            screenColumn = this.$renderTokenInChunks(parent, screenColumn, token, value);
        }
    };
    this.$renderOverflowMessage = function (parent, screenColumn, token, value, hide) {
        if (token) {
            this.$renderTokenInChunks(parent, screenColumn, token, value.slice(0, this.MAX_LINE_LENGTH - screenColumn));
        }
        var overflowEl = this.dom.createElement(&quot;span&quot;);
        overflowEl.className = &quot;ace_inline_button ace_keyword ace_toggle_wrap&quot;;
        overflowEl.textContent = hide ? &quot;&lt;hide&gt;&quot; : &quot;&lt;click to see more...&gt;&quot;;
        parent.appendChild(overflowEl);
    };
    this.$renderLine = function (parent, row, foldLine) {
        if (!foldLine &amp;&amp; foldLine != false)
            foldLine = this.session.getFoldLine(row);
        if (foldLine)
            var tokens = this.$getFoldLineTokens(row, foldLine);
        else
            var tokens = this.session.getTokens(row);
        var lastLineEl = parent;
        if (tokens.length) {
            var splits = this.session.getRowSplitData(row);
            if (splits &amp;&amp; splits.length) {
                this.$renderWrappedLine(parent, tokens, splits);
                var lastLineEl = parent.lastChild;
            }
            else {
                var lastLineEl = parent;
                if (this.$useLineGroups()) {
                    lastLineEl = this.$createLineElement();
                    parent.appendChild(lastLineEl);
                }
                this.$renderSimpleLine(lastLineEl, tokens);
            }
        }
        else if (this.$useLineGroups()) {
            lastLineEl = this.$createLineElement();
            parent.appendChild(lastLineEl);
        }
        if (this.showEOL &amp;&amp; lastLineEl) {
            if (foldLine)
                row = foldLine.end.row;
            var invisibleEl = this.dom.createElement(&quot;span&quot;);
            invisibleEl.className = &quot;ace_invisible ace_invisible_eol&quot;;
            invisibleEl.textContent = row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR;
            lastLineEl.appendChild(invisibleEl);
        }
    };
    this.$getFoldLineTokens = function (row, foldLine) {
        var session = this.session;
        var renderTokens = [];
        function addTokens(tokens, from, to) {
            var idx = 0, col = 0;
            while ((col + tokens[idx].value.length) &lt; from) {
                col += tokens[idx].value.length;
                idx++;
                if (idx == tokens.length)
                    return;
            }
            if (col != from) {
                var value = tokens[idx].value.substring(from - col);
                if (value.length &gt; (to - from))
                    value = value.substring(0, to - from);
                renderTokens.push({
                    type: tokens[idx].type,
                    value: value
                });
                col = from + value.length;
                idx += 1;
            }
            while (col &lt; to &amp;&amp; idx &lt; tokens.length) {
                var value = tokens[idx].value;
                if (value.length + col &gt; to) {
                    renderTokens.push({
                        type: tokens[idx].type,
                        value: value.substring(0, to - col)
                    });
                }
                else
                    renderTokens.push(tokens[idx]);
                col += value.length;
                idx += 1;
            }
        }
        var tokens = session.getTokens(row);
        foldLine.walk(function (placeholder, row, column, lastColumn, isNewRow) {
            if (placeholder != null) {
                renderTokens.push({
                    type: &quot;fold&quot;,
                    value: placeholder
                });
            }
            else {
                if (isNewRow)
                    tokens = session.getTokens(row);
                if (tokens.length)
                    addTokens(tokens, lastColumn, column);
            }
        }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);
        return renderTokens;
    };
    this.$useLineGroups = function () {
        return this.session.getUseWrapMode();
    };
    this.destroy = function () { };
}).call(Text.prototype);
exports.Text = Text;

});

define(&quot;ace/layer/cursor&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/dom&quot;], function(require, exports, module){&quot;use strict&quot;;
var dom = require(&quot;../lib/dom&quot;);
var Cursor = function (parentEl) {
    this.element = dom.createElement(&quot;div&quot;);
    this.element.className = &quot;ace_layer ace_cursor-layer&quot;;
    parentEl.appendChild(this.element);
    this.isVisible = false;
    this.isBlinking = true;
    this.blinkInterval = 1000;
    this.smoothBlinking = false;
    this.cursors = [];
    this.cursor = this.addCursor();
    dom.addCssClass(this.element, &quot;ace_hidden-cursors&quot;);
    this.$updateCursors = this.$updateOpacity.bind(this);
};
(function () {
    this.$updateOpacity = function (val) {
        var cursors = this.cursors;
        for (var i = cursors.length; i--;)
            dom.setStyle(cursors[i].style, &quot;opacity&quot;, val ? &quot;&quot; : &quot;0&quot;);
    };
    this.$startCssAnimation = function () {
        var cursors = this.cursors;
        for (var i = cursors.length; i--;)
            cursors[i].style.animationDuration = this.blinkInterval + &quot;ms&quot;;
        this.$isAnimating = true;
        setTimeout(function () {
            if (this.$isAnimating) {
                dom.addCssClass(this.element, &quot;ace_animate-blinking&quot;);
            }
        }.bind(this));
    };
    this.$stopCssAnimation = function () {
        this.$isAnimating = false;
        dom.removeCssClass(this.element, &quot;ace_animate-blinking&quot;);
    };
    this.$padding = 0;
    this.setPadding = function (padding) {
        this.$padding = padding;
    };
    this.setSession = function (session) {
        this.session = session;
    };
    this.setBlinking = function (blinking) {
        if (blinking != this.isBlinking) {
            this.isBlinking = blinking;
            this.restartTimer();
        }
    };
    this.setBlinkInterval = function (blinkInterval) {
        if (blinkInterval != this.blinkInterval) {
            this.blinkInterval = blinkInterval;
            this.restartTimer();
        }
    };
    this.setSmoothBlinking = function (smoothBlinking) {
        if (smoothBlinking != this.smoothBlinking) {
            this.smoothBlinking = smoothBlinking;
            dom.setCssClass(this.element, &quot;ace_smooth-blinking&quot;, smoothBlinking);
            this.$updateCursors(true);
            this.restartTimer();
        }
    };
    this.addCursor = function () {
        var el = dom.createElement(&quot;div&quot;);
        el.className = &quot;ace_cursor&quot;;
        this.element.appendChild(el);
        this.cursors.push(el);
        return el;
    };
    this.removeCursor = function () {
        if (this.cursors.length &gt; 1) {
            var el = this.cursors.pop();
            el.parentNode.removeChild(el);
            return el;
        }
    };
    this.hideCursor = function () {
        this.isVisible = false;
        dom.addCssClass(this.element, &quot;ace_hidden-cursors&quot;);
        this.restartTimer();
    };
    this.showCursor = function () {
        this.isVisible = true;
        dom.removeCssClass(this.element, &quot;ace_hidden-cursors&quot;);
        this.restartTimer();
    };
    this.restartTimer = function () {
        var update = this.$updateCursors;
        clearInterval(this.intervalId);
        clearTimeout(this.timeoutId);
        this.$stopCssAnimation();
        if (this.smoothBlinking) {
            this.$isSmoothBlinking = false;
            dom.removeCssClass(this.element, &quot;ace_smooth-blinking&quot;);
        }
        update(true);
        if (!this.isBlinking || !this.blinkInterval || !this.isVisible) {
            this.$stopCssAnimation();
            return;
        }
        if (this.smoothBlinking) {
            this.$isSmoothBlinking = true;
            setTimeout(function () {
                if (this.$isSmoothBlinking) {
                    dom.addCssClass(this.element, &quot;ace_smooth-blinking&quot;);
                }
            }.bind(this));
        }
        if (dom.HAS_CSS_ANIMATION) {
            this.$startCssAnimation();
        }
        else {
            var blink = function () {
                this.timeoutId = setTimeout(function () {
                    update(false);
                }, 0.6 * this.blinkInterval);
            }.bind(this);
            this.intervalId = setInterval(function () {
                update(true);
                blink();
            }, this.blinkInterval);
            blink();
        }
    };
    this.getPixelPosition = function (position, onScreen) {
        if (!this.config || !this.session)
            return { left: 0, top: 0 };
        if (!position)
            position = this.session.selection.getCursor();
        var pos = this.session.documentToScreenPosition(position);
        var cursorLeft = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, position.row)
            ? this.session.$bidiHandler.getPosLeft(pos.column)
            : pos.column * this.config.characterWidth);
        var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) *
            this.config.lineHeight;
        return { left: cursorLeft, top: cursorTop };
    };
    this.isCursorInView = function (pixelPos, config) {
        return pixelPos.top &gt;= 0 &amp;&amp; pixelPos.top &lt; config.maxHeight;
    };
    this.update = function (config) {
        this.config = config;
        var selections = this.session.$selectionMarkers;
        var i = 0, cursorIndex = 0;
        if (selections === undefined || selections.length === 0) {
            selections = [{ cursor: null }];
        }
        for (var i = 0, n = selections.length; i &lt; n; i++) {
            var pixelPos = this.getPixelPosition(selections[i].cursor, true);
            if ((pixelPos.top &gt; config.height + config.offset ||
                pixelPos.top &lt; 0) &amp;&amp; i &gt; 1) {
                continue;
            }
            var element = this.cursors[cursorIndex++] || this.addCursor();
            var style = element.style;
            if (!this.drawCursor) {
                if (!this.isCursorInView(pixelPos, config)) {
                    dom.setStyle(style, &quot;display&quot;, &quot;none&quot;);
                }
                else {
                    dom.setStyle(style, &quot;display&quot;, &quot;block&quot;);
                    dom.translate(element, pixelPos.left, pixelPos.top);
                    dom.setStyle(style, &quot;width&quot;, Math.round(config.characterWidth) + &quot;px&quot;);
                    dom.setStyle(style, &quot;height&quot;, config.lineHeight + &quot;px&quot;);
                }
            }
            else {
                this.drawCursor(element, pixelPos, config, selections[i], this.session);
            }
        }
        while (this.cursors.length &gt; cursorIndex)
            this.removeCursor();
        var overwrite = this.session.getOverwrite();
        this.$setOverwrite(overwrite);
        this.$pixelPos = pixelPos;
        this.restartTimer();
    };
    this.drawCursor = null;
    this.$setOverwrite = function (overwrite) {
        if (overwrite != this.overwrite) {
            this.overwrite = overwrite;
            if (overwrite)
                dom.addCssClass(this.element, &quot;ace_overwrite-cursors&quot;);
            else
                dom.removeCssClass(this.element, &quot;ace_overwrite-cursors&quot;);
        }
    };
    this.destroy = function () {
        clearInterval(this.intervalId);
        clearTimeout(this.timeoutId);
    };
}).call(Cursor.prototype);
exports.Cursor = Cursor;

});

define(&quot;ace/scrollbar&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/dom&quot;,&quot;ace/lib/event&quot;,&quot;ace/lib/event_emitter&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;./lib/oop&quot;);
var dom = require(&quot;./lib/dom&quot;);
var event = require(&quot;./lib/event&quot;);
var EventEmitter = require(&quot;./lib/event_emitter&quot;).EventEmitter;
var MAX_SCROLL_H = 0x8000;
var ScrollBar = function (parent) {
    this.element = dom.createElement(&quot;div&quot;);
    this.element.className = &quot;ace_scrollbar ace_scrollbar&quot; + this.classSuffix;
    this.inner = dom.createElement(&quot;div&quot;);
    this.inner.className = &quot;ace_scrollbar-inner&quot;;
    this.inner.textContent = &quot;\xa0&quot;;
    this.element.appendChild(this.inner);
    parent.appendChild(this.element);
    this.setVisible(false);
    this.skipEvent = false;
    event.addListener(this.element, &quot;scroll&quot;, this.onScroll.bind(this));
    event.addListener(this.element, &quot;mousedown&quot;, event.preventDefault);
};
(function () {
    oop.implement(this, EventEmitter);
    this.setVisible = function (isVisible) {
        this.element.style.display = isVisible ? &quot;&quot; : &quot;none&quot;;
        this.isVisible = isVisible;
        this.coeff = 1;
    };
}).call(ScrollBar.prototype);
var VScrollBar = function (parent, renderer) {
    ScrollBar.call(this, parent);
    this.scrollTop = 0;
    this.scrollHeight = 0;
    renderer.$scrollbarWidth =
        this.width = dom.scrollbarWidth(parent.ownerDocument);
    this.inner.style.width =
        this.element.style.width = (this.width || 15) + 5 + &quot;px&quot;;
    this.$minWidth = 0;
};
oop.inherits(VScrollBar, ScrollBar);
(function () {
    this.classSuffix = &#039;-v&#039;;
    this.onScroll = function () {
        if (!this.skipEvent) {
            this.scrollTop = this.element.scrollTop;
            if (this.coeff != 1) {
                var h = this.element.clientHeight / this.scrollHeight;
                this.scrollTop = this.scrollTop * (1 - h) / (this.coeff - h);
            }
            this._emit(&quot;scroll&quot;, { data: this.scrollTop });
        }
        this.skipEvent = false;
    };
    this.getWidth = function () {
        return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
    };
    this.setHeight = function (height) {
        this.element.style.height = height + &quot;px&quot;;
    };
    this.setInnerHeight =
        this.setScrollHeight = function (height) {
            this.scrollHeight = height;
            if (height &gt; MAX_SCROLL_H) {
                this.coeff = MAX_SCROLL_H / height;
                height = MAX_SCROLL_H;
            }
            else if (this.coeff != 1) {
                this.coeff = 1;
            }
            this.inner.style.height = height + &quot;px&quot;;
        };
    this.setScrollTop = function (scrollTop) {
        if (this.scrollTop != scrollTop) {
            this.skipEvent = true;
            this.scrollTop = scrollTop;
            this.element.scrollTop = scrollTop * this.coeff;
        }
    };
}).call(VScrollBar.prototype);
var HScrollBar = function (parent, renderer) {
    ScrollBar.call(this, parent);
    this.scrollLeft = 0;
    this.height = renderer.$scrollbarWidth;
    this.inner.style.height =
        this.element.style.height = (this.height || 15) + 5 + &quot;px&quot;;
};
oop.inherits(HScrollBar, ScrollBar);
(function () {
    this.classSuffix = &#039;-h&#039;;
    this.onScroll = function () {
        if (!this.skipEvent) {
            this.scrollLeft = this.element.scrollLeft;
            this._emit(&quot;scroll&quot;, { data: this.scrollLeft });
        }
        this.skipEvent = false;
    };
    this.getHeight = function () {
        return this.isVisible ? this.height : 0;
    };
    this.setWidth = function (width) {
        this.element.style.width = width + &quot;px&quot;;
    };
    this.setInnerWidth = function (width) {
        this.inner.style.width = width + &quot;px&quot;;
    };
    this.setScrollWidth = function (width) {
        this.inner.style.width = width + &quot;px&quot;;
    };
    this.setScrollLeft = function (scrollLeft) {
        if (this.scrollLeft != scrollLeft) {
            this.skipEvent = true;
            this.scrollLeft = this.element.scrollLeft = scrollLeft;
        }
    };
}).call(HScrollBar.prototype);
exports.ScrollBar = VScrollBar; // backward compatibility
exports.ScrollBarV = VScrollBar; // backward compatibility
exports.ScrollBarH = HScrollBar; // backward compatibility
exports.VScrollBar = VScrollBar;
exports.HScrollBar = HScrollBar;

});

define(&quot;ace/scrollbar_custom&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/dom&quot;,&quot;ace/lib/event&quot;,&quot;ace/lib/event_emitter&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;./lib/oop&quot;);
var dom = require(&quot;./lib/dom&quot;);
var event = require(&quot;./lib/event&quot;);
var EventEmitter = require(&quot;./lib/event_emitter&quot;).EventEmitter;
dom.importCssString(&quot;.ace_editor&gt;.ace_sb-v div, .ace_editor&gt;.ace_sb-h div{\n  position: absolute;\n  background: rgba(128, 128, 128, 0.6);\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  border: 1px solid #bbb;\n  border-radius: 2px;\n  z-index: 8;\n}\n.ace_editor&gt;.ace_sb-v, .ace_editor&gt;.ace_sb-h {\n  position: absolute;\n  z-index: 6;\n  background: none;\n  overflow: hidden!important;\n}\n.ace_editor&gt;.ace_sb-v {\n  z-index: 6;\n  right: 0;\n  top: 0;\n  width: 12px;\n}\n.ace_editor&gt;.ace_sb-v div {\n  z-index: 8;\n  right: 0;\n  width: 100%;\n}\n.ace_editor&gt;.ace_sb-h {\n  bottom: 0;\n  left: 0;\n  height: 12px;\n}\n.ace_editor&gt;.ace_sb-h div {\n  bottom: 0;\n  height: 100%;\n}\n.ace_editor&gt;.ace_sb_grabbed {\n  z-index: 8;\n  background: #000;\n}&quot;, &quot;ace_scrollbar.css&quot;, false);
var ScrollBar = function (parent) {
    this.element = dom.createElement(&quot;div&quot;);
    this.element.className = &quot;ace_sb&quot; + this.classSuffix;
    this.inner = dom.createElement(&quot;div&quot;);
    this.inner.className = &quot;&quot;;
    this.element.appendChild(this.inner);
    this.VScrollWidth = 12;
    this.HScrollHeight = 12;
    parent.appendChild(this.element);
    this.setVisible(false);
    this.skipEvent = false;
    event.addMultiMouseDownListener(this.element, [500, 300, 300], this, &quot;onMouseDown&quot;);
};
(function () {
    oop.implement(this, EventEmitter);
    this.setVisible = function (isVisible) {
        this.element.style.display = isVisible ? &quot;&quot; : &quot;none&quot;;
        this.isVisible = isVisible;
        this.coeff = 1;
    };
}).call(ScrollBar.prototype);
var VScrollBar = function (parent, renderer) {
    ScrollBar.call(this, parent);
    this.scrollTop = 0;
    this.scrollHeight = 0;
    this.parent = parent;
    this.width = this.VScrollWidth;
    this.renderer = renderer;
    this.inner.style.width = this.element.style.width = (this.width || 15) + &quot;px&quot;;
    this.$minWidth = 0;
};
oop.inherits(VScrollBar, ScrollBar);
(function () {
    this.classSuffix = &#039;-v&#039;;
    oop.implement(this, EventEmitter);
    this.onMouseDown = function (eType, e) {
        if (eType !== &quot;mousedown&quot;)
            return;
        if (event.getButton(e) !== 0 || e.detail === 2) {
            return;
        }
        if (e.target === this.inner) {
            var self = this;
            var mousePageY = e.clientY;
            var onMouseMove = function (e) {
                mousePageY = e.clientY;
            };
            var onMouseUp = function () {
                clearInterval(timerId);
            };
            var startY = e.clientY;
            var startTop = this.thumbTop;
            var onScrollInterval = function () {
                if (mousePageY === undefined)
                    return;
                var scrollTop = self.scrollTopFromThumbTop(startTop + mousePageY - startY);
                if (scrollTop === self.scrollTop)
                    return;
                self._emit(&quot;scroll&quot;, { data: scrollTop });
            };
            event.capture(this.inner, onMouseMove, onMouseUp);
            var timerId = setInterval(onScrollInterval, 20);
            return event.preventDefault(e);
        }
        var top = e.clientY - this.element.getBoundingClientRect().top - this.thumbHeight / 2;
        this._emit(&quot;scroll&quot;, { data: this.scrollTopFromThumbTop(top) });
        return event.preventDefault(e);
    };
    this.getHeight = function () {
        return this.height;
    };
    this.scrollTopFromThumbTop = function (thumbTop) {
        var scrollTop = thumbTop * (this.pageHeight - this.viewHeight) / (this.slideHeight - this.thumbHeight);
        scrollTop = scrollTop &gt;&gt; 0;
        if (scrollTop &lt; 0) {
            scrollTop = 0;
        }
        else if (scrollTop &gt; this.pageHeight - this.viewHeight) {
            scrollTop = this.pageHeight - this.viewHeight;
        }
        return scrollTop;
    };
    this.getWidth = function () {
        return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
    };
    this.setHeight = function (height) {
        this.height = Math.max(0, height);
        this.slideHeight = this.height;
        this.viewHeight = this.height;
        this.setScrollHeight(this.pageHeight, true);
    };
    this.setInnerHeight = this.setScrollHeight = function (height, force) {
        if (this.pageHeight === height &amp;&amp; !force)
            return;
        this.pageHeight = height;
        this.thumbHeight = this.slideHeight * this.viewHeight / this.pageHeight;
        if (this.thumbHeight &gt; this.slideHeight)
            this.thumbHeight = this.slideHeight;
        if (this.thumbHeight &lt; 15)
            this.thumbHeight = 15;
        this.inner.style.height = this.thumbHeight + &quot;px&quot;;
        if (this.scrollTop &gt; (this.pageHeight - this.viewHeight)) {
            this.scrollTop = (this.pageHeight - this.viewHeight);
            if (this.scrollTop &lt; 0)
                this.scrollTop = 0;
            this._emit(&quot;scroll&quot;, { data: this.scrollTop });
        }
    };
    this.setScrollTop = function (scrollTop) {
        this.scrollTop = scrollTop;
        if (scrollTop &lt; 0)
            scrollTop = 0;
        this.thumbTop = scrollTop * (this.slideHeight - this.thumbHeight) / (this.pageHeight - this.viewHeight);
        this.inner.style.top = this.thumbTop + &quot;px&quot;;
    };
}).call(VScrollBar.prototype);
var HScrollBar = function (parent, renderer) {
    ScrollBar.call(this, parent);
    this.scrollLeft = 0;
    this.scrollWidth = 0;
    this.height = this.HScrollHeight;
    this.inner.style.height = this.element.style.height = (this.height || 12) + &quot;px&quot;;
    this.renderer = renderer;
};
oop.inherits(HScrollBar, ScrollBar);
(function () {
    this.classSuffix = &#039;-h&#039;;
    oop.implement(this, EventEmitter);
    this.onMouseDown = function (eType, e) {
        if (eType !== &quot;mousedown&quot;)
            return;
        if (event.getButton(e) !== 0 || e.detail === 2) {
            return;
        }
        if (e.target === this.inner) {
            var self = this;
            var mousePageX = e.clientX;
            var onMouseMove = function (e) {
                mousePageX = e.clientX;
            };
            var onMouseUp = function () {
                clearInterval(timerId);
            };
            var startX = e.clientX;
            var startLeft = this.thumbLeft;
            var onScrollInterval = function () {
                if (mousePageX === undefined)
                    return;
                var scrollLeft = self.scrollLeftFromThumbLeft(startLeft + mousePageX - startX);
                if (scrollLeft === self.scrollLeft)
                    return;
                self._emit(&quot;scroll&quot;, { data: scrollLeft });
            };
            event.capture(this.inner, onMouseMove, onMouseUp);
            var timerId = setInterval(onScrollInterval, 20);
            return event.preventDefault(e);
        }
        var left = e.clientX - this.element.getBoundingClientRect().left - this.thumbWidth / 2;
        this._emit(&quot;scroll&quot;, { data: this.scrollLeftFromThumbLeft(left) });
        return event.preventDefault(e);
    };
    this.getHeight = function () {
        return this.isVisible ? this.height : 0;
    };
    this.scrollLeftFromThumbLeft = function (thumbLeft) {
        var scrollLeft = thumbLeft * (this.pageWidth - this.viewWidth) / (this.slideWidth - this.thumbWidth);
        scrollLeft = scrollLeft &gt;&gt; 0;
        if (scrollLeft &lt; 0) {
            scrollLeft = 0;
        }
        else if (scrollLeft &gt; this.pageWidth - this.viewWidth) {
            scrollLeft = this.pageWidth - this.viewWidth;
        }
        return scrollLeft;
    };
    this.setWidth = function (width) {
        this.width = Math.max(0, width);
        this.element.style.width = this.width + &quot;px&quot;;
        this.slideWidth = this.width;
        this.viewWidth = this.width;
        this.setScrollWidth(this.pageWidth, true);
    };
    this.setInnerWidth = this.setScrollWidth = function (width, force) {
        if (this.pageWidth === width &amp;&amp; !force)
            return;
        this.pageWidth = width;
        this.thumbWidth = this.slideWidth * this.viewWidth / this.pageWidth;
        if (this.thumbWidth &gt; this.slideWidth)
            this.thumbWidth = this.slideWidth;
        if (this.thumbWidth &lt; 15)
            this.thumbWidth = 15;
        this.inner.style.width = this.thumbWidth + &quot;px&quot;;
        if (this.scrollLeft &gt; (this.pageWidth - this.viewWidth)) {
            this.scrollLeft = (this.pageWidth - this.viewWidth);
            if (this.scrollLeft &lt; 0)
                this.scrollLeft = 0;
            this._emit(&quot;scroll&quot;, { data: this.scrollLeft });
        }
    };
    this.setScrollLeft = function (scrollLeft) {
        this.scrollLeft = scrollLeft;
        if (scrollLeft &lt; 0)
            scrollLeft = 0;
        this.thumbLeft = scrollLeft * (this.slideWidth - this.thumbWidth) / (this.pageWidth - this.viewWidth);
        this.inner.style.left = (this.thumbLeft) + &quot;px&quot;;
    };
}).call(HScrollBar.prototype);
exports.ScrollBar = VScrollBar; // backward compatibility
exports.ScrollBarV = VScrollBar; // backward compatibility
exports.ScrollBarH = HScrollBar; // backward compatibility
exports.VScrollBar = VScrollBar;
exports.HScrollBar = HScrollBar;

});

define(&quot;ace/renderloop&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/event&quot;], function(require, exports, module){&quot;use strict&quot;;
var event = require(&quot;./lib/event&quot;);
var RenderLoop = function (onRender, win) {
    this.onRender = onRender;
    this.pending = false;
    this.changes = 0;
    this.$recursionLimit = 2;
    this.window = win || window;
    var _self = this;
    this._flush = function (ts) {
        _self.pending = false;
        var changes = _self.changes;
        if (changes) {
            event.blockIdle(100);
            _self.changes = 0;
            _self.onRender(changes);
        }
        if (_self.changes) {
            if (_self.$recursionLimit-- &lt; 0)
                return;
            _self.schedule();
        }
        else {
            _self.$recursionLimit = 2;
        }
    };
};
(function () {
    this.schedule = function (change) {
        this.changes = this.changes | change;
        if (this.changes &amp;&amp; !this.pending) {
            event.nextFrame(this._flush);
            this.pending = true;
        }
    };
    this.clear = function (change) {
        var changes = this.changes;
        this.changes = 0;
        return changes;
    };
}).call(RenderLoop.prototype);
exports.RenderLoop = RenderLoop;

});

define(&quot;ace/layer/font_metrics&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/dom&quot;,&quot;ace/lib/lang&quot;,&quot;ace/lib/event&quot;,&quot;ace/lib/useragent&quot;,&quot;ace/lib/event_emitter&quot;], function(require, exports, module){var oop = require(&quot;../lib/oop&quot;);
var dom = require(&quot;../lib/dom&quot;);
var lang = require(&quot;../lib/lang&quot;);
var event = require(&quot;../lib/event&quot;);
var useragent = require(&quot;../lib/useragent&quot;);
var EventEmitter = require(&quot;../lib/event_emitter&quot;).EventEmitter;
var DEFAULT_CHAR_COUNT = 250;
var USE_OBSERVER = typeof ResizeObserver == &quot;function&quot;;
var L = 200;
var FontMetrics = exports.FontMetrics = function (parentEl, charCount) {
    this.charCount = charCount || DEFAULT_CHAR_COUNT;
    this.el = dom.createElement(&quot;div&quot;);
    this.$setMeasureNodeStyles(this.el.style, true);
    this.$main = dom.createElement(&quot;div&quot;);
    this.$setMeasureNodeStyles(this.$main.style);
    this.$measureNode = dom.createElement(&quot;div&quot;);
    this.$setMeasureNodeStyles(this.$measureNode.style);
    this.el.appendChild(this.$main);
    this.el.appendChild(this.$measureNode);
    parentEl.appendChild(this.el);
    this.$measureNode.textContent = lang.stringRepeat(&quot;X&quot;, this.charCount);
    this.$characterSize = { width: 0, height: 0 };
    if (USE_OBSERVER)
        this.$addObserver();
    else
        this.checkForSizeChanges();
};
(function () {
    oop.implement(this, EventEmitter);
    this.$characterSize = { width: 0, height: 0 };
    this.$setMeasureNodeStyles = function (style, isRoot) {
        style.width = style.height = &quot;auto&quot;;
        style.left = style.top = &quot;0px&quot;;
        style.visibility = &quot;hidden&quot;;
        style.position = &quot;absolute&quot;;
        style.whiteSpace = &quot;pre&quot;;
        if (useragent.isIE &lt; 8) {
            style[&quot;font-family&quot;] = &quot;inherit&quot;;
        }
        else {
            style.font = &quot;inherit&quot;;
        }
        style.overflow = isRoot ? &quot;hidden&quot; : &quot;visible&quot;;
    };
    this.checkForSizeChanges = function (size) {
        if (size === undefined)
            size = this.$measureSizes();
        if (size &amp;&amp; (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
            this.$measureNode.style.fontWeight = &quot;bold&quot;;
            var boldSize = this.$measureSizes();
            this.$measureNode.style.fontWeight = &quot;&quot;;
            this.$characterSize = size;
            this.charSizes = Object.create(null);
            this.allowBoldFonts = boldSize &amp;&amp; boldSize.width === size.width &amp;&amp; boldSize.height === size.height;
            this._emit(&quot;changeCharacterSize&quot;, { data: size });
        }
    };
    this.$addObserver = function () {
        var self = this;
        this.$observer = new window.ResizeObserver(function (e) {
            self.checkForSizeChanges();
        });
        this.$observer.observe(this.$measureNode);
    };
    this.$pollSizeChanges = function () {
        if (this.$pollSizeChangesTimer || this.$observer)
            return this.$pollSizeChangesTimer;
        var self = this;
        return this.$pollSizeChangesTimer = event.onIdle(function cb() {
            self.checkForSizeChanges();
            event.onIdle(cb, 500);
        }, 500);
    };
    this.setPolling = function (val) {
        if (val) {
            this.$pollSizeChanges();
        }
        else if (this.$pollSizeChangesTimer) {
            clearInterval(this.$pollSizeChangesTimer);
            this.$pollSizeChangesTimer = 0;
        }
    };
    this.$measureSizes = function (node) {
        node = node || this.$measureNode;
        var rect = node.getBoundingClientRect();
        var charSize = {
            height: rect.height,
            width: rect.width / this.charCount
        };
        if (charSize.width === 0 || charSize.height === 0)
            return null;
        return charSize;
    };
    this.$measureCharWidth = function (ch) {
        this.$main.textContent = lang.stringRepeat(ch, this.charCount);
        var rect = this.$main.getBoundingClientRect();
        return rect.width / this.charCount;
    };
    this.getCharacterWidth = function (ch) {
        var w = this.charSizes[ch];
        if (w === undefined) {
            w = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
        }
        return w;
    };
    this.destroy = function () {
        clearInterval(this.$pollSizeChangesTimer);
        if (this.$observer)
            this.$observer.disconnect();
        if (this.el &amp;&amp; this.el.parentNode)
            this.el.parentNode.removeChild(this.el);
    };
    this.$getZoom = function getZoom(element) {
        if (!element || !element.parentElement)
            return 1;
        return (window.getComputedStyle(element).zoom || 1) * getZoom(element.parentElement);
    };
    this.$initTransformMeasureNodes = function () {
        var t = function (t, l) {
            return [&quot;div&quot;, {
                    style: &quot;position: absolute;top:&quot; + t + &quot;px;left:&quot; + l + &quot;px;&quot;
                }];
        };
        this.els = dom.buildDom([t(0, 0), t(L, 0), t(0, L), t(L, L)], this.el);
    };
    this.transformCoordinates = function (clientPos, elPos) {
        if (clientPos) {
            var zoom = this.$getZoom(this.el);
            clientPos = mul(1 / zoom, clientPos);
        }
        function solve(l1, l2, r) {
            var det = l1[1] * l2[0] - l1[0] * l2[1];
            return [
                (-l2[1] * r[0] + l2[0] * r[1]) / det,
                (+l1[1] * r[0] - l1[0] * r[1]) / det
            ];
        }
        function sub(a, b) { return [a[0] - b[0], a[1] - b[1]]; }
        function add(a, b) { return [a[0] + b[0], a[1] + b[1]]; }
        function mul(a, b) { return [a * b[0], a * b[1]]; }
        if (!this.els)
            this.$initTransformMeasureNodes();
        function p(el) {
            var r = el.getBoundingClientRect();
            return [r.left, r.top];
        }
        var a = p(this.els[0]);
        var b = p(this.els[1]);
        var c = p(this.els[2]);
        var d = p(this.els[3]);
        var h = solve(sub(d, b), sub(d, c), sub(add(b, c), add(d, a)));
        var m1 = mul(1 + h[0], sub(b, a));
        var m2 = mul(1 + h[1], sub(c, a));
        if (elPos) {
            var x = elPos;
            var k = h[0] * x[0] / L + h[1] * x[1] / L + 1;
            var ut = add(mul(x[0], m1), mul(x[1], m2));
            return add(mul(1 / k / L, ut), a);
        }
        var u = sub(clientPos, a);
        var f = solve(sub(m1, mul(h[0], u)), sub(m2, mul(h[1], u)), u);
        return mul(L, f);
    };
}).call(FontMetrics.prototype);

});

define(&quot;ace/css/editor.css&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;], function(require, exports, module){module.exports = &quot;/*\nstyles = []\nfor (var i = 1; i &lt; 16; i++) {\n    styles.push(\&quot;.ace_br\&quot; + i + \&quot;{\&quot; + (\n        [\&quot;top-left\&quot;, \&quot;top-right\&quot;, \&quot;bottom-right\&quot;, \&quot;bottom-left\&quot;]\n    ).map(function(x, j) {\n        return i &amp; (1&lt;&lt;j) ? \&quot;border-\&quot; + x + \&quot;-radius: 3px;\&quot; : \&quot;\&quot; \n    }).filter(Boolean).join(\&quot; \&quot;) + \&quot;}\&quot;)\n}\nstyles.join(\&quot;\\n\&quot;)\n*/\n.ace_br1 {border-top-left-radius    : 3px;}\n.ace_br2 {border-top-right-radius   : 3px;}\n.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}\n.ace_br4 {border-bottom-right-radius: 3px;}\n.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}\n.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}\n.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}\n.ace_br8 {border-bottom-left-radius : 3px;}\n.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}\n.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}\n.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}\n.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\n.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\n.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\n.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}\n\n\n.ace_editor {\n    position: relative;\n    overflow: hidden;\n    padding: 0;\n    font: 12px/normal &#039;Monaco&#039;, &#039;Menlo&#039;, &#039;Ubuntu Mono&#039;, &#039;Consolas&#039;, &#039;source-code-pro&#039;, monospace;\n    direction: ltr;\n    text-align: left;\n    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n}\n\n.ace_scroller {\n    position: absolute;\n    overflow: hidden;\n    top: 0;\n    bottom: 0;\n    background-color: inherit;\n    -ms-user-select: none;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    user-select: none;\n    cursor: text;\n}\n\n.ace_content {\n    position: absolute;\n    box-sizing: border-box;\n    min-width: 100%;\n    contain: style size layout;\n    font-variant-ligatures: no-common-ligatures;\n}\n\n.ace_dragging .ace_scroller:before{\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    content: &#039;&#039;;\n    background: rgba(250, 250, 250, 0.01);\n    z-index: 1000;\n}\n.ace_dragging.ace_dark .ace_scroller:before{\n    background: rgba(0, 0, 0, 0.01);\n}\n\n.ace_gutter {\n    position: absolute;\n    overflow : hidden;\n    width: auto;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    cursor: default;\n    z-index: 4;\n    -ms-user-select: none;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    user-select: none;\n    contain: style size layout;\n}\n\n.ace_gutter-active-line {\n    position: absolute;\n    left: 0;\n    right: 0;\n}\n\n.ace_scroller.ace_scroll-left {\n    box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\n}\n\n.ace_gutter-cell {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    padding-left: 19px;\n    padding-right: 6px;\n    background-repeat: no-repeat;\n}\n\n.ace_gutter-cell.ace_error {\n    background-image: url(\&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==\&quot;);\n    background-repeat: no-repeat;\n    background-position: 2px center;\n}\n\n.ace_gutter-cell.ace_warning {\n    background-image: url(\&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==\&quot;);\n    background-position: 2px center;\n}\n\n.ace_gutter-cell.ace_info {\n    background-image: url(\&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=\&quot;);\n    background-position: 2px center;\n}\n.ace_dark .ace_gutter-cell.ace_info {\n    background-image: url(\&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC\&quot;);\n}\n\n.ace_scrollbar {\n    contain: strict;\n    position: absolute;\n    right: 0;\n    bottom: 0;\n    z-index: 6;\n}\n\n.ace_scrollbar-inner {\n    position: absolute;\n    cursor: text;\n    left: 0;\n    top: 0;\n}\n\n.ace_scrollbar-v{\n    overflow-x: hidden;\n    overflow-y: scroll;\n    top: 0;\n}\n\n.ace_scrollbar-h {\n    overflow-x: scroll;\n    overflow-y: hidden;\n    left: 0;\n}\n\n.ace_print-margin {\n    position: absolute;\n    height: 100%;\n}\n\n.ace_text-input {\n    position: absolute;\n    z-index: 0;\n    width: 0.5em;\n    height: 1em;\n    opacity: 0;\n    background: transparent;\n    -moz-appearance: none;\n    appearance: none;\n    border: none;\n    resize: none;\n    outline: none;\n    overflow: hidden;\n    font: inherit;\n    padding: 0 1px;\n    margin: 0 -1px;\n    contain: strict;\n    -ms-user-select: text;\n    -moz-user-select: text;\n    -webkit-user-select: text;\n    user-select: text;\n    /*with `pre-line` chrome inserts &amp;nbsp; instead of space*/\n    white-space: pre!important;\n}\n.ace_text-input.ace_composition {\n    background: transparent;\n    color: inherit;\n    z-index: 1000;\n    opacity: 1;\n}\n.ace_composition_placeholder { color: transparent }\n.ace_composition_marker { \n    border-bottom: 1px solid;\n    position: absolute;\n    border-radius: 0;\n    margin-top: 1px;\n}\n\n[ace_nocontext=true] {\n    transform: none!important;\n    filter: none!important;\n    clip-path: none!important;\n    mask : none!important;\n    contain: none!important;\n    perspective: none!important;\n    mix-blend-mode: initial!important;\n    z-index: auto;\n}\n\n.ace_layer {\n    z-index: 1;\n    position: absolute;\n    overflow: hidden;\n    /* workaround for chrome bug https://github.com/ajaxorg/ace/issues/2312*/\n    word-wrap: normal;\n    white-space: pre;\n    height: 100%;\n    width: 100%;\n    box-sizing: border-box;\n    /* setting pointer-events: auto; on node under the mouse, which changes\n        during scroll, will break mouse wheel scrolling in Safari */\n    pointer-events: none;\n}\n\n.ace_gutter-layer {\n    position: relative;\n    width: auto;\n    text-align: right;\n    pointer-events: auto;\n    height: 1000000px;\n    contain: style size layout;\n}\n\n.ace_text-layer {\n    font: inherit !important;\n    position: absolute;\n    height: 1000000px;\n    width: 1000000px;\n    contain: style size layout;\n}\n\n.ace_text-layer &gt; .ace_line, .ace_text-layer &gt; .ace_line_group {\n    contain: style size layout;\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n}\n\n.ace_hidpi .ace_text-layer,\n.ace_hidpi .ace_gutter-layer,\n.ace_hidpi .ace_content,\n.ace_hidpi .ace_gutter {\n    contain: strict;\n    will-change: transform;\n}\n.ace_hidpi .ace_text-layer &gt; .ace_line, \n.ace_hidpi .ace_text-layer &gt; .ace_line_group {\n    contain: strict;\n}\n\n.ace_cjk {\n    display: inline-block;\n    text-align: center;\n}\n\n.ace_cursor-layer {\n    z-index: 4;\n}\n\n.ace_cursor {\n    z-index: 4;\n    position: absolute;\n    box-sizing: border-box;\n    border-left: 2px solid;\n    /* workaround for smooth cursor repaintng whole screen in chrome */\n    transform: translatez(0);\n}\n\n.ace_multiselect .ace_cursor {\n    border-left-width: 1px;\n}\n\n.ace_slim-cursors .ace_cursor {\n    border-left-width: 1px;\n}\n\n.ace_overwrite-cursors .ace_cursor {\n    border-left-width: 0;\n    border-bottom: 1px solid;\n}\n\n.ace_hidden-cursors .ace_cursor {\n    opacity: 0.2;\n}\n\n.ace_hasPlaceholder .ace_hidden-cursors .ace_cursor {\n    opacity: 0;\n}\n\n.ace_smooth-blinking .ace_cursor {\n    transition: opacity 0.18s;\n}\n\n.ace_animate-blinking .ace_cursor {\n    animation-duration: 1000ms;\n    animation-timing-function: step-end;\n    animation-name: blink-ace-animate;\n    animation-iteration-count: infinite;\n}\n\n.ace_animate-blinking.ace_smooth-blinking .ace_cursor {\n    animation-duration: 1000ms;\n    animation-timing-function: ease-in-out;\n    animation-name: blink-ace-animate-smooth;\n}\n    \n@keyframes blink-ace-animate {\n    from, to { opacity: 1; }\n    60% { opacity: 0; }\n}\n\n@keyframes blink-ace-animate-smooth {\n    from, to { opacity: 1; }\n    45% { opacity: 1; }\n    60% { opacity: 0; }\n    85% { opacity: 0; }\n}\n\n.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\n    position: absolute;\n    z-index: 3;\n}\n\n.ace_marker-layer .ace_selection {\n    position: absolute;\n    z-index: 5;\n}\n\n.ace_marker-layer .ace_bracket {\n    position: absolute;\n    z-index: 6;\n}\n\n.ace_marker-layer .ace_error_bracket {\n    position: absolute;\n    border-bottom: 1px solid #DE5555;\n    border-radius: 0;\n}\n\n.ace_marker-layer .ace_active-line {\n    position: absolute;\n    z-index: 2;\n}\n\n.ace_marker-layer .ace_selected-word {\n    position: absolute;\n    z-index: 4;\n    box-sizing: border-box;\n}\n\n.ace_line .ace_fold {\n    box-sizing: border-box;\n\n    display: inline-block;\n    height: 11px;\n    margin-top: -2px;\n    vertical-align: middle;\n\n    background-image:\n        url(\&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\&quot;),\n        url(\&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=\&quot;);\n    background-repeat: no-repeat, repeat-x;\n    background-position: center center, top left;\n    color: transparent;\n\n    border: 1px solid black;\n    border-radius: 2px;\n\n    cursor: pointer;\n    pointer-events: auto;\n}\n\n.ace_dark .ace_fold {\n}\n\n.ace_fold:hover{\n    background-image:\n        url(\&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\&quot;),\n        url(\&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC\&quot;);\n}\n\n.ace_tooltip {\n    background-color: #FFF;\n    background-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));\n    border: 1px solid gray;\n    border-radius: 1px;\n    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\n    color: black;\n    max-width: 100%;\n    padding: 3px 4px;\n    position: fixed;\n    z-index: 999999;\n    box-sizing: border-box;\n    cursor: default;\n    white-space: pre;\n    word-wrap: break-word;\n    line-height: normal;\n    font-style: normal;\n    font-weight: normal;\n    letter-spacing: normal;\n    pointer-events: none;\n}\n\n.ace_folding-enabled &gt; .ace_gutter-cell {\n    padding-right: 13px;\n}\n\n.ace_fold-widget {\n    box-sizing: border-box;\n\n    margin: 0 -12px 0 1px;\n    display: none;\n    width: 11px;\n    vertical-align: top;\n\n    background-image: url(\&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==\&quot;);\n    background-repeat: no-repeat;\n    background-position: center;\n\n    border-radius: 3px;\n    \n    border: 1px solid transparent;\n    cursor: pointer;\n}\n\n.ace_folding-enabled .ace_fold-widget {\n    display: inline-block;   \n}\n\n.ace_fold-widget.ace_end {\n    background-image: url(\&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==\&quot;);\n}\n\n.ace_fold-widget.ace_closed {\n    background-image: url(\&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==\&quot;);\n}\n\n.ace_fold-widget:hover {\n    border: 1px solid rgba(0, 0, 0, 0.3);\n    background-color: rgba(255, 255, 255, 0.2);\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\n}\n\n.ace_fold-widget:active {\n    border: 1px solid rgba(0, 0, 0, 0.4);\n    background-color: rgba(0, 0, 0, 0.05);\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\n}\n/**\n * Dark version for fold widgets\n */\n.ace_dark .ace_fold-widget {\n    background-image: url(\&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC\&quot;);\n}\n.ace_dark .ace_fold-widget.ace_end {\n    background-image: url(\&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==\&quot;);\n}\n.ace_dark .ace_fold-widget.ace_closed {\n    background-image: url(\&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==\&quot;);\n}\n.ace_dark .ace_fold-widget:hover {\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\n    background-color: rgba(255, 255, 255, 0.1);\n}\n.ace_dark .ace_fold-widget:active {\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\n}\n\n.ace_inline_button {\n    border: 1px solid lightgray;\n    display: inline-block;\n    margin: -1px 8px;\n    padding: 0 5px;\n    pointer-events: auto;\n    cursor: pointer;\n}\n.ace_inline_button:hover {\n    border-color: gray;\n    background: rgba(200,200,200,0.2);\n    display: inline-block;\n    pointer-events: auto;\n}\n\n.ace_fold-widget.ace_invalid {\n    background-color: #FFB4B4;\n    border-color: #DE5555;\n}\n\n.ace_fade-fold-widgets .ace_fold-widget {\n    transition: opacity 0.4s ease 0.05s;\n    opacity: 0;\n}\n\n.ace_fade-fold-widgets:hover .ace_fold-widget {\n    transition: opacity 0.05s ease 0.05s;\n    opacity:1;\n}\n\n.ace_underline {\n    text-decoration: underline;\n}\n\n.ace_bold {\n    font-weight: bold;\n}\n\n.ace_nobold .ace_bold {\n    font-weight: normal;\n}\n\n.ace_italic {\n    font-style: italic;\n}\n\n\n.ace_error-marker {\n    background-color: rgba(255, 0, 0,0.2);\n    position: absolute;\n    z-index: 9;\n}\n\n.ace_highlight-marker {\n    background-color: rgba(255, 255, 0,0.2);\n    position: absolute;\n    z-index: 8;\n}\n\n.ace_mobile-menu {\n    position: absolute;\n    line-height: 1.5;\n    border-radius: 4px;\n    -ms-user-select: none;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    user-select: none;\n    background: white;\n    box-shadow: 1px 3px 2px grey;\n    border: 1px solid #dcdcdc;\n    color: black;\n}\n.ace_dark &gt; .ace_mobile-menu {\n    background: #333;\n    color: #ccc;\n    box-shadow: 1px 3px 2px grey;\n    border: 1px solid #444;\n\n}\n.ace_mobile-button {\n    padding: 2px;\n    cursor: pointer;\n    overflow: hidden;\n}\n.ace_mobile-button:hover {\n    background-color: #eee;\n    opacity:1;\n}\n.ace_mobile-button:active {\n    background-color: #ddd;\n}\n\n.ace_placeholder {\n    font-family: arial;\n    transform: scale(0.9);\n    transform-origin: left;\n    white-space: pre;\n    opacity: 0.7;\n    margin: 0 10px;\n}&quot;;

});

define(&quot;ace/layer/decorators&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/dom&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/event_emitter&quot;], function(require, exports, module){&quot;use strict&quot;;
var dom = require(&quot;../lib/dom&quot;);
var oop = require(&quot;../lib/oop&quot;);
var EventEmitter = require(&quot;../lib/event_emitter&quot;).EventEmitter;
var Decorator = function (parent, renderer) {
    this.canvas = dom.createElement(&quot;canvas&quot;);
    this.renderer = renderer;
    this.pixelRatio = 1;
    this.maxHeight = renderer.layerConfig.maxHeight;
    this.lineHeight = renderer.layerConfig.lineHeight;
    this.canvasHeight = parent.parent.scrollHeight;
    this.heightRatio = this.canvasHeight / this.maxHeight;
    this.canvasWidth = parent.width;
    this.minDecorationHeight = (2 * this.pixelRatio) | 0;
    this.halfMinDecorationHeight = (this.minDecorationHeight / 2) | 0;
    this.canvas.width = this.canvasWidth;
    this.canvas.height = this.canvasHeight;
    this.canvas.style.top = 0 + &quot;px&quot;;
    this.canvas.style.right = 0 + &quot;px&quot;;
    this.canvas.style.zIndex = 7 + &quot;px&quot;;
    this.canvas.style.position = &quot;absolute&quot;;
    this.colors = {};
    this.colors.dark = {
        &quot;error&quot;: &quot;rgba(255, 18, 18, 1)&quot;,
        &quot;warning&quot;: &quot;rgba(18, 136, 18, 1)&quot;,
        &quot;info&quot;: &quot;rgba(18, 18, 136, 1)&quot;
    };
    this.colors.light = {
        &quot;error&quot;: &quot;rgb(255,51,51)&quot;,
        &quot;warning&quot;: &quot;rgb(32,133,72)&quot;,
        &quot;info&quot;: &quot;rgb(35,68,138)&quot;
    };
    parent.element.appendChild(this.canvas);
};
(function () {
    oop.implement(this, EventEmitter);
    this.$updateDecorators = function (config) {
        var colors = (this.renderer.theme.isDark === true) ? this.colors.dark : this.colors.light;
        if (config) {
            this.maxHeight = config.maxHeight;
            this.lineHeight = config.lineHeight;
            this.canvasHeight = config.height;
            var allLineHeight = (config.lastRow + 1) * this.lineHeight;
            if (allLineHeight &lt; this.canvasHeight) {
                this.heightRatio = 1;
            }
            else {
                this.heightRatio = this.canvasHeight / this.maxHeight;
            }
        }
        var ctx = this.canvas.getContext(&quot;2d&quot;);
        function compare(a, b) {
            if (a.priority &lt; b.priority)
                return -1;
            if (a.priority &gt; b.priority)
                return 1;
            return 0;
        }
        var annotations = this.renderer.session.$annotations;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        if (annotations) {
            var priorities = {
                &quot;info&quot;: 1,
                &quot;warning&quot;: 2,
                &quot;error&quot;: 3
            };
            annotations.forEach(function (item) {
                item.priority = priorities[item.type] || null;
            });
            annotations = annotations.sort(compare);
            var foldData = this.renderer.session.$foldData;
            for (var i = 0; i &lt; annotations.length; i++) {
                var row = annotations[i].row;
                var compensateFold = this.compensateFoldRows(row, foldData);
                var currentY = Math.round((row - compensateFold) * this.lineHeight * this.heightRatio);
                var y1 = Math.round(((row - compensateFold) * this.lineHeight * this.heightRatio));
                var y2 = Math.round((((row - compensateFold) * this.lineHeight + this.lineHeight) * this.heightRatio));
                var height = y2 - y1;
                if (height &lt; this.minDecorationHeight) {
                    var yCenter = ((y1 + y2) / 2) | 0;
                    if (yCenter &lt; this.halfMinDecorationHeight) {
                        yCenter = this.halfMinDecorationHeight;
                    }
                    else if (yCenter + this.halfMinDecorationHeight &gt; this.canvasHeight) {
                        yCenter = this.canvasHeight - this.halfMinDecorationHeight;
                    }
                    y1 = Math.round(yCenter - this.halfMinDecorationHeight);
                    y2 = Math.round(yCenter + this.halfMinDecorationHeight);
                }
                ctx.fillStyle = colors[annotations[i].type] || null;
                ctx.fillRect(0, currentY, this.canvasWidth, y2 - y1);
            }
        }
        var cursor = this.renderer.session.selection.getCursor();
        if (cursor) {
            var compensateFold = this.compensateFoldRows(cursor.row, foldData);
            var currentY = Math.round((cursor.row - compensateFold) * this.lineHeight * this.heightRatio);
            ctx.fillStyle = &quot;rgba(0, 0, 0, 0.5)&quot;;
            ctx.fillRect(0, currentY, this.canvasWidth, 2);
        }
    };
    this.compensateFoldRows = function (row, foldData) {
        var compensateFold = 0;
        if (foldData &amp;&amp; foldData.length &gt; 0) {
            for (var j = 0; j &lt; foldData.length; j++) {
                if (row &gt; foldData[j].start.row &amp;&amp; row &lt; foldData[j].end.row) {
                    compensateFold += row - foldData[j].start.row;
                }
                else if (row &gt;= foldData[j].end.row) {
                    compensateFold += foldData[j].end.row - foldData[j].start.row;
                }
            }
        }
        return compensateFold;
    };
}.call(Decorator.prototype));
exports.Decorator = Decorator;

});

define(&quot;ace/virtual_renderer&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/dom&quot;,&quot;ace/config&quot;,&quot;ace/layer/gutter&quot;,&quot;ace/layer/marker&quot;,&quot;ace/layer/text&quot;,&quot;ace/layer/cursor&quot;,&quot;ace/scrollbar&quot;,&quot;ace/scrollbar&quot;,&quot;ace/scrollbar_custom&quot;,&quot;ace/scrollbar_custom&quot;,&quot;ace/renderloop&quot;,&quot;ace/layer/font_metrics&quot;,&quot;ace/lib/event_emitter&quot;,&quot;ace/css/editor.css&quot;,&quot;ace/layer/decorators&quot;,&quot;ace/lib/useragent&quot;], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;./lib/oop&quot;);
var dom = require(&quot;./lib/dom&quot;);
var config = require(&quot;./config&quot;);
var GutterLayer = require(&quot;./layer/gutter&quot;).Gutter;
var MarkerLayer = require(&quot;./layer/marker&quot;).Marker;
var TextLayer = require(&quot;./layer/text&quot;).Text;
var CursorLayer = require(&quot;./layer/cursor&quot;).Cursor;
var HScrollBar = require(&quot;./scrollbar&quot;).HScrollBar;
var VScrollBar = require(&quot;./scrollbar&quot;).VScrollBar;
var HScrollBarCustom = require(&quot;./scrollbar_custom&quot;).HScrollBar;
var VScrollBarCustom = require(&quot;./scrollbar_custom&quot;).VScrollBar;
var RenderLoop = require(&quot;./renderloop&quot;).RenderLoop;
var FontMetrics = require(&quot;./layer/font_metrics&quot;).FontMetrics;
var EventEmitter = require(&quot;./lib/event_emitter&quot;).EventEmitter;
var editorCss = require(&quot;./css/editor.css&quot;);
var Decorator = require(&quot;./layer/decorators&quot;).Decorator;
var useragent = require(&quot;./lib/useragent&quot;);
var HIDE_TEXTAREA = useragent.isIE;
dom.importCssString(editorCss, &quot;ace_editor.css&quot;, false);
var VirtualRenderer = function (container, theme) {
    var _self = this;
    this.container = container || dom.createElement(&quot;div&quot;);
    dom.addCssClass(this.container, &quot;ace_editor&quot;);
    if (dom.HI_DPI)
        dom.addCssClass(this.container, &quot;ace_hidpi&quot;);
    this.setTheme(theme);
    if (config.get(&quot;useStrictCSP&quot;) == null)
        config.set(&quot;useStrictCSP&quot;, false);
    this.$gutter = dom.createElement(&quot;div&quot;);
    this.$gutter.className = &quot;ace_gutter&quot;;
    this.container.appendChild(this.$gutter);
    this.$gutter.setAttribute(&quot;aria-hidden&quot;, true);
    this.scroller = dom.createElement(&quot;div&quot;);
    this.scroller.className = &quot;ace_scroller&quot;;
    this.container.appendChild(this.scroller);
    this.content = dom.createElement(&quot;div&quot;);
    this.content.className = &quot;ace_content&quot;;
    this.scroller.appendChild(this.content);
    this.$gutterLayer = new GutterLayer(this.$gutter);
    this.$gutterLayer.on(&quot;changeGutterWidth&quot;, this.onGutterResize.bind(this));
    this.$markerBack = new MarkerLayer(this.content);
    var textLayer = this.$textLayer = new TextLayer(this.content);
    this.canvas = textLayer.element;
    this.$markerFront = new MarkerLayer(this.content);
    this.$cursorLayer = new CursorLayer(this.content);
    this.$horizScroll = false;
    this.$vScroll = false;
    this.scrollBar =
        this.scrollBarV = new VScrollBar(this.container, this);
    this.scrollBarH = new HScrollBar(this.container, this);
    this.scrollBarV.on(&quot;scroll&quot;, function (e) {
        if (!_self.$scrollAnimation)
            _self.session.setScrollTop(e.data - _self.scrollMargin.top);
    });
    this.scrollBarH.on(&quot;scroll&quot;, function (e) {
        if (!_self.$scrollAnimation)
            _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
    });
    this.scrollTop = 0;
    this.scrollLeft = 0;
    this.cursorPos = {
        row: 0,
        column: 0
    };
    this.$fontMetrics = new FontMetrics(this.container, this.$textLayer.MAX_CHUNK_LENGTH);
    this.$textLayer.$setFontMetrics(this.$fontMetrics);
    this.$textLayer.on(&quot;changeCharacterSize&quot;, function (e) {
        _self.updateCharacterSize();
        _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
        _self._signal(&quot;changeCharacterSize&quot;, e);
    });
    this.$size = {
        width: 0,
        height: 0,
        scrollerHeight: 0,
        scrollerWidth: 0,
        $dirty: true
    };
    this.layerConfig = {
        width: 1,
        padding: 0,
        firstRow: 0,
        firstRowScreen: 0,
        lastRow: 0,
        lineHeight: 0,
        characterWidth: 0,
        minHeight: 1,
        maxHeight: 1,
        offset: 0,
        height: 1,
        gutterOffset: 1
    };
    this.scrollMargin = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        v: 0,
        h: 0
    };
    this.margin = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        v: 0,
        h: 0
    };
    this.$keepTextAreaAtCursor = !useragent.isIOS;
    this.$loop = new RenderLoop(this.$renderChanges.bind(this), this.container.ownerDocument.defaultView);
    this.$loop.schedule(this.CHANGE_FULL);
    this.updateCharacterSize();
    this.setPadding(4);
    config.resetOptions(this);
    config._signal(&quot;renderer&quot;, this);
};
(function () {
    this.CHANGE_CURSOR = 1;
    this.CHANGE_MARKER = 2;
    this.CHANGE_GUTTER = 4;
    this.CHANGE_SCROLL = 8;
    this.CHANGE_LINES = 16;
    this.CHANGE_TEXT = 32;
    this.CHANGE_SIZE = 64;
    this.CHANGE_MARKER_BACK = 128;
    this.CHANGE_MARKER_FRONT = 256;
    this.CHANGE_FULL = 512;
    this.CHANGE_H_SCROLL = 1024;
    oop.implement(this, EventEmitter);
    this.updateCharacterSize = function () {
        if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
            this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
            this.setStyle(&quot;ace_nobold&quot;, !this.$allowBoldFonts);
        }
        this.layerConfig.characterWidth =
            this.characterWidth = this.$textLayer.getCharacterWidth();
        this.layerConfig.lineHeight =
            this.lineHeight = this.$textLayer.getLineHeight();
        this.$updatePrintMargin();
        dom.setStyle(this.scroller.style, &quot;line-height&quot;, this.lineHeight + &quot;px&quot;);
    };
    this.setSession = function (session) {
        if (this.session)
            this.session.doc.off(&quot;changeNewLineMode&quot;, this.onChangeNewLineMode);
        this.session = session;
        if (session &amp;&amp; this.scrollMargin.top &amp;&amp; session.getScrollTop() &lt;= 0)
            session.setScrollTop(-this.scrollMargin.top);
        this.$cursorLayer.setSession(session);
        this.$markerBack.setSession(session);
        this.$markerFront.setSession(session);
        this.$gutterLayer.setSession(session);
        this.$textLayer.setSession(session);
        if (!session)
            return;
        this.$loop.schedule(this.CHANGE_FULL);
        this.session.$setFontMetrics(this.$fontMetrics);
        this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
        this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
        this.onChangeNewLineMode();
        this.session.doc.on(&quot;changeNewLineMode&quot;, this.onChangeNewLineMode);
    };
    this.updateLines = function (firstRow, lastRow, force) {
        if (lastRow === undefined)
            lastRow = Infinity;
        if (!this.$changedLines) {
            this.$changedLines = {
                firstRow: firstRow,
                lastRow: lastRow
            };
        }
        else {
            if (this.$changedLines.firstRow &gt; firstRow)
                this.$changedLines.firstRow = firstRow;
            if (this.$changedLines.lastRow &lt; lastRow)
                this.$changedLines.lastRow = lastRow;
        }
        if (this.$changedLines.lastRow &lt; this.layerConfig.firstRow) {
            if (force)
                this.$changedLines.lastRow = this.layerConfig.lastRow;
            else
                return;
        }
        if (this.$changedLines.firstRow &gt; this.layerConfig.lastRow)
            return;
        this.$loop.schedule(this.CHANGE_LINES);
    };
    this.onChangeNewLineMode = function () {
        this.$loop.schedule(this.CHANGE_TEXT);
        this.$textLayer.$updateEolChar();
        this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR);
    };
    this.onChangeTabSize = function () {
        this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
        this.$textLayer.onChangeTabSize();
    };
    this.updateText = function () {
        this.$loop.schedule(this.CHANGE_TEXT);
    };
    this.updateFull = function (force) {
        if (force)
            this.$renderChanges(this.CHANGE_FULL, true);
        else
            this.$loop.schedule(this.CHANGE_FULL);
    };
    this.updateFontSize = function () {
        this.$textLayer.checkForSizeChanges();
    };
    this.$changes = 0;
    this.$updateSizeAsync = function () {
        if (this.$loop.pending)
            this.$size.$dirty = true;
        else
            this.onResize();
    };
    this.onResize = function (force, gutterWidth, width, height) {
        if (this.resizing &gt; 2)
            return;
        else if (this.resizing &gt; 0)
            this.resizing++;
        else
            this.resizing = force ? 1 : 0;
        var el = this.container;
        if (!height)
            height = el.clientHeight || el.scrollHeight;
        if (!width)
            width = el.clientWidth || el.scrollWidth;
        var changes = this.$updateCachedSize(force, gutterWidth, width, height);
        if (!this.$size.scrollerHeight || (!width &amp;&amp; !height))
            return this.resizing = 0;
        if (force)
            this.$gutterLayer.$padding = null;
        if (force)
            this.$renderChanges(changes | this.$changes, true);
        else
            this.$loop.schedule(changes | this.$changes);
        if (this.resizing)
            this.resizing = 0;
        this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
        if (this.$customScrollbar) {
            this.$updateCustomScrollbar(true);
        }
    };
    this.$updateCachedSize = function (force, gutterWidth, width, height) {
        height -= (this.$extraHeight || 0);
        var changes = 0;
        var size = this.$size;
        var oldSize = {
            width: size.width,
            height: size.height,
            scrollerHeight: size.scrollerHeight,
            scrollerWidth: size.scrollerWidth
        };
        if (height &amp;&amp; (force || size.height != height)) {
            size.height = height;
            changes |= this.CHANGE_SIZE;
            size.scrollerHeight = size.height;
            if (this.$horizScroll)
                size.scrollerHeight -= this.scrollBarH.getHeight();
            this.scrollBarV.setHeight(size.scrollerHeight);
            this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + &quot;px&quot;;
            changes = changes | this.CHANGE_SCROLL;
        }
        if (width &amp;&amp; (force || size.width != width)) {
            changes |= this.CHANGE_SIZE;
            size.width = width;
            if (gutterWidth == null)
                gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
            this.gutterWidth = gutterWidth;
            dom.setStyle(this.scrollBarH.element.style, &quot;left&quot;, gutterWidth + &quot;px&quot;);
            dom.setStyle(this.scroller.style, &quot;left&quot;, gutterWidth + this.margin.left + &quot;px&quot;);
            size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth() - this.margin.h);
            dom.setStyle(this.$gutter.style, &quot;left&quot;, this.margin.left + &quot;px&quot;);
            var right = this.scrollBarV.getWidth() + &quot;px&quot;;
            dom.setStyle(this.scrollBarH.element.style, &quot;right&quot;, right);
            dom.setStyle(this.scroller.style, &quot;right&quot;, right);
            dom.setStyle(this.scroller.style, &quot;bottom&quot;, this.scrollBarH.getHeight());
            this.scrollBarH.setWidth(size.scrollerWidth);
            if (this.session &amp;&amp; this.session.getUseWrapMode() &amp;&amp; this.adjustWrapLimit() || force) {
                changes |= this.CHANGE_FULL;
            }
        }
        size.$dirty = !width || !height;
        if (changes)
            this._signal(&quot;resize&quot;, oldSize);
        return changes;
    };
    this.onGutterResize = function (width) {
        var gutterWidth = this.$showGutter ? width : 0;
        if (gutterWidth != this.gutterWidth)
            this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);
        if (this.session.getUseWrapMode() &amp;&amp; this.adjustWrapLimit()) {
            this.$loop.schedule(this.CHANGE_FULL);
        }
        else if (this.$size.$dirty) {
            this.$loop.schedule(this.CHANGE_FULL);
        }
        else {
            this.$computeLayerConfig();
        }
    };
    this.adjustWrapLimit = function () {
        var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
        var limit = Math.floor(availableWidth / this.characterWidth);
        return this.session.adjustWrapLimit(limit, this.$showPrintMargin &amp;&amp; this.$printMarginColumn);
    };
    this.setAnimatedScroll = function (shouldAnimate) {
        this.setOption(&quot;animatedScroll&quot;, shouldAnimate);
    };
    this.getAnimatedScroll = function () {
        return this.$animatedScroll;
    };
    this.setShowInvisibles = function (showInvisibles) {
        this.setOption(&quot;showInvisibles&quot;, showInvisibles);
        this.session.$bidiHandler.setShowInvisibles(showInvisibles);
    };
    this.getShowInvisibles = function () {
        return this.getOption(&quot;showInvisibles&quot;);
    };
    this.getDisplayIndentGuides = function () {
        return this.getOption(&quot;displayIndentGuides&quot;);
    };
    this.setDisplayIndentGuides = function (display) {
        this.setOption(&quot;displayIndentGuides&quot;, display);
    };
    this.getHighlightIndentGuides = function () {
        return this.getOption(&quot;highlightIndentGuides&quot;);
    };
    this.setHighlightIndentGuides = function (highlight) {
        this.setOption(&quot;highlightIndentGuides&quot;, highlight);
    };
    this.setShowPrintMargin = function (showPrintMargin) {
        this.setOption(&quot;showPrintMargin&quot;, showPrintMargin);
    };
    this.getShowPrintMargin = function () {
        return this.getOption(&quot;showPrintMargin&quot;);
    };
    this.setPrintMarginColumn = function (showPrintMargin) {
        this.setOption(&quot;printMarginColumn&quot;, showPrintMargin);
    };
    this.getPrintMarginColumn = function () {
        return this.getOption(&quot;printMarginColumn&quot;);
    };
    this.getShowGutter = function () {
        return this.getOption(&quot;showGutter&quot;);
    };
    this.setShowGutter = function (show) {
        return this.setOption(&quot;showGutter&quot;, show);
    };
    this.getFadeFoldWidgets = function () {
        return this.getOption(&quot;fadeFoldWidgets&quot;);
    };
    this.setFadeFoldWidgets = function (show) {
        this.setOption(&quot;fadeFoldWidgets&quot;, show);
    };
    this.setHighlightGutterLine = function (shouldHighlight) {
        this.setOption(&quot;highlightGutterLine&quot;, shouldHighlight);
    };
    this.getHighlightGutterLine = function () {
        return this.getOption(&quot;highlightGutterLine&quot;);
    };
    this.$updatePrintMargin = function () {
        if (!this.$showPrintMargin &amp;&amp; !this.$printMarginEl)
            return;
        if (!this.$printMarginEl) {
            var containerEl = dom.createElement(&quot;div&quot;);
            containerEl.className = &quot;ace_layer ace_print-margin-layer&quot;;
            this.$printMarginEl = dom.createElement(&quot;div&quot;);
            this.$printMarginEl.className = &quot;ace_print-margin&quot;;
            containerEl.appendChild(this.$printMarginEl);
            this.content.insertBefore(containerEl, this.content.firstChild);
        }
        var style = this.$printMarginEl.style;
        style.left = Math.round(this.characterWidth * this.$printMarginColumn + this.$padding) + &quot;px&quot;;
        style.visibility = this.$showPrintMargin ? &quot;visible&quot; : &quot;hidden&quot;;
        if (this.session &amp;&amp; this.session.$wrap == -1)
            this.adjustWrapLimit();
    };
    this.getContainerElement = function () {
        return this.container;
    };
    this.getMouseEventTarget = function () {
        return this.scroller;
    };
    this.getTextAreaContainer = function () {
        return this.container;
    };
    this.$moveTextAreaToCursor = function () {
        if (this.$isMousePressed)
            return;
        var style = this.textarea.style;
        var composition = this.$composition;
        if (!this.$keepTextAreaAtCursor &amp;&amp; !composition) {
            dom.translate(this.textarea, -100, 0);
            return;
        }
        var pixelPos = this.$cursorLayer.$pixelPos;
        if (!pixelPos)
            return;
        if (composition &amp;&amp; composition.markerRange)
            pixelPos = this.$cursorLayer.getPixelPosition(composition.markerRange.start, true);
        var config = this.layerConfig;
        var posTop = pixelPos.top;
        var posLeft = pixelPos.left;
        posTop -= config.offset;
        var h = composition &amp;&amp; composition.useTextareaForIME ? this.lineHeight : HIDE_TEXTAREA ? 0 : 1;
        if (posTop &lt; 0 || posTop &gt; config.height - h) {
            dom.translate(this.textarea, 0, 0);
            return;
        }
        var w = 1;
        var maxTop = this.$size.height - h;
        if (!composition) {
            posTop += this.lineHeight;
        }
        else {
            if (composition.useTextareaForIME) {
                var val = this.textarea.value;
                w = this.characterWidth * (this.session.$getStringScreenWidth(val)[0]);
            }
            else {
                posTop += this.lineHeight + 2;
            }
        }
        posLeft -= this.scrollLeft;
        if (posLeft &gt; this.$size.scrollerWidth - w)
            posLeft = this.$size.scrollerWidth - w;
        posLeft += this.gutterWidth + this.margin.left;
        dom.setStyle(style, &quot;height&quot;, h + &quot;px&quot;);
        dom.setStyle(style, &quot;width&quot;, w + &quot;px&quot;);
        dom.translate(this.textarea, Math.min(posLeft, this.$size.scrollerWidth - w), Math.min(posTop, maxTop));
    };
    this.getFirstVisibleRow = function () {
        return this.layerConfig.firstRow;
    };
    this.getFirstFullyVisibleRow = function () {
        return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
    };
    this.getLastFullyVisibleRow = function () {
        var config = this.layerConfig;
        var lastRow = config.lastRow;
        var top = this.session.documentToScreenRow(lastRow, 0) * config.lineHeight;
        if (top - this.session.getScrollTop() &gt; config.height - config.lineHeight)
            return lastRow - 1;
        return lastRow;
    };
    this.getLastVisibleRow = function () {
        return this.layerConfig.lastRow;
    };
    this.$padding = null;
    this.setPadding = function (padding) {
        this.$padding = padding;
        this.$textLayer.setPadding(padding);
        this.$cursorLayer.setPadding(padding);
        this.$markerFront.setPadding(padding);
        this.$markerBack.setPadding(padding);
        this.$loop.schedule(this.CHANGE_FULL);
        this.$updatePrintMargin();
    };
    this.setScrollMargin = function (top, bottom, left, right) {
        var sm = this.scrollMargin;
        sm.top = top | 0;
        sm.bottom = bottom | 0;
        sm.right = right | 0;
        sm.left = left | 0;
        sm.v = sm.top + sm.bottom;
        sm.h = sm.left + sm.right;
        if (sm.top &amp;&amp; this.scrollTop &lt;= 0 &amp;&amp; this.session)
            this.session.setScrollTop(-sm.top);
        this.updateFull();
    };
    this.setMargin = function (top, bottom, left, right) {
        var sm = this.margin;
        sm.top = top | 0;
        sm.bottom = bottom | 0;
        sm.right = right | 0;
        sm.left = left | 0;
        sm.v = sm.top + sm.bottom;
        sm.h = sm.left + sm.right;
        this.$updateCachedSize(true, this.gutterWidth, this.$size.width, this.$size.height);
        this.updateFull();
    };
    this.getHScrollBarAlwaysVisible = function () {
        return this.$hScrollBarAlwaysVisible;
    };
    this.setHScrollBarAlwaysVisible = function (alwaysVisible) {
        this.setOption(&quot;hScrollBarAlwaysVisible&quot;, alwaysVisible);
    };
    this.getVScrollBarAlwaysVisible = function () {
        return this.$vScrollBarAlwaysVisible;
    };
    this.setVScrollBarAlwaysVisible = function (alwaysVisible) {
        this.setOption(&quot;vScrollBarAlwaysVisible&quot;, alwaysVisible);
    };
    this.$updateScrollBarV = function () {
        var scrollHeight = this.layerConfig.maxHeight;
        var scrollerHeight = this.$size.scrollerHeight;
        if (!this.$maxLines &amp;&amp; this.$scrollPastEnd) {
            scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
            if (this.scrollTop &gt; scrollHeight - scrollerHeight) {
                scrollHeight = this.scrollTop + scrollerHeight;
                this.scrollBarV.scrollTop = null;
            }
        }
        this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
        this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
    };
    this.$updateScrollBarH = function () {
        this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
        this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
    };
    this.$frozen = false;
    this.freeze = function () {
        this.$frozen = true;
    };
    this.unfreeze = function () {
        this.$frozen = false;
    };
    this.$renderChanges = function (changes, force) {
        if (this.$changes) {
            changes |= this.$changes;
            this.$changes = 0;
        }
        if ((!this.session || !this.container.offsetWidth || this.$frozen) || (!changes &amp;&amp; !force)) {
            this.$changes |= changes;
            return;
        }
        if (this.$size.$dirty) {
            this.$changes |= changes;
            return this.onResize(true);
        }
        if (!this.lineHeight) {
            this.$textLayer.checkForSizeChanges();
        }
        this._signal(&quot;beforeRender&quot;, changes);
        if (this.session &amp;&amp; this.session.$bidiHandler)
            this.session.$bidiHandler.updateCharacterWidths(this.$fontMetrics);
        var config = this.layerConfig;
        if (changes &amp; this.CHANGE_FULL ||
            changes &amp; this.CHANGE_SIZE ||
            changes &amp; this.CHANGE_TEXT ||
            changes &amp; this.CHANGE_LINES ||
            changes &amp; this.CHANGE_SCROLL ||
            changes &amp; this.CHANGE_H_SCROLL) {
            changes |= this.$computeLayerConfig() | this.$loop.clear();
            if (config.firstRow != this.layerConfig.firstRow &amp;&amp; config.firstRowScreen == this.layerConfig.firstRowScreen) {
                var st = this.scrollTop + (config.firstRow - this.layerConfig.firstRow) * this.lineHeight;
                if (st &gt; 0) {
                    this.scrollTop = st;
                    changes = changes | this.CHANGE_SCROLL;
                    changes |= this.$computeLayerConfig() | this.$loop.clear();
                }
            }
            config = this.layerConfig;
            this.$updateScrollBarV();
            if (changes &amp; this.CHANGE_H_SCROLL)
                this.$updateScrollBarH();
            dom.translate(this.content, -this.scrollLeft, -config.offset);
            var width = config.width + 2 * this.$padding + &quot;px&quot;;
            var height = config.minHeight + &quot;px&quot;;
            dom.setStyle(this.content.style, &quot;width&quot;, width);
            dom.setStyle(this.content.style, &quot;height&quot;, height);
        }
        if (changes &amp; this.CHANGE_H_SCROLL) {
            dom.translate(this.content, -this.scrollLeft, -config.offset);
            this.scroller.className = this.scrollLeft &lt;= 0 ? &quot;ace_scroller&quot; : &quot;ace_scroller ace_scroll-left&quot;;
        }
        if (changes &amp; this.CHANGE_FULL) {
            this.$changedLines = null;
            this.$textLayer.update(config);
            if (this.$showGutter)
                this.$gutterLayer.update(config);
            if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config);
            }
            this.$markerBack.update(config);
            this.$markerFront.update(config);
            this.$cursorLayer.update(config);
            this.$moveTextAreaToCursor();
            this._signal(&quot;afterRender&quot;, changes);
            return;
        }
        if (changes &amp; this.CHANGE_SCROLL) {
            this.$changedLines = null;
            if (changes &amp; this.CHANGE_TEXT || changes &amp; this.CHANGE_LINES)
                this.$textLayer.update(config);
            else
                this.$textLayer.scrollLines(config);
            if (this.$showGutter) {
                if (changes &amp; this.CHANGE_GUTTER || changes &amp; this.CHANGE_LINES)
                    this.$gutterLayer.update(config);
                else
                    this.$gutterLayer.scrollLines(config);
            }
            if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config);
            }
            this.$markerBack.update(config);
            this.$markerFront.update(config);
            this.$cursorLayer.update(config);
            this.$moveTextAreaToCursor();
            this._signal(&quot;afterRender&quot;, changes);
            return;
        }
        if (changes &amp; this.CHANGE_TEXT) {
            this.$changedLines = null;
            this.$textLayer.update(config);
            if (this.$showGutter)
                this.$gutterLayer.update(config);
            if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config);
            }
        }
        else if (changes &amp; this.CHANGE_LINES) {
            if (this.$updateLines() || (changes &amp; this.CHANGE_GUTTER) &amp;&amp; this.$showGutter)
                this.$gutterLayer.update(config);
            if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config);
            }
        }
        else if (changes &amp; this.CHANGE_TEXT || changes &amp; this.CHANGE_GUTTER) {
            if (this.$showGutter)
                this.$gutterLayer.update(config);
            if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config);
            }
        }
        else if (changes &amp; this.CHANGE_CURSOR) {
            if (this.$highlightGutterLine)
                this.$gutterLayer.updateLineHighlight(config);
            if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config);
            }
        }
        if (changes &amp; this.CHANGE_CURSOR) {
            this.$cursorLayer.update(config);
            this.$moveTextAreaToCursor();
        }
        if (changes &amp; (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
            this.$markerFront.update(config);
        }
        if (changes &amp; (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
            this.$markerBack.update(config);
        }
        this._signal(&quot;afterRender&quot;, changes);
    };
    this.$autosize = function () {
        var height = this.session.getScreenLength() * this.lineHeight;
        var maxHeight = this.$maxLines * this.lineHeight;
        var desiredHeight = Math.min(maxHeight, Math.max((this.$minLines || 1) * this.lineHeight, height)) + this.scrollMargin.v + (this.$extraHeight || 0);
        if (this.$horizScroll)
            desiredHeight += this.scrollBarH.getHeight();
        if (this.$maxPixelHeight &amp;&amp; desiredHeight &gt; this.$maxPixelHeight)
            desiredHeight = this.$maxPixelHeight;
        var hideScrollbars = desiredHeight &lt;= 2 * this.lineHeight;
        var vScroll = !hideScrollbars &amp;&amp; height &gt; maxHeight;
        if (desiredHeight != this.desiredHeight ||
            this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
            if (vScroll != this.$vScroll) {
                this.$vScroll = vScroll;
                this.scrollBarV.setVisible(vScroll);
            }
            var w = this.container.clientWidth;
            this.container.style.height = desiredHeight + &quot;px&quot;;
            this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
            this.desiredHeight = desiredHeight;
            this._signal(&quot;autosize&quot;);
        }
    };
    this.$computeLayerConfig = function () {
        var session = this.session;
        var size = this.$size;
        var hideScrollbars = size.height &lt;= 2 * this.lineHeight;
        var screenLines = this.session.getScreenLength();
        var maxHeight = screenLines * this.lineHeight;
        var longestLine = this.$getLongestLine();
        var horizScroll = !hideScrollbars &amp;&amp; (this.$hScrollBarAlwaysVisible ||
            size.scrollerWidth - longestLine - 2 * this.$padding &lt; 0);
        var hScrollChanged = this.$horizScroll !== horizScroll;
        if (hScrollChanged) {
            this.$horizScroll = horizScroll;
            this.scrollBarH.setVisible(horizScroll);
        }
        var vScrollBefore = this.$vScroll; // autosize can change vscroll value in which case we need to update longestLine
        if (this.$maxLines &amp;&amp; this.lineHeight &gt; 1)
            this.$autosize();
        var minHeight = size.scrollerHeight + this.lineHeight;
        var scrollPastEnd = !this.$maxLines &amp;&amp; this.$scrollPastEnd
            ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd
            : 0;
        maxHeight += scrollPastEnd;
        var sm = this.scrollMargin;
        this.session.setScrollTop(Math.max(-sm.top, Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));
        this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft, longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));
        var vScroll = !hideScrollbars &amp;&amp; (this.$vScrollBarAlwaysVisible ||
            size.scrollerHeight - maxHeight + scrollPastEnd &lt; 0 || this.scrollTop &gt; sm.top);
        var vScrollChanged = vScrollBefore !== vScroll;
        if (vScrollChanged) {
            this.$vScroll = vScroll;
            this.scrollBarV.setVisible(vScroll);
        }
        var offset = this.scrollTop % this.lineHeight;
        var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
        var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
        var lastRow = firstRow + lineCount;
        var firstRowScreen, firstRowHeight;
        var lineHeight = this.lineHeight;
        firstRow = session.screenToDocumentRow(firstRow, 0);
        var foldLine = session.getFoldLine(firstRow);
        if (foldLine) {
            firstRow = foldLine.start.row;
        }
        firstRowScreen = session.documentToScreenRow(firstRow, 0);
        firstRowHeight = session.getRowLength(firstRow) * lineHeight;
        lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
        minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight +
            firstRowHeight;
        offset = this.scrollTop - firstRowScreen * lineHeight;
        var changes = 0;
        if (this.layerConfig.width != longestLine || hScrollChanged)
            changes = this.CHANGE_H_SCROLL;
        if (hScrollChanged || vScrollChanged) {
            changes |= this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
            this._signal(&quot;scrollbarVisibilityChanged&quot;);
            if (vScrollChanged)
                longestLine = this.$getLongestLine();
        }
        this.layerConfig = {
            width: longestLine,
            padding: this.$padding,
            firstRow: firstRow,
            firstRowScreen: firstRowScreen,
            lastRow: lastRow,
            lineHeight: lineHeight,
            characterWidth: this.characterWidth,
            minHeight: minHeight,
            maxHeight: maxHeight,
            offset: offset,
            gutterOffset: lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,
            height: this.$size.scrollerHeight
        };
        if (this.session.$bidiHandler)
            this.session.$bidiHandler.setContentWidth(longestLine - this.$padding);
        return changes;
    };
    this.$updateLines = function () {
        if (!this.$changedLines)
            return;
        var firstRow = this.$changedLines.firstRow;
        var lastRow = this.$changedLines.lastRow;
        this.$changedLines = null;
        var layerConfig = this.layerConfig;
        if (firstRow &gt; layerConfig.lastRow + 1) {
            return;
        }
        if (lastRow &lt; layerConfig.firstRow) {
            return;
        }
        if (lastRow === Infinity) {
            if (this.$showGutter)
                this.$gutterLayer.update(layerConfig);
            this.$textLayer.update(layerConfig);
            return;
        }
        this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
        return true;
    };
    this.$getLongestLine = function () {
        var charCount = this.session.getScreenWidth();
        if (this.showInvisibles &amp;&amp; !this.session.$useWrapMode)
            charCount += 1;
        if (this.$textLayer &amp;&amp; charCount &gt; this.$textLayer.MAX_LINE_LENGTH)
            charCount = this.$textLayer.MAX_LINE_LENGTH + 30;
        return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
    };
    this.updateFrontMarkers = function () {
        this.$markerFront.setMarkers(this.session.getMarkers(true));
        this.$loop.schedule(this.CHANGE_MARKER_FRONT);
    };
    this.updateBackMarkers = function () {
        this.$markerBack.setMarkers(this.session.getMarkers());
        this.$loop.schedule(this.CHANGE_MARKER_BACK);
    };
    this.addGutterDecoration = function (row, className) {
        this.$gutterLayer.addGutterDecoration(row, className);
    };
    this.removeGutterDecoration = function (row, className) {
        this.$gutterLayer.removeGutterDecoration(row, className);
    };
    this.updateBreakpoints = function (rows) {
        this.$loop.schedule(this.CHANGE_GUTTER);
    };
    this.setAnnotations = function (annotations) {
        this.$gutterLayer.setAnnotations(annotations);
        this.$loop.schedule(this.CHANGE_GUTTER);
    };
    this.updateCursor = function () {
        this.$loop.schedule(this.CHANGE_CURSOR);
    };
    this.hideCursor = function () {
        this.$cursorLayer.hideCursor();
    };
    this.showCursor = function () {
        this.$cursorLayer.showCursor();
    };
    this.scrollSelectionIntoView = function (anchor, lead, offset) {
        this.scrollCursorIntoView(anchor, offset);
        this.scrollCursorIntoView(lead, offset);
    };
    this.scrollCursorIntoView = function (cursor, offset, $viewMargin) {
        if (this.$size.scrollerHeight === 0)
            return;
        var pos = this.$cursorLayer.getPixelPosition(cursor);
        var newLeft = pos.left;
        var newTop = pos.top;
        var topMargin = $viewMargin &amp;&amp; $viewMargin.top || 0;
        var bottomMargin = $viewMargin &amp;&amp; $viewMargin.bottom || 0;
        if (this.$scrollAnimation) {
            this.$stopAnimation = true;
        }
        var currentTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
        if (currentTop + topMargin &gt; newTop) {
            if (offset &amp;&amp; currentTop + topMargin &gt; newTop + this.lineHeight)
                newTop -= offset * this.$size.scrollerHeight;
            if (newTop === 0)
                newTop = -this.scrollMargin.top;
            this.session.setScrollTop(newTop);
        }
        else if (currentTop + this.$size.scrollerHeight - bottomMargin &lt; newTop + this.lineHeight) {
            if (offset &amp;&amp; currentTop + this.$size.scrollerHeight - bottomMargin &lt; newTop - this.lineHeight)
                newTop += offset * this.$size.scrollerHeight;
            this.session.setScrollTop(newTop + this.lineHeight + bottomMargin - this.$size.scrollerHeight);
        }
        var currentLeft = this.scrollLeft;
        var twoCharsWidth = 2 * this.layerConfig.characterWidth;
        if (newLeft - twoCharsWidth &lt; currentLeft) {
            newLeft -= twoCharsWidth;
            if (newLeft &lt; this.$padding + twoCharsWidth) {
                newLeft = -this.scrollMargin.left;
            }
            this.session.setScrollLeft(newLeft);
        }
        else {
            newLeft += twoCharsWidth;
            if (currentLeft + this.$size.scrollerWidth &lt; newLeft + this.characterWidth) {
                this.session.setScrollLeft(Math.round(newLeft + this.characterWidth - this.$size.scrollerWidth));
            }
            else if (currentLeft &lt;= this.$padding &amp;&amp; newLeft - currentLeft &lt; this.characterWidth) {
                this.session.setScrollLeft(0);
            }
        }
    };
    this.getScrollTop = function () {
        return this.session.getScrollTop();
    };
    this.getScrollLeft = function () {
        return this.session.getScrollLeft();
    };
    this.getScrollTopRow = function () {
        return this.scrollTop / this.lineHeight;
    };
    this.getScrollBottomRow = function () {
        return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
    };
    this.scrollToRow = function (row) {
        this.session.setScrollTop(row * this.lineHeight);
    };
    this.alignCursor = function (cursor, alignment) {
        if (typeof cursor == &quot;number&quot;)
            cursor = { row: cursor, column: 0 };
        var pos = this.$cursorLayer.getPixelPosition(cursor);
        var h = this.$size.scrollerHeight - this.lineHeight;
        var offset = pos.top - h * (alignment || 0);
        this.session.setScrollTop(offset);
        return offset;
    };
    this.STEPS = 8;
    this.$calcSteps = function (fromValue, toValue) {
        var i = 0;
        var l = this.STEPS;
        var steps = [];
        var func = function (t, x_min, dx) {
            return dx * (Math.pow(t - 1, 3) + 1) + x_min;
        };
        for (i = 0; i &lt; l; ++i)
            steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));
        return steps;
    };
    this.scrollToLine = function (line, center, animate, callback) {
        var pos = this.$cursorLayer.getPixelPosition({ row: line, column: 0 });
        var offset = pos.top;
        if (center)
            offset -= this.$size.scrollerHeight / 2;
        var initialScroll = this.scrollTop;
        this.session.setScrollTop(offset);
        if (animate !== false)
            this.animateScrolling(initialScroll, callback);
    };
    this.animateScrolling = function (fromValue, callback) {
        var toValue = this.scrollTop;
        if (!this.$animatedScroll)
            return;
        var _self = this;
        if (fromValue == toValue)
            return;
        if (this.$scrollAnimation) {
            var oldSteps = this.$scrollAnimation.steps;
            if (oldSteps.length) {
                fromValue = oldSteps[0];
                if (fromValue == toValue)
                    return;
            }
        }
        var steps = _self.$calcSteps(fromValue, toValue);
        this.$scrollAnimation = { from: fromValue, to: toValue, steps: steps };
        clearInterval(this.$timer);
        _self.session.setScrollTop(steps.shift());
        _self.session.$scrollTop = toValue;
        function endAnimation() {
            _self.$timer = clearInterval(_self.$timer);
            _self.$scrollAnimation = null;
            _self.$stopAnimation = false;
            callback &amp;&amp; callback();
        }
        this.$timer = setInterval(function () {
            if (_self.$stopAnimation) {
                endAnimation();
                return;
            }
            if (!_self.session)
                return clearInterval(_self.$timer);
            if (steps.length) {
                _self.session.setScrollTop(steps.shift());
                _self.session.$scrollTop = toValue;
            }
            else if (toValue != null) {
                _self.session.$scrollTop = -1;
                _self.session.setScrollTop(toValue);
                toValue = null;
            }
            else {
                endAnimation();
            }
        }, 10);
    };
    this.scrollToY = function (scrollTop) {
        if (this.scrollTop !== scrollTop) {
            this.$loop.schedule(this.CHANGE_SCROLL);
            this.scrollTop = scrollTop;
        }
    };
    this.scrollToX = function (scrollLeft) {
        if (this.scrollLeft !== scrollLeft)
            this.scrollLeft = scrollLeft;
        this.$loop.schedule(this.CHANGE_H_SCROLL);
    };
    this.scrollTo = function (x, y) {
        this.session.setScrollTop(y);
        this.session.setScrollLeft(x);
    };
    this.scrollBy = function (deltaX, deltaY) {
        deltaY &amp;&amp; this.session.setScrollTop(this.session.getScrollTop() + deltaY);
        deltaX &amp;&amp; this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
    };
    this.isScrollableBy = function (deltaX, deltaY) {
        if (deltaY &lt; 0 &amp;&amp; this.session.getScrollTop() &gt;= 1 - this.scrollMargin.top)
            return true;
        if (deltaY &gt; 0 &amp;&amp; this.session.getScrollTop() + this.$size.scrollerHeight
            - this.layerConfig.maxHeight &lt; -1 + this.scrollMargin.bottom)
            return true;
        if (deltaX &lt; 0 &amp;&amp; this.session.getScrollLeft() &gt;= 1 - this.scrollMargin.left)
            return true;
        if (deltaX &gt; 0 &amp;&amp; this.session.getScrollLeft() + this.$size.scrollerWidth
            - this.layerConfig.width &lt; -1 + this.scrollMargin.right)
            return true;
    };
    this.pixelToScreenCoordinates = function (x, y) {
        var canvasPos;
        if (this.$hasCssTransforms) {
            canvasPos = { top: 0, left: 0 };
            var p = this.$fontMetrics.transformCoordinates([x, y]);
            x = p[1] - this.gutterWidth - this.margin.left;
            y = p[0];
        }
        else {
            canvasPos = this.scroller.getBoundingClientRect();
        }
        var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
        var offset = offsetX / this.characterWidth;
        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
        var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);
        return { row: row, column: col, side: offset - col &gt; 0 ? 1 : -1, offsetX: offsetX };
    };
    this.screenToTextCoordinates = function (x, y) {
        var canvasPos;
        if (this.$hasCssTransforms) {
            canvasPos = { top: 0, left: 0 };
            var p = this.$fontMetrics.transformCoordinates([x, y]);
            x = p[1] - this.gutterWidth - this.margin.left;
            y = p[0];
        }
        else {
            canvasPos = this.scroller.getBoundingClientRect();
        }
        var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
        var offset = offsetX / this.characterWidth;
        var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);
        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
        return this.session.screenToDocumentPosition(row, Math.max(col, 0), offsetX);
    };
    this.textToScreenCoordinates = function (row, column) {
        var canvasPos = this.scroller.getBoundingClientRect();
        var pos = this.session.documentToScreenPosition(row, column);
        var x = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, row)
            ? this.session.$bidiHandler.getPosLeft(pos.column)
            : Math.round(pos.column * this.characterWidth));
        var y = pos.row * this.lineHeight;
        return {
            pageX: canvasPos.left + x - this.scrollLeft,
            pageY: canvasPos.top + y - this.scrollTop
        };
    };
    this.visualizeFocus = function () {
        dom.addCssClass(this.container, &quot;ace_focus&quot;);
    };
    this.visualizeBlur = function () {
        dom.removeCssClass(this.container, &quot;ace_focus&quot;);
    };
    this.showComposition = function (composition) {
        this.$composition = composition;
        if (!composition.cssText) {
            composition.cssText = this.textarea.style.cssText;
        }
        if (composition.useTextareaForIME == undefined)
            composition.useTextareaForIME = this.$useTextareaForIME;
        if (this.$useTextareaForIME) {
            dom.addCssClass(this.textarea, &quot;ace_composition&quot;);
            this.textarea.style.cssText = &quot;&quot;;
            this.$moveTextAreaToCursor();
            this.$cursorLayer.element.style.display = &quot;none&quot;;
        }
        else {
            composition.markerId = this.session.addMarker(composition.markerRange, &quot;ace_composition_marker&quot;, &quot;text&quot;);
        }
    };
    this.setCompositionText = function (text) {
        var cursor = this.session.selection.cursor;
        this.addToken(text, &quot;composition_placeholder&quot;, cursor.row, cursor.column);
        this.$moveTextAreaToCursor();
    };
    this.hideComposition = function () {
        if (!this.$composition)
            return;
        if (this.$composition.markerId)
            this.session.removeMarker(this.$composition.markerId);
        dom.removeCssClass(this.textarea, &quot;ace_composition&quot;);
        this.textarea.style.cssText = this.$composition.cssText;
        var cursor = this.session.selection.cursor;
        this.removeExtraToken(cursor.row, cursor.column);
        this.$composition = null;
        this.$cursorLayer.element.style.display = &quot;&quot;;
    };
    this.addToken = function (text, type, row, column) {
        var session = this.session;
        session.bgTokenizer.lines[row] = null;
        var newToken = { type: type, value: text };
        var tokens = session.getTokens(row);
        if (column == null) {
            tokens.push(newToken);
        }
        else {
            var l = 0;
            for (var i = 0; i &lt; tokens.length; i++) {
                var token = tokens[i];
                l += token.value.length;
                if (column &lt;= l) {
                    var diff = token.value.length - (l - column);
                    var before = token.value.slice(0, diff);
                    var after = token.value.slice(diff);
                    tokens.splice(i, 1, { type: token.type, value: before }, newToken, { type: token.type, value: after });
                    break;
                }
            }
        }
        this.updateLines(row, row);
    };
    this.removeExtraToken = function (row, column) {
        this.updateLines(row, row);
    };
    this.setTheme = function (theme, cb) {
        var _self = this;
        this.$themeId = theme;
        _self._dispatchEvent(&#039;themeChange&#039;, { theme: theme });
        if (!theme || typeof theme == &quot;string&quot;) {
            var moduleName = theme || this.$options.theme.initialValue;
            config.loadModule([&quot;theme&quot;, moduleName], afterLoad);
        }
        else {
            afterLoad(theme);
        }
        function afterLoad(module) {
            if (_self.$themeId != theme)
                return cb &amp;&amp; cb();
            if (!module || !module.cssClass)
                throw new Error(&quot;couldn&#039;t load module &quot; + theme + &quot; or it didn&#039;t call define&quot;);
            if (module.$id)
                _self.$themeId = module.$id;
            dom.importCssString(module.cssText, module.cssClass, _self.container);
            if (_self.theme)
                dom.removeCssClass(_self.container, _self.theme.cssClass);
            var padding = &quot;padding&quot; in module ? module.padding
                : &quot;padding&quot; in (_self.theme || {}) ? 4 : _self.$padding;
            if (_self.$padding &amp;&amp; padding != _self.$padding)
                _self.setPadding(padding);
            _self.$theme = module.cssClass;
            _self.theme = module;
            dom.addCssClass(_self.container, module.cssClass);
            dom.setCssClass(_self.container, &quot;ace_dark&quot;, module.isDark);
            if (_self.$size) {
                _self.$size.width = 0;
                _self.$updateSizeAsync();
            }
            _self._dispatchEvent(&#039;themeLoaded&#039;, { theme: module });
            cb &amp;&amp; cb();
        }
    };
    this.getTheme = function () {
        return this.$themeId;
    };
    this.setStyle = function (style, include) {
        dom.setCssClass(this.container, style, include !== false);
    };
    this.unsetStyle = function (style) {
        dom.removeCssClass(this.container, style);
    };
    this.setCursorStyle = function (style) {
        dom.setStyle(this.scroller.style, &quot;cursor&quot;, style);
    };
    this.setMouseCursor = function (cursorStyle) {
        dom.setStyle(this.scroller.style, &quot;cursor&quot;, cursorStyle);
    };
    this.attachToShadowRoot = function () {
        dom.importCssString(editorCss, &quot;ace_editor.css&quot;, this.container);
    };
    this.destroy = function () {
        this.freeze();
        this.$fontMetrics.destroy();
        this.$cursorLayer.destroy();
        this.removeAllListeners();
        this.container.textContent = &quot;&quot;;
    };
    this.$updateCustomScrollbar = function (val) {
        var _self = this;
        this.$horizScroll = this.$vScroll = null;
        this.scrollBarV.element.remove();
        this.scrollBarH.element.remove();
        if (this.$scrollDecorator) {
            delete this.$scrollDecorator;
        }
        if (val === true) {
            this.scrollBarV = new VScrollBarCustom(this.container, this);
            this.scrollBarH = new HScrollBarCustom(this.container, this);
            this.scrollBarV.setHeight(this.$size.scrollerHeight);
            this.scrollBarH.setWidth(this.$size.scrollerWidth);
            this.scrollBarV.addEventListener(&quot;scroll&quot;, function (e) {
                if (!_self.$scrollAnimation)
                    _self.session.setScrollTop(e.data - _self.scrollMargin.top);
            });
            this.scrollBarH.addEventListener(&quot;scroll&quot;, function (e) {
                if (!_self.$scrollAnimation)
                    _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
            });
            this.$scrollDecorator = new Decorator(this.scrollBarV, this);
            this.$scrollDecorator.$updateDecorators();
        }
        else {
            this.scrollBarV = new VScrollBar(this.container, this);
            this.scrollBarH = new HScrollBar(this.container, this);
            this.scrollBarV.addEventListener(&quot;scroll&quot;, function (e) {
                if (!_self.$scrollAnimation)
                    _self.session.setScrollTop(e.data - _self.scrollMargin.top);
            });
            this.scrollBarH.addEventListener(&quot;scroll&quot;, function (e) {
                if (!_self.$scrollAnimation)
                    _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
            });
        }
    };
}).call(VirtualRenderer.prototype);
config.defineOptions(VirtualRenderer.prototype, &quot;renderer&quot;, {
    animatedScroll: { initialValue: false },
    showInvisibles: {
        set: function (value) {
            if (this.$textLayer.setShowInvisibles(value))
                this.$loop.schedule(this.CHANGE_TEXT);
        },
        initialValue: false
    },
    showPrintMargin: {
        set: function () { this.$updatePrintMargin(); },
        initialValue: true
    },
    printMarginColumn: {
        set: function () { this.$updatePrintMargin(); },
        initialValue: 80
    },
    printMargin: {
        set: function (val) {
            if (typeof val == &quot;number&quot;)
                this.$printMarginColumn = val;
            this.$showPrintMargin = !!val;
            this.$updatePrintMargin();
        },
        get: function () {
            return this.$showPrintMargin &amp;&amp; this.$printMarginColumn;
        }
    },
    showGutter: {
        set: function (show) {
            this.$gutter.style.display = show ? &quot;block&quot; : &quot;none&quot;;
            this.$loop.schedule(this.CHANGE_FULL);
            this.onGutterResize();
        },
        initialValue: true
    },
    fadeFoldWidgets: {
        set: function (show) {
            dom.setCssClass(this.$gutter, &quot;ace_fade-fold-widgets&quot;, show);
        },
        initialValue: false
    },
    showFoldWidgets: {
        set: function (show) {
            this.$gutterLayer.setShowFoldWidgets(show);
            this.$loop.schedule(this.CHANGE_GUTTER);
        },
        initialValue: true
    },
    displayIndentGuides: {
        set: function (show) {
            if (this.$textLayer.setDisplayIndentGuides(show))
                this.$loop.schedule(this.CHANGE_TEXT);
        },
        initialValue: true
    },
    highlightIndentGuides: {
        set: function (show) {
            if (this.$textLayer.setHighlightIndentGuides(show) == true) {
                this.$textLayer.$highlightIndentGuide();
            }
            else {
                this.$textLayer.$clearActiveIndentGuide(this.$textLayer.$lines.cells);
            }
        },
        initialValue: true
    },
    highlightGutterLine: {
        set: function (shouldHighlight) {
            this.$gutterLayer.setHighlightGutterLine(shouldHighlight);
            this.$loop.schedule(this.CHANGE_GUTTER);
        },
        initialValue: true
    },
    hScrollBarAlwaysVisible: {
        set: function (val) {
            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
                this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: false
    },
    vScrollBarAlwaysVisible: {
        set: function (val) {
            if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
                this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: false
    },
    fontSize: {
        set: function (size) {
            if (typeof size == &quot;number&quot;)
                size = size + &quot;px&quot;;
            this.container.style.fontSize = size;
            this.updateFontSize();
        },
        initialValue: 12
    },
    fontFamily: {
        set: function (name) {
            this.container.style.fontFamily = name;
            this.updateFontSize();
        }
    },
    maxLines: {
        set: function (val) {
            this.updateFull();
        }
    },
    minLines: {
        set: function (val) {
            if (!(this.$minLines &lt; 0x1ffffffffffff))
                this.$minLines = 0;
            this.updateFull();
        }
    },
    maxPixelHeight: {
        set: function (val) {
            this.updateFull();
        },
        initialValue: 0
    },
    scrollPastEnd: {
        set: function (val) {
            val = +val || 0;
            if (this.$scrollPastEnd == val)
                return;
            this.$scrollPastEnd = val;
            this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: 0,
        handlesSet: true
    },
    fixedWidthGutter: {
        set: function (val) {
            this.$gutterLayer.$fixedWidth = !!val;
            this.$loop.schedule(this.CHANGE_GUTTER);
        }
    },
    customScrollbar: {
        set: function (val) {
            this.$updateCustomScrollbar(val);
        },
        initialValue: false
    },
    theme: {
        set: function (val) { this.setTheme(val); },
        get: function () { return this.$themeId || this.theme; },
        initialValue: &quot;./theme/textmate&quot;,
        handlesSet: true
    },
    hasCssTransforms: {},
    useTextareaForIME: {
        initialValue: !useragent.isMobile &amp;&amp; !useragent.isIE
    }
});
exports.VirtualRenderer = VirtualRenderer;

});

define(&quot;ace/worker/worker_client&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/net&quot;,&quot;ace/lib/event_emitter&quot;,&quot;ace/config&quot;], function(require, exports, module) {
&quot;use strict&quot;;

var oop = require(&quot;../lib/oop&quot;);
var net = require(&quot;../lib/net&quot;);
var EventEmitter = require(&quot;../lib/event_emitter&quot;).EventEmitter;
var config = require(&quot;../config&quot;);

function $workerBlob(workerUrl) {
    var script = &quot;importScripts(&#039;&quot; + net.qualifyURL(workerUrl) + &quot;&#039;);&quot;;
    try {
        return new Blob([script], {&quot;type&quot;: &quot;application/javascript&quot;});
    } catch (e) { // Backwards-compatibility
        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
        var blobBuilder = new BlobBuilder();
        blobBuilder.append(script);
        return blobBuilder.getBlob(&quot;application/javascript&quot;);
    }
}

function createWorker(workerUrl) {
    if (typeof Worker == &quot;undefined&quot;)
        return { postMessage: function() {}, terminate: function() {} };
    if (config.get(&quot;loadWorkerFromBlob&quot;)) {
        var blob = $workerBlob(workerUrl);
        var URL = window.URL || window.webkitURL;
        var blobURL = URL.createObjectURL(blob);
        return new Worker(blobURL);
    }
    return new Worker(workerUrl);
}

var WorkerClient = function(worker) {
    if (!worker.postMessage)
        worker = this.$createWorkerFromOldConfig.apply(this, arguments);

    this.$worker = worker;
    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
    this.changeListener = this.changeListener.bind(this);
    this.onMessage = this.onMessage.bind(this);

    this.callbackId = 1;
    this.callbacks = {};

    this.$worker.onmessage = this.onMessage;
};

(function(){

    oop.implement(this, EventEmitter);

    this.$createWorkerFromOldConfig = function(topLevelNamespaces, mod, classname, workerUrl, importScripts) {
        if (require.nameToUrl &amp;&amp; !require.toUrl)
            require.toUrl = require.nameToUrl;

        if (config.get(&quot;packaged&quot;) || !require.toUrl) {
            workerUrl = workerUrl || config.moduleUrl(mod, &quot;worker&quot;);
        } else {
            var normalizePath = this.$normalizePath;
            workerUrl = workerUrl || normalizePath(require.toUrl(&quot;ace/worker/worker.js&quot;, null, &quot;_&quot;));

            var tlns = {};
            topLevelNamespaces.forEach(function(ns) {
                tlns[ns] = normalizePath(require.toUrl(ns, null, &quot;_&quot;).replace(/(\.js)?(\?.*)?$/, &quot;&quot;));
            });
        }

        this.$worker = createWorker(workerUrl);
        if (importScripts) {
            this.send(&quot;importScripts&quot;, importScripts);
        }
        this.$worker.postMessage({
            init : true,
            tlns : tlns,
            module : mod,
            classname : classname
        });
        return this.$worker;
    };

    this.onMessage = function(e) {
        var msg = e.data;
        switch (msg.type) {
            case &quot;event&quot;:
                this._signal(msg.name, {data: msg.data});
                break;
            case &quot;call&quot;:
                var callback = this.callbacks[msg.id];
                if (callback) {
                    callback(msg.data);
                    delete this.callbacks[msg.id];
                }
                break;
            case &quot;error&quot;:
                this.reportError(msg.data);
                break;
            case &quot;log&quot;:
                window.console &amp;&amp; console.log &amp;&amp; console.log.apply(console, msg.data);
                break;
        }
    };
    
    this.reportError = function(err) {
        window.console &amp;&amp; console.error &amp;&amp; console.error(err);
    };

    this.$normalizePath = function(path) {
        return net.qualifyURL(path);
    };

    this.terminate = function() {
        this._signal(&quot;terminate&quot;, {});
        this.deltaQueue = null;
        this.$worker.terminate();
        this.$worker = null;
        if (this.$doc)
            this.$doc.off(&quot;change&quot;, this.changeListener);
        this.$doc = null;
    };

    this.send = function(cmd, args) {
        this.$worker.postMessage({command: cmd, args: args});
    };

    this.call = function(cmd, args, callback) {
        if (callback) {
            var id = this.callbackId++;
            this.callbacks[id] = callback;
            args.push(id);
        }
        this.send(cmd, args);
    };

    this.emit = function(event, data) {
        try {
            if (data.data &amp;&amp; data.data.err)
                data.data.err = {message: data.data.err.message, stack: data.data.err.stack, code: data.data.err.code};
                this.$worker &amp;&amp; this.$worker.postMessage({event: event, data: {data: data.data}});
        }
        catch(ex) {
            console.error(ex.stack);
        }
    };

    this.attachToDocument = function(doc) {
        if (this.$doc)
            this.terminate();

        this.$doc = doc;
        this.call(&quot;setValue&quot;, [doc.getValue()]);
        doc.on(&quot;change&quot;, this.changeListener, true);
    };

    this.changeListener = function(delta) {
        if (!this.deltaQueue) {
            this.deltaQueue = [];
            setTimeout(this.$sendDeltaQueue, 0);
        }
        if (delta.action == &quot;insert&quot;)
            this.deltaQueue.push(delta.start, delta.lines);
        else
            this.deltaQueue.push(delta.start, delta.end);
    };

    this.$sendDeltaQueue = function() {
        var q = this.deltaQueue;
        if (!q) return;
        this.deltaQueue = null;
        if (q.length &gt; 50 &amp;&amp; q.length &gt; this.$doc.getLength() &gt;&gt; 1) {
            this.call(&quot;setValue&quot;, [this.$doc.getValue()]);
        } else
            this.emit(&quot;change&quot;, {data: q});
    };

}).call(WorkerClient.prototype);


var UIWorkerClient = function(topLevelNamespaces, mod, classname) {
    var main = null;
    var emitSync = false;
    var sender = Object.create(EventEmitter);

    var messageBuffer = [];
    var workerClient = new WorkerClient({
        messageBuffer: messageBuffer,
        terminate: function() {},
        postMessage: function(e) {
            messageBuffer.push(e);
            if (!main) return;
            if (emitSync)
                setTimeout(processNext);
            else
                processNext();
        }
    });

    workerClient.setEmitSync = function(val) { emitSync = val; };

    var processNext = function() {
        var msg = messageBuffer.shift();
        if (msg.command)
            main[msg.command].apply(main, msg.args);
        else if (msg.event)
            sender._signal(msg.event, msg.data);
    };

    sender.postMessage = function(msg) {
        workerClient.onMessage({data: msg});
    };
    sender.callback = function(data, callbackId) {
        this.postMessage({type: &quot;call&quot;, id: callbackId, data: data});
    };
    sender.emit = function(name, data) {
        this.postMessage({type: &quot;event&quot;, name: name, data: data});
    };

    config.loadModule([&quot;worker&quot;, mod], function(Main) {
        main = new Main[classname](sender);
        while (messageBuffer.length)
            processNext();
    });

    return workerClient;
};

exports.UIWorkerClient = UIWorkerClient;
exports.WorkerClient = WorkerClient;
exports.createWorker = createWorker;


});

define(&quot;ace/placeholder&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/range&quot;,&quot;ace/lib/event_emitter&quot;,&quot;ace/lib/oop&quot;], function(require, exports, module){&quot;use strict&quot;;
var Range = require(&quot;./range&quot;).Range;
var EventEmitter = require(&quot;./lib/event_emitter&quot;).EventEmitter;
var oop = require(&quot;./lib/oop&quot;);
var PlaceHolder = function (session, length, pos, others, mainClass, othersClass) {
    var _self = this;
    this.length = length;
    this.session = session;
    this.doc = session.getDocument();
    this.mainClass = mainClass;
    this.othersClass = othersClass;
    this.$onUpdate = this.onUpdate.bind(this);
    this.doc.on(&quot;change&quot;, this.$onUpdate, true);
    this.$others = others;
    this.$onCursorChange = function () {
        setTimeout(function () {
            _self.onCursorChange();
        });
    };
    this.$pos = pos;
    var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || { length: -1 };
    this.$undoStackDepth = undoStack.length;
    this.setup();
    session.selection.on(&quot;changeCursor&quot;, this.$onCursorChange);
};
(function () {
    oop.implement(this, EventEmitter);
    this.setup = function () {
        var _self = this;
        var doc = this.doc;
        var session = this.session;
        this.selectionBefore = session.selection.toJSON();
        if (session.selection.inMultiSelectMode)
            session.selection.toSingleRange();
        this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);
        var pos = this.pos;
        pos.$insertRight = true;
        pos.detach();
        pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
        this.others = [];
        this.$others.forEach(function (other) {
            var anchor = doc.createAnchor(other.row, other.column);
            anchor.$insertRight = true;
            anchor.detach();
            _self.others.push(anchor);
        });
        session.setUndoSelect(false);
    };
    this.showOtherMarkers = function () {
        if (this.othersActive)
            return;
        var session = this.session;
        var _self = this;
        this.othersActive = true;
        this.others.forEach(function (anchor) {
            anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column + _self.length), _self.othersClass, null, false);
        });
    };
    this.hideOtherMarkers = function () {
        if (!this.othersActive)
            return;
        this.othersActive = false;
        for (var i = 0; i &lt; this.others.length; i++) {
            this.session.removeMarker(this.others[i].markerId);
        }
    };
    this.onUpdate = function (delta) {
        if (this.$updating)
            return this.updateAnchors(delta);
        var range = delta;
        if (range.start.row !== range.end.row)
            return;
        if (range.start.row !== this.pos.row)
            return;
        this.$updating = true;
        var lengthDiff = delta.action === &quot;insert&quot; ? range.end.column - range.start.column : range.start.column - range.end.column;
        var inMainRange = range.start.column &gt;= this.pos.column &amp;&amp; range.start.column &lt;= this.pos.column + this.length + 1;
        var distanceFromStart = range.start.column - this.pos.column;
        this.updateAnchors(delta);
        if (inMainRange)
            this.length += lengthDiff;
        if (inMainRange &amp;&amp; !this.session.$fromUndo) {
            if (delta.action === &#039;insert&#039;) {
                for (var i = this.others.length - 1; i &gt;= 0; i--) {
                    var otherPos = this.others[i];
                    var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };
                    this.doc.insertMergedLines(newPos, delta.lines);
                }
            }
            else if (delta.action === &#039;remove&#039;) {
                for (var i = this.others.length - 1; i &gt;= 0; i--) {
                    var otherPos = this.others[i];
                    var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };
                    this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
                }
            }
        }
        this.$updating = false;
        this.updateMarkers();
    };
    this.updateAnchors = function (delta) {
        this.pos.onChange(delta);
        for (var i = this.others.length; i--;)
            this.others[i].onChange(delta);
        this.updateMarkers();
    };
    this.updateMarkers = function () {
        if (this.$updating)
            return;
        var _self = this;
        var session = this.session;
        var updateMarker = function (pos, className) {
            session.removeMarker(pos.markerId);
            pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + _self.length), className, null, false);
        };
        updateMarker(this.pos, this.mainClass);
        for (var i = this.others.length; i--;)
            updateMarker(this.others[i], this.othersClass);
    };
    this.onCursorChange = function (event) {
        if (this.$updating || !this.session)
            return;
        var pos = this.session.selection.getCursor();
        if (pos.row === this.pos.row &amp;&amp; pos.column &gt;= this.pos.column &amp;&amp; pos.column &lt;= this.pos.column + this.length) {
            this.showOtherMarkers();
            this._emit(&quot;cursorEnter&quot;, event);
        }
        else {
            this.hideOtherMarkers();
            this._emit(&quot;cursorLeave&quot;, event);
        }
    };
    this.detach = function () {
        this.session.removeMarker(this.pos &amp;&amp; this.pos.markerId);
        this.hideOtherMarkers();
        this.doc.off(&quot;change&quot;, this.$onUpdate);
        this.session.selection.off(&quot;changeCursor&quot;, this.$onCursorChange);
        this.session.setUndoSelect(true);
        this.session = null;
    };
    this.cancel = function () {
        if (this.$undoStackDepth === -1)
            return;
        var undoManager = this.session.getUndoManager();
        var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;
        for (var i = 0; i &lt; undosRequired; i++) {
            undoManager.undo(this.session, true);
        }
        if (this.selectionBefore)
            this.session.selection.fromJSON(this.selectionBefore);
    };
}).call(PlaceHolder.prototype);
exports.PlaceHolder = PlaceHolder;

});

define(&quot;ace/mouse/multi_select_handler&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/event&quot;,&quot;ace/lib/useragent&quot;], function(require, exports, module){var event = require(&quot;../lib/event&quot;);
var useragent = require(&quot;../lib/useragent&quot;);
function isSamePoint(p1, p2) {
    return p1.row == p2.row &amp;&amp; p1.column == p2.column;
}
function onMouseDown(e) {
    var ev = e.domEvent;
    var alt = ev.altKey;
    var shift = ev.shiftKey;
    var ctrl = ev.ctrlKey;
    var accel = e.getAccelKey();
    var button = e.getButton();
    if (ctrl &amp;&amp; useragent.isMac)
        button = ev.button;
    if (e.editor.inMultiSelectMode &amp;&amp; button == 2) {
        e.editor.textInput.onContextMenu(e.domEvent);
        return;
    }
    if (!ctrl &amp;&amp; !alt &amp;&amp; !accel) {
        if (button === 0 &amp;&amp; e.editor.inMultiSelectMode)
            e.editor.exitMultiSelectMode();
        return;
    }
    if (button !== 0)
        return;
    var editor = e.editor;
    var selection = editor.selection;
    var isMultiSelect = editor.inMultiSelectMode;
    var pos = e.getDocumentPosition();
    var cursor = selection.getCursor();
    var inSelection = e.inSelection() || (selection.isEmpty() &amp;&amp; isSamePoint(pos, cursor));
    var mouseX = e.x, mouseY = e.y;
    var onMouseSelection = function (e) {
        mouseX = e.clientX;
        mouseY = e.clientY;
    };
    var session = editor.session;
    var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
    var screenCursor = screenAnchor;
    var selectionMode;
    if (editor.$mouseHandler.$enableJumpToDef) {
        if (ctrl &amp;&amp; alt || accel &amp;&amp; alt)
            selectionMode = shift ? &quot;block&quot; : &quot;add&quot;;
        else if (alt &amp;&amp; editor.$blockSelectEnabled)
            selectionMode = &quot;block&quot;;
    }
    else {
        if (accel &amp;&amp; !alt) {
            selectionMode = &quot;add&quot;;
            if (!isMultiSelect &amp;&amp; shift)
                return;
        }
        else if (alt &amp;&amp; editor.$blockSelectEnabled) {
            selectionMode = &quot;block&quot;;
        }
    }
    if (selectionMode &amp;&amp; useragent.isMac &amp;&amp; ev.ctrlKey) {
        editor.$mouseHandler.cancelContextMenu();
    }
    if (selectionMode == &quot;add&quot;) {
        if (!isMultiSelect &amp;&amp; inSelection)
            return; // dragging
        if (!isMultiSelect) {
            var range = selection.toOrientedRange();
            editor.addSelectionMarker(range);
        }
        var oldRange = selection.rangeList.rangeAtPoint(pos);
        editor.inVirtualSelectionMode = true;
        if (shift) {
            oldRange = null;
            range = selection.ranges[0] || range;
            editor.removeSelectionMarker(range);
        }
        editor.once(&quot;mouseup&quot;, function () {
            var tmpSel = selection.toOrientedRange();
            if (oldRange &amp;&amp; tmpSel.isEmpty() &amp;&amp; isSamePoint(oldRange.cursor, tmpSel.cursor))
                selection.substractPoint(tmpSel.cursor);
            else {
                if (shift) {
                    selection.substractPoint(range.cursor);
                }
                else if (range) {
                    editor.removeSelectionMarker(range);
                    selection.addRange(range);
                }
                selection.addRange(tmpSel);
            }
            editor.inVirtualSelectionMode = false;
        });
    }
    else if (selectionMode == &quot;block&quot;) {
        e.stop();
        editor.inVirtualSelectionMode = true;
        var initialRange;
        var rectSel = [];
        var blockSelect = function () {
            var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
            var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column, newCursor.offsetX);
            if (isSamePoint(screenCursor, newCursor) &amp;&amp; isSamePoint(cursor, selection.lead))
                return;
            screenCursor = newCursor;
            editor.selection.moveToPosition(cursor);
            editor.renderer.scrollCursorIntoView();
            editor.removeSelectionMarkers(rectSel);
            rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
            if (editor.$mouseHandler.$clickSelection &amp;&amp; rectSel.length == 1 &amp;&amp; rectSel[0].isEmpty())
                rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
            rectSel.forEach(editor.addSelectionMarker, editor);
            editor.updateSelectionMarkers();
        };
        if (isMultiSelect &amp;&amp; !accel) {
            selection.toSingleRange();
        }
        else if (!isMultiSelect &amp;&amp; accel) {
            initialRange = selection.toOrientedRange();
            editor.addSelectionMarker(initialRange);
        }
        if (shift)
            screenAnchor = session.documentToScreenPosition(selection.lead);
        else
            selection.moveToPosition(pos);
        screenCursor = { row: -1, column: -1 };
        var onMouseSelectionEnd = function (e) {
            blockSelect();
            clearInterval(timerId);
            editor.removeSelectionMarkers(rectSel);
            if (!rectSel.length)
                rectSel = [selection.toOrientedRange()];
            if (initialRange) {
                editor.removeSelectionMarker(initialRange);
                selection.toSingleRange(initialRange);
            }
            for (var i = 0; i &lt; rectSel.length; i++)
                selection.addRange(rectSel[i]);
            editor.inVirtualSelectionMode = false;
            editor.$mouseHandler.$clickSelection = null;
        };
        var onSelectionInterval = blockSelect;
        event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
        var timerId = setInterval(function () { onSelectionInterval(); }, 20);
        return e.preventDefault();
    }
}
exports.onMouseDown = onMouseDown;

});

define(&quot;ace/commands/multi_select_commands&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/keyboard/hash_handler&quot;], function(require, exports, module){// commands to enter multiselect mode
exports.defaultCommands = [{
        name: &quot;addCursorAbove&quot;,
        description: &quot;Add cursor above&quot;,
        exec: function (editor) { editor.selectMoreLines(-1); },
        bindKey: { win: &quot;Ctrl-Alt-Up&quot;, mac: &quot;Ctrl-Alt-Up&quot; },
        scrollIntoView: &quot;cursor&quot;,
        readOnly: true
    }, {
        name: &quot;addCursorBelow&quot;,
        description: &quot;Add cursor below&quot;,
        exec: function (editor) { editor.selectMoreLines(1); },
        bindKey: { win: &quot;Ctrl-Alt-Down&quot;, mac: &quot;Ctrl-Alt-Down&quot; },
        scrollIntoView: &quot;cursor&quot;,
        readOnly: true
    }, {
        name: &quot;addCursorAboveSkipCurrent&quot;,
        description: &quot;Add cursor above (skip current)&quot;,
        exec: function (editor) { editor.selectMoreLines(-1, true); },
        bindKey: { win: &quot;Ctrl-Alt-Shift-Up&quot;, mac: &quot;Ctrl-Alt-Shift-Up&quot; },
        scrollIntoView: &quot;cursor&quot;,
        readOnly: true
    }, {
        name: &quot;addCursorBelowSkipCurrent&quot;,
        description: &quot;Add cursor below (skip current)&quot;,
        exec: function (editor) { editor.selectMoreLines(1, true); },
        bindKey: { win: &quot;Ctrl-Alt-Shift-Down&quot;, mac: &quot;Ctrl-Alt-Shift-Down&quot; },
        scrollIntoView: &quot;cursor&quot;,
        readOnly: true
    }, {
        name: &quot;selectMoreBefore&quot;,
        description: &quot;Select more before&quot;,
        exec: function (editor) { editor.selectMore(-1); },
        bindKey: { win: &quot;Ctrl-Alt-Left&quot;, mac: &quot;Ctrl-Alt-Left&quot; },
        scrollIntoView: &quot;cursor&quot;,
        readOnly: true
    }, {
        name: &quot;selectMoreAfter&quot;,
        description: &quot;Select more after&quot;,
        exec: function (editor) { editor.selectMore(1); },
        bindKey: { win: &quot;Ctrl-Alt-Right&quot;, mac: &quot;Ctrl-Alt-Right&quot; },
        scrollIntoView: &quot;cursor&quot;,
        readOnly: true
    }, {
        name: &quot;selectNextBefore&quot;,
        description: &quot;Select next before&quot;,
        exec: function (editor) { editor.selectMore(-1, true); },
        bindKey: { win: &quot;Ctrl-Alt-Shift-Left&quot;, mac: &quot;Ctrl-Alt-Shift-Left&quot; },
        scrollIntoView: &quot;cursor&quot;,
        readOnly: true
    }, {
        name: &quot;selectNextAfter&quot;,
        description: &quot;Select next after&quot;,
        exec: function (editor) { editor.selectMore(1, true); },
        bindKey: { win: &quot;Ctrl-Alt-Shift-Right&quot;, mac: &quot;Ctrl-Alt-Shift-Right&quot; },
        scrollIntoView: &quot;cursor&quot;,
        readOnly: true
    }, {
        name: &quot;toggleSplitSelectionIntoLines&quot;,
        description: &quot;Split into lines&quot;,
        exec: function (editor) {
            if (editor.multiSelect.rangeCount &gt; 1)
                editor.multiSelect.joinSelections();
            else
                editor.multiSelect.splitIntoLines();
        },
        bindKey: { win: &quot;Ctrl-Alt-L&quot;, mac: &quot;Ctrl-Alt-L&quot; },
        readOnly: true
    }, {
        name: &quot;splitSelectionIntoLines&quot;,
        description: &quot;Split into lines&quot;,
        exec: function (editor) { editor.multiSelect.splitIntoLines(); },
        readOnly: true
    }, {
        name: &quot;alignCursors&quot;,
        description: &quot;Align cursors&quot;,
        exec: function (editor) { editor.alignCursors(); },
        bindKey: { win: &quot;Ctrl-Alt-A&quot;, mac: &quot;Ctrl-Alt-A&quot; },
        scrollIntoView: &quot;cursor&quot;
    }, {
        name: &quot;findAll&quot;,
        description: &quot;Find all&quot;,
        exec: function (editor) { editor.findAll(); },
        bindKey: { win: &quot;Ctrl-Alt-K&quot;, mac: &quot;Ctrl-Alt-G&quot; },
        scrollIntoView: &quot;cursor&quot;,
        readOnly: true
    }];
exports.multiSelectCommands = [{
        name: &quot;singleSelection&quot;,
        description: &quot;Single selection&quot;,
        bindKey: &quot;esc&quot;,
        exec: function (editor) { editor.exitMultiSelectMode(); },
        scrollIntoView: &quot;cursor&quot;,
        readOnly: true,
        isAvailable: function (editor) { return editor &amp;&amp; editor.inMultiSelectMode; }
    }];
var HashHandler = require(&quot;../keyboard/hash_handler&quot;).HashHandler;
exports.keyboardHandler = new HashHandler(exports.multiSelectCommands);

});

define(&quot;ace/multi_select&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/range_list&quot;,&quot;ace/range&quot;,&quot;ace/selection&quot;,&quot;ace/mouse/multi_select_handler&quot;,&quot;ace/lib/event&quot;,&quot;ace/lib/lang&quot;,&quot;ace/commands/multi_select_commands&quot;,&quot;ace/search&quot;,&quot;ace/edit_session&quot;,&quot;ace/editor&quot;,&quot;ace/config&quot;], function(require, exports, module){var RangeList = require(&quot;./range_list&quot;).RangeList;
var Range = require(&quot;./range&quot;).Range;
var Selection = require(&quot;./selection&quot;).Selection;
var onMouseDown = require(&quot;./mouse/multi_select_handler&quot;).onMouseDown;
var event = require(&quot;./lib/event&quot;);
var lang = require(&quot;./lib/lang&quot;);
var commands = require(&quot;./commands/multi_select_commands&quot;);
exports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
var Search = require(&quot;./search&quot;).Search;
var search = new Search();
function find(session, needle, dir) {
    search.$options.wrap = true;
    search.$options.needle = needle;
    search.$options.backwards = dir == -1;
    return search.find(session);
}
var EditSession = require(&quot;./edit_session&quot;).EditSession;
(function () {
    this.getSelectionMarkers = function () {
        return this.$selectionMarkers;
    };
}).call(EditSession.prototype);
(function () {
    this.ranges = null;
    this.rangeList = null;
    this.addRange = function (range, $blockChangeEvents) {
        if (!range)
            return;
        if (!this.inMultiSelectMode &amp;&amp; this.rangeCount === 0) {
            var oldRange = this.toOrientedRange();
            this.rangeList.add(oldRange);
            this.rangeList.add(range);
            if (this.rangeList.ranges.length != 2) {
                this.rangeList.removeAll();
                return $blockChangeEvents || this.fromOrientedRange(range);
            }
            this.rangeList.removeAll();
            this.rangeList.add(oldRange);
            this.$onAddRange(oldRange);
        }
        if (!range.cursor)
            range.cursor = range.end;
        var removed = this.rangeList.add(range);
        this.$onAddRange(range);
        if (removed.length)
            this.$onRemoveRange(removed);
        if (this.rangeCount &gt; 1 &amp;&amp; !this.inMultiSelectMode) {
            this._signal(&quot;multiSelect&quot;);
            this.inMultiSelectMode = true;
            this.session.$undoSelect = false;
            this.rangeList.attach(this.session);
        }
        return $blockChangeEvents || this.fromOrientedRange(range);
    };
    this.toSingleRange = function (range) {
        range = range || this.ranges[0];
        var removed = this.rangeList.removeAll();
        if (removed.length)
            this.$onRemoveRange(removed);
        range &amp;&amp; this.fromOrientedRange(range);
    };
    this.substractPoint = function (pos) {
        var removed = this.rangeList.substractPoint(pos);
        if (removed) {
            this.$onRemoveRange(removed);
            return removed[0];
        }
    };
    this.mergeOverlappingRanges = function () {
        var removed = this.rangeList.merge();
        if (removed.length)
            this.$onRemoveRange(removed);
    };
    this.$onAddRange = function (range) {
        this.rangeCount = this.rangeList.ranges.length;
        this.ranges.unshift(range);
        this._signal(&quot;addRange&quot;, { range: range });
    };
    this.$onRemoveRange = function (removed) {
        this.rangeCount = this.rangeList.ranges.length;
        if (this.rangeCount == 1 &amp;&amp; this.inMultiSelectMode) {
            var lastRange = this.rangeList.ranges.pop();
            removed.push(lastRange);
            this.rangeCount = 0;
        }
        for (var i = removed.length; i--;) {
            var index = this.ranges.indexOf(removed[i]);
            this.ranges.splice(index, 1);
        }
        this._signal(&quot;removeRange&quot;, { ranges: removed });
        if (this.rangeCount === 0 &amp;&amp; this.inMultiSelectMode) {
            this.inMultiSelectMode = false;
            this._signal(&quot;singleSelect&quot;);
            this.session.$undoSelect = true;
            this.rangeList.detach(this.session);
        }
        lastRange = lastRange || this.ranges[0];
        if (lastRange &amp;&amp; !lastRange.isEqual(this.getRange()))
            this.fromOrientedRange(lastRange);
    };
    this.$initRangeList = function () {
        if (this.rangeList)
            return;
        this.rangeList = new RangeList();
        this.ranges = [];
        this.rangeCount = 0;
    };
    this.getAllRanges = function () {
        return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
    };
    this.splitIntoLines = function () {
        var ranges = this.ranges.length ? this.ranges : [this.getRange()];
        var newRanges = [];
        for (var i = 0; i &lt; ranges.length; i++) {
            var range = ranges[i];
            var row = range.start.row;
            var endRow = range.end.row;
            if (row === endRow) {
                newRanges.push(range.clone());
            }
            else {
                newRanges.push(new Range(row, range.start.column, row, this.session.getLine(row).length));
                while (++row &lt; endRow)
                    newRanges.push(this.getLineRange(row, true));
                newRanges.push(new Range(endRow, 0, endRow, range.end.column));
            }
            if (i == 0 &amp;&amp; !this.isBackwards())
                newRanges = newRanges.reverse();
        }
        this.toSingleRange();
        for (var i = newRanges.length; i--;)
            this.addRange(newRanges[i]);
    };
    this.joinSelections = function () {
        var ranges = this.rangeList.ranges;
        var lastRange = ranges[ranges.length - 1];
        var range = Range.fromPoints(ranges[0].start, lastRange.end);
        this.toSingleRange();
        this.setSelectionRange(range, lastRange.cursor == lastRange.start);
    };
    this.toggleBlockSelection = function () {
        if (this.rangeCount &gt; 1) {
            var ranges = this.rangeList.ranges;
            var lastRange = ranges[ranges.length - 1];
            var range = Range.fromPoints(ranges[0].start, lastRange.end);
            this.toSingleRange();
            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
        }
        else {
            var cursor = this.session.documentToScreenPosition(this.cursor);
            var anchor = this.session.documentToScreenPosition(this.anchor);
            var rectSel = this.rectangularRangeBlock(cursor, anchor);
            rectSel.forEach(this.addRange, this);
        }
    };
    this.rectangularRangeBlock = function (screenCursor, screenAnchor, includeEmptyLines) {
        var rectSel = [];
        var xBackwards = screenCursor.column &lt; screenAnchor.column;
        if (xBackwards) {
            var startColumn = screenCursor.column;
            var endColumn = screenAnchor.column;
            var startOffsetX = screenCursor.offsetX;
            var endOffsetX = screenAnchor.offsetX;
        }
        else {
            var startColumn = screenAnchor.column;
            var endColumn = screenCursor.column;
            var startOffsetX = screenAnchor.offsetX;
            var endOffsetX = screenCursor.offsetX;
        }
        var yBackwards = screenCursor.row &lt; screenAnchor.row;
        if (yBackwards) {
            var startRow = screenCursor.row;
            var endRow = screenAnchor.row;
        }
        else {
            var startRow = screenAnchor.row;
            var endRow = screenCursor.row;
        }
        if (startColumn &lt; 0)
            startColumn = 0;
        if (startRow &lt; 0)
            startRow = 0;
        if (startRow == endRow)
            includeEmptyLines = true;
        var docEnd;
        for (var row = startRow; row &lt;= endRow; row++) {
            var range = Range.fromPoints(this.session.screenToDocumentPosition(row, startColumn, startOffsetX), this.session.screenToDocumentPosition(row, endColumn, endOffsetX));
            if (range.isEmpty()) {
                if (docEnd &amp;&amp; isSamePoint(range.end, docEnd))
                    break;
                docEnd = range.end;
            }
            range.cursor = xBackwards ? range.start : range.end;
            rectSel.push(range);
        }
        if (yBackwards)
            rectSel.reverse();
        if (!includeEmptyLines) {
            var end = rectSel.length - 1;
            while (rectSel[end].isEmpty() &amp;&amp; end &gt; 0)
                end--;
            if (end &gt; 0) {
                var start = 0;
                while (rectSel[start].isEmpty())
                    start++;
            }
            for (var i = end; i &gt;= start; i--) {
                if (rectSel[i].isEmpty())
                    rectSel.splice(i, 1);
            }
        }
        return rectSel;
    };
}).call(Selection.prototype);
var Editor = require(&quot;./editor&quot;).Editor;
(function () {
    this.updateSelectionMarkers = function () {
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };
    this.addSelectionMarker = function (orientedRange) {
        if (!orientedRange.cursor)
            orientedRange.cursor = orientedRange.end;
        var style = this.getSelectionStyle();
        orientedRange.marker = this.session.addMarker(orientedRange, &quot;ace_selection&quot;, style);
        this.session.$selectionMarkers.push(orientedRange);
        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
        return orientedRange;
    };
    this.removeSelectionMarker = function (range) {
        if (!range.marker)
            return;
        this.session.removeMarker(range.marker);
        var index = this.session.$selectionMarkers.indexOf(range);
        if (index != -1)
            this.session.$selectionMarkers.splice(index, 1);
        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
    };
    this.removeSelectionMarkers = function (ranges) {
        var markerList = this.session.$selectionMarkers;
        for (var i = ranges.length; i--;) {
            var range = ranges[i];
            if (!range.marker)
                continue;
            this.session.removeMarker(range.marker);
            var index = markerList.indexOf(range);
            if (index != -1)
                markerList.splice(index, 1);
        }
        this.session.selectionMarkerCount = markerList.length;
    };
    this.$onAddRange = function (e) {
        this.addSelectionMarker(e.range);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };
    this.$onRemoveRange = function (e) {
        this.removeSelectionMarkers(e.ranges);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };
    this.$onMultiSelect = function (e) {
        if (this.inMultiSelectMode)
            return;
        this.inMultiSelectMode = true;
        this.setStyle(&quot;ace_multiselect&quot;);
        this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
        this.commands.setDefaultHandler(&quot;exec&quot;, this.$onMultiSelectExec);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };
    this.$onSingleSelect = function (e) {
        if (this.session.multiSelect.inVirtualMode)
            return;
        this.inMultiSelectMode = false;
        this.unsetStyle(&quot;ace_multiselect&quot;);
        this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);
        this.commands.removeDefaultHandler(&quot;exec&quot;, this.$onMultiSelectExec);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
        this._emit(&quot;changeSelection&quot;);
    };
    this.$onMultiSelectExec = function (e) {
        var command = e.command;
        var editor = e.editor;
        if (!editor.multiSelect)
            return;
        if (!command.multiSelectAction) {
            var result = command.exec(editor, e.args || {});
            editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
            editor.multiSelect.mergeOverlappingRanges();
        }
        else if (command.multiSelectAction == &quot;forEach&quot;) {
            result = editor.forEachSelection(command, e.args);
        }
        else if (command.multiSelectAction == &quot;forEachLine&quot;) {
            result = editor.forEachSelection(command, e.args, true);
        }
        else if (command.multiSelectAction == &quot;single&quot;) {
            editor.exitMultiSelectMode();
            result = command.exec(editor, e.args || {});
        }
        else {
            result = command.multiSelectAction(editor, e.args || {});
        }
        return result;
    };
    this.forEachSelection = function (cmd, args, options) {
        if (this.inVirtualSelectionMode)
            return;
        var keepOrder = options &amp;&amp; options.keepOrder;
        var $byLines = options == true || options &amp;&amp; options.$byLines;
        var session = this.session;
        var selection = this.selection;
        var rangeList = selection.rangeList;
        var ranges = (keepOrder ? selection : rangeList).ranges;
        var result;
        if (!ranges.length)
            return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
        var reg = selection._eventRegistry;
        selection._eventRegistry = {};
        var tmpSel = new Selection(session);
        this.inVirtualSelectionMode = true;
        for (var i = ranges.length; i--;) {
            if ($byLines) {
                while (i &gt; 0 &amp;&amp; ranges[i].start.row == ranges[i - 1].end.row)
                    i--;
            }
            tmpSel.fromOrientedRange(ranges[i]);
            tmpSel.index = i;
            this.selection = session.selection = tmpSel;
            var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
            if (!result &amp;&amp; cmdResult !== undefined)
                result = cmdResult;
            tmpSel.toOrientedRange(ranges[i]);
        }
        tmpSel.detach();
        this.selection = session.selection = selection;
        this.inVirtualSelectionMode = false;
        selection._eventRegistry = reg;
        selection.mergeOverlappingRanges();
        if (selection.ranges[0])
            selection.fromOrientedRange(selection.ranges[0]);
        var anim = this.renderer.$scrollAnimation;
        this.onCursorChange();
        this.onSelectionChange();
        if (anim &amp;&amp; anim.from == anim.to)
            this.renderer.animateScrolling(anim.from);
        return result;
    };
    this.exitMultiSelectMode = function () {
        if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
            return;
        this.multiSelect.toSingleRange();
    };
    this.getSelectedText = function () {
        var text = &quot;&quot;;
        if (this.inMultiSelectMode &amp;&amp; !this.inVirtualSelectionMode) {
            var ranges = this.multiSelect.rangeList.ranges;
            var buf = [];
            for (var i = 0; i &lt; ranges.length; i++) {
                buf.push(this.session.getTextRange(ranges[i]));
            }
            var nl = this.session.getDocument().getNewLineCharacter();
            text = buf.join(nl);
            if (text.length == (buf.length - 1) * nl.length)
                text = &quot;&quot;;
        }
        else if (!this.selection.isEmpty()) {
            text = this.session.getTextRange(this.getSelectionRange());
        }
        return text;
    };
    this.$checkMultiselectChange = function (e, anchor) {
        if (this.inMultiSelectMode &amp;&amp; !this.inVirtualSelectionMode) {
            var range = this.multiSelect.ranges[0];
            if (this.multiSelect.isEmpty() &amp;&amp; anchor == this.multiSelect.anchor)
                return;
            var pos = anchor == this.multiSelect.anchor
                ? range.cursor == range.start ? range.end : range.start
                : range.cursor;
            if (pos.row != anchor.row
                || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)
                this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
            else
                this.multiSelect.mergeOverlappingRanges();
        }
    };
    this.findAll = function (needle, options, additive) {
        options = options || {};
        options.needle = needle || options.needle;
        if (options.needle == undefined) {
            var range = this.selection.isEmpty()
                ? this.selection.getWordRange()
                : this.selection.getRange();
            options.needle = this.session.getTextRange(range);
        }
        this.$search.set(options);
        var ranges = this.$search.findAll(this.session);
        if (!ranges.length)
            return 0;
        var selection = this.multiSelect;
        if (!additive)
            selection.toSingleRange(ranges[0]);
        for (var i = ranges.length; i--;)
            selection.addRange(ranges[i], true);
        if (range &amp;&amp; selection.rangeList.rangeAtPoint(range.start))
            selection.addRange(range, true);
        return ranges.length;
    };
    this.selectMoreLines = function (dir, skip) {
        var range = this.selection.toOrientedRange();
        var isBackwards = range.cursor == range.end;
        var screenLead = this.session.documentToScreenPosition(range.cursor);
        if (this.selection.$desiredColumn)
            screenLead.column = this.selection.$desiredColumn;
        var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);
        if (!range.isEmpty()) {
            var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
            var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
        }
        else {
            var anchor = lead;
        }
        if (isBackwards) {
            var newRange = Range.fromPoints(lead, anchor);
            newRange.cursor = newRange.start;
        }
        else {
            var newRange = Range.fromPoints(anchor, lead);
            newRange.cursor = newRange.end;
        }
        newRange.desiredColumn = screenLead.column;
        if (!this.selection.inMultiSelectMode) {
            this.selection.addRange(range);
        }
        else {
            if (skip)
                var toRemove = range.cursor;
        }
        this.selection.addRange(newRange);
        if (toRemove)
            this.selection.substractPoint(toRemove);
    };
    this.transposeSelections = function (dir) {
        var session = this.session;
        var sel = session.multiSelect;
        var all = sel.ranges;
        for (var i = all.length; i--;) {
            var range = all[i];
            if (range.isEmpty()) {
                var tmp = session.getWordRange(range.start.row, range.start.column);
                range.start.row = tmp.start.row;
                range.start.column = tmp.start.column;
                range.end.row = tmp.end.row;
                range.end.column = tmp.end.column;
            }
        }
        sel.mergeOverlappingRanges();
        var words = [];
        for (var i = all.length; i--;) {
            var range = all[i];
            words.unshift(session.getTextRange(range));
        }
        if (dir &lt; 0)
            words.unshift(words.pop());
        else
            words.push(words.shift());
        for (var i = all.length; i--;) {
            var range = all[i];
            var tmp = range.clone();
            session.replace(range, words[i]);
            range.start.row = tmp.start.row;
            range.start.column = tmp.start.column;
        }
        sel.fromOrientedRange(sel.ranges[0]);
    };
    this.selectMore = function (dir, skip, stopAtFirst) {
        var session = this.session;
        var sel = session.multiSelect;
        var range = sel.toOrientedRange();
        if (range.isEmpty()) {
            range = session.getWordRange(range.start.row, range.start.column);
            range.cursor = dir == -1 ? range.start : range.end;
            this.multiSelect.addRange(range);
            if (stopAtFirst)
                return;
        }
        var needle = session.getTextRange(range);
        var newRange = find(session, needle, dir);
        if (newRange) {
            newRange.cursor = dir == -1 ? newRange.start : newRange.end;
            this.session.unfold(newRange);
            this.multiSelect.addRange(newRange);
            this.renderer.scrollCursorIntoView(null, 0.5);
        }
        if (skip)
            this.multiSelect.substractPoint(range.cursor);
    };
    this.alignCursors = function () {
        var session = this.session;
        var sel = session.multiSelect;
        var ranges = sel.ranges;
        var row = -1;
        var sameRowRanges = ranges.filter(function (r) {
            if (r.cursor.row == row)
                return true;
            row = r.cursor.row;
        });
        if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
            var range = this.selection.getRange();
            var fr = range.start.row, lr = range.end.row;
            var guessRange = fr == lr;
            if (guessRange) {
                var max = this.session.getLength();
                var line;
                do {
                    line = this.session.getLine(lr);
                } while (/[=:]/.test(line) &amp;&amp; ++lr &lt; max);
                do {
                    line = this.session.getLine(fr);
                } while (/[=:]/.test(line) &amp;&amp; --fr &gt; 0);
                if (fr &lt; 0)
                    fr = 0;
                if (lr &gt;= max)
                    lr = max - 1;
            }
            var lines = this.session.removeFullLines(fr, lr);
            lines = this.$reAlignText(lines, guessRange);
            this.session.insert({ row: fr, column: 0 }, lines.join(&quot;\n&quot;) + &quot;\n&quot;);
            if (!guessRange) {
                range.start.column = 0;
                range.end.column = lines[lines.length - 1].length;
            }
            this.selection.setRange(range);
        }
        else {
            sameRowRanges.forEach(function (r) {
                sel.substractPoint(r.cursor);
            });
            var maxCol = 0;
            var minSpace = Infinity;
            var spaceOffsets = ranges.map(function (r) {
                var p = r.cursor;
                var line = session.getLine(p.row);
                var spaceOffset = line.substr(p.column).search(/\S/g);
                if (spaceOffset == -1)
                    spaceOffset = 0;
                if (p.column &gt; maxCol)
                    maxCol = p.column;
                if (spaceOffset &lt; minSpace)
                    minSpace = spaceOffset;
                return spaceOffset;
            });
            ranges.forEach(function (r, i) {
                var p = r.cursor;
                var l = maxCol - p.column;
                var d = spaceOffsets[i] - minSpace;
                if (l &gt; d)
                    session.insert(p, lang.stringRepeat(&quot; &quot;, l - d));
                else
                    session.remove(new Range(p.row, p.column, p.row, p.column - l + d));
                r.start.column = r.end.column = maxCol;
                r.start.row = r.end.row = p.row;
                r.cursor = r.end;
            });
            sel.fromOrientedRange(ranges[0]);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
        }
    };
    this.$reAlignText = function (lines, forceLeft) {
        var isLeftAligned = true, isRightAligned = true;
        var startW, textW, endW;
        return lines.map(function (line) {
            var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
            if (!m)
                return [line];
            if (startW == null) {
                startW = m[1].length;
                textW = m[2].length;
                endW = m[3].length;
                return m;
            }
            if (startW + textW + endW != m[1].length + m[2].length + m[3].length)
                isRightAligned = false;
            if (startW != m[1].length)
                isLeftAligned = false;
            if (startW &gt; m[1].length)
                startW = m[1].length;
            if (textW &lt; m[2].length)
                textW = m[2].length;
            if (endW &gt; m[3].length)
                endW = m[3].length;
            return m;
        }).map(forceLeft ? alignLeft :
            isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);
        function spaces(n) {
            return lang.stringRepeat(&quot; &quot;, n);
        }
        function alignLeft(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2]
                + spaces(textW - m[2].length + endW)
                + m[4].replace(/^([=:])\s+/, &quot;$1 &quot;);
        }
        function alignRight(m) {
            return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2]
                + spaces(endW)
                + m[4].replace(/^([=:])\s+/, &quot;$1 &quot;);
        }
        function unAlign(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2]
                + spaces(endW)
                + m[4].replace(/^([=:])\s+/, &quot;$1 &quot;);
        }
    };
}).call(Editor.prototype);
function isSamePoint(p1, p2) {
    return p1.row == p2.row &amp;&amp; p1.column == p2.column;
}
exports.onSessionChange = function (e) {
    var session = e.session;
    if (session &amp;&amp; !session.multiSelect) {
        session.$selectionMarkers = [];
        session.selection.$initRangeList();
        session.multiSelect = session.selection;
    }
    this.multiSelect = session &amp;&amp; session.multiSelect;
    var oldSession = e.oldSession;
    if (oldSession) {
        oldSession.multiSelect.off(&quot;addRange&quot;, this.$onAddRange);
        oldSession.multiSelect.off(&quot;removeRange&quot;, this.$onRemoveRange);
        oldSession.multiSelect.off(&quot;multiSelect&quot;, this.$onMultiSelect);
        oldSession.multiSelect.off(&quot;singleSelect&quot;, this.$onSingleSelect);
        oldSession.multiSelect.lead.off(&quot;change&quot;, this.$checkMultiselectChange);
        oldSession.multiSelect.anchor.off(&quot;change&quot;, this.$checkMultiselectChange);
    }
    if (session) {
        session.multiSelect.on(&quot;addRange&quot;, this.$onAddRange);
        session.multiSelect.on(&quot;removeRange&quot;, this.$onRemoveRange);
        session.multiSelect.on(&quot;multiSelect&quot;, this.$onMultiSelect);
        session.multiSelect.on(&quot;singleSelect&quot;, this.$onSingleSelect);
        session.multiSelect.lead.on(&quot;change&quot;, this.$checkMultiselectChange);
        session.multiSelect.anchor.on(&quot;change&quot;, this.$checkMultiselectChange);
    }
    if (session &amp;&amp; this.inMultiSelectMode != session.selection.inMultiSelectMode) {
        if (session.selection.inMultiSelectMode)
            this.$onMultiSelect();
        else
            this.$onSingleSelect();
    }
};
function MultiSelect(editor) {
    if (editor.$multiselectOnSessionChange)
        return;
    editor.$onAddRange = editor.$onAddRange.bind(editor);
    editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
    editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
    editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
    editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);
    editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);
    editor.$multiselectOnSessionChange(editor);
    editor.on(&quot;changeSession&quot;, editor.$multiselectOnSessionChange);
    editor.on(&quot;mousedown&quot;, onMouseDown);
    editor.commands.addCommands(commands.defaultCommands);
    addAltCursorListeners(editor);
}
function addAltCursorListeners(editor) {
    if (!editor.textInput)
        return;
    var el = editor.textInput.getElement();
    var altCursor = false;
    event.addListener(el, &quot;keydown&quot;, function (e) {
        var altDown = e.keyCode == 18 &amp;&amp; !(e.ctrlKey || e.shiftKey || e.metaKey);
        if (editor.$blockSelectEnabled &amp;&amp; altDown) {
            if (!altCursor) {
                editor.renderer.setMouseCursor(&quot;crosshair&quot;);
                altCursor = true;
            }
        }
        else if (altCursor) {
            reset();
        }
    }, editor);
    event.addListener(el, &quot;keyup&quot;, reset, editor);
    event.addListener(el, &quot;blur&quot;, reset, editor);
    function reset(e) {
        if (altCursor) {
            editor.renderer.setMouseCursor(&quot;&quot;);
            altCursor = false;
        }
    }
}
exports.MultiSelect = MultiSelect;
require(&quot;./config&quot;).defineOptions(Editor.prototype, &quot;editor&quot;, {
    enableMultiselect: {
        set: function (val) {
            MultiSelect(this);
            if (val) {
                this.on(&quot;changeSession&quot;, this.$multiselectOnSessionChange);
                this.on(&quot;mousedown&quot;, onMouseDown);
            }
            else {
                this.off(&quot;changeSession&quot;, this.$multiselectOnSessionChange);
                this.off(&quot;mousedown&quot;, onMouseDown);
            }
        },
        value: true
    },
    enableBlockSelect: {
        set: function (val) {
            this.$blockSelectEnabled = val;
        },
        value: true
    }
});

});

define(&quot;ace/mode/folding/fold_mode&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/range&quot;], function(require, exports, module){&quot;use strict&quot;;
var Range = require(&quot;../../range&quot;).Range;
var FoldMode = exports.FoldMode = function () { };
(function () {
    this.foldingStartMarker = null;
    this.foldingStopMarker = null;
    this.getFoldWidget = function (session, foldStyle, row) {
        var line = session.getLine(row);
        if (this.foldingStartMarker.test(line))
            return &quot;start&quot;;
        if (foldStyle == &quot;markbeginend&quot;
            &amp;&amp; this.foldingStopMarker
            &amp;&amp; this.foldingStopMarker.test(line))
            return &quot;end&quot;;
        return &quot;&quot;;
    };
    this.getFoldWidgetRange = function (session, foldStyle, row) {
        return null;
    };
    this.indentationBlock = function (session, row, column) {
        var re = /\S/;
        var line = session.getLine(row);
        var startLevel = line.search(re);
        if (startLevel == -1)
            return;
        var startColumn = column || line.length;
        var maxRow = session.getLength();
        var startRow = row;
        var endRow = row;
        while (++row &lt; maxRow) {
            var level = session.getLine(row).search(re);
            if (level == -1)
                continue;
            if (level &lt;= startLevel) {
                var token = session.getTokenAt(row, 0);
                if (!token || token.type !== &quot;string&quot;)
                    break;
            }
            endRow = row;
        }
        if (endRow &gt; startRow) {
            var endColumn = session.getLine(endRow).length;
            return new Range(startRow, startColumn, endRow, endColumn);
        }
    };
    this.openingBracketBlock = function (session, bracket, row, column, typeRe) {
        var start = { row: row, column: column + 1 };
        var end = session.$findClosingBracket(bracket, start, typeRe);
        if (!end)
            return;
        var fw = session.foldWidgets[end.row];
        if (fw == null)
            fw = session.getFoldWidget(end.row);
        if (fw == &quot;start&quot; &amp;&amp; end.row &gt; start.row) {
            end.row--;
            end.column = session.getLine(end.row).length;
        }
        return Range.fromPoints(start, end);
    };
    this.closingBracketBlock = function (session, bracket, row, column, typeRe) {
        var end = { row: row, column: column };
        var start = session.$findOpeningBracket(bracket, end);
        if (!start)
            return;
        start.column++;
        end.column--;
        return Range.fromPoints(start, end);
    };
}).call(FoldMode.prototype);

});

define(&quot;ace/line_widgets&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/dom&quot;], function(require, exports, module){&quot;use strict&quot;;
var dom = require(&quot;./lib/dom&quot;);
function LineWidgets(session) {
    this.session = session;
    this.session.widgetManager = this;
    this.session.getRowLength = this.getRowLength;
    this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
    this.updateOnChange = this.updateOnChange.bind(this);
    this.renderWidgets = this.renderWidgets.bind(this);
    this.measureWidgets = this.measureWidgets.bind(this);
    this.session._changedWidgets = [];
    this.$onChangeEditor = this.$onChangeEditor.bind(this);
    this.session.on(&quot;change&quot;, this.updateOnChange);
    this.session.on(&quot;changeFold&quot;, this.updateOnFold);
    this.session.on(&quot;changeEditor&quot;, this.$onChangeEditor);
}
(function () {
    this.getRowLength = function (row) {
        var h;
        if (this.lineWidgets)
            h = this.lineWidgets[row] &amp;&amp; this.lineWidgets[row].rowCount || 0;
        else
            h = 0;
        if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1 + h;
        }
        else {
            return this.$wrapData[row].length + 1 + h;
        }
    };
    this.$getWidgetScreenLength = function () {
        var screenRows = 0;
        this.lineWidgets.forEach(function (w) {
            if (w &amp;&amp; w.rowCount &amp;&amp; !w.hidden)
                screenRows += w.rowCount;
        });
        return screenRows;
    };
    this.$onChangeEditor = function (e) {
        this.attach(e.editor);
    };
    this.attach = function (editor) {
        if (editor &amp;&amp; editor.widgetManager &amp;&amp; editor.widgetManager != this)
            editor.widgetManager.detach();
        if (this.editor == editor)
            return;
        this.detach();
        this.editor = editor;
        if (editor) {
            editor.widgetManager = this;
            editor.renderer.on(&quot;beforeRender&quot;, this.measureWidgets);
            editor.renderer.on(&quot;afterRender&quot;, this.renderWidgets);
        }
    };
    this.detach = function (e) {
        var editor = this.editor;
        if (!editor)
            return;
        this.editor = null;
        editor.widgetManager = null;
        editor.renderer.off(&quot;beforeRender&quot;, this.measureWidgets);
        editor.renderer.off(&quot;afterRender&quot;, this.renderWidgets);
        var lineWidgets = this.session.lineWidgets;
        lineWidgets &amp;&amp; lineWidgets.forEach(function (w) {
            if (w &amp;&amp; w.el &amp;&amp; w.el.parentNode) {
                w._inDocument = false;
                w.el.parentNode.removeChild(w.el);
            }
        });
    };
    this.updateOnFold = function (e, session) {
        var lineWidgets = session.lineWidgets;
        if (!lineWidgets || !e.action)
            return;
        var fold = e.data;
        var start = fold.start.row;
        var end = fold.end.row;
        var hide = e.action == &quot;add&quot;;
        for (var i = start + 1; i &lt; end; i++) {
            if (lineWidgets[i])
                lineWidgets[i].hidden = hide;
        }
        if (lineWidgets[end]) {
            if (hide) {
                if (!lineWidgets[start])
                    lineWidgets[start] = lineWidgets[end];
                else
                    lineWidgets[end].hidden = hide;
            }
            else {
                if (lineWidgets[start] == lineWidgets[end])
                    lineWidgets[start] = undefined;
                lineWidgets[end].hidden = hide;
            }
        }
    };
    this.updateOnChange = function (delta) {
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets)
            return;
        var startRow = delta.start.row;
        var len = delta.end.row - startRow;
        if (len === 0) {
        }
        else if (delta.action == &quot;remove&quot;) {
            var removed = lineWidgets.splice(startRow + 1, len);
            if (!lineWidgets[startRow] &amp;&amp; removed[removed.length - 1]) {
                lineWidgets[startRow] = removed.pop();
            }
            removed.forEach(function (w) {
                w &amp;&amp; this.removeLineWidget(w);
            }, this);
            this.$updateRows();
        }
        else {
            var args = new Array(len);
            if (lineWidgets[startRow] &amp;&amp; lineWidgets[startRow].column != null) {
                if (delta.start.column &gt; lineWidgets[startRow].column)
                    startRow++;
            }
            args.unshift(startRow, 0);
            lineWidgets.splice.apply(lineWidgets, args);
            this.$updateRows();
        }
    };
    this.$updateRows = function () {
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets)
            return;
        var noWidgets = true;
        lineWidgets.forEach(function (w, i) {
            if (w) {
                noWidgets = false;
                w.row = i;
                while (w.$oldWidget) {
                    w.$oldWidget.row = i;
                    w = w.$oldWidget;
                }
            }
        });
        if (noWidgets)
            this.session.lineWidgets = null;
    };
    this.$registerLineWidget = function (w) {
        if (!this.session.lineWidgets)
            this.session.lineWidgets = new Array(this.session.getLength());
        var old = this.session.lineWidgets[w.row];
        if (old) {
            w.$oldWidget = old;
            if (old.el &amp;&amp; old.el.parentNode) {
                old.el.parentNode.removeChild(old.el);
                old._inDocument = false;
            }
        }
        this.session.lineWidgets[w.row] = w;
        return w;
    };
    this.addLineWidget = function (w) {
        this.$registerLineWidget(w);
        w.session = this.session;
        if (!this.editor)
            return w;
        var renderer = this.editor.renderer;
        if (w.html &amp;&amp; !w.el) {
            w.el = dom.createElement(&quot;div&quot;);
            w.el.innerHTML = w.html;
        }
        if (w.el) {
            dom.addCssClass(w.el, &quot;ace_lineWidgetContainer&quot;);
            w.el.style.position = &quot;absolute&quot;;
            w.el.style.zIndex = 5;
            renderer.container.appendChild(w.el);
            w._inDocument = true;
            if (!w.coverGutter) {
                w.el.style.zIndex = 3;
            }
            if (w.pixelHeight == null) {
                w.pixelHeight = w.el.offsetHeight;
            }
        }
        if (w.rowCount == null) {
            w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
        }
        var fold = this.session.getFoldAt(w.row, 0);
        w.$fold = fold;
        if (fold) {
            var lineWidgets = this.session.lineWidgets;
            if (w.row == fold.end.row &amp;&amp; !lineWidgets[fold.start.row])
                lineWidgets[fold.start.row] = w;
            else
                w.hidden = true;
        }
        this.session._emit(&quot;changeFold&quot;, { data: { start: { row: w.row } } });
        this.$updateRows();
        this.renderWidgets(null, renderer);
        this.onWidgetChanged(w);
        return w;
    };
    this.removeLineWidget = function (w) {
        w._inDocument = false;
        w.session = null;
        if (w.el &amp;&amp; w.el.parentNode)
            w.el.parentNode.removeChild(w.el);
        if (w.editor &amp;&amp; w.editor.destroy)
            try {
                w.editor.destroy();
            }
            catch (e) { }
        if (this.session.lineWidgets) {
            var w1 = this.session.lineWidgets[w.row];
            if (w1 == w) {
                this.session.lineWidgets[w.row] = w.$oldWidget;
                if (w.$oldWidget)
                    this.onWidgetChanged(w.$oldWidget);
            }
            else {
                while (w1) {
                    if (w1.$oldWidget == w) {
                        w1.$oldWidget = w.$oldWidget;
                        break;
                    }
                    w1 = w1.$oldWidget;
                }
            }
        }
        this.session._emit(&quot;changeFold&quot;, { data: { start: { row: w.row } } });
        this.$updateRows();
    };
    this.getWidgetsAtRow = function (row) {
        var lineWidgets = this.session.lineWidgets;
        var w = lineWidgets &amp;&amp; lineWidgets[row];
        var list = [];
        while (w) {
            list.push(w);
            w = w.$oldWidget;
        }
        return list;
    };
    this.onWidgetChanged = function (w) {
        this.session._changedWidgets.push(w);
        this.editor &amp;&amp; this.editor.renderer.updateFull();
    };
    this.measureWidgets = function (e, renderer) {
        var changedWidgets = this.session._changedWidgets;
        var config = renderer.layerConfig;
        if (!changedWidgets || !changedWidgets.length)
            return;
        var min = Infinity;
        for (var i = 0; i &lt; changedWidgets.length; i++) {
            var w = changedWidgets[i];
            if (!w || !w.el)
                continue;
            if (w.session != this.session)
                continue;
            if (!w._inDocument) {
                if (this.session.lineWidgets[w.row] != w)
                    continue;
                w._inDocument = true;
                renderer.container.appendChild(w.el);
            }
            w.h = w.el.offsetHeight;
            if (!w.fixedWidth) {
                w.w = w.el.offsetWidth;
                w.screenWidth = Math.ceil(w.w / config.characterWidth);
            }
            var rowCount = w.h / config.lineHeight;
            if (w.coverLine) {
                rowCount -= this.session.getRowLineCount(w.row);
                if (rowCount &lt; 0)
                    rowCount = 0;
            }
            if (w.rowCount != rowCount) {
                w.rowCount = rowCount;
                if (w.row &lt; min)
                    min = w.row;
            }
        }
        if (min != Infinity) {
            this.session._emit(&quot;changeFold&quot;, { data: { start: { row: min } } });
            this.session.lineWidgetWidth = null;
        }
        this.session._changedWidgets = [];
    };
    this.renderWidgets = function (e, renderer) {
        var config = renderer.layerConfig;
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets)
            return;
        var first = Math.min(this.firstRow, config.firstRow);
        var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);
        while (first &gt; 0 &amp;&amp; !lineWidgets[first])
            first--;
        this.firstRow = config.firstRow;
        this.lastRow = config.lastRow;
        renderer.$cursorLayer.config = config;
        for (var i = first; i &lt;= last; i++) {
            var w = lineWidgets[i];
            if (!w || !w.el)
                continue;
            if (w.hidden) {
                w.el.style.top = -100 - (w.pixelHeight || 0) + &quot;px&quot;;
                continue;
            }
            if (!w._inDocument) {
                w._inDocument = true;
                renderer.container.appendChild(w.el);
            }
            var top = renderer.$cursorLayer.getPixelPosition({ row: i, column: 0 }, true).top;
            if (!w.coverLine)
                top += config.lineHeight * this.session.getRowLineCount(w.row);
            w.el.style.top = top - config.offset + &quot;px&quot;;
            var left = w.coverGutter ? 0 : renderer.gutterWidth;
            if (!w.fixedWidth)
                left -= renderer.scrollLeft;
            w.el.style.left = left + &quot;px&quot;;
            if (w.fullWidth &amp;&amp; w.screenWidth) {
                w.el.style.minWidth = config.width + 2 * config.padding + &quot;px&quot;;
            }
            if (w.fixedWidth) {
                w.el.style.right = renderer.scrollBar.getWidth() + &quot;px&quot;;
            }
            else {
                w.el.style.right = &quot;&quot;;
            }
        }
    };
}).call(LineWidgets.prototype);
exports.LineWidgets = LineWidgets;

});

define(&quot;ace/ext/error_marker&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/line_widgets&quot;,&quot;ace/lib/dom&quot;,&quot;ace/range&quot;], function(require, exports, module){&quot;use strict&quot;;
var LineWidgets = require(&quot;../line_widgets&quot;).LineWidgets;
var dom = require(&quot;../lib/dom&quot;);
var Range = require(&quot;../range&quot;).Range;
function binarySearch(array, needle, comparator) {
    var first = 0;
    var last = array.length - 1;
    while (first &lt;= last) {
        var mid = (first + last) &gt;&gt; 1;
        var c = comparator(needle, array[mid]);
        if (c &gt; 0)
            first = mid + 1;
        else if (c &lt; 0)
            last = mid - 1;
        else
            return mid;
    }
    return -(first + 1);
}
function findAnnotations(session, row, dir) {
    var annotations = session.getAnnotations().sort(Range.comparePoints);
    if (!annotations.length)
        return;
    var i = binarySearch(annotations, { row: row, column: -1 }, Range.comparePoints);
    if (i &lt; 0)
        i = -i - 1;
    if (i &gt;= annotations.length)
        i = dir &gt; 0 ? 0 : annotations.length - 1;
    else if (i === 0 &amp;&amp; dir &lt; 0)
        i = annotations.length - 1;
    var annotation = annotations[i];
    if (!annotation || !dir)
        return;
    if (annotation.row === row) {
        do {
            annotation = annotations[i += dir];
        } while (annotation &amp;&amp; annotation.row === row);
        if (!annotation)
            return annotations.slice();
    }
    var matched = [];
    row = annotation.row;
    do {
        matched[dir &lt; 0 ? &quot;unshift&quot; : &quot;push&quot;](annotation);
        annotation = annotations[i += dir];
    } while (annotation &amp;&amp; annotation.row == row);
    return matched.length &amp;&amp; matched;
}
exports.showErrorMarker = function (editor, dir) {
    var session = editor.session;
    if (!session.widgetManager) {
        session.widgetManager = new LineWidgets(session);
        session.widgetManager.attach(editor);
    }
    var pos = editor.getCursorPosition();
    var row = pos.row;
    var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function (w) {
        return w.type == &quot;errorMarker&quot;;
    })[0];
    if (oldWidget) {
        oldWidget.destroy();
    }
    else {
        row -= dir;
    }
    var annotations = findAnnotations(session, row, dir);
    var gutterAnno;
    if (annotations) {
        var annotation = annotations[0];
        pos.column = (annotation.pos &amp;&amp; typeof annotation.column != &quot;number&quot;
            ? annotation.pos.sc
            : annotation.column) || 0;
        pos.row = annotation.row;
        gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
    }
    else if (oldWidget) {
        return;
    }
    else {
        gutterAnno = {
            text: [&quot;Looks good!&quot;],
            className: &quot;ace_ok&quot;
        };
    }
    editor.session.unfold(pos.row);
    editor.selection.moveToPosition(pos);
    var w = {
        row: pos.row,
        fixedWidth: true,
        coverGutter: true,
        el: dom.createElement(&quot;div&quot;),
        type: &quot;errorMarker&quot;
    };
    var el = w.el.appendChild(dom.createElement(&quot;div&quot;));
    var arrow = w.el.appendChild(dom.createElement(&quot;div&quot;));
    arrow.className = &quot;error_widget_arrow &quot; + gutterAnno.className;
    var left = editor.renderer.$cursorLayer
        .getPixelPosition(pos).left;
    arrow.style.left = left + editor.renderer.gutterWidth - 5 + &quot;px&quot;;
    w.el.className = &quot;error_widget_wrapper&quot;;
    el.className = &quot;error_widget &quot; + gutterAnno.className;
    el.innerHTML = gutterAnno.text.join(&quot;&lt;br&gt;&quot;);
    el.appendChild(dom.createElement(&quot;div&quot;));
    var kb = function (_, hashId, keyString) {
        if (hashId === 0 &amp;&amp; (keyString === &quot;esc&quot; || keyString === &quot;return&quot;)) {
            w.destroy();
            return { command: &quot;null&quot; };
        }
    };
    w.destroy = function () {
        if (editor.$mouseHandler.isMousePressed)
            return;
        editor.keyBinding.removeKeyboardHandler(kb);
        session.widgetManager.removeLineWidget(w);
        editor.off(&quot;changeSelection&quot;, w.destroy);
        editor.off(&quot;changeSession&quot;, w.destroy);
        editor.off(&quot;mouseup&quot;, w.destroy);
        editor.off(&quot;change&quot;, w.destroy);
    };
    editor.keyBinding.addKeyboardHandler(kb);
    editor.on(&quot;changeSelection&quot;, w.destroy);
    editor.on(&quot;changeSession&quot;, w.destroy);
    editor.on(&quot;mouseup&quot;, w.destroy);
    editor.on(&quot;change&quot;, w.destroy);
    editor.session.widgetManager.addLineWidget(w);
    w.el.onmousedown = editor.focus.bind(editor);
    editor.renderer.scrollCursorIntoView(null, 0.5, { bottom: w.el.offsetHeight });
};
dom.importCssString(&quot;\n    .error_widget_wrapper {\n        background: inherit;\n        color: inherit;\n        border:none\n    }\n    .error_widget {\n        border-top: solid 2px;\n        border-bottom: solid 2px;\n        margin: 5px 0;\n        padding: 10px 40px;\n        white-space: pre-wrap;\n    }\n    .error_widget.ace_error, .error_widget_arrow.ace_error{\n        border-color: #ff5a5a\n    }\n    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\n        border-color: #F1D817\n    }\n    .error_widget.ace_info, .error_widget_arrow.ace_info{\n        border-color: #5a5a5a\n    }\n    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\n        border-color: #5aaa5a\n    }\n    .error_widget_arrow {\n        position: absolute;\n        border: solid 5px;\n        border-top-color: transparent!important;\n        border-right-color: transparent!important;\n        border-left-color: transparent!important;\n        top: -5px;\n    }\n&quot;, &quot;error_marker.css&quot;, false);

});

define(&quot;ace/ace&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/dom&quot;,&quot;ace/lib/event&quot;,&quot;ace/range&quot;,&quot;ace/editor&quot;,&quot;ace/edit_session&quot;,&quot;ace/undomanager&quot;,&quot;ace/virtual_renderer&quot;,&quot;ace/worker/worker_client&quot;,&quot;ace/keyboard/hash_handler&quot;,&quot;ace/placeholder&quot;,&quot;ace/multi_select&quot;,&quot;ace/mode/folding/fold_mode&quot;,&quot;ace/theme/textmate&quot;,&quot;ace/ext/error_marker&quot;,&quot;ace/config&quot;,&quot;ace/loader_build&quot;], function(require, exports, module){/**
 * The main class required to set up an Ace instance in the browser.
 *
 * @class Ace
 **/
&quot;use strict&quot;;
require(&quot;./loader_build&quot;)(exports)
var dom = require(&quot;./lib/dom&quot;);
var event = require(&quot;./lib/event&quot;);
var Range = require(&quot;./range&quot;).Range;
var Editor = require(&quot;./editor&quot;).Editor;
var EditSession = require(&quot;./edit_session&quot;).EditSession;
var UndoManager = require(&quot;./undomanager&quot;).UndoManager;
var Renderer = require(&quot;./virtual_renderer&quot;).VirtualRenderer;
require(&quot;./worker/worker_client&quot;);
require(&quot;./keyboard/hash_handler&quot;);
require(&quot;./placeholder&quot;);
require(&quot;./multi_select&quot;);
require(&quot;./mode/folding/fold_mode&quot;);
require(&quot;./theme/textmate&quot;);
require(&quot;./ext/error_marker&quot;);
exports.config = require(&quot;./config&quot;);
exports.edit = function (el, options) {
    if (typeof el == &quot;string&quot;) {
        var _id = el;
        el = document.getElementById(_id);
        if (!el)
            throw new Error(&quot;ace.edit can&#039;t find div #&quot; + _id);
    }
    if (el &amp;&amp; el.env &amp;&amp; el.env.editor instanceof Editor)
        return el.env.editor;
    var value = &quot;&quot;;
    if (el &amp;&amp; /input|textarea/i.test(el.tagName)) {
        var oldNode = el;
        value = oldNode.value;
        el = dom.createElement(&quot;pre&quot;);
        oldNode.parentNode.replaceChild(el, oldNode);
    }
    else if (el) {
        value = el.textContent;
        el.innerHTML = &quot;&quot;;
    }
    var doc = exports.createEditSession(value);
    var editor = new Editor(new Renderer(el), doc, options);
    var env = {
        document: doc,
        editor: editor,
        onResize: editor.resize.bind(editor, null)
    };
    if (oldNode)
        env.textarea = oldNode;
    event.addListener(window, &quot;resize&quot;, env.onResize);
    editor.on(&quot;destroy&quot;, function () {
        event.removeListener(window, &quot;resize&quot;, env.onResize);
        env.editor.container.env = null; // prevent memory leak on old ie
    });
    editor.container.env = editor.env = env;
    return editor;
};
exports.createEditSession = function (text, mode) {
    var doc = new EditSession(text, mode);
    doc.setUndoManager(new UndoManager());
    return doc;
};
exports.Range = Range;
exports.Editor = Editor;
exports.EditSession = EditSession;
exports.UndoManager = UndoManager;
exports.VirtualRenderer = Renderer;
exports.version = exports.config.version;

});            (function() {
                window.require([&quot;ace/ace&quot;], function(a) {
                    if (a) {
                        a.config.init(true);
                        a.define = window.define;
                    }
                    if (!window.ace)
                        window.ace = a;
                    for (var key in a) if (a.hasOwnProperty(key))
                        window.ace[key] = a[key];
                    window.ace[&quot;default&quot;] = window.ace;
                    if (typeof module == &quot;object&quot; &amp;&amp; typeof exports == &quot;object&quot; &amp;&amp; module) {
                        module.exports = window.ace;
                    }
                });
            })();</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
