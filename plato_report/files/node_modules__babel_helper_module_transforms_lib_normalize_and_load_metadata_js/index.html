<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">60.57</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">354</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">69.74</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.08</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

Object.defineProperty(exports, &quot;__esModule&quot;, {
  value: true
});
exports.default = normalizeModuleAndLoadMetadata;
exports.hasExports = hasExports;
exports.isSideEffectImport = isSideEffectImport;
exports.validateImportInteropOption = validateImportInteropOption;
var _path = require(&quot;path&quot;);
var _helperValidatorIdentifier = require(&quot;@babel/helper-validator-identifier&quot;);
var _helperSplitExportDeclaration = require(&quot;@babel/helper-split-export-declaration&quot;);
function hasExports(metadata) {
  return metadata.hasExports;
}
function isSideEffectImport(source) {
  return source.imports.size === 0 &amp;&amp; source.importsNamespace.size === 0 &amp;&amp; source.reexports.size === 0 &amp;&amp; source.reexportNamespace.size === 0 &amp;&amp; !source.reexportAll;
}
function validateImportInteropOption(importInterop) {
  if (typeof importInterop !== &quot;function&quot; &amp;&amp; importInterop !== &quot;none&quot; &amp;&amp; importInterop !== &quot;babel&quot; &amp;&amp; importInterop !== &quot;node&quot;) {
    throw new Error(`.importInterop must be one of &quot;none&quot;, &quot;babel&quot;, &quot;node&quot;, or a function returning one of those values (received ${importInterop}).`);
  }
  return importInterop;
}
function resolveImportInterop(importInterop, source, filename) {
  if (typeof importInterop === &quot;function&quot;) {
    return validateImportInteropOption(importInterop(source, filename));
  }
  return importInterop;
}
function normalizeModuleAndLoadMetadata(programPath, exportName, {
  importInterop,
  initializeReexports = false,
  lazy = false,
  esNamespaceOnly = false,
  filename
}) {
  if (!exportName) {
    exportName = programPath.scope.generateUidIdentifier(&quot;exports&quot;).name;
  }
  const stringSpecifiers = new Set();
  nameAnonymousExports(programPath);
  const {
    local,
    sources,
    hasExports
  } = getModuleMetadata(programPath, {
    initializeReexports,
    lazy
  }, stringSpecifiers);
  removeImportExportDeclarations(programPath);
  for (const [source, metadata] of sources) {
    if (metadata.importsNamespace.size &gt; 0) {
      metadata.name = metadata.importsNamespace.values().next().value;
    }
    const resolvedInterop = resolveImportInterop(importInterop, source, filename);
    if (resolvedInterop === &quot;none&quot;) {
      metadata.interop = &quot;none&quot;;
    } else if (resolvedInterop === &quot;node&quot; &amp;&amp; metadata.interop === &quot;namespace&quot;) {
      metadata.interop = &quot;node-namespace&quot;;
    } else if (resolvedInterop === &quot;node&quot; &amp;&amp; metadata.interop === &quot;default&quot;) {
      metadata.interop = &quot;node-default&quot;;
    } else if (esNamespaceOnly &amp;&amp; metadata.interop === &quot;namespace&quot;) {
      metadata.interop = &quot;default&quot;;
    }
  }
  return {
    exportName,
    exportNameListName: null,
    hasExports,
    local,
    source: sources,
    stringSpecifiers
  };
}
function getExportSpecifierName(path, stringSpecifiers) {
  if (path.isIdentifier()) {
    return path.node.name;
  } else if (path.isStringLiteral()) {
    const stringValue = path.node.value;
    if (!(0, _helperValidatorIdentifier.isIdentifierName)(stringValue)) {
      stringSpecifiers.add(stringValue);
    }
    return stringValue;
  } else {
    throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${path.node.type}`);
  }
}
function assertExportSpecifier(path) {
  if (path.isExportSpecifier()) {
    return;
  } else if (path.isExportNamespaceSpecifier()) {
    throw path.buildCodeFrameError(&quot;Export namespace should be first transformed by `@babel/plugin-proposal-export-namespace-from`.&quot;);
  } else {
    throw path.buildCodeFrameError(&quot;Unexpected export specifier type&quot;);
  }
}
function getModuleMetadata(programPath, {
  lazy,
  initializeReexports
}, stringSpecifiers) {
  const localData = getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers);
  const sourceData = new Map();
  const getData = sourceNode =&gt; {
    const source = sourceNode.value;
    let data = sourceData.get(source);
    if (!data) {
      data = {
        name: programPath.scope.generateUidIdentifier((0, _path.basename)(source, (0, _path.extname)(source))).name,
        interop: &quot;none&quot;,
        loc: null,
        imports: new Map(),
        importsNamespace: new Set(),
        reexports: new Map(),
        reexportNamespace: new Set(),
        reexportAll: null,
        lazy: false,
        referenced: false
      };
      sourceData.set(source, data);
    }
    return data;
  };
  let hasExports = false;
  programPath.get(&quot;body&quot;).forEach(child =&gt; {
    if (child.isImportDeclaration()) {
      const data = getData(child.node.source);
      if (!data.loc) data.loc = child.node.loc;
      child.get(&quot;specifiers&quot;).forEach(spec =&gt; {
        if (spec.isImportDefaultSpecifier()) {
          const localName = spec.get(&quot;local&quot;).node.name;
          data.imports.set(localName, &quot;default&quot;);
          const reexport = localData.get(localName);
          if (reexport) {
            localData.delete(localName);
            reexport.names.forEach(name =&gt; {
              data.reexports.set(name, &quot;default&quot;);
            });
            data.referenced = true;
          }
        } else if (spec.isImportNamespaceSpecifier()) {
          const localName = spec.get(&quot;local&quot;).node.name;
          data.importsNamespace.add(localName);
          const reexport = localData.get(localName);
          if (reexport) {
            localData.delete(localName);
            reexport.names.forEach(name =&gt; {
              data.reexportNamespace.add(name);
            });
            data.referenced = true;
          }
        } else if (spec.isImportSpecifier()) {
          const importName = getExportSpecifierName(spec.get(&quot;imported&quot;), stringSpecifiers);
          const localName = spec.get(&quot;local&quot;).node.name;
          data.imports.set(localName, importName);
          const reexport = localData.get(localName);
          if (reexport) {
            localData.delete(localName);
            reexport.names.forEach(name =&gt; {
              data.reexports.set(name, importName);
            });
            data.referenced = true;
          }
        }
      });
    } else if (child.isExportAllDeclaration()) {
      hasExports = true;
      const data = getData(child.node.source);
      if (!data.loc) data.loc = child.node.loc;
      data.reexportAll = {
        loc: child.node.loc
      };
      data.referenced = true;
    } else if (child.isExportNamedDeclaration() &amp;&amp; child.node.source) {
      hasExports = true;
      const data = getData(child.node.source);
      if (!data.loc) data.loc = child.node.loc;
      child.get(&quot;specifiers&quot;).forEach(spec =&gt; {
        assertExportSpecifier(spec);
        const importName = getExportSpecifierName(spec.get(&quot;local&quot;), stringSpecifiers);
        const exportName = getExportSpecifierName(spec.get(&quot;exported&quot;), stringSpecifiers);
        data.reexports.set(exportName, importName);
        data.referenced = true;
        if (exportName === &quot;__esModule&quot;) {
          throw spec.get(&quot;exported&quot;).buildCodeFrameError(&#039;Illegal export &quot;__esModule&quot;.&#039;);
        }
      });
    } else if (child.isExportNamedDeclaration() || child.isExportDefaultDeclaration()) {
      hasExports = true;
    }
  });
  for (const metadata of sourceData.values()) {
    let needsDefault = false;
    let needsNamed = false;
    if (metadata.importsNamespace.size &gt; 0) {
      needsDefault = true;
      needsNamed = true;
    }
    if (metadata.reexportAll) {
      needsNamed = true;
    }
    for (const importName of metadata.imports.values()) {
      if (importName === &quot;default&quot;) needsDefault = true;else needsNamed = true;
    }
    for (const importName of metadata.reexports.values()) {
      if (importName === &quot;default&quot;) needsDefault = true;else needsNamed = true;
    }
    if (needsDefault &amp;&amp; needsNamed) {
      metadata.interop = &quot;namespace&quot;;
    } else if (needsDefault) {
      metadata.interop = &quot;default&quot;;
    }
  }
  for (const [source, metadata] of sourceData) {
    if (lazy !== false &amp;&amp; !(isSideEffectImport(metadata) || metadata.reexportAll)) {
      if (lazy === true) {
        metadata.lazy = !/\./.test(source);
      } else if (Array.isArray(lazy)) {
        metadata.lazy = lazy.indexOf(source) !== -1;
      } else if (typeof lazy === &quot;function&quot;) {
        metadata.lazy = lazy(source);
      } else {
        throw new Error(`.lazy must be a boolean, string array, or function`);
      }
    }
  }
  return {
    hasExports,
    local: localData,
    sources: sourceData
  };
}
function getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers) {
  const bindingKindLookup = new Map();
  programPath.get(&quot;body&quot;).forEach(child =&gt; {
    let kind;
    if (child.isImportDeclaration()) {
      kind = &quot;import&quot;;
    } else {
      if (child.isExportDefaultDeclaration()) {
        child = child.get(&quot;declaration&quot;);
      }
      if (child.isExportNamedDeclaration()) {
        if (child.node.declaration) {
          child = child.get(&quot;declaration&quot;);
        } else if (initializeReexports &amp;&amp; child.node.source &amp;&amp; child.get(&quot;source&quot;).isStringLiteral()) {
          child.get(&quot;specifiers&quot;).forEach(spec =&gt; {
            assertExportSpecifier(spec);
            bindingKindLookup.set(spec.get(&quot;local&quot;).node.name, &quot;block&quot;);
          });
          return;
        }
      }
      if (child.isFunctionDeclaration()) {
        kind = &quot;hoisted&quot;;
      } else if (child.isClassDeclaration()) {
        kind = &quot;block&quot;;
      } else if (child.isVariableDeclaration({
        kind: &quot;var&quot;
      })) {
        kind = &quot;var&quot;;
      } else if (child.isVariableDeclaration()) {
        kind = &quot;block&quot;;
      } else {
        return;
      }
    }
    Object.keys(child.getOuterBindingIdentifiers()).forEach(name =&gt; {
      bindingKindLookup.set(name, kind);
    });
  });
  const localMetadata = new Map();
  const getLocalMetadata = idPath =&gt; {
    const localName = idPath.node.name;
    let metadata = localMetadata.get(localName);
    if (!metadata) {
      const kind = bindingKindLookup.get(localName);
      if (kind === undefined) {
        throw idPath.buildCodeFrameError(`Exporting local &quot;${localName}&quot;, which is not declared.`);
      }
      metadata = {
        names: [],
        kind
      };
      localMetadata.set(localName, metadata);
    }
    return metadata;
  };
  programPath.get(&quot;body&quot;).forEach(child =&gt; {
    if (child.isExportNamedDeclaration() &amp;&amp; (initializeReexports || !child.node.source)) {
      if (child.node.declaration) {
        const declaration = child.get(&quot;declaration&quot;);
        const ids = declaration.getOuterBindingIdentifierPaths();
        Object.keys(ids).forEach(name =&gt; {
          if (name === &quot;__esModule&quot;) {
            throw declaration.buildCodeFrameError(&#039;Illegal export &quot;__esModule&quot;.&#039;);
          }
          getLocalMetadata(ids[name]).names.push(name);
        });
      } else {
        child.get(&quot;specifiers&quot;).forEach(spec =&gt; {
          const local = spec.get(&quot;local&quot;);
          const exported = spec.get(&quot;exported&quot;);
          const localMetadata = getLocalMetadata(local);
          const exportName = getExportSpecifierName(exported, stringSpecifiers);
          if (exportName === &quot;__esModule&quot;) {
            throw exported.buildCodeFrameError(&#039;Illegal export &quot;__esModule&quot;.&#039;);
          }
          localMetadata.names.push(exportName);
        });
      }
    } else if (child.isExportDefaultDeclaration()) {
      const declaration = child.get(&quot;declaration&quot;);
      if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {
        getLocalMetadata(declaration.get(&quot;id&quot;)).names.push(&quot;default&quot;);
      } else {
        throw declaration.buildCodeFrameError(&quot;Unexpected default expression export.&quot;);
      }
    }
  });
  return localMetadata;
}
function nameAnonymousExports(programPath) {
  programPath.get(&quot;body&quot;).forEach(child =&gt; {
    if (!child.isExportDefaultDeclaration()) return;
    (0, _helperSplitExportDeclaration.default)(child);
  });
}
function removeImportExportDeclarations(programPath) {
  programPath.get(&quot;body&quot;).forEach(child =&gt; {
    if (child.isImportDeclaration()) {
      child.remove();
    } else if (child.isExportNamedDeclaration()) {
      if (child.node.declaration) {
        child.node.declaration._blockHoist = child.node._blockHoist;
        child.replaceWith(child.node.declaration);
      } else {
        child.remove();
      }
    } else if (child.isExportDefaultDeclaration()) {
      const declaration = child.get(&quot;declaration&quot;);
      if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {
        declaration._blockHoist = child.node._blockHoist;
        child.replaceWith(declaration);
      } else {
        throw declaration.buildCodeFrameError(&quot;Unexpected default expression export.&quot;);
      }
    } else if (child.isExportAllDeclaration()) {
      child.remove();
    }
  });
}

//# sourceMappingURL=normalize-and-load-metadata.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
