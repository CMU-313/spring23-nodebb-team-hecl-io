<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@typescript-eslint/eslint-plugin/dist/rules/prefer-optional-chain.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@typescript-eslint/eslint-plugin/dist/rules/prefer-optional-chain.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">60.03</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">488</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">78.93</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.70</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
var __createBinding = (this &amp;&amp; this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (&quot;get&quot; in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this &amp;&amp; this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, &quot;default&quot;, { enumerable: true, value: v });
}) : function(o, v) {
    o[&quot;default&quot;] = v;
});
var __importStar = (this &amp;&amp; this.__importStar) || function (mod) {
    if (mod &amp;&amp; mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== &quot;default&quot; &amp;&amp; Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
const utils_1 = require(&quot;@typescript-eslint/utils&quot;);
const tsutils_1 = require(&quot;tsutils&quot;);
const ts = __importStar(require(&quot;typescript&quot;));
const util = __importStar(require(&quot;../util&quot;));
/*
The AST is always constructed such the first element is always the deepest element.
I.e. for this code: `foo &amp;&amp; foo.bar &amp;&amp; foo.bar.baz &amp;&amp; foo.bar.baz.buzz`
The AST will look like this:
{
  left: {
    left: {
      left: foo
      right: foo.bar
    }
    right: foo.bar.baz
  }
  right: foo.bar.baz.buzz
}
*/
exports.default = util.createRule({
    name: &#039;prefer-optional-chain&#039;,
    meta: {
        type: &#039;suggestion&#039;,
        docs: {
            description: &#039;Enforce using concise optional chain expressions instead of chained logical ands, negated logical ors, or empty objects&#039;,
            recommended: &#039;strict&#039;,
        },
        hasSuggestions: true,
        messages: {
            preferOptionalChain: &quot;Prefer using an optional chain expression instead, as it&#039;s more concise and easier to read.&quot;,
            optionalChainSuggest: &#039;Change to an optional chain.&#039;,
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        const sourceCode = context.getSourceCode();
        const parserServices = util.getParserServices(context, true);
        return {
            &#039;LogicalExpression[operator=&quot;||&quot;], LogicalExpression[operator=&quot;??&quot;]&#039;(node) {
                const leftNode = node.left;
                const rightNode = node.right;
                const parentNode = node.parent;
                const isRightNodeAnEmptyObjectLiteral = rightNode.type === utils_1.AST_NODE_TYPES.ObjectExpression &amp;&amp;
                    rightNode.properties.length === 0;
                if (!isRightNodeAnEmptyObjectLiteral ||
                    !parentNode ||
                    parentNode.type !== utils_1.AST_NODE_TYPES.MemberExpression ||
                    parentNode.optional) {
                    return;
                }
                function isLeftSideLowerPrecedence() {
                    const logicalTsNode = parserServices.esTreeNodeToTSNodeMap.get(node);
                    const leftTsNode = parserServices.esTreeNodeToTSNodeMap.get(leftNode);
                    const operator = (0, tsutils_1.isBinaryExpression)(logicalTsNode)
                        ? logicalTsNode.operatorToken.kind
                        : ts.SyntaxKind.Unknown;
                    const leftPrecedence = util.getOperatorPrecedence(leftTsNode.kind, operator);
                    return leftPrecedence &lt; util.OperatorPrecedence.LeftHandSide;
                }
                context.report({
                    node: parentNode,
                    messageId: &#039;optionalChainSuggest&#039;,
                    suggest: [
                        {
                            messageId: &#039;optionalChainSuggest&#039;,
                            fix: (fixer) =&gt; {
                                const leftNodeText = sourceCode.getText(leftNode);
                                // Any node that is made of an operator with higher or equal precedence,
                                const maybeWrappedLeftNode = isLeftSideLowerPrecedence()
                                    ? `(${leftNodeText})`
                                    : leftNodeText;
                                const propertyToBeOptionalText = sourceCode.getText(parentNode.property);
                                const maybeWrappedProperty = parentNode.computed
                                    ? `[${propertyToBeOptionalText}]`
                                    : propertyToBeOptionalText;
                                return fixer.replaceTextRange(parentNode.range, `${maybeWrappedLeftNode}?.${maybeWrappedProperty}`);
                            },
                        },
                    ],
                });
            },
            [[
                &#039;LogicalExpression[operator=&quot;||&quot;] &gt; UnaryExpression[operator=&quot;!&quot;] &gt; Identifier&#039;,
                &#039;LogicalExpression[operator=&quot;||&quot;] &gt; UnaryExpression[operator=&quot;!&quot;] &gt; MemberExpression&#039;,
                &#039;LogicalExpression[operator=&quot;||&quot;] &gt; UnaryExpression[operator=&quot;!&quot;] &gt; ChainExpression &gt; MemberExpression&#039;,
                &#039;LogicalExpression[operator=&quot;||&quot;] &gt; UnaryExpression[operator=&quot;!&quot;] &gt; MetaProperty&#039;,
            ].join(&#039;,&#039;)](initialIdentifierOrNotEqualsExpr) {
                // selector guarantees this cast
                const initialExpression = (initialIdentifierOrNotEqualsExpr.parent.type ===
                    utils_1.AST_NODE_TYPES.ChainExpression
                    ? initialIdentifierOrNotEqualsExpr.parent.parent
                    : initialIdentifierOrNotEqualsExpr.parent).parent;
                if (initialExpression.left.type !== utils_1.AST_NODE_TYPES.UnaryExpression ||
                    initialExpression.left.argument !== initialIdentifierOrNotEqualsExpr) {
                    // the node(identifier or member expression) is not the deepest left node
                    return;
                }
                // walk up the tree to figure out how many logical expressions we can include
                let previous = initialExpression;
                let current = initialExpression;
                let previousLeftText = getText(initialIdentifierOrNotEqualsExpr);
                let optionallyChainedCode = previousLeftText;
                let expressionCount = 1;
                while (current.type === utils_1.AST_NODE_TYPES.LogicalExpression) {
                    if (current.right.type !== utils_1.AST_NODE_TYPES.UnaryExpression ||
                        !isValidChainTarget(current.right.argument, 
                        // only allow unary &#039;!&#039; with identifiers for the first chain - !foo || !foo()
                        expressionCount === 1)) {
                        break;
                    }
                    const { rightText, shouldBreak } = breakIfInvalid({
                        rightNode: current.right.argument,
                        previousLeftText,
                    });
                    if (shouldBreak) {
                        break;
                    }
                    let invalidOptionallyChainedPrivateProperty;
                    ({
                        invalidOptionallyChainedPrivateProperty,
                        expressionCount,
                        previousLeftText,
                        optionallyChainedCode,
                        previous,
                        current,
                    } = normalizeRepeatingPatterns(rightText, expressionCount, previousLeftText, optionallyChainedCode, previous, current));
                    if (invalidOptionallyChainedPrivateProperty) {
                        return;
                    }
                }
                reportIfMoreThanOne({
                    expressionCount,
                    previous,
                    optionallyChainedCode,
                    sourceCode,
                    context,
                    shouldHandleChainedAnds: false,
                });
            },
            [[
                &#039;LogicalExpression[operator=&quot;&amp;&amp;&quot;] &gt; Identifier&#039;,
                &#039;LogicalExpression[operator=&quot;&amp;&amp;&quot;] &gt; MemberExpression&#039;,
                &#039;LogicalExpression[operator=&quot;&amp;&amp;&quot;] &gt; ChainExpression &gt; MemberExpression&#039;,
                &#039;LogicalExpression[operator=&quot;&amp;&amp;&quot;] &gt; MetaProperty&#039;,
                &#039;LogicalExpression[operator=&quot;&amp;&amp;&quot;] &gt; BinaryExpression[operator=&quot;!==&quot;]&#039;,
                &#039;LogicalExpression[operator=&quot;&amp;&amp;&quot;] &gt; BinaryExpression[operator=&quot;!=&quot;]&#039;,
            ].join(&#039;,&#039;)](initialIdentifierOrNotEqualsExpr) {
                var _a;
                // selector guarantees this cast
                const initialExpression = (((_a = initialIdentifierOrNotEqualsExpr.parent) === null || _a === void 0 ? void 0 : _a.type) ===
                    utils_1.AST_NODE_TYPES.ChainExpression
                    ? initialIdentifierOrNotEqualsExpr.parent.parent
                    : initialIdentifierOrNotEqualsExpr.parent);
                if (initialExpression.left !== initialIdentifierOrNotEqualsExpr) {
                    // the node(identifier or member expression) is not the deepest left node
                    return;
                }
                if (!isValidChainTarget(initialIdentifierOrNotEqualsExpr, true)) {
                    return;
                }
                // walk up the tree to figure out how many logical expressions we can include
                let previous = initialExpression;
                let current = initialExpression;
                let previousLeftText = getText(initialIdentifierOrNotEqualsExpr);
                let optionallyChainedCode = previousLeftText;
                let expressionCount = 1;
                while (current.type === utils_1.AST_NODE_TYPES.LogicalExpression) {
                    if (!isValidChainTarget(current.right, 
                    // only allow identifiers for the first chain - foo &amp;&amp; foo()
                    expressionCount === 1)) {
                        break;
                    }
                    const { rightText, shouldBreak } = breakIfInvalid({
                        rightNode: current.right,
                        previousLeftText,
                    });
                    if (shouldBreak) {
                        break;
                    }
                    let invalidOptionallyChainedPrivateProperty;
                    ({
                        invalidOptionallyChainedPrivateProperty,
                        expressionCount,
                        previousLeftText,
                        optionallyChainedCode,
                        previous,
                        current,
                    } = normalizeRepeatingPatterns(rightText, expressionCount, previousLeftText, optionallyChainedCode, previous, current));
                    if (invalidOptionallyChainedPrivateProperty) {
                        return;
                    }
                }
                reportIfMoreThanOne({
                    expressionCount,
                    previous,
                    optionallyChainedCode,
                    sourceCode,
                    context,
                    shouldHandleChainedAnds: true,
                });
            },
        };
        function breakIfInvalid({ previousLeftText, rightNode, }) {
            let shouldBreak = false;
            const rightText = getText(rightNode);
            // can&#039;t just use startsWith because of cases like foo &amp;&amp; fooBar.baz;
            const matchRegex = new RegExp(`^${
            // escape regex characters
            previousLeftText.replace(/[.*+?^${}()|[\]\\]/g, &#039;\\$&amp;&#039;)}[^a-zA-Z0-9_$]`);
            if (!matchRegex.test(rightText) &amp;&amp;
                // handle redundant cases like foo.bar &amp;&amp; foo.bar
                previousLeftText !== rightText) {
                shouldBreak = true;
            }
            return { shouldBreak, leftText: previousLeftText, rightText };
        }
        function getText(node) {
            if (node.type === utils_1.AST_NODE_TYPES.BinaryExpression) {
                return getText(
                // isValidChainTarget ensures this is type safe
                node.left);
            }
            if (node.type === utils_1.AST_NODE_TYPES.CallExpression) {
                const calleeText = getText(
                // isValidChainTarget ensures this is type safe
                node.callee);
                // ensure that the call arguments are left untouched, or else we can break cases that _need_ whitespace:
                // - JSX: &lt;Foo Needs Space Between Attrs /&gt;
                // - Unary Operators: typeof foo, await bar, delete baz
                const closingParenToken = util.nullThrows(sourceCode.getLastToken(node), util.NullThrowsReasons.MissingToken(&#039;closing parenthesis&#039;, node.type));
                const openingParenToken = util.nullThrows(sourceCode.getFirstTokenBetween(node.callee, closingParenToken, util.isOpeningParenToken), util.NullThrowsReasons.MissingToken(&#039;opening parenthesis&#039;, node.type));
                const argumentsText = sourceCode.text.substring(openingParenToken.range[0], closingParenToken.range[1]);
                return `${calleeText}${argumentsText}`;
            }
            if (node.type === utils_1.AST_NODE_TYPES.Identifier ||
                node.type === utils_1.AST_NODE_TYPES.PrivateIdentifier) {
                return node.name;
            }
            if (node.type === utils_1.AST_NODE_TYPES.MetaProperty) {
                return `${node.meta.name}.${node.property.name}`;
            }
            if (node.type === utils_1.AST_NODE_TYPES.ThisExpression) {
                return &#039;this&#039;;
            }
            if (node.type === utils_1.AST_NODE_TYPES.ChainExpression) {
                /* istanbul ignore if */ if (node.expression.type === utils_1.AST_NODE_TYPES.TSNonNullExpression) {
                    // this shouldn&#039;t happen
                    return &#039;&#039;;
                }
                return getText(node.expression);
            }
            if (node.object.type === utils_1.AST_NODE_TYPES.TSNonNullExpression) {
                // Not supported mixing with TSNonNullExpression
                return &#039;&#039;;
            }
            return getMemberExpressionText(node);
        }
        /**
         * Gets a normalized representation of the given MemberExpression
         */
        function getMemberExpressionText(node) {
            let objectText;
            // cases should match the list in ALLOWED_MEMBER_OBJECT_TYPES
            switch (node.object.type) {
                case utils_1.AST_NODE_TYPES.MemberExpression:
                    objectText = getMemberExpressionText(node.object);
                    break;
                case utils_1.AST_NODE_TYPES.CallExpression:
                case utils_1.AST_NODE_TYPES.Identifier:
                case utils_1.AST_NODE_TYPES.MetaProperty:
                case utils_1.AST_NODE_TYPES.ThisExpression:
                    objectText = getText(node.object);
                    break;
                /* istanbul ignore next */
                default:
                    return &#039;&#039;;
            }
            let propertyText;
            if (node.computed) {
                // cases should match the list in ALLOWED_COMPUTED_PROP_TYPES
                switch (node.property.type) {
                    case utils_1.AST_NODE_TYPES.Identifier:
                        propertyText = getText(node.property);
                        break;
                    case utils_1.AST_NODE_TYPES.Literal:
                    case utils_1.AST_NODE_TYPES.TemplateLiteral:
                    case utils_1.AST_NODE_TYPES.BinaryExpression:
                        propertyText = sourceCode.getText(node.property);
                        break;
                    case utils_1.AST_NODE_TYPES.MemberExpression:
                        propertyText = getMemberExpressionText(node.property);
                        break;
                    /* istanbul ignore next */
                    default:
                        return &#039;&#039;;
                }
                return `${objectText}${node.optional ? &#039;?.&#039; : &#039;&#039;}[${propertyText}]`;
            }
            else {
                // cases should match the list in ALLOWED_NON_COMPUTED_PROP_TYPES
                switch (node.property.type) {
                    case utils_1.AST_NODE_TYPES.Identifier:
                        propertyText = getText(node.property);
                        break;
                    case utils_1.AST_NODE_TYPES.PrivateIdentifier:
                        propertyText = &#039;#&#039; + getText(node.property);
                        break;
                    default:
                        propertyText = sourceCode.getText(node.property);
                }
                return `${objectText}${node.optional ? &#039;?.&#039; : &#039;.&#039;}${propertyText}`;
            }
        }
    },
});
const ALLOWED_MEMBER_OBJECT_TYPES = new Set([
    utils_1.AST_NODE_TYPES.CallExpression,
    utils_1.AST_NODE_TYPES.Identifier,
    utils_1.AST_NODE_TYPES.MemberExpression,
    utils_1.AST_NODE_TYPES.ThisExpression,
    utils_1.AST_NODE_TYPES.MetaProperty,
]);
const ALLOWED_COMPUTED_PROP_TYPES = new Set([
    utils_1.AST_NODE_TYPES.Identifier,
    utils_1.AST_NODE_TYPES.Literal,
    utils_1.AST_NODE_TYPES.MemberExpression,
    utils_1.AST_NODE_TYPES.TemplateLiteral,
]);
const ALLOWED_NON_COMPUTED_PROP_TYPES = new Set([
    utils_1.AST_NODE_TYPES.Identifier,
    utils_1.AST_NODE_TYPES.PrivateIdentifier,
]);
function reportIfMoreThanOne({ expressionCount, previous, optionallyChainedCode, sourceCode, context, shouldHandleChainedAnds, }) {
    if (expressionCount &gt; 1) {
        if (shouldHandleChainedAnds &amp;&amp;
            previous.right.type === utils_1.AST_NODE_TYPES.BinaryExpression) {
            let operator = previous.right.operator;
            if (previous.right.operator === &#039;!==&#039; &amp;&amp;
                // TODO(#4820): Use the type checker to know whether this is `null`
                previous.right.right.type === utils_1.AST_NODE_TYPES.Literal &amp;&amp;
                previous.right.right.raw === &#039;null&#039;) {
                // case like foo !== null &amp;&amp; foo.bar !== null
                operator = &#039;!=&#039;;
            }
            // case like foo &amp;&amp; foo.bar !== someValue
            optionallyChainedCode += ` ${operator} ${sourceCode.getText(previous.right.right)}`;
        }
        context.report({
            node: previous,
            messageId: &#039;preferOptionalChain&#039;,
            suggest: [
                {
                    messageId: &#039;optionalChainSuggest&#039;,
                    fix: (fixer) =&gt; [
                        fixer.replaceText(previous, `${shouldHandleChainedAnds ? &#039;&#039; : &#039;!&#039;}${optionallyChainedCode}`),
                    ],
                },
            ],
        });
    }
}
function normalizeRepeatingPatterns(rightText, expressionCount, previousLeftText, optionallyChainedCode, previous, current) {
    const leftText = previousLeftText;
    let invalidOptionallyChainedPrivateProperty = false;
    // omit weird doubled up expression that make no sense like foo.bar &amp;&amp; foo.bar
    if (rightText !== previousLeftText) {
        expressionCount += 1;
        previousLeftText = rightText;
        /*
        Diff the left and right text to construct the fix string
        There are the following cases:
    
        1)
        rightText === &#039;foo.bar.baz.buzz&#039;
        leftText === &#039;foo.bar.baz&#039;
        diff === &#039;.buzz&#039;
    
        2)
        rightText === &#039;foo.bar.baz.buzz()&#039;
        leftText === &#039;foo.bar.baz&#039;
        diff === &#039;.buzz()&#039;
    
        3)
        rightText === &#039;foo.bar.baz.buzz()&#039;
        leftText === &#039;foo.bar.baz.buzz&#039;
        diff === &#039;()&#039;
    
        4)
        rightText === &#039;foo.bar.baz[buzz]&#039;
        leftText === &#039;foo.bar.baz&#039;
        diff === &#039;[buzz]&#039;
    
        5)
        rightText === &#039;foo.bar.baz?.buzz&#039;
        leftText === &#039;foo.bar.baz&#039;
        diff === &#039;?.buzz&#039;
        */
        const diff = rightText.replace(leftText, &#039;&#039;);
        if (diff.startsWith(&#039;.#&#039;)) {
            // Do not handle direct optional chaining on private properties because of a typescript bug (https://github.com/microsoft/TypeScript/issues/42734)
            // We still allow in computed properties
            invalidOptionallyChainedPrivateProperty = true;
        }
        if (diff.startsWith(&#039;?&#039;)) {
            // item was &quot;pre optional chained&quot;
            optionallyChainedCode += diff;
        }
        else {
            const needsDot = diff.startsWith(&#039;(&#039;) || diff.startsWith(&#039;[&#039;);
            optionallyChainedCode += `?${needsDot ? &#039;.&#039; : &#039;&#039;}${diff}`;
        }
    }
    previous = current;
    current = util.nullThrows(current.parent, util.NullThrowsReasons.MissingParent);
    return {
        invalidOptionallyChainedPrivateProperty,
        expressionCount,
        previousLeftText,
        optionallyChainedCode,
        previous,
        current,
    };
}
function isValidChainTarget(node, allowIdentifier) {
    if (node.type === utils_1.AST_NODE_TYPES.ChainExpression) {
        return isValidChainTarget(node.expression, allowIdentifier);
    }
    if (node.type === utils_1.AST_NODE_TYPES.MemberExpression) {
        const isObjectValid = ALLOWED_MEMBER_OBJECT_TYPES.has(node.object.type) &amp;&amp;
            // make sure to validate the expression is of our expected structure
            isValidChainTarget(node.object, true);
        const isPropertyValid = node.computed
            ? ALLOWED_COMPUTED_PROP_TYPES.has(node.property.type) &amp;&amp;
                // make sure to validate the member expression is of our expected structure
                (node.property.type === utils_1.AST_NODE_TYPES.MemberExpression
                    ? isValidChainTarget(node.property, allowIdentifier)
                    : true)
            : ALLOWED_NON_COMPUTED_PROP_TYPES.has(node.property.type);
        return isObjectValid &amp;&amp; isPropertyValid;
    }
    if (node.type === utils_1.AST_NODE_TYPES.CallExpression) {
        return isValidChainTarget(node.callee, allowIdentifier);
    }
    if (allowIdentifier &amp;&amp;
        (node.type === utils_1.AST_NODE_TYPES.Identifier ||
            node.type === utils_1.AST_NODE_TYPES.ThisExpression ||
            node.type === utils_1.AST_NODE_TYPES.MetaProperty)) {
        return true;
    }
    /*
    special case for the following, where we only want the left
    - foo !== null
    - foo != null
    - foo !== undefined
    - foo != undefined
    */
    return (node.type === utils_1.AST_NODE_TYPES.BinaryExpression &amp;&amp;
        [&#039;!==&#039;, &#039;!=&#039;].includes(node.operator) &amp;&amp;
        isValidChainTarget(node.left, allowIdentifier) &amp;&amp;
        (util.isUndefinedIdentifier(node.right) || util.isNullLiteral(node.right)));
}
//# sourceMappingURL=prefer-optional-chain.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
