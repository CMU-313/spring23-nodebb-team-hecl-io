<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">61.86</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">250</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">71.52</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.02</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">(function (global, factory) {
    typeof exports === &#039;object&#039; &amp;&amp; typeof module !== &#039;undefined&#039; ? module.exports = factory() :
    typeof define === &#039;function&#039; &amp;&amp; define.amd ? define(factory) :
    (global = typeof globalThis !== &#039;undefined&#039; ? globalThis : global || self, global.resolveURI = factory());
})(this, (function () { &#039;use strict&#039;;

    // Matches the scheme of a URL, eg &quot;http://&quot;
    const schemeRegex = /^[\w+.-]+:\/\//;
    /**
     * Matches the parts of a URL:
     * 1. Scheme, including &quot;:&quot;, guaranteed.
     * 2. User/password, including &quot;@&quot;, optional.
     * 3. Host, guaranteed.
     * 4. Port, including &quot;:&quot;, optional.
     * 5. Path, including &quot;/&quot;, optional.
     * 6. Query, including &quot;?&quot;, optional.
     * 7. Hash, including &quot;#&quot;, optional.
     */
    const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
    /**
     * File URLs are weird. They dont&#039; need the regular `//` in the scheme, they may or may not start
     * with a leading `/`, they can have a domain (but only if they don&#039;t start with a Windows drive).
     *
     * 1. Host, optional.
     * 2. Path, which may include &quot;/&quot;, guaranteed.
     * 3. Query, including &quot;?&quot;, optional.
     * 4. Hash, including &quot;#&quot;, optional.
     */
    const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
    var UrlType;
    (function (UrlType) {
        UrlType[UrlType[&quot;Empty&quot;] = 1] = &quot;Empty&quot;;
        UrlType[UrlType[&quot;Hash&quot;] = 2] = &quot;Hash&quot;;
        UrlType[UrlType[&quot;Query&quot;] = 3] = &quot;Query&quot;;
        UrlType[UrlType[&quot;RelativePath&quot;] = 4] = &quot;RelativePath&quot;;
        UrlType[UrlType[&quot;AbsolutePath&quot;] = 5] = &quot;AbsolutePath&quot;;
        UrlType[UrlType[&quot;SchemeRelative&quot;] = 6] = &quot;SchemeRelative&quot;;
        UrlType[UrlType[&quot;Absolute&quot;] = 7] = &quot;Absolute&quot;;
    })(UrlType || (UrlType = {}));
    function isAbsoluteUrl(input) {
        return schemeRegex.test(input);
    }
    function isSchemeRelativeUrl(input) {
        return input.startsWith(&#039;//&#039;);
    }
    function isAbsolutePath(input) {
        return input.startsWith(&#039;/&#039;);
    }
    function isFileUrl(input) {
        return input.startsWith(&#039;file:&#039;);
    }
    function isRelative(input) {
        return /^[.?#]/.test(input);
    }
    function parseAbsoluteUrl(input) {
        const match = urlRegex.exec(input);
        return makeUrl(match[1], match[2] || &#039;&#039;, match[3], match[4] || &#039;&#039;, match[5] || &#039;/&#039;, match[6] || &#039;&#039;, match[7] || &#039;&#039;);
    }
    function parseFileUrl(input) {
        const match = fileRegex.exec(input);
        const path = match[2];
        return makeUrl(&#039;file:&#039;, &#039;&#039;, match[1] || &#039;&#039;, &#039;&#039;, isAbsolutePath(path) ? path : &#039;/&#039; + path, match[3] || &#039;&#039;, match[4] || &#039;&#039;);
    }
    function makeUrl(scheme, user, host, port, path, query, hash) {
        return {
            scheme,
            user,
            host,
            port,
            path,
            query,
            hash,
            type: UrlType.Absolute,
        };
    }
    function parseUrl(input) {
        if (isSchemeRelativeUrl(input)) {
            const url = parseAbsoluteUrl(&#039;http:&#039; + input);
            url.scheme = &#039;&#039;;
            url.type = UrlType.SchemeRelative;
            return url;
        }
        if (isAbsolutePath(input)) {
            const url = parseAbsoluteUrl(&#039;http://foo.com&#039; + input);
            url.scheme = &#039;&#039;;
            url.host = &#039;&#039;;
            url.type = UrlType.AbsolutePath;
            return url;
        }
        if (isFileUrl(input))
            return parseFileUrl(input);
        if (isAbsoluteUrl(input))
            return parseAbsoluteUrl(input);
        const url = parseAbsoluteUrl(&#039;http://foo.com/&#039; + input);
        url.scheme = &#039;&#039;;
        url.host = &#039;&#039;;
        url.type = input
            ? input.startsWith(&#039;?&#039;)
                ? UrlType.Query
                : input.startsWith(&#039;#&#039;)
                    ? UrlType.Hash
                    : UrlType.RelativePath
            : UrlType.Empty;
        return url;
    }
    function stripPathFilename(path) {
        // If a path ends with a parent directory &quot;..&quot;, then it&#039;s a relative path with excess parent
        // paths. It&#039;s not a file, so we can&#039;t strip it.
        if (path.endsWith(&#039;/..&#039;))
            return path;
        const index = path.lastIndexOf(&#039;/&#039;);
        return path.slice(0, index + 1);
    }
    function mergePaths(url, base) {
        normalizePath(base, base.type);
        // If the path is just a &quot;/&quot;, then it was an empty path to begin with (remember, we&#039;re a relative
        // path).
        if (url.path === &#039;/&#039;) {
            url.path = base.path;
        }
        else {
            // Resolution happens relative to the base path&#039;s directory, not the file.
            url.path = stripPathFilename(base.path) + url.path;
        }
    }
    /**
     * The path can have empty directories &quot;//&quot;, unneeded parents &quot;foo/..&quot;, or current directory
     * &quot;foo/.&quot;. We need to normalize to a standard representation.
     */
    function normalizePath(url, type) {
        const rel = type &lt;= UrlType.RelativePath;
        const pieces = url.path.split(&#039;/&#039;);
        // We need to preserve the first piece always, so that we output a leading slash. The item at
        // pieces[0] is an empty string.
        let pointer = 1;
        // Positive is the number of real directories we&#039;ve output, used for popping a parent directory.
        // Eg, &quot;foo/bar/..&quot; will have a positive 2, and we can decrement to be left with just &quot;foo&quot;.
        let positive = 0;
        // We need to keep a trailing slash if we encounter an empty directory (eg, splitting &quot;foo/&quot; will
        // generate `[&quot;foo&quot;, &quot;&quot;]` pieces). And, if we pop a parent directory. But once we encounter a
        // real directory, we won&#039;t need to append, unless the other conditions happen again.
        let addTrailingSlash = false;
        for (let i = 1; i &lt; pieces.length; i++) {
            const piece = pieces[i];
            // An empty directory, could be a trailing slash, or just a double &quot;//&quot; in the path.
            if (!piece) {
                addTrailingSlash = true;
                continue;
            }
            // If we encounter a real directory, then we don&#039;t need to append anymore.
            addTrailingSlash = false;
            // A current directory, which we can always drop.
            if (piece === &#039;.&#039;)
                continue;
            // A parent directory, we need to see if there are any real directories we can pop. Else, we
            // have an excess of parents, and we&#039;ll need to keep the &quot;..&quot;.
            if (piece === &#039;..&#039;) {
                if (positive) {
                    addTrailingSlash = true;
                    positive--;
                    pointer--;
                }
                else if (rel) {
                    // If we&#039;re in a relativePath, then we need to keep the excess parents. Else, in an absolute
                    // URL, protocol relative URL, or an absolute path, we don&#039;t need to keep excess.
                    pieces[pointer++] = piece;
                }
                continue;
            }
            // We&#039;ve encountered a real directory. Move it to the next insertion pointer, which accounts for
            // any popped or dropped directories.
            pieces[pointer++] = piece;
            positive++;
        }
        let path = &#039;&#039;;
        for (let i = 1; i &lt; pointer; i++) {
            path += &#039;/&#039; + pieces[i];
        }
        if (!path || (addTrailingSlash &amp;&amp; !path.endsWith(&#039;/..&#039;))) {
            path += &#039;/&#039;;
        }
        url.path = path;
    }
    /**
     * Attempts to resolve `input` URL/path relative to `base`.
     */
    function resolve(input, base) {
        if (!input &amp;&amp; !base)
            return &#039;&#039;;
        const url = parseUrl(input);
        let inputType = url.type;
        if (base &amp;&amp; inputType !== UrlType.Absolute) {
            const baseUrl = parseUrl(base);
            const baseType = baseUrl.type;
            switch (inputType) {
                case UrlType.Empty:
                    url.hash = baseUrl.hash;
                // fall through
                case UrlType.Hash:
                    url.query = baseUrl.query;
                // fall through
                case UrlType.Query:
                case UrlType.RelativePath:
                    mergePaths(url, baseUrl);
                // fall through
                case UrlType.AbsolutePath:
                    // The host, user, and port are joined, you can&#039;t copy one without the others.
                    url.user = baseUrl.user;
                    url.host = baseUrl.host;
                    url.port = baseUrl.port;
                // fall through
                case UrlType.SchemeRelative:
                    // The input doesn&#039;t have a schema at least, so we need to copy at least that over.
                    url.scheme = baseUrl.scheme;
            }
            if (baseType &gt; inputType)
                inputType = baseType;
        }
        normalizePath(url, inputType);
        const queryHash = url.query + url.hash;
        switch (inputType) {
            // This is impossible, because of the empty checks at the start of the function.
            // case UrlType.Empty:
            case UrlType.Hash:
            case UrlType.Query:
                return queryHash;
            case UrlType.RelativePath: {
                // The first char is always a &quot;/&quot;, and we need it to be relative.
                const path = url.path.slice(1);
                if (!path)
                    return queryHash || &#039;.&#039;;
                if (isRelative(base || input) &amp;&amp; !isRelative(path)) {
                    // If base started with a leading &quot;.&quot;, or there is no base and input started with a &quot;.&quot;,
                    // then we need to ensure that the relative path starts with a &quot;.&quot;. We don&#039;t know if
                    // relative starts with a &quot;..&quot;, though, so check before prepending.
                    return &#039;./&#039; + path + queryHash;
                }
                return path + queryHash;
            }
            case UrlType.AbsolutePath:
                return url.path + queryHash;
            default:
                return url.scheme + &#039;//&#039; + url.user + url.host + url.port + url.path + queryHash;
        }
    }

    return resolve;

}));
//# sourceMappingURL=resolve-uri.umd.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
