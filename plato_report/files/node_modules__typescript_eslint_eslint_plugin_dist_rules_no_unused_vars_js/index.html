<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-unused-vars.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-unused-vars.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">62.68</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">532</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">76.89</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.03</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
var __createBinding = (this &amp;&amp; this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (&quot;get&quot; in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this &amp;&amp; this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, &quot;default&quot;, { enumerable: true, value: v });
}) : function(o, v) {
    o[&quot;default&quot;] = v;
});
var __importStar = (this &amp;&amp; this.__importStar) || function (mod) {
    if (mod &amp;&amp; mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== &quot;default&quot; &amp;&amp; Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
const scope_manager_1 = require(&quot;@typescript-eslint/scope-manager&quot;);
const utils_1 = require(&quot;@typescript-eslint/utils&quot;);
const util = __importStar(require(&quot;../util&quot;));
exports.default = util.createRule({
    name: &#039;no-unused-vars&#039;,
    meta: {
        type: &#039;problem&#039;,
        docs: {
            description: &#039;Disallow unused variables&#039;,
            recommended: &#039;warn&#039;,
            extendsBaseRule: true,
        },
        schema: [
            {
                oneOf: [
                    {
                        enum: [&#039;all&#039;, &#039;local&#039;],
                    },
                    {
                        type: &#039;object&#039;,
                        properties: {
                            vars: {
                                enum: [&#039;all&#039;, &#039;local&#039;],
                            },
                            varsIgnorePattern: {
                                type: &#039;string&#039;,
                            },
                            args: {
                                enum: [&#039;all&#039;, &#039;after-used&#039;, &#039;none&#039;],
                            },
                            ignoreRestSiblings: {
                                type: &#039;boolean&#039;,
                            },
                            argsIgnorePattern: {
                                type: &#039;string&#039;,
                            },
                            caughtErrors: {
                                enum: [&#039;all&#039;, &#039;none&#039;],
                            },
                            caughtErrorsIgnorePattern: {
                                type: &#039;string&#039;,
                            },
                            destructuredArrayIgnorePattern: {
                                type: &#039;string&#039;,
                            },
                        },
                        additionalProperties: false,
                    },
                ],
            },
        ],
        messages: {
            unusedVar: &quot;&#039;{{varName}}&#039; is {{action}} but never used{{additional}}.&quot;,
        },
    },
    defaultOptions: [{}],
    create(context, [firstOption]) {
        const filename = context.getFilename();
        const sourceCode = context.getSourceCode();
        const MODULE_DECL_CACHE = new Map();
        const options = (() =&gt; {
            var _a, _b, _c, _d;
            const options = {
                vars: &#039;all&#039;,
                args: &#039;after-used&#039;,
                ignoreRestSiblings: false,
                caughtErrors: &#039;none&#039;,
            };
            if (firstOption) {
                if (typeof firstOption === &#039;string&#039;) {
                    options.vars = firstOption;
                }
                else {
                    options.vars = (_a = firstOption.vars) !== null &amp;&amp; _a !== void 0 ? _a : options.vars;
                    options.args = (_b = firstOption.args) !== null &amp;&amp; _b !== void 0 ? _b : options.args;
                    options.ignoreRestSiblings =
                        (_c = firstOption.ignoreRestSiblings) !== null &amp;&amp; _c !== void 0 ? _c : options.ignoreRestSiblings;
                    options.caughtErrors =
                        (_d = firstOption.caughtErrors) !== null &amp;&amp; _d !== void 0 ? _d : options.caughtErrors;
                    if (firstOption.varsIgnorePattern) {
                        options.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern, &#039;u&#039;);
                    }
                    if (firstOption.argsIgnorePattern) {
                        options.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern, &#039;u&#039;);
                    }
                    if (firstOption.caughtErrorsIgnorePattern) {
                        options.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern, &#039;u&#039;);
                    }
                    if (firstOption.destructuredArrayIgnorePattern) {
                        options.destructuredArrayIgnorePattern = new RegExp(firstOption.destructuredArrayIgnorePattern, &#039;u&#039;);
                    }
                }
            }
            return options;
        })();
        function collectUnusedVariables() {
            var _a, _b, _c, _d, _e;
            /**
             * Checks whether a node is a sibling of the rest property or not.
             * @param {ASTNode} node a node to check
             * @returns {boolean} True if the node is a sibling of the rest property, otherwise false.
             */
            function hasRestSibling(node) {
                var _a;
                return (node.type === utils_1.AST_NODE_TYPES.Property &amp;&amp;
                    ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.ObjectPattern &amp;&amp;
                    node.parent.properties[node.parent.properties.length - 1].type ===
                        utils_1.AST_NODE_TYPES.RestElement);
            }
            /**
             * Determines if a variable has a sibling rest property
             * @param variable eslint-scope variable object.
             * @returns True if the variable is exported, false if not.
             */
            function hasRestSpreadSibling(variable) {
                if (options.ignoreRestSiblings) {
                    const hasRestSiblingDefinition = variable.defs.some(def =&gt; hasRestSibling(def.name.parent));
                    const hasRestSiblingReference = variable.references.some(ref =&gt; hasRestSibling(ref.identifier.parent));
                    return hasRestSiblingDefinition || hasRestSiblingReference;
                }
                return false;
            }
            /**
             * Checks whether the given variable is after the last used parameter.
             * @param variable The variable to check.
             * @returns `true` if the variable is defined after the last used parameter.
             */
            function isAfterLastUsedArg(variable) {
                const def = variable.defs[0];
                const params = context.getDeclaredVariables(def.node);
                const posteriorParams = params.slice(params.indexOf(variable) + 1);
                // If any used parameters occur after this parameter, do not report.
                return !posteriorParams.some(v =&gt; v.references.length &gt; 0 || v.eslintUsed);
            }
            const unusedVariablesOriginal = util.collectUnusedVariables(context);
            const unusedVariablesReturn = [];
            for (const variable of unusedVariablesOriginal) {
                // explicit global variables don&#039;t have definitions.
                if (variable.defs.length === 0) {
                    unusedVariablesReturn.push(variable);
                    continue;
                }
                const def = variable.defs[0];
                if (variable.scope.type === utils_1.TSESLint.Scope.ScopeType.global &amp;&amp;
                    options.vars === &#039;local&#039;) {
                    // skip variables in the global scope if configured to
                    continue;
                }
                const refUsedInArrayPatterns = variable.references.some(ref =&gt; { var _a; return ((_a = ref.identifier.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.ArrayPattern; });
                // skip elements of array destructuring patterns
                if ((((_a = def.name.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.ArrayPattern ||
                    refUsedInArrayPatterns) &amp;&amp;
                    &#039;name&#039; in def.name &amp;&amp;
                    ((_b = options.destructuredArrayIgnorePattern) === null || _b === void 0 ? void 0 : _b.test(def.name.name))) {
                    continue;
                }
                // skip catch variables
                if (def.type === utils_1.TSESLint.Scope.DefinitionType.CatchClause) {
                    if (options.caughtErrors === &#039;none&#039;) {
                        continue;
                    }
                    // skip ignored parameters
                    if (&#039;name&#039; in def.name &amp;&amp;
                        ((_c = options.caughtErrorsIgnorePattern) === null || _c === void 0 ? void 0 : _c.test(def.name.name))) {
                        continue;
                    }
                }
                if (def.type === utils_1.TSESLint.Scope.DefinitionType.Parameter) {
                    // if &quot;args&quot; option is &quot;none&quot;, skip any parameter
                    if (options.args === &#039;none&#039;) {
                        continue;
                    }
                    // skip ignored parameters
                    if (&#039;name&#039; in def.name &amp;&amp;
                        ((_d = options.argsIgnorePattern) === null || _d === void 0 ? void 0 : _d.test(def.name.name))) {
                        continue;
                    }
                    // if &quot;args&quot; option is &quot;after-used&quot;, skip used variables
                    if (options.args === &#039;after-used&#039; &amp;&amp;
                        util.isFunction(def.name.parent) &amp;&amp;
                        !isAfterLastUsedArg(variable)) {
                        continue;
                    }
                }
                else {
                    // skip ignored variables
                    if (&#039;name&#039; in def.name &amp;&amp;
                        ((_e = options.varsIgnorePattern) === null || _e === void 0 ? void 0 : _e.test(def.name.name))) {
                        continue;
                    }
                }
                if (hasRestSpreadSibling(variable)) {
                    continue;
                }
                // in case another rule has run and used the collectUnusedVariables,
                // we want to ensure our selectors that marked variables as used are respected
                if (variable.eslintUsed) {
                    continue;
                }
                unusedVariablesReturn.push(variable);
            }
            return unusedVariablesReturn;
        }
        return {
            // declaration file handling
            [ambientDeclarationSelector(utils_1.AST_NODE_TYPES.Program, true)](node) {
                if (!util.isDefinitionFile(filename)) {
                    return;
                }
                markDeclarationChildAsUsed(node);
            },
            // module declaration in module declaration should not report unused vars error
            // this is workaround as this change should be done in better way
            &#039;TSModuleDeclaration &gt; TSModuleDeclaration&#039;(node) {
                if (node.id.type === utils_1.AST_NODE_TYPES.Identifier) {
                    let scope = context.getScope();
                    if (scope.upper) {
                        scope = scope.upper;
                    }
                    const superVar = scope.set.get(node.id.name);
                    if (superVar) {
                        superVar.eslintUsed = true;
                    }
                }
            },
            // children of a namespace that is a child of a declared namespace are auto-exported
            [ambientDeclarationSelector(&#039;TSModuleDeclaration[declare = true] &gt; TSModuleBlock TSModuleDeclaration &gt; TSModuleBlock&#039;, false)](node) {
                markDeclarationChildAsUsed(node);
            },
            // declared namespace handling
            [ambientDeclarationSelector(&#039;TSModuleDeclaration[declare = true] &gt; TSModuleBlock&#039;, false)](node) {
                var _a;
                const moduleDecl = util.nullThrows((_a = node.parent) === null || _a === void 0 ? void 0 : _a.parent, util.NullThrowsReasons.MissingParent);
                // declared ambient modules with an `export =` statement will only export that one thing
                // all other statements are not automatically exported in this case
                if (moduleDecl.id.type === utils_1.AST_NODE_TYPES.Literal &amp;&amp;
                    checkModuleDeclForExportEquals(moduleDecl)) {
                    return;
                }
                markDeclarationChildAsUsed(node);
            },
            // collect
            &#039;Program:exit&#039;(programNode) {
                /**
                 * Generates the message data about the variable being defined and unused,
                 * including the ignore pattern if configured.
                 * @param unusedVar eslint-scope variable object.
                 * @returns The message data to be used with this unused variable.
                 */
                function getDefinedMessageData(unusedVar) {
                    var _a;
                    const defType = (_a = unusedVar === null || unusedVar === void 0 ? void 0 : unusedVar.defs[0]) === null || _a === void 0 ? void 0 : _a.type;
                    let type;
                    let pattern;
                    if (defType === utils_1.TSESLint.Scope.DefinitionType.CatchClause &amp;&amp;
                        options.caughtErrorsIgnorePattern) {
                        type = &#039;args&#039;;
                        pattern = options.caughtErrorsIgnorePattern.toString();
                    }
                    else if (defType === utils_1.TSESLint.Scope.DefinitionType.Parameter &amp;&amp;
                        options.argsIgnorePattern) {
                        type = &#039;args&#039;;
                        pattern = options.argsIgnorePattern.toString();
                    }
                    else if (defType !== utils_1.TSESLint.Scope.DefinitionType.Parameter &amp;&amp;
                        options.varsIgnorePattern) {
                        type = &#039;vars&#039;;
                        pattern = options.varsIgnorePattern.toString();
                    }
                    const additional = type
                        ? `. Allowed unused ${type} must match ${pattern}`
                        : &#039;&#039;;
                    return {
                        varName: unusedVar.name,
                        action: &#039;defined&#039;,
                        additional,
                    };
                }
                /**
                 * Generate the warning message about the variable being
                 * assigned and unused, including the ignore pattern if configured.
                 * @param unusedVar eslint-scope variable object.
                 * @returns The message data to be used with this unused variable.
                 */
                function getAssignedMessageData(unusedVar) {
                    var _a;
                    const def = unusedVar.defs[0];
                    let additional = &#039;&#039;;
                    if (options.destructuredArrayIgnorePattern &amp;&amp;
                        ((_a = def === null || def === void 0 ? void 0 : def.name.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.ArrayPattern) {
                        additional = `. Allowed unused elements of array destructuring patterns must match ${options.destructuredArrayIgnorePattern.toString()}`;
                    }
                    else if (options.varsIgnorePattern) {
                        additional = `. Allowed unused vars must match ${options.varsIgnorePattern.toString()}`;
                    }
                    return {
                        varName: unusedVar.name,
                        action: &#039;assigned a value&#039;,
                        additional,
                    };
                }
                const unusedVars = collectUnusedVariables();
                for (const unusedVar of unusedVars) {
                    // Report the first declaration.
                    if (unusedVar.defs.length &gt; 0) {
                        const writeReferences = unusedVar.references.filter(ref =&gt; ref.isWrite() &amp;&amp;
                            ref.from.variableScope === unusedVar.scope.variableScope);
                        context.report({
                            node: writeReferences.length
                                ? writeReferences[writeReferences.length - 1].identifier
                                : unusedVar.identifiers[0],
                            messageId: &#039;unusedVar&#039;,
                            data: unusedVar.references.some(ref =&gt; ref.isWrite())
                                ? getAssignedMessageData(unusedVar)
                                : getDefinedMessageData(unusedVar),
                        });
                        // If there are no regular declaration, report the first `/*globals*/` comment directive.
                    }
                    else if (&#039;eslintExplicitGlobalComments&#039; in unusedVar &amp;&amp;
                        unusedVar.eslintExplicitGlobalComments) {
                        const directiveComment = unusedVar.eslintExplicitGlobalComments[0];
                        context.report({
                            node: programNode,
                            loc: util.getNameLocationInGlobalDirectiveComment(sourceCode, directiveComment, unusedVar.name),
                            messageId: &#039;unusedVar&#039;,
                            data: getDefinedMessageData(unusedVar),
                        });
                    }
                }
            },
        };
        function checkModuleDeclForExportEquals(node) {
            const cached = MODULE_DECL_CACHE.get(node);
            if (cached != null) {
                return cached;
            }
            if (node.body &amp;&amp; node.body.type === utils_1.AST_NODE_TYPES.TSModuleBlock) {
                for (const statement of node.body.body) {
                    if (statement.type === utils_1.AST_NODE_TYPES.TSExportAssignment) {
                        MODULE_DECL_CACHE.set(node, true);
                        return true;
                    }
                }
            }
            MODULE_DECL_CACHE.set(node, false);
            return false;
        }
        function ambientDeclarationSelector(parent, childDeclare) {
            return [
                // Types are ambiently exported
                `${parent} &gt; :matches(${[
                    utils_1.AST_NODE_TYPES.TSInterfaceDeclaration,
                    utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration,
                ].join(&#039;, &#039;)})`,
                // Value things are ambiently exported if they are &quot;declare&quot;d
                `${parent} &gt; :matches(${[
                    utils_1.AST_NODE_TYPES.ClassDeclaration,
                    utils_1.AST_NODE_TYPES.TSDeclareFunction,
                    utils_1.AST_NODE_TYPES.TSEnumDeclaration,
                    utils_1.AST_NODE_TYPES.TSModuleDeclaration,
                    utils_1.AST_NODE_TYPES.VariableDeclaration,
                ].join(&#039;, &#039;)})${childDeclare ? &#039;[declare = true]&#039; : &#039;&#039;}`,
            ].join(&#039;, &#039;);
        }
        function markDeclarationChildAsUsed(node) {
            var _a;
            const identifiers = [];
            switch (node.type) {
                case utils_1.AST_NODE_TYPES.TSInterfaceDeclaration:
                case utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration:
                case utils_1.AST_NODE_TYPES.ClassDeclaration:
                case utils_1.AST_NODE_TYPES.FunctionDeclaration:
                case utils_1.AST_NODE_TYPES.TSDeclareFunction:
                case utils_1.AST_NODE_TYPES.TSEnumDeclaration:
                case utils_1.AST_NODE_TYPES.TSModuleDeclaration:
                    if (((_a = node.id) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.Identifier) {
                        identifiers.push(node.id);
                    }
                    break;
                case utils_1.AST_NODE_TYPES.VariableDeclaration:
                    for (const declaration of node.declarations) {
                        visitPattern(declaration, pattern =&gt; {
                            identifiers.push(pattern);
                        });
                    }
                    break;
            }
            let scope = context.getScope();
            const shouldUseUpperScope = [
                utils_1.AST_NODE_TYPES.TSModuleDeclaration,
                utils_1.AST_NODE_TYPES.TSDeclareFunction,
            ].includes(node.type);
            if (scope.variableScope !== scope) {
                scope = scope.variableScope;
            }
            else if (shouldUseUpperScope &amp;&amp; scope.upper) {
                scope = scope.upper;
            }
            for (const id of identifiers) {
                const superVar = scope.set.get(id.name);
                if (superVar) {
                    superVar.eslintUsed = true;
                }
            }
        }
        function visitPattern(node, cb) {
            const visitor = new scope_manager_1.PatternVisitor({}, node, cb);
            visitor.visit(node);
        }
    },
});
/*

###### TODO ######

Edge cases that aren&#039;t currently handled due to laziness and them being super edgy edge cases


--- function params referenced in typeof type refs in the function declaration ---
--- NOTE - TS gets these cases wrong

function _foo(
  arg: number // arg should be unused
): typeof arg {
  return 1 as any;
}

function _bar(
  arg: number, // arg should be unused
  _arg2: typeof arg,
) {}


--- function names referenced in typeof type refs in the function declaration ---
--- NOTE - TS gets these cases right

function foo( // foo should be unused
): typeof foo {
    return 1 as any;
}

function bar( // bar should be unused
  _arg: typeof bar
) {}


--- if an interface is merged into a namespace  ---
--- NOTE - TS gets these cases wrong

namespace Test {
    interface Foo { // Foo should be unused here
        a: string;
    }
    export namespace Foo {
       export type T = &#039;b&#039;;
    }
}
type T = Test.Foo; // Error: Namespace &#039;Test&#039; has no exported member &#039;Foo&#039;.


namespace Test {
    export interface Foo {
        a: string;
    }
    namespace Foo { // Foo should be unused here
       export type T = &#039;b&#039;;
    }
}
type T = Test.Foo.T; // Error: Namespace &#039;Test&#039; has no exported member &#039;Foo&#039;.

*/
/*

###### TODO ######

We currently extend base `no-unused-vars` implementation because it&#039;s easier and lighter-weight.

Because of this, there are a few false-negatives which won&#039;t get caught.
We could fix these if we fork the base rule; but that&#039;s a lot of code (~650 lines) to add in.
I didn&#039;t want to do that just yet without some real-world issues, considering these are pretty rare edge-cases.

These cases are mishandled because the base rule assumes that each variable has one def, but type-value shadowing
creates a variable with two defs

--- type-only or value-only references to type/value shadowed variables ---
--- NOTE - TS gets these cases wrong

type T = 1;
const T = 2; // this T should be unused

type U = T; // this U should be unused
const U = 3;

const _V = U;


--- partially exported type/value shadowed variables ---
--- NOTE - TS gets these cases wrong

export interface Foo {}
const Foo = 1; // this Foo should be unused

interface Bar {} // this Bar should be unused
export const Bar = 1;

*/
//# sourceMappingURL=no-unused-vars.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
