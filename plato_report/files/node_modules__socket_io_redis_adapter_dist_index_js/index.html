<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@socket.io/redis-adapter/dist/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@socket.io/redis-adapter/dist/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">59.79</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">705</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">137.71</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">8.54</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
exports.RedisAdapter = exports.createAdapter = void 0;
const uid2 = require(&quot;uid2&quot;);
const msgpack = require(&quot;notepack.io&quot;);
const socket_io_adapter_1 = require(&quot;socket.io-adapter&quot;);
const debug = require(&quot;debug&quot;)(&quot;socket.io-redis&quot;);
module.exports = exports = createAdapter;
/**
 * Request types, for messages between nodes
 */
var RequestType;
(function (RequestType) {
    RequestType[RequestType[&quot;SOCKETS&quot;] = 0] = &quot;SOCKETS&quot;;
    RequestType[RequestType[&quot;ALL_ROOMS&quot;] = 1] = &quot;ALL_ROOMS&quot;;
    RequestType[RequestType[&quot;REMOTE_JOIN&quot;] = 2] = &quot;REMOTE_JOIN&quot;;
    RequestType[RequestType[&quot;REMOTE_LEAVE&quot;] = 3] = &quot;REMOTE_LEAVE&quot;;
    RequestType[RequestType[&quot;REMOTE_DISCONNECT&quot;] = 4] = &quot;REMOTE_DISCONNECT&quot;;
    RequestType[RequestType[&quot;REMOTE_FETCH&quot;] = 5] = &quot;REMOTE_FETCH&quot;;
    RequestType[RequestType[&quot;SERVER_SIDE_EMIT&quot;] = 6] = &quot;SERVER_SIDE_EMIT&quot;;
    RequestType[RequestType[&quot;BROADCAST&quot;] = 7] = &quot;BROADCAST&quot;;
    RequestType[RequestType[&quot;BROADCAST_CLIENT_COUNT&quot;] = 8] = &quot;BROADCAST_CLIENT_COUNT&quot;;
    RequestType[RequestType[&quot;BROADCAST_ACK&quot;] = 9] = &quot;BROADCAST_ACK&quot;;
})(RequestType || (RequestType = {}));
const isNumeric = (str) =&gt; !isNaN(str) &amp;&amp; !isNaN(parseFloat(str));
/**
 * Returns a function that will create a RedisAdapter instance.
 *
 * @param pubClient - a Redis client that will be used to publish messages
 * @param subClient - a Redis client that will be used to receive messages (put in subscribed state)
 * @param opts - additional options
 *
 * @public
 */
function createAdapter(pubClient, subClient, opts) {
    return function (nsp) {
        return new RedisAdapter(nsp, pubClient, subClient, opts);
    };
}
exports.createAdapter = createAdapter;
class RedisAdapter extends socket_io_adapter_1.Adapter {
    /**
     * Adapter constructor.
     *
     * @param nsp - the namespace
     * @param pubClient - a Redis client that will be used to publish messages
     * @param subClient - a Redis client that will be used to receive messages (put in subscribed state)
     * @param opts - additional options
     *
     * @public
     */
    constructor(nsp, pubClient, subClient, opts = {}) {
        super(nsp);
        this.pubClient = pubClient;
        this.subClient = subClient;
        this.requests = new Map();
        this.ackRequests = new Map();
        this.uid = uid2(6);
        this.requestsTimeout = opts.requestsTimeout || 5000;
        this.publishOnSpecificResponseChannel = !!opts.publishOnSpecificResponseChannel;
        this.parser = opts.parser || msgpack;
        const prefix = opts.key || &quot;socket.io&quot;;
        this.channel = prefix + &quot;#&quot; + nsp.name + &quot;#&quot;;
        this.requestChannel = prefix + &quot;-request#&quot; + this.nsp.name + &quot;#&quot;;
        this.responseChannel = prefix + &quot;-response#&quot; + this.nsp.name + &quot;#&quot;;
        const specificResponseChannel = this.responseChannel + this.uid + &quot;#&quot;;
        const isRedisV4 = typeof this.pubClient.pSubscribe === &quot;function&quot;;
        if (isRedisV4) {
            this.subClient.pSubscribe(this.channel + &quot;*&quot;, (msg, channel) =&gt; {
                this.onmessage(null, channel, msg);
            }, true);
            this.subClient.subscribe([this.requestChannel, this.responseChannel, specificResponseChannel], (msg, channel) =&gt; {
                this.onrequest(channel, msg);
            }, true);
        }
        else {
            this.subClient.psubscribe(this.channel + &quot;*&quot;);
            this.subClient.on(&quot;pmessageBuffer&quot;, this.onmessage.bind(this));
            this.subClient.subscribe([
                this.requestChannel,
                this.responseChannel,
                specificResponseChannel,
            ]);
            this.subClient.on(&quot;messageBuffer&quot;, this.onrequest.bind(this));
        }
        const registerFriendlyErrorHandler = (redisClient) =&gt; {
            redisClient.on(&quot;error&quot;, () =&gt; {
                if (redisClient.listenerCount(&quot;error&quot;) === 1) {
                    console.warn(&quot;missing &#039;error&#039; handler on this Redis client&quot;);
                }
            });
        };
        registerFriendlyErrorHandler(this.pubClient);
        registerFriendlyErrorHandler(this.subClient);
    }
    /**
     * Called with a subscription message
     *
     * @private
     */
    onmessage(pattern, channel, msg) {
        channel = channel.toString();
        const channelMatches = channel.startsWith(this.channel);
        if (!channelMatches) {
            return debug(&quot;ignore different channel&quot;);
        }
        const room = channel.slice(this.channel.length, -1);
        if (room !== &quot;&quot; &amp;&amp; !this.hasRoom(room)) {
            return debug(&quot;ignore unknown room %s&quot;, room);
        }
        const args = this.parser.decode(msg);
        const [uid, packet, opts] = args;
        if (this.uid === uid)
            return debug(&quot;ignore same uid&quot;);
        if (packet &amp;&amp; packet.nsp === undefined) {
            packet.nsp = &quot;/&quot;;
        }
        if (!packet || packet.nsp !== this.nsp.name) {
            return debug(&quot;ignore different namespace&quot;);
        }
        opts.rooms = new Set(opts.rooms);
        opts.except = new Set(opts.except);
        super.broadcast(packet, opts);
    }
    hasRoom(room) {
        // @ts-ignore
        const hasNumericRoom = isNumeric(room) &amp;&amp; this.rooms.has(parseFloat(room));
        return hasNumericRoom || this.rooms.has(room);
    }
    /**
     * Called on request from another node
     *
     * @private
     */
    async onrequest(channel, msg) {
        channel = channel.toString();
        if (channel.startsWith(this.responseChannel)) {
            return this.onresponse(channel, msg);
        }
        else if (!channel.startsWith(this.requestChannel)) {
            return debug(&quot;ignore different channel&quot;);
        }
        let request;
        try {
            // if the buffer starts with a &quot;{&quot; character
            if (msg[0] === 0x7b) {
                request = JSON.parse(msg.toString());
            }
            else {
                request = this.parser.decode(msg);
            }
        }
        catch (err) {
            debug(&quot;ignoring malformed request&quot;);
            return;
        }
        debug(&quot;received request %j&quot;, request);
        let response, socket;
        switch (request.type) {
            case RequestType.SOCKETS:
                if (this.requests.has(request.requestId)) {
                    return;
                }
                const sockets = await super.sockets(new Set(request.rooms));
                response = JSON.stringify({
                    requestId: request.requestId,
                    sockets: [...sockets],
                });
                this.publishResponse(request, response);
                break;
            case RequestType.ALL_ROOMS:
                if (this.requests.has(request.requestId)) {
                    return;
                }
                response = JSON.stringify({
                    requestId: request.requestId,
                    rooms: [...this.rooms.keys()],
                });
                this.publishResponse(request, response);
                break;
            case RequestType.REMOTE_JOIN:
                if (request.opts) {
                    const opts = {
                        rooms: new Set(request.opts.rooms),
                        except: new Set(request.opts.except),
                    };
                    return super.addSockets(opts, request.rooms);
                }
                socket = this.nsp.sockets.get(request.sid);
                if (!socket) {
                    return;
                }
                socket.join(request.room);
                response = JSON.stringify({
                    requestId: request.requestId,
                });
                this.publishResponse(request, response);
                break;
            case RequestType.REMOTE_LEAVE:
                if (request.opts) {
                    const opts = {
                        rooms: new Set(request.opts.rooms),
                        except: new Set(request.opts.except),
                    };
                    return super.delSockets(opts, request.rooms);
                }
                socket = this.nsp.sockets.get(request.sid);
                if (!socket) {
                    return;
                }
                socket.leave(request.room);
                response = JSON.stringify({
                    requestId: request.requestId,
                });
                this.publishResponse(request, response);
                break;
            case RequestType.REMOTE_DISCONNECT:
                if (request.opts) {
                    const opts = {
                        rooms: new Set(request.opts.rooms),
                        except: new Set(request.opts.except),
                    };
                    return super.disconnectSockets(opts, request.close);
                }
                socket = this.nsp.sockets.get(request.sid);
                if (!socket) {
                    return;
                }
                socket.disconnect(request.close);
                response = JSON.stringify({
                    requestId: request.requestId,
                });
                this.publishResponse(request, response);
                break;
            case RequestType.REMOTE_FETCH:
                if (this.requests.has(request.requestId)) {
                    return;
                }
                const opts = {
                    rooms: new Set(request.opts.rooms),
                    except: new Set(request.opts.except),
                };
                const localSockets = await super.fetchSockets(opts);
                response = JSON.stringify({
                    requestId: request.requestId,
                    sockets: localSockets.map((socket) =&gt; {
                        // remove sessionStore from handshake, as it may contain circular references
                        const _a = socket.handshake, { sessionStore } = _a, handshake = __rest(_a, [&quot;sessionStore&quot;]);
                        return {
                            id: socket.id,
                            handshake,
                            rooms: [...socket.rooms],
                            data: socket.data,
                        };
                    }),
                });
                this.publishResponse(request, response);
                break;
            case RequestType.SERVER_SIDE_EMIT:
                if (request.uid === this.uid) {
                    debug(&quot;ignore same uid&quot;);
                    return;
                }
                const withAck = request.requestId !== undefined;
                if (!withAck) {
                    this.nsp._onServerSideEmit(request.data);
                    return;
                }
                let called = false;
                const callback = (arg) =&gt; {
                    // only one argument is expected
                    if (called) {
                        return;
                    }
                    called = true;
                    debug(&quot;calling acknowledgement with %j&quot;, arg);
                    this.pubClient.publish(this.responseChannel, JSON.stringify({
                        type: RequestType.SERVER_SIDE_EMIT,
                        requestId: request.requestId,
                        data: arg,
                    }));
                };
                request.data.push(callback);
                this.nsp._onServerSideEmit(request.data);
                break;
            case RequestType.BROADCAST: {
                if (this.ackRequests.has(request.requestId)) {
                    // ignore self
                    return;
                }
                const opts = {
                    rooms: new Set(request.opts.rooms),
                    except: new Set(request.opts.except),
                };
                super.broadcastWithAck(request.packet, opts, (clientCount) =&gt; {
                    debug(&quot;waiting for %d client acknowledgements&quot;, clientCount);
                    this.publishResponse(request, JSON.stringify({
                        type: RequestType.BROADCAST_CLIENT_COUNT,
                        requestId: request.requestId,
                        clientCount,
                    }));
                }, (arg) =&gt; {
                    debug(&quot;received acknowledgement with value %j&quot;, arg);
                    this.publishResponse(request, this.parser.encode({
                        type: RequestType.BROADCAST_ACK,
                        requestId: request.requestId,
                        packet: arg,
                    }));
                });
                break;
            }
            default:
                debug(&quot;ignoring unknown request type: %s&quot;, request.type);
        }
    }
    /**
     * Send the response to the requesting node
     * @param request
     * @param response
     * @private
     */
    publishResponse(request, response) {
        const responseChannel = this.publishOnSpecificResponseChannel
            ? `${this.responseChannel}${request.uid}#`
            : this.responseChannel;
        debug(&quot;publishing response to channel %s&quot;, responseChannel);
        this.pubClient.publish(responseChannel, response);
    }
    /**
     * Called on response from another node
     *
     * @private
     */
    onresponse(channel, msg) {
        let response;
        try {
            // if the buffer starts with a &quot;{&quot; character
            if (msg[0] === 0x7b) {
                response = JSON.parse(msg.toString());
            }
            else {
                response = this.parser.decode(msg);
            }
        }
        catch (err) {
            debug(&quot;ignoring malformed response&quot;);
            return;
        }
        const requestId = response.requestId;
        if (this.ackRequests.has(requestId)) {
            const ackRequest = this.ackRequests.get(requestId);
            switch (response.type) {
                case RequestType.BROADCAST_CLIENT_COUNT: {
                    ackRequest === null || ackRequest === void 0 ? void 0 : ackRequest.clientCountCallback(response.clientCount);
                    break;
                }
                case RequestType.BROADCAST_ACK: {
                    ackRequest === null || ackRequest === void 0 ? void 0 : ackRequest.ack(response.packet);
                    break;
                }
            }
            return;
        }
        if (!requestId ||
            !(this.requests.has(requestId) || this.ackRequests.has(requestId))) {
            debug(&quot;ignoring unknown request&quot;);
            return;
        }
        debug(&quot;received response %j&quot;, response);
        const request = this.requests.get(requestId);
        switch (request.type) {
            case RequestType.SOCKETS:
            case RequestType.REMOTE_FETCH:
                request.msgCount++;
                // ignore if response does not contain &#039;sockets&#039; key
                if (!response.sockets || !Array.isArray(response.sockets))
                    return;
                if (request.type === RequestType.SOCKETS) {
                    response.sockets.forEach((s) =&gt; request.sockets.add(s));
                }
                else {
                    response.sockets.forEach((s) =&gt; request.sockets.push(s));
                }
                if (request.msgCount === request.numSub) {
                    clearTimeout(request.timeout);
                    if (request.resolve) {
                        request.resolve(request.sockets);
                    }
                    this.requests.delete(requestId);
                }
                break;
            case RequestType.ALL_ROOMS:
                request.msgCount++;
                // ignore if response does not contain &#039;rooms&#039; key
                if (!response.rooms || !Array.isArray(response.rooms))
                    return;
                response.rooms.forEach((s) =&gt; request.rooms.add(s));
                if (request.msgCount === request.numSub) {
                    clearTimeout(request.timeout);
                    if (request.resolve) {
                        request.resolve(request.rooms);
                    }
                    this.requests.delete(requestId);
                }
                break;
            case RequestType.REMOTE_JOIN:
            case RequestType.REMOTE_LEAVE:
            case RequestType.REMOTE_DISCONNECT:
                clearTimeout(request.timeout);
                if (request.resolve) {
                    request.resolve();
                }
                this.requests.delete(requestId);
                break;
            case RequestType.SERVER_SIDE_EMIT:
                request.responses.push(response.data);
                debug(&quot;serverSideEmit: got %d responses out of %d&quot;, request.responses.length, request.numSub);
                if (request.responses.length === request.numSub) {
                    clearTimeout(request.timeout);
                    if (request.resolve) {
                        request.resolve(null, request.responses);
                    }
                    this.requests.delete(requestId);
                }
                break;
            default:
                debug(&quot;ignoring unknown request type: %s&quot;, request.type);
        }
    }
    /**
     * Broadcasts a packet.
     *
     * @param {Object} packet - packet to emit
     * @param {Object} opts - options
     *
     * @public
     */
    broadcast(packet, opts) {
        packet.nsp = this.nsp.name;
        const onlyLocal = opts &amp;&amp; opts.flags &amp;&amp; opts.flags.local;
        if (!onlyLocal) {
            const rawOpts = {
                rooms: [...opts.rooms],
                except: [...new Set(opts.except)],
                flags: opts.flags,
            };
            const msg = this.parser.encode([this.uid, packet, rawOpts]);
            let channel = this.channel;
            if (opts.rooms &amp;&amp; opts.rooms.size === 1) {
                channel += opts.rooms.keys().next().value + &quot;#&quot;;
            }
            debug(&quot;publishing message to channel %s&quot;, channel);
            this.pubClient.publish(channel, msg);
        }
        super.broadcast(packet, opts);
    }
    broadcastWithAck(packet, opts, clientCountCallback, ack) {
        var _a;
        packet.nsp = this.nsp.name;
        const onlyLocal = (_a = opts === null || opts === void 0 ? void 0 : opts.flags) === null || _a === void 0 ? void 0 : _a.local;
        if (!onlyLocal) {
            const requestId = uid2(6);
            const rawOpts = {
                rooms: [...opts.rooms],
                except: [...new Set(opts.except)],
                flags: opts.flags,
            };
            const request = this.parser.encode({
                uid: this.uid,
                requestId,
                type: RequestType.BROADCAST,
                packet,
                opts: rawOpts,
            });
            this.pubClient.publish(this.requestChannel, request);
            this.ackRequests.set(requestId, {
                clientCountCallback,
                ack,
            });
            // we have no way to know at this level whether the server has received an acknowledgement from each client, so we
            // will simply clean up the ackRequests map after the given delay
            setTimeout(() =&gt; {
                this.ackRequests.delete(requestId);
            }, opts.flags.timeout);
        }
        super.broadcastWithAck(packet, opts, clientCountCallback, ack);
    }
    /**
     * Gets the list of all rooms (across every node)
     *
     * @public
     */
    async allRooms() {
        const localRooms = new Set(this.rooms.keys());
        const numSub = await this.getNumSub();
        debug(&#039;waiting for %d responses to &quot;allRooms&quot; request&#039;, numSub);
        if (numSub &lt;= 1) {
            return localRooms;
        }
        const requestId = uid2(6);
        const request = JSON.stringify({
            uid: this.uid,
            requestId,
            type: RequestType.ALL_ROOMS,
        });
        return new Promise((resolve, reject) =&gt; {
            const timeout = setTimeout(() =&gt; {
                if (this.requests.has(requestId)) {
                    reject(new Error(&quot;timeout reached while waiting for allRooms response&quot;));
                    this.requests.delete(requestId);
                }
            }, this.requestsTimeout);
            this.requests.set(requestId, {
                type: RequestType.ALL_ROOMS,
                numSub,
                resolve,
                timeout,
                msgCount: 1,
                rooms: localRooms,
            });
            this.pubClient.publish(this.requestChannel, request);
        });
    }
    async fetchSockets(opts) {
        var _a;
        const localSockets = await super.fetchSockets(opts);
        if ((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local) {
            return localSockets;
        }
        const numSub = await this.getNumSub();
        debug(&#039;waiting for %d responses to &quot;fetchSockets&quot; request&#039;, numSub);
        if (numSub &lt;= 1) {
            return localSockets;
        }
        const requestId = uid2(6);
        const request = JSON.stringify({
            uid: this.uid,
            requestId,
            type: RequestType.REMOTE_FETCH,
            opts: {
                rooms: [...opts.rooms],
                except: [...opts.except],
            },
        });
        return new Promise((resolve, reject) =&gt; {
            const timeout = setTimeout(() =&gt; {
                if (this.requests.has(requestId)) {
                    reject(new Error(&quot;timeout reached while waiting for fetchSockets response&quot;));
                    this.requests.delete(requestId);
                }
            }, this.requestsTimeout);
            this.requests.set(requestId, {
                type: RequestType.REMOTE_FETCH,
                numSub,
                resolve,
                timeout,
                msgCount: 1,
                sockets: localSockets,
            });
            this.pubClient.publish(this.requestChannel, request);
        });
    }
    addSockets(opts, rooms) {
        var _a;
        if ((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local) {
            return super.addSockets(opts, rooms);
        }
        const request = JSON.stringify({
            uid: this.uid,
            type: RequestType.REMOTE_JOIN,
            opts: {
                rooms: [...opts.rooms],
                except: [...opts.except],
            },
            rooms: [...rooms],
        });
        this.pubClient.publish(this.requestChannel, request);
    }
    delSockets(opts, rooms) {
        var _a;
        if ((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local) {
            return super.delSockets(opts, rooms);
        }
        const request = JSON.stringify({
            uid: this.uid,
            type: RequestType.REMOTE_LEAVE,
            opts: {
                rooms: [...opts.rooms],
                except: [...opts.except],
            },
            rooms: [...rooms],
        });
        this.pubClient.publish(this.requestChannel, request);
    }
    disconnectSockets(opts, close) {
        var _a;
        if ((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local) {
            return super.disconnectSockets(opts, close);
        }
        const request = JSON.stringify({
            uid: this.uid,
            type: RequestType.REMOTE_DISCONNECT,
            opts: {
                rooms: [...opts.rooms],
                except: [...opts.except],
            },
            close,
        });
        this.pubClient.publish(this.requestChannel, request);
    }
    serverSideEmit(packet) {
        const withAck = typeof packet[packet.length - 1] === &quot;function&quot;;
        if (withAck) {
            this.serverSideEmitWithAck(packet).catch(() =&gt; {
                // ignore errors
            });
            return;
        }
        const request = JSON.stringify({
            uid: this.uid,
            type: RequestType.SERVER_SIDE_EMIT,
            data: packet,
        });
        this.pubClient.publish(this.requestChannel, request);
    }
    async serverSideEmitWithAck(packet) {
        const ack = packet.pop();
        const numSub = (await this.getNumSub()) - 1; // ignore self
        debug(&#039;waiting for %d responses to &quot;serverSideEmit&quot; request&#039;, numSub);
        if (numSub &lt;= 0) {
            return ack(null, []);
        }
        const requestId = uid2(6);
        const request = JSON.stringify({
            uid: this.uid,
            requestId,
            type: RequestType.SERVER_SIDE_EMIT,
            data: packet,
        });
        const timeout = setTimeout(() =&gt; {
            const storedRequest = this.requests.get(requestId);
            if (storedRequest) {
                ack(new Error(`timeout reached: only ${storedRequest.responses.length} responses received out of ${storedRequest.numSub}`), storedRequest.responses);
                this.requests.delete(requestId);
            }
        }, this.requestsTimeout);
        this.requests.set(requestId, {
            type: RequestType.SERVER_SIDE_EMIT,
            numSub,
            timeout,
            resolve: ack,
            responses: [],
        });
        this.pubClient.publish(this.requestChannel, request);
    }
    /**
     * Get the number of subscribers of the request channel
     *
     * @private
     */
    getNumSub() {
        if (this.pubClient.constructor.name === &quot;Cluster&quot; ||
            this.pubClient.isCluster) {
            // Cluster
            const nodes = this.pubClient.nodes();
            return Promise.all(nodes.map((node) =&gt; node.send_command(&quot;pubsub&quot;, [&quot;numsub&quot;, this.requestChannel]))).then((values) =&gt; {
                let numSub = 0;
                values.map((value) =&gt; {
                    numSub += parseInt(value[1], 10);
                });
                return numSub;
            });
        }
        else if (typeof this.pubClient.pSubscribe === &quot;function&quot;) {
            return this.pubClient
                .sendCommand([&quot;pubsub&quot;, &quot;numsub&quot;, this.requestChannel])
                .then((res) =&gt; parseInt(res[1], 10));
        }
        else {
            // RedisClient or Redis
            return new Promise((resolve, reject) =&gt; {
                this.pubClient.send_command(&quot;pubsub&quot;, [&quot;numsub&quot;, this.requestChannel], (err, numSub) =&gt; {
                    if (err)
                        return reject(err);
                    resolve(parseInt(numSub[1], 10));
                });
            });
        }
    }
    serverCount() {
        return this.getNumSub();
    }
}
exports.RedisAdapter = RedisAdapter;</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
