<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/ace-builds/src/mode-livescript.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/ace-builds/src/mode-livescript.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">60.45</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">271</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">35.66</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.38</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">define(&quot;ace/mode/matching_brace_outdent&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/range&quot;], function(require, exports, module){&quot;use strict&quot;;
var Range = require(&quot;../range&quot;).Range;
var MatchingBraceOutdent = function () { };
(function () {
    this.checkOutdent = function (line, input) {
        if (!/^\s+$/.test(line))
            return false;
        return /^\s*\}/.test(input);
    };
    this.autoOutdent = function (doc, row) {
        var line = doc.getLine(row);
        var match = line.match(/^(\s*\})/);
        if (!match)
            return 0;
        var column = match[1].length;
        var openBracePos = doc.findMatchingBracket({ row: row, column: column });
        if (!openBracePos || openBracePos.row == row)
            return 0;
        var indent = this.$getIndent(doc.getLine(openBracePos.row));
        doc.replace(new Range(row, 0, row, column - 1), indent);
    };
    this.$getIndent = function (line) {
        return line.match(/^\s*/)[0];
    };
}).call(MatchingBraceOutdent.prototype);
exports.MatchingBraceOutdent = MatchingBraceOutdent;

});

define(&quot;ace/mode/livescript&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/tokenizer&quot;,&quot;ace/mode/matching_brace_outdent&quot;,&quot;ace/mode/behaviour/cstyle&quot;,&quot;ace/mode/text&quot;], function(require, exports, module){var identifier, LiveScriptMode, keywordend, stringfill;
identifier = &#039;(?![\\d\\s])[$\\w\\xAA-\\uFFDC](?:(?!\\s)[$\\w\\xAA-\\uFFDC]|-[A-Za-z])*&#039;;
exports.Mode = LiveScriptMode = (function (superclass) {
    var indenter, prototype = extend$((import$(LiveScriptMode, superclass).displayName = &#039;LiveScriptMode&#039;, LiveScriptMode), superclass).prototype, constructor = LiveScriptMode;
    function LiveScriptMode() {
        var that;
        this.$tokenizer = new (require(&#039;../tokenizer&#039;)).Tokenizer(LiveScriptMode.Rules);
        if (that = require(&#039;../mode/matching_brace_outdent&#039;)) {
            this.$outdent = new that.MatchingBraceOutdent;
        }
        this.$id = &quot;ace/mode/livescript&quot;;
        this.$behaviour = new (require(&quot;./behaviour/cstyle&quot;).CstyleBehaviour)();
    }
    indenter = RegExp(&#039;(?:[({[=:]|[-~]&gt;|\\b(?:e(?:lse|xport)|d(?:o|efault)|t(?:ry|hen)|finally|import(?:\\s*all)?|const|var|let|new|catch(?:\\s*&#039; + identifier + &#039;)?))\\s*$&#039;);
    prototype.getNextLineIndent = function (state, line, tab) {
        var indent, tokens;
        indent = this.$getIndent(line);
        tokens = this.$tokenizer.getLineTokens(line, state).tokens;
        if (!(tokens.length &amp;&amp; tokens[tokens.length - 1].type === &#039;comment&#039;)) {
            if (state === &#039;start&#039; &amp;&amp; indenter.test(line)) {
                indent += tab;
            }
        }
        return indent;
    };
    prototype.lineCommentStart = &quot;#&quot;;
    prototype.blockComment = { start: &quot;###&quot;, end: &quot;###&quot; };
    prototype.checkOutdent = function (state, line, input) {
        var ref$;
        return (ref$ = this.$outdent) != null ? ref$.checkOutdent(line, input) : void 8;
    };
    prototype.autoOutdent = function (state, doc, row) {
        var ref$;
        return (ref$ = this.$outdent) != null ? ref$.autoOutdent(doc, row) : void 8;
    };
    return LiveScriptMode;
}(require(&#039;../mode/text&#039;).Mode));
keywordend = &#039;(?![$\\w]|-[A-Za-z]|\\s*:(?![:=]))&#039;;
stringfill = {
    defaultToken: &#039;string&#039;
};
LiveScriptMode.Rules = {
    start: [
        {
            token: &#039;keyword&#039;,
            regex: &#039;(?:t(?:h(?:is|row|en)|ry|ypeof!?)|c(?:on(?:tinue|st)|a(?:se|tch)|lass)|i(?:n(?:stanceof)?|mp(?:ort(?:\\s+all)?|lements)|[fs])|d(?:e(?:fault|lete|bugger)|o)|f(?:or(?:\\s+own)?|inally|unction)|s(?:uper|witch)|e(?:lse|x(?:tends|port)|val)|a(?:nd|rguments)|n(?:ew|ot)|un(?:less|til)|w(?:hile|ith)|o[fr]|return|break|let|var|loop)&#039; + keywordend
        }, {
            token: &#039;constant.language&#039;,
            regex: &#039;(?:true|false|yes|no|on|off|null|void|undefined)&#039; + keywordend
        }, {
            token: &#039;invalid.illegal&#039;,
            regex: &#039;(?:p(?:ackage|r(?:ivate|otected)|ublic)|i(?:mplements|nterface)|enum|static|yield)&#039; + keywordend
        }, {
            token: &#039;language.support.class&#039;,
            regex: &#039;(?:R(?:e(?:gExp|ferenceError)|angeError)|S(?:tring|yntaxError)|E(?:rror|valError)|Array|Boolean|Date|Function|Number|Object|TypeError|URIError)&#039; + keywordend
        }, {
            token: &#039;language.support.function&#039;,
            regex: &#039;(?:is(?:NaN|Finite)|parse(?:Int|Float)|Math|JSON|(?:en|de)codeURI(?:Component)?)&#039; + keywordend
        }, {
            token: &#039;variable.language&#039;,
            regex: &#039;(?:t(?:hat|il|o)|f(?:rom|allthrough)|it|by|e)&#039; + keywordend
        }, {
            token: &#039;identifier&#039;,
            regex: identifier + &#039;\\s*:(?![:=])&#039;
        }, {
            token: &#039;variable&#039;,
            regex: identifier
        }, {
            token: &#039;keyword.operator&#039;,
            regex: &#039;(?:\\.{3}|\\s+\\?)&#039;
        }, {
            token: &#039;keyword.variable&#039;,
            regex: &#039;(?:@+|::|\\.\\.)&#039;,
            next: &#039;key&#039;
        }, {
            token: &#039;keyword.operator&#039;,
            regex: &#039;\\.\\s*&#039;,
            next: &#039;key&#039;
        }, {
            token: &#039;string&#039;,
            regex: &#039;\\\\\\S[^\\s,;)}\\]]*&#039;
        }, {
            token: &#039;string.doc&#039;,
            regex: &#039;\&#039;\&#039;\&#039;&#039;,
            next: &#039;qdoc&#039;
        }, {
            token: &#039;string.doc&#039;,
            regex: &#039;&quot;&quot;&quot;&#039;,
            next: &#039;qqdoc&#039;
        }, {
            token: &#039;string&#039;,
            regex: &#039;\&#039;&#039;,
            next: &#039;qstring&#039;
        }, {
            token: &#039;string&#039;,
            regex: &#039;&quot;&#039;,
            next: &#039;qqstring&#039;
        }, {
            token: &#039;string&#039;,
            regex: &#039;`&#039;,
            next: &#039;js&#039;
        }, {
            token: &#039;string&#039;,
            regex: &#039;&lt;\\[&#039;,
            next: &#039;words&#039;
        }, {
            token: &#039;string.regex&#039;,
            regex: &#039;//&#039;,
            next: &#039;heregex&#039;
        }, {
            token: &#039;comment.doc&#039;,
            regex: &#039;/\\*&#039;,
            next: &#039;comment&#039;
        }, {
            token: &#039;comment&#039;,
            regex: &#039;#.*&#039;
        }, {
            token: &#039;string.regex&#039;,
            regex: &#039;\\/(?:[^[\\/\\n\\\\]*(?:(?:\\\\.|\\[[^\\]\\n\\\\]*(?:\\\\.[^\\]\\n\\\\]*)*\\])[^[\\/\\n\\\\]*)*)\\/[gimy$]{0,4}&#039;,
            next: &#039;key&#039;
        }, {
            token: &#039;constant.numeric&#039;,
            regex: &#039;(?:0x[\\da-fA-F][\\da-fA-F_]*|(?:[2-9]|[12]\\d|3[0-6])r[\\da-zA-Z][\\da-zA-Z_]*|(?:\\d[\\d_]*(?:\\.\\d[\\d_]*)?|\\.\\d[\\d_]*)(?:e[+-]?\\d[\\d_]*)?[\\w$]*)&#039;
        }, {
            token: &#039;lparen&#039;,
            regex: &#039;[({[]&#039;
        }, {
            token: &#039;rparen&#039;,
            regex: &#039;[)}\\]]&#039;,
            next: &#039;key&#039;
        }, {
            token: &#039;keyword.operator&#039;,
            regex: &#039;[\\^!|&amp;%+\\-]+&#039;
        }, {
            token: &#039;text&#039;,
            regex: &#039;\\s+&#039;
        }
    ],
    heregex: [
        {
            token: &#039;string.regex&#039;,
            regex: &#039;.*?//[gimy$?]{0,4}&#039;,
            next: &#039;start&#039;
        }, {
            token: &#039;string.regex&#039;,
            regex: &#039;\\s*#{&#039;
        }, {
            token: &#039;comment.regex&#039;,
            regex: &#039;\\s+(?:#.*)?&#039;
        }, {
            defaultToken: &#039;string.regex&#039;
        }
    ],
    key: [
        {
            token: &#039;keyword.operator&#039;,
            regex: &#039;[.?@!]+&#039;
        }, {
            token: &#039;identifier&#039;,
            regex: identifier,
            next: &#039;start&#039;
        }, {
            token: &#039;text&#039;,
            regex: &#039;&#039;,
            next: &#039;start&#039;
        }
    ],
    comment: [
        {
            token: &#039;comment.doc&#039;,
            regex: &#039;.*?\\*/&#039;,
            next: &#039;start&#039;
        }, {
            defaultToken: &#039;comment.doc&#039;
        }
    ],
    qdoc: [
        {
            token: &#039;string&#039;,
            regex: &quot;.*?&#039;&#039;&#039;&quot;,
            next: &#039;key&#039;
        }, stringfill
    ],
    qqdoc: [
        {
            token: &#039;string&#039;,
            regex: &#039;.*?&quot;&quot;&quot;&#039;,
            next: &#039;key&#039;
        }, stringfill
    ],
    qstring: [
        {
            token: &#039;string&#039;,
            regex: &#039;[^\\\\\&#039;]*(?:\\\\.[^\\\\\&#039;]*)*\&#039;&#039;,
            next: &#039;key&#039;
        }, stringfill
    ],
    qqstring: [
        {
            token: &#039;string&#039;,
            regex: &#039;[^\\\\&quot;]*(?:\\\\.[^\\\\&quot;]*)*&quot;&#039;,
            next: &#039;key&#039;
        }, stringfill
    ],
    js: [
        {
            token: &#039;string&#039;,
            regex: &#039;[^\\\\`]*(?:\\\\.[^\\\\`]*)*`&#039;,
            next: &#039;key&#039;
        }, stringfill
    ],
    words: [
        {
            token: &#039;string&#039;,
            regex: &#039;.*?\\]&gt;&#039;,
            next: &#039;key&#039;
        }, stringfill
    ]
};
function extend$(sub, sup) {
    function fun() { }
    fun.prototype = (sub.superclass = sup).prototype;
    (sub.prototype = new fun).constructor = sub;
    if (typeof sup.extended == &#039;function&#039;)
        sup.extended(sub);
    return sub;
}
function import$(obj, src) {
    var own = {}.hasOwnProperty;
    for (var key in src)
        if (own.call(src, key))
            obj[key] = src[key];
    return obj;
}

});                (function() {
                    window.require([&quot;ace/mode/livescript&quot;], function(m) {
                        if (typeof module == &quot;object&quot; &amp;&amp; typeof exports == &quot;object&quot; &amp;&amp; module) {
                            module.exports = m;
                        }
                    });
                })();</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
