<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@typescript-eslint/eslint-plugin/dist/rules/strict-boolean-expressions.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@typescript-eslint/eslint-plugin/dist/rules/strict-boolean-expressions.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">64.21</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">784</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">63.96</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.67</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
var __createBinding = (this &amp;&amp; this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (&quot;get&quot; in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this &amp;&amp; this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, &quot;default&quot;, { enumerable: true, value: v });
}) : function(o, v) {
    o[&quot;default&quot;] = v;
});
var __importStar = (this &amp;&amp; this.__importStar) || function (mod) {
    if (mod &amp;&amp; mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== &quot;default&quot; &amp;&amp; Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
const utils_1 = require(&quot;@typescript-eslint/utils&quot;);
const tsutils = __importStar(require(&quot;tsutils&quot;));
const ts = __importStar(require(&quot;typescript&quot;));
const util = __importStar(require(&quot;../util&quot;));
exports.default = util.createRule({
    name: &#039;strict-boolean-expressions&#039;,
    meta: {
        type: &#039;suggestion&#039;,
        fixable: &#039;code&#039;,
        hasSuggestions: true,
        docs: {
            description: &#039;Disallow certain types in boolean expressions&#039;,
            recommended: false,
            requiresTypeChecking: true,
        },
        schema: [
            {
                type: &#039;object&#039;,
                properties: {
                    allowString: { type: &#039;boolean&#039; },
                    allowNumber: { type: &#039;boolean&#039; },
                    allowNullableObject: { type: &#039;boolean&#039; },
                    allowNullableBoolean: { type: &#039;boolean&#039; },
                    allowNullableString: { type: &#039;boolean&#039; },
                    allowNullableNumber: { type: &#039;boolean&#039; },
                    allowNullableEnum: { type: &#039;boolean&#039; },
                    allowAny: { type: &#039;boolean&#039; },
                    allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: {
                        type: &#039;boolean&#039;,
                    },
                },
                additionalProperties: false,
            },
        ],
        messages: {
            conditionErrorOther: &#039;Unexpected value in conditional. &#039; +
                &#039;A boolean expression is required.&#039;,
            conditionErrorAny: &#039;Unexpected any value in conditional. &#039; +
                &#039;An explicit comparison or type cast is required.&#039;,
            conditionErrorNullish: &#039;Unexpected nullish value in conditional. &#039; +
                &#039;The condition is always false.&#039;,
            conditionErrorNullableBoolean: &#039;Unexpected nullable boolean value in conditional. &#039; +
                &#039;Please handle the nullish case explicitly.&#039;,
            conditionErrorString: &#039;Unexpected string value in conditional. &#039; +
                &#039;An explicit empty string check is required.&#039;,
            conditionErrorNullableString: &#039;Unexpected nullable string value in conditional. &#039; +
                &#039;Please handle the nullish/empty cases explicitly.&#039;,
            conditionErrorNumber: &#039;Unexpected number value in conditional. &#039; +
                &#039;An explicit zero/NaN check is required.&#039;,
            conditionErrorNullableNumber: &#039;Unexpected nullable number value in conditional. &#039; +
                &#039;Please handle the nullish/zero/NaN cases explicitly.&#039;,
            conditionErrorObject: &#039;Unexpected object value in conditional. &#039; +
                &#039;The condition is always true.&#039;,
            conditionErrorNullableObject: &#039;Unexpected nullable object value in conditional. &#039; +
                &#039;An explicit null check is required.&#039;,
            conditionErrorNullableEnum: &#039;Unexpected nullable enum value in conditional. &#039; +
                &#039;Please handle the nullish/zero/NaN cases explicitly.&#039;,
            noStrictNullCheck: &#039;This rule requires the `strictNullChecks` compiler option to be turned on to function correctly.&#039;,
            conditionFixDefaultFalse: &#039;Explicitly treat nullish value the same as false (`value ?? false`)&#039;,
            conditionFixDefaultEmptyString: &#039;Explicitly treat nullish value the same as an empty string (`value ?? &quot;&quot;`)&#039;,
            conditionFixDefaultZero: &#039;Explicitly treat nullish value the same as 0 (`value ?? 0`)&#039;,
            conditionFixCompareNullish: &#039;Change condition to check for null/undefined (`value != null`)&#039;,
            conditionFixCastBoolean: &#039;Explicitly cast value to a boolean (`Boolean(value)`)&#039;,
            conditionFixCompareTrue: &#039;Change condition to check if true (`value === true`)&#039;,
            conditionFixCompareFalse: &#039;Change condition to check if false (`value === false`)&#039;,
            conditionFixCompareStringLength: &quot;Change condition to check string&#039;s length (`value.length !== 0`)&quot;,
            conditionFixCompareEmptyString: &#039;Change condition to check for empty string (`value !== &quot;&quot;`)&#039;,
            conditionFixCompareZero: &#039;Change condition to check for 0 (`value !== 0`)&#039;,
            conditionFixCompareNaN: &#039;Change condition to check for NaN (`!Number.isNaN(value)`)&#039;,
        },
    },
    defaultOptions: [
        {
            allowString: true,
            allowNumber: true,
            allowNullableObject: true,
            allowNullableBoolean: false,
            allowNullableString: false,
            allowNullableNumber: false,
            allowNullableEnum: true,
            allowAny: false,
            allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: false,
        },
    ],
    create(context, [options]) {
        const parserServices = util.getParserServices(context);
        const typeChecker = parserServices.program.getTypeChecker();
        const compilerOptions = parserServices.program.getCompilerOptions();
        const sourceCode = context.getSourceCode();
        const isStrictNullChecks = tsutils.isStrictCompilerOptionEnabled(compilerOptions, &#039;strictNullChecks&#039;);
        if (!isStrictNullChecks &amp;&amp;
            options.allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing !== true) {
            context.report({
                loc: {
                    start: { line: 0, column: 0 },
                    end: { line: 0, column: 0 },
                },
                messageId: &#039;noStrictNullCheck&#039;,
            });
        }
        const traversedNodes = new Set();
        return {
            ConditionalExpression: traverseTestExpression,
            DoWhileStatement: traverseTestExpression,
            ForStatement: traverseTestExpression,
            IfStatement: traverseTestExpression,
            WhileStatement: traverseTestExpression,
            &#039;LogicalExpression[operator!=&quot;??&quot;]&#039;: traverseLogicalExpression,
            &#039;UnaryExpression[operator=&quot;!&quot;]&#039;: traverseUnaryLogicalExpression,
        };
        /**
         * Inspects condition of a test expression. (`if`, `while`, `for`, etc.)
         */
        function traverseTestExpression(node) {
            if (node.test == null) {
                return;
            }
            traverseNode(node.test, true);
        }
        /**
         * Inspects the argument of a unary logical expression (`!`).
         */
        function traverseUnaryLogicalExpression(node) {
            traverseNode(node.argument, true);
        }
        /**
         * Inspects the arguments of a logical expression (`&amp;&amp;`, `||`).
         *
         * If the logical expression is a descendant of a test expression,
         * the `isCondition` flag should be set to true.
         * Otherwise, if the logical expression is there on it&#039;s own,
         * it&#039;s used for control flow and is not a condition itself.
         */
        function traverseLogicalExpression(node, isCondition = false) {
            // left argument is always treated as a condition
            traverseNode(node.left, true);
            // if the logical expression is used for control flow,
            // then it&#039;s right argument is used for it&#039;s side effects only
            traverseNode(node.right, isCondition);
        }
        /**
         * Inspects any node.
         *
         * If it&#039;s a logical expression then it recursively traverses its arguments.
         * If it&#039;s any other kind of node then it&#039;s type is finally checked against the rule,
         * unless `isCondition` flag is set to false, in which case
         * it&#039;s assumed to be used for side effects only and is skipped.
         */
        function traverseNode(node, isCondition) {
            // prevent checking the same node multiple times
            if (traversedNodes.has(node)) {
                return;
            }
            traversedNodes.add(node);
            // for logical operator, we check its operands
            if (node.type === utils_1.AST_NODE_TYPES.LogicalExpression &amp;&amp;
                node.operator !== &#039;??&#039;) {
                traverseLogicalExpression(node, isCondition);
                return;
            }
            // skip if node is not a condition
            if (!isCondition) {
                return;
            }
            checkNode(node);
        }
        /**
         * This function does the actual type check on a node.
         * It analyzes the type of a node and checks if it is allowed in a boolean context.
         */
        function checkNode(node) {
            const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);
            const type = util.getConstrainedTypeAtLocation(typeChecker, tsNode);
            const types = inspectVariantTypes(tsutils.unionTypeParts(type));
            const is = (...wantedTypes) =&gt; types.size === wantedTypes.length &amp;&amp;
                wantedTypes.every(type =&gt; types.has(type));
            // boolean
            if (is(&#039;boolean&#039;) || is(&#039;truthy boolean&#039;)) {
                // boolean is always okay
                return;
            }
            // never
            if (is(&#039;never&#039;)) {
                // never is always okay
                return;
            }
            // nullish
            if (is(&#039;nullish&#039;)) {
                // condition is always false
                context.report({ node, messageId: &#039;conditionErrorNullish&#039; });
                return;
            }
            // Known edge case: boolean `true` and nullish values are always valid boolean expressions
            if (is(&#039;nullish&#039;, &#039;truthy boolean&#039;)) {
                return;
            }
            // nullable boolean
            if (is(&#039;nullish&#039;, &#039;boolean&#039;)) {
                if (!options.allowNullableBoolean) {
                    if (isLogicalNegationExpression(node.parent)) {
                        // if (!nullableBoolean)
                        context.report({
                            node,
                            messageId: &#039;conditionErrorNullableBoolean&#039;,
                            suggest: [
                                {
                                    messageId: &#039;conditionFixDefaultFalse&#039;,
                                    fix: util.getWrappingFixer({
                                        sourceCode,
                                        node,
                                        wrap: code =&gt; `${code} ?? false`,
                                    }),
                                },
                                {
                                    messageId: &#039;conditionFixCompareFalse&#039;,
                                    fix: util.getWrappingFixer({
                                        sourceCode,
                                        node: node.parent,
                                        innerNode: node,
                                        wrap: code =&gt; `${code} === false`,
                                    }),
                                },
                            ],
                        });
                    }
                    else {
                        // if (nullableBoolean)
                        context.report({
                            node,
                            messageId: &#039;conditionErrorNullableBoolean&#039;,
                            suggest: [
                                {
                                    messageId: &#039;conditionFixDefaultFalse&#039;,
                                    fix: util.getWrappingFixer({
                                        sourceCode,
                                        node,
                                        wrap: code =&gt; `${code} ?? false`,
                                    }),
                                },
                                {
                                    messageId: &#039;conditionFixCompareTrue&#039;,
                                    fix: util.getWrappingFixer({
                                        sourceCode,
                                        node,
                                        wrap: code =&gt; `${code} === true`,
                                    }),
                                },
                            ],
                        });
                    }
                }
                return;
            }
            // Known edge case: truthy primitives and nullish values are always valid boolean expressions
            if ((options.allowNumber &amp;&amp; is(&#039;nullish&#039;, &#039;truthy number&#039;)) ||
                (options.allowString &amp;&amp; is(&#039;nullish&#039;, &#039;truthy string&#039;))) {
                return;
            }
            // string
            if (is(&#039;string&#039;) || is(&#039;truthy string&#039;)) {
                if (!options.allowString) {
                    if (isLogicalNegationExpression(node.parent)) {
                        // if (!string)
                        context.report({
                            node,
                            messageId: &#039;conditionErrorString&#039;,
                            suggest: [
                                {
                                    messageId: &#039;conditionFixCompareStringLength&#039;,
                                    fix: util.getWrappingFixer({
                                        sourceCode,
                                        node: node.parent,
                                        innerNode: node,
                                        wrap: code =&gt; `${code}.length === 0`,
                                    }),
                                },
                                {
                                    messageId: &#039;conditionFixCompareEmptyString&#039;,
                                    fix: util.getWrappingFixer({
                                        sourceCode,
                                        node: node.parent,
                                        innerNode: node,
                                        wrap: code =&gt; `${code} === &quot;&quot;`,
                                    }),
                                },
                                {
                                    messageId: &#039;conditionFixCastBoolean&#039;,
                                    fix: util.getWrappingFixer({
                                        sourceCode,
                                        node: node.parent,
                                        innerNode: node,
                                        wrap: code =&gt; `!Boolean(${code})`,
                                    }),
                                },
                            ],
                        });
                    }
                    else {
                        // if (string)
                        context.report({
                            node,
                            messageId: &#039;conditionErrorString&#039;,
                            suggest: [
                                {
                                    messageId: &#039;conditionFixCompareStringLength&#039;,
                                    fix: util.getWrappingFixer({
                                        sourceCode,
                                        node,
                                        wrap: code =&gt; `${code}.length &gt; 0`,
                                    }),
                                },
                                {
                                    messageId: &#039;conditionFixCompareEmptyString&#039;,
                                    fix: util.getWrappingFixer({
                                        sourceCode,
                                        node,
                                        wrap: code =&gt; `${code} !== &quot;&quot;`,
                                    }),
                                },
                                {
                                    messageId: &#039;conditionFixCastBoolean&#039;,
                                    fix: util.getWrappingFixer({
                                        sourceCode,
                                        node,
                                        wrap: code =&gt; `Boolean(${code})`,
                                    }),
                                },
                            ],
                        });
                    }
                }
                return;
            }
            // nullable string
            if (is(&#039;nullish&#039;, &#039;string&#039;)) {
                if (!options.allowNullableString) {
                    if (isLogicalNegationExpression(node.parent)) {
                        // if (!nullableString)
                        context.report({
                            node,
                            messageId: &#039;conditionErrorNullableString&#039;,
                            suggest: [
                                {
                                    messageId: &#039;conditionFixCompareNullish&#039;,
                                    fix: util.getWrappingFixer({
                                        sourceCode,
                                        node: node.parent,
                                        innerNode: node,
                                        wrap: code =&gt; `${code} == null`,
                                    }),
                                },
                                {
                                    messageId: &#039;conditionFixDefaultEmptyString&#039;,
                                    fix: util.getWrappingFixer({
                                        sourceCode,
                                        node,
                                        wrap: code =&gt; `${code} ?? &quot;&quot;`,
                                    }),
                                },
                                {
                                    messageId: &#039;conditionFixCastBoolean&#039;,
                                    fix: util.getWrappingFixer({
                                        sourceCode,
                                        node: node.parent,
                                        innerNode: node,
                                        wrap: code =&gt; `!Boolean(${code})`,
                                    }),
                                },
                            ],
                        });
                    }
                    else {
                        // if (nullableString)
                        context.report({
                            node,
                            messageId: &#039;conditionErrorNullableString&#039;,
                            suggest: [
                                {
                                    messageId: &#039;conditionFixCompareNullish&#039;,
                                    fix: util.getWrappingFixer({
                                        sourceCode,
                                        node,
                                        wrap: code =&gt; `${code} != null`,
                                    }),
                                },
                                {
                                    messageId: &#039;conditionFixDefaultEmptyString&#039;,
                                    fix: util.getWrappingFixer({
                                        sourceCode,
                                        node,
                                        wrap: code =&gt; `${code} ?? &quot;&quot;`,
                                    }),
                                },
                                {
                                    messageId: &#039;conditionFixCastBoolean&#039;,
                                    fix: util.getWrappingFixer({
                                        sourceCode,
                                        node,
                                        wrap: code =&gt; `Boolean(${code})`,
                                    }),
                                },
                            ],
                        });
                    }
                }
                return;
            }
            // number
            if (is(&#039;number&#039;) || is(&#039;truthy number&#039;)) {
                if (!options.allowNumber) {
                    if (isArrayLengthExpression(node, typeChecker, parserServices)) {
                        if (isLogicalNegationExpression(node.parent)) {
                            // if (!array.length)
                            context.report({
                                node,
                                messageId: &#039;conditionErrorNumber&#039;,
                                fix: util.getWrappingFixer({
                                    sourceCode,
                                    node: node.parent,
                                    innerNode: node,
                                    wrap: code =&gt; `${code} === 0`,
                                }),
                            });
                        }
                        else {
                            // if (array.length)
                            context.report({
                                node,
                                messageId: &#039;conditionErrorNumber&#039;,
                                fix: util.getWrappingFixer({
                                    sourceCode,
                                    node,
                                    wrap: code =&gt; `${code} &gt; 0`,
                                }),
                            });
                        }
                    }
                    else if (isLogicalNegationExpression(node.parent)) {
                        // if (!number)
                        context.report({
                            node,
                            messageId: &#039;conditionErrorNumber&#039;,
                            suggest: [
                                {
                                    messageId: &#039;conditionFixCompareZero&#039;,
                                    fix: util.getWrappingFixer({
                                        sourceCode,
                                        node: node.parent,
                                        innerNode: node,
                                        // TODO: we have to compare to 0n if the type is bigint
                                        wrap: code =&gt; `${code} === 0`,
                                    }),
                                },
                                {
                                    // TODO: don&#039;t suggest this for bigint because it can&#039;t be NaN
                                    messageId: &#039;conditionFixCompareNaN&#039;,
                                    fix: util.getWrappingFixer({
                                        sourceCode,
                                        node: node.parent,
                                        innerNode: node,
                                        wrap: code =&gt; `Number.isNaN(${code})`,
                                    }),
                                },
                                {
                                    messageId: &#039;conditionFixCastBoolean&#039;,
                                    fix: util.getWrappingFixer({
                                        sourceCode,
                                        node: node.parent,
                                        innerNode: node,
                                        wrap: code =&gt; `!Boolean(${code})`,
                                    }),
                                },
                            ],
                        });
                    }
                    else {
                        // if (number)
                        context.report({
                            node,
                            messageId: &#039;conditionErrorNumber&#039;,
                            suggest: [
                                {
                                    messageId: &#039;conditionFixCompareZero&#039;,
                                    fix: util.getWrappingFixer({
                                        sourceCode,
                                        node,
                                        wrap: code =&gt; `${code} !== 0`,
                                    }),
                                },
                                {
                                    messageId: &#039;conditionFixCompareNaN&#039;,
                                    fix: util.getWrappingFixer({
                                        sourceCode,
                                        node,
                                        wrap: code =&gt; `!Number.isNaN(${code})`,
                                    }),
                                },
                                {
                                    messageId: &#039;conditionFixCastBoolean&#039;,
                                    fix: util.getWrappingFixer({
                                        sourceCode,
                                        node,
                                        wrap: code =&gt; `Boolean(${code})`,
                                    }),
                                },
                            ],
                        });
                    }
                }
                return;
            }
            // nullable number
            if (is(&#039;nullish&#039;, &#039;number&#039;)) {
                if (!options.allowNullableNumber) {
                    if (isLogicalNegationExpression(node.parent)) {
                        // if (!nullableNumber)
                        context.report({
                            node,
                            messageId: &#039;conditionErrorNullableNumber&#039;,
                            suggest: [
                                {
                                    messageId: &#039;conditionFixCompareNullish&#039;,
                                    fix: util.getWrappingFixer({
                                        sourceCode,
                                        node: node.parent,
                                        innerNode: node,
                                        wrap: code =&gt; `${code} == null`,
                                    }),
                                },
                                {
                                    messageId: &#039;conditionFixDefaultZero&#039;,
                                    fix: util.getWrappingFixer({
                                        sourceCode,
                                        node,
                                        wrap: code =&gt; `${code} ?? 0`,
                                    }),
                                },
                                {
                                    messageId: &#039;conditionFixCastBoolean&#039;,
                                    fix: util.getWrappingFixer({
                                        sourceCode,
                                        node: node.parent,
                                        innerNode: node,
                                        wrap: code =&gt; `!Boolean(${code})`,
                                    }),
                                },
                            ],
                        });
                    }
                    else {
                        // if (nullableNumber)
                        context.report({
                            node,
                            messageId: &#039;conditionErrorNullableNumber&#039;,
                            suggest: [
                                {
                                    messageId: &#039;conditionFixCompareNullish&#039;,
                                    fix: util.getWrappingFixer({
                                        sourceCode,
                                        node,
                                        wrap: code =&gt; `${code} != null`,
                                    }),
                                },
                                {
                                    messageId: &#039;conditionFixDefaultZero&#039;,
                                    fix: util.getWrappingFixer({
                                        sourceCode,
                                        node,
                                        wrap: code =&gt; `${code} ?? 0`,
                                    }),
                                },
                                {
                                    messageId: &#039;conditionFixCastBoolean&#039;,
                                    fix: util.getWrappingFixer({
                                        sourceCode,
                                        node,
                                        wrap: code =&gt; `Boolean(${code})`,
                                    }),
                                },
                            ],
                        });
                    }
                }
                return;
            }
            // object
            if (is(&#039;object&#039;)) {
                // condition is always true
                context.report({ node, messageId: &#039;conditionErrorObject&#039; });
                return;
            }
            // nullable object
            if (is(&#039;nullish&#039;, &#039;object&#039;)) {
                if (!options.allowNullableObject) {
                    if (isLogicalNegationExpression(node.parent)) {
                        // if (!nullableObject)
                        context.report({
                            node,
                            messageId: &#039;conditionErrorNullableObject&#039;,
                            fix: util.getWrappingFixer({
                                sourceCode,
                                node: node.parent,
                                innerNode: node,
                                wrap: code =&gt; `${code} == null`,
                            }),
                        });
                    }
                    else {
                        // if (nullableObject)
                        context.report({
                            node,
                            messageId: &#039;conditionErrorNullableObject&#039;,
                            fix: util.getWrappingFixer({
                                sourceCode,
                                node,
                                wrap: code =&gt; `${code} != null`,
                            }),
                        });
                    }
                }
                return;
            }
            // nullable enum
            if (is(&#039;nullish&#039;, &#039;number&#039;, &#039;enum&#039;) || is(&#039;nullish&#039;, &#039;string&#039;, &#039;enum&#039;)) {
                if (!options.allowNullableEnum) {
                    if (isLogicalNegationExpression(node.parent)) {
                        context.report({
                            node,
                            messageId: &#039;conditionErrorNullableEnum&#039;,
                            fix: util.getWrappingFixer({
                                sourceCode,
                                node: node.parent,
                                innerNode: node,
                                wrap: code =&gt; `${code} == null`,
                            }),
                        });
                    }
                    else {
                        context.report({
                            node,
                            messageId: &#039;conditionErrorNullableEnum&#039;,
                            fix: util.getWrappingFixer({
                                sourceCode,
                                node,
                                wrap: code =&gt; `${code} != null`,
                            }),
                        });
                    }
                }
                return;
            }
            // any
            if (is(&#039;any&#039;)) {
                if (!options.allowAny) {
                    context.report({
                        node,
                        messageId: &#039;conditionErrorAny&#039;,
                        suggest: [
                            {
                                messageId: &#039;conditionFixCastBoolean&#039;,
                                fix: util.getWrappingFixer({
                                    sourceCode,
                                    node,
                                    wrap: code =&gt; `Boolean(${code})`,
                                }),
                            },
                        ],
                    });
                }
                return;
            }
            // other
            context.report({ node, messageId: &#039;conditionErrorOther&#039; });
        }
        /**
         * Check union variants for the types we care about
         */
        function inspectVariantTypes(types) {
            const variantTypes = new Set();
            if (types.some(type =&gt; tsutils.isTypeFlagSet(type, ts.TypeFlags.Null | ts.TypeFlags.Undefined | ts.TypeFlags.VoidLike))) {
                variantTypes.add(&#039;nullish&#039;);
            }
            const booleans = types.filter(type =&gt; tsutils.isTypeFlagSet(type, ts.TypeFlags.BooleanLike));
            // If incoming type is either &quot;true&quot; or &quot;false&quot;, there will be one type
            // object with intrinsicName set accordingly
            // If incoming type is boolean, there will be two type objects with
            // intrinsicName set &quot;true&quot; and &quot;false&quot; each because of tsutils.unionTypeParts()
            if (booleans.length === 1) {
                tsutils.isBooleanLiteralType(booleans[0], true)
                    ? variantTypes.add(&#039;truthy boolean&#039;)
                    : variantTypes.add(&#039;boolean&#039;);
            }
            else if (booleans.length === 2) {
                variantTypes.add(&#039;boolean&#039;);
            }
            const strings = types.filter(type =&gt; tsutils.isTypeFlagSet(type, ts.TypeFlags.StringLike));
            if (strings.length) {
                if (strings.some(type =&gt; type.isStringLiteral() &amp;&amp; type.value !== &#039;&#039;)) {
                    variantTypes.add(&#039;truthy string&#039;);
                }
                else {
                    variantTypes.add(&#039;string&#039;);
                }
            }
            const numbers = types.filter(type =&gt; tsutils.isTypeFlagSet(type, ts.TypeFlags.NumberLike | ts.TypeFlags.BigIntLike));
            if (numbers.length) {
                if (numbers.some(type =&gt; type.isNumberLiteral() &amp;&amp; type.value !== 0)) {
                    variantTypes.add(&#039;truthy number&#039;);
                }
                else {
                    variantTypes.add(&#039;number&#039;);
                }
            }
            if (types.some(type =&gt; tsutils.isTypeFlagSet(type, ts.TypeFlags.EnumLike))) {
                variantTypes.add(&#039;enum&#039;);
            }
            if (types.some(type =&gt; !tsutils.isTypeFlagSet(type, ts.TypeFlags.Null |
                ts.TypeFlags.Undefined |
                ts.TypeFlags.VoidLike |
                ts.TypeFlags.BooleanLike |
                ts.TypeFlags.StringLike |
                ts.TypeFlags.NumberLike |
                ts.TypeFlags.BigIntLike |
                ts.TypeFlags.TypeParameter |
                ts.TypeFlags.Any |
                ts.TypeFlags.Unknown |
                ts.TypeFlags.Never))) {
                variantTypes.add(&#039;object&#039;);
            }
            if (types.some(type =&gt; util.isTypeFlagSet(type, ts.TypeFlags.TypeParameter |
                ts.TypeFlags.Any |
                ts.TypeFlags.Unknown))) {
                variantTypes.add(&#039;any&#039;);
            }
            if (types.some(type =&gt; tsutils.isTypeFlagSet(type, ts.TypeFlags.Never))) {
                variantTypes.add(&#039;never&#039;);
            }
            return variantTypes;
        }
    },
});
function isLogicalNegationExpression(node) {
    return node.type === utils_1.AST_NODE_TYPES.UnaryExpression &amp;&amp; node.operator === &#039;!&#039;;
}
function isArrayLengthExpression(node, typeChecker, parserServices) {
    if (node.type !== utils_1.AST_NODE_TYPES.MemberExpression) {
        return false;
    }
    if (node.computed) {
        return false;
    }
    if (node.property.name !== &#039;length&#039;) {
        return false;
    }
    const objectTsNode = parserServices.esTreeNodeToTSNodeMap.get(node.object);
    const objectType = util.getConstrainedTypeAtLocation(typeChecker, objectTsNode);
    return util.isTypeArrayTypeOrUnionOfArrayTypes(objectType, typeChecker);
}
//# sourceMappingURL=strict-boolean-expressions.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
