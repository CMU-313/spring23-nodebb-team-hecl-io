<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@humanwhocodes/object-schema/tests/object-schema.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@humanwhocodes/object-schema/tests/object-schema.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">69.90</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">611</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">37.03</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.84</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @filedescription Object Schema Tests
 */
/* global it, describe, beforeEach */

&quot;use strict&quot;;

//-----------------------------------------------------------------------------
// Requirements
//-----------------------------------------------------------------------------

const assert = require(&quot;chai&quot;).assert;
const { ObjectSchema } = require(&quot;../src/&quot;);

//-----------------------------------------------------------------------------
// Class
//-----------------------------------------------------------------------------

describe(&quot;ObjectSchema&quot;, () =&gt; {

    let schema;

    describe(&quot;new ObjectSchema()&quot;, () =&gt; {

        it(&quot;should add a new key when a strategy is passed&quot;, () =&gt; {
            schema = new ObjectSchema({
                foo: {
                    merge() {},
                    validate() {}
                }
            });

            assert.isTrue(schema.hasKey(&quot;foo&quot;));
        });

        it(&quot;should throw an error when a strategy is missing a merge() method&quot;, () =&gt; {
            assert.throws(() =&gt; {
                schema = new ObjectSchema({
                    foo: {
                        validate() { }
                    }
                });
            }, /Definition for key &quot;foo&quot; must have a merge property/);
        });

        it(&quot;should throw an error when a strategy is missing a merge() method&quot;, () =&gt; {
            assert.throws(() =&gt; {
                schema = new ObjectSchema();
            }, /Schema definitions missing/);
        });

        it(&quot;should throw an error when a strategy is missing a validate() method&quot;, () =&gt; {
            assert.throws(() =&gt; {
                schema = new ObjectSchema({
                    foo: {
                        merge() { },
                    }
                });
            }, /Definition for key &quot;foo&quot; must have a validate\(\) method/);
        });

        it(&quot;should throw an error when merge is an invalid string&quot;, () =&gt; {
            assert.throws(() =&gt; {
                new ObjectSchema({
                    foo: {
                        merge: &quot;bar&quot;,
                        validate() { }
                    }
                });
            }, /key &quot;foo&quot; missing valid merge strategy/);
        });

        it(&quot;should throw an error when validate is an invalid string&quot;, () =&gt; {
            assert.throws(() =&gt; {
                new ObjectSchema({
                    foo: {
                        merge: &quot;assign&quot;,
                        validate: &quot;s&quot;
                    }
                });
            }, /key &quot;foo&quot; missing valid validation strategy/);
        });

    });


    describe(&quot;merge()&quot;, () =&gt; {

        it(&quot;should throw an error when an unexpected key is found&quot;, () =&gt; {
            let schema = new ObjectSchema({});

            assert.throws(() =&gt; {
                schema.merge({ foo: true }, { foo: true });
            }, /Unexpected key &quot;foo&quot;/);
        });

        it(&quot;should throw an error when merge() throws an error&quot;, () =&gt; {
            let schema = new ObjectSchema({
                foo: {
                    merge() {
                        throw new Error(&quot;Boom!&quot;);
                    },
                    validate() {}
                }
            });

            assert.throws(() =&gt; {
                schema.merge({ foo: true }, { foo: true });
            }, /Key &quot;foo&quot;: Boom!/);
        
        });

        it(&quot;should call the merge() strategy for one key when called&quot;, () =&gt; {
            
            schema = new ObjectSchema({
                foo: {
                    merge() {
                        return &quot;bar&quot;;
                    },
                    validate() {}
                }
            });

            const result = schema.merge({ foo: true }, { foo: false });
            assert.propertyVal(result, &quot;foo&quot;, &quot;bar&quot;);
        });

        it(&quot;should not call the merge() strategy when both objects don&#039;t contain the key&quot;, () =&gt; {
            
            let called = false;

            schema = new ObjectSchema({
                foo: {
                    merge() {
                        called = true;
                    },
                    validate() {}
                }
            });

            schema.merge({}, {});
            assert.isFalse(called, &quot;The merge() strategy should not have been called.&quot;);
        });

        it(&quot;should omit returning the key when the merge() strategy returns undefined&quot;, () =&gt; {
            schema = new ObjectSchema({
                foo: {
                    merge() {
                        return undefined;
                    },
                    validate() { }
                }
            });
            
            const result = schema.merge({ foo: true }, { foo: false });
            assert.notProperty(result, &quot;foo&quot;);
        });

        it(&quot;should call the merge() strategy for two keys when called&quot;, () =&gt; {
            schema = new ObjectSchema({
                foo: {
                    merge() {
                        return &quot;bar&quot;;
                    },
                    validate() { }
                },
                bar: {
                    merge() {
                        return &quot;baz&quot;;
                    },
                    validate() {}
                }
            });
            
            const result = schema.merge({ foo: true, bar: 1 }, { foo: true, bar: 2 });
            assert.propertyVal(result, &quot;foo&quot;, &quot;bar&quot;);
            assert.propertyVal(result, &quot;bar&quot;, &quot;baz&quot;);
        });

        it(&quot;should call the merge() strategy for two keys when called on three objects&quot;, () =&gt; {
            schema = new ObjectSchema({
                foo: {
                    merge() {
                        return &quot;bar&quot;;
                    },
                    validate() { }
                },
                bar: {
                    merge() {
                        return &quot;baz&quot;;
                    },
                    validate() { }
                }
            });
            
            const result = schema.merge(
                { foo: true, bar: 1 },
                { foo: true, bar: 3 },
                { foo: false, bar: 2 }
            );
            assert.propertyVal(result, &quot;foo&quot;, &quot;bar&quot;);
            assert.propertyVal(result, &quot;bar&quot;, &quot;baz&quot;);
        });

        it(&quot;should call the merge() strategy when defined as &#039;overwrite&#039;&quot;, () =&gt; {
            schema = new ObjectSchema({
                foo: {
                    merge: &quot;overwrite&quot;,
                    validate() { }
                }
            });
            
            const result = schema.merge(
                { foo: true },
                { foo: false }
            );
            assert.propertyVal(result, &quot;foo&quot;, false);
        });

        it(&quot;should call the merge() strategy when defined as &#039;assign&#039;&quot;, () =&gt; {
            schema = new ObjectSchema({
                foo: {
                    merge: &quot;assign&quot;,
                    validate() { }
                }
            });
            
            const result = schema.merge(
                { foo: { bar: true } },
                { foo: { baz: false } }
            );

            assert.strictEqual(result.foo.bar, true);
            assert.strictEqual(result.foo.baz, false);
        });

        it(&quot;should call the merge strategy when there&#039;s a subschema&quot;, () =&gt; {

            schema = new ObjectSchema({
                name: {
                    schema: {
                        first: {
                            merge: &quot;replace&quot;,
                            validate: &quot;string&quot;
                        },
                        last: {
                            merge: &quot;replace&quot;,
                            validate: &quot;string&quot;
                        }
                    }
                }
            });

            const result = schema.merge({
                name: {
                    first: &quot;n&quot;,
                    last: &quot;z&quot;
                }
            }, {
                name: {
                    first: &quot;g&quot;
                }
            });

            assert.strictEqual(result.name.first, &quot;g&quot;);
            assert.strictEqual(result.name.last, &quot;z&quot;);
        });

        it(&quot;should return separate objects when using subschema&quot;, () =&gt; {

            schema = new ObjectSchema({
                age: {
                    merge: &quot;replace&quot;,
                    validate: &quot;number&quot;
                },
                address: {
                    schema: {
                        street: {
                            schema: {
                                number: {
                                    merge: &quot;replace&quot;,
                                    validate: &quot;number&quot;
                                },
                                streetName: {
                                    merge: &quot;replace&quot;,
                                    validate: &quot;string&quot;
                                }
                            }
                        },
                        state: {
                            merge: &quot;replace&quot;,
                            validate: &quot;string&quot;
                        }
                    }
                }
            });

            const baseObject = {
                address: {
                    street: {
                        number: 100,
                        streetName: &quot;Foo St&quot;
                    },
                    state: &quot;HA&quot;
                }
            };

            const result = schema.merge(baseObject, {
                age: 29
            });

            assert.notStrictEqual(result.address.street, baseObject.address.street);
            assert.deepStrictEqual(result.address, baseObject.address);
        });

        it(&quot;should not error when calling the merge strategy when there&#039;s a subschema and no matching key in second object&quot;, () =&gt; {

            schema = new ObjectSchema({
                name: {
                    schema: {
                        first: {
                            merge: &quot;replace&quot;,
                            validate: &quot;string&quot;
                        },
                        last: {
                            merge: &quot;replace&quot;,
                            validate: &quot;string&quot;
                        }
                    }
                }
            });

            const result = schema.merge({
                name: {
                    first: &quot;n&quot;,
                    last: &quot;z&quot;
                }
            }, {
            });

            assert.strictEqual(result.name.first, &quot;n&quot;);
            assert.strictEqual(result.name.last, &quot;z&quot;);
        });

        it(&quot;should not error when calling the merge strategy when there&#039;s multiple subschemas and no matching key in second object&quot;, () =&gt; {

            schema = new ObjectSchema({
                user: {
                    schema: {
                        name: {
                            schema: {
                                first: {
                                    merge: &quot;replace&quot;,
                                    validate: &quot;string&quot;
                                },
                                last: {
                                    merge: &quot;replace&quot;,
                                    validate: &quot;string&quot;
                                }
                            }
                        }

                    }
                }
            });

            const result = schema.merge({
                user: {
                    name: {
                        first: &quot;n&quot;,
                        last: &quot;z&quot;
                    }
                }
            }, {
            });

            assert.strictEqual(result.user.name.first, &quot;n&quot;);
            assert.strictEqual(result.user.name.last, &quot;z&quot;);
        });


    });

    describe(&quot;validate()&quot;, () =&gt; {

        it(&quot;should throw an error when an unexpected key is found&quot;, () =&gt; {
            let schema = new ObjectSchema({});
            assert.throws(() =&gt; {
                schema.validate({ foo: true });
            }, /Unexpected key &quot;foo&quot;/);
        });

        it(&quot;should not throw an error when an expected key is found&quot;, () =&gt; {
            schema = new ObjectSchema({
                foo: {
                    merge() {
                        return &quot;bar&quot;;
                    },
                    validate() {}
                }
            });
            
            schema.validate({ foo: true });
        });

        it(&quot;should pass the property value into validate() when key is found&quot;, () =&gt; {
            schema = new ObjectSchema({
                foo: {
                    merge() {
                        return &quot;bar&quot;;
                    },
                    validate(value) {
                        assert.isTrue(value);
                    }
                }
            });
            
            schema.validate({ foo: true });
        });

        it(&quot;should not throw an error when expected keys are found&quot;, () =&gt; {
            schema = new ObjectSchema({
                foo: {
                    merge() {
                        return &quot;bar&quot;;
                    },
                    validate() {}
                },
                bar: {
                    merge() {
                        return &quot;baz&quot;;
                    },
                    validate() {}
                }
            });
            
            schema.validate({ foo: true, bar: true });
        });

        it(&quot;should not throw an error when expected keys are found with required keys&quot;, () =&gt; {
            schema = new ObjectSchema({
                foo: {
                    merge() {
                        return &quot;bar&quot;;
                    },
                    validate() { }
                },
                bar: {
                    requires: [&quot;foo&quot;],
                    merge() {
                        return &quot;baz&quot;;
                    },
                    validate() { }
                }
            });
            
            schema.validate({ foo: true, bar: true });
        });

        it(&quot;should throw an error when expected keys are found without required keys&quot;, () =&gt; {
            schema = new ObjectSchema({
                foo: {
                    merge() {
                        return &quot;bar&quot;;
                    },
                    validate() { }
                },
                baz: {
                    merge() {
                        return &quot;baz&quot;;
                    },
                    validate() { }
                },
                bar: {
                    name: &quot;bar&quot;,
                    requires: [&quot;foo&quot;, &quot;baz&quot;],
                    merge() { },
                    validate() { }
                }
            });

            assert.throws(() =&gt; {
                schema.validate({ bar: true });
            }, /Key &quot;bar&quot; requires keys &quot;foo&quot;, &quot;baz&quot;./);
        });


        it(&quot;should throw an error when an expected key is found but is invalid&quot;, () =&gt; {

            schema = new ObjectSchema({
                foo: {
                    merge() {
                        return &quot;bar&quot;;
                    },
                    validate() {
                        throw new Error(&quot;Invalid key.&quot;);
                    }
                }
            });

            assert.throws(() =&gt; {
                schema.validate({ foo: true });
            }, /Key &quot;foo&quot;: Invalid key/);
        });

        it(&quot;should throw an error when an expected key is found but is invalid with a string validator&quot;, () =&gt; {

            schema = new ObjectSchema({
                foo: {
                    merge() {
                        return &quot;bar&quot;;
                    },
                    validate: &quot;string&quot;
                }
            });

            assert.throws(() =&gt; {
                schema.validate({ foo: true });
            }, /Key &quot;foo&quot;: Expected a string/);
        });

        it(&quot;should throw an error when an expected key is found but is invalid with a number validator&quot;, () =&gt; {

            schema = new ObjectSchema({
                foo: {
                    merge() {
                        return &quot;bar&quot;;
                    },
                    validate: &quot;number&quot;
                }
            });

            assert.throws(() =&gt; {
                schema.validate({ foo: true });
            }, /Key &quot;foo&quot;: Expected a number/);
        });

        it(&quot;should throw an error when a required key is missing&quot;, () =&gt; {

            schema = new ObjectSchema({
                foo: {
                    required: true,
                    merge() {
                        return &quot;bar&quot;;
                    },
                    validate() {}
                }
            });

            assert.throws(() =&gt; {
                schema.validate({});
            }, /Missing required key &quot;foo&quot;/);
        });

        it(&quot;should throw an error when a subschema is provided and the value doesn&#039;t validate&quot;, () =&gt; {

            schema = new ObjectSchema({
                name: {
                    schema: {
                        first: {
                            merge: &quot;replace&quot;,
                            validate: &quot;string&quot;
                        },
                        last: {
                            merge: &quot;replace&quot;,
                            validate: &quot;string&quot;
                        }
                    }
                }
            });

            assert.throws(() =&gt; {
                schema.validate({
                    name: {
                        first: 123,
                        last: &quot;z&quot;
                    }
                });
                        
            }, /Key &quot;name&quot;: Key &quot;first&quot;: Expected a string/);
        });

        it(&quot;should not throw an error when a subschema is provided and the value validates&quot;, () =&gt; {

            schema = new ObjectSchema({
                name: {
                    schema: {
                        first: {
                            merge: &quot;replace&quot;,
                            validate: &quot;string&quot;
                        },
                        last: {
                            merge: &quot;replace&quot;,
                            validate: &quot;string&quot;
                        }
                    }
                }
            });

            schema.validate({
                name: {
                    first: &quot;n&quot;,
                    last: &quot;z&quot;
                }
            });
                    
        });

    });

});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
