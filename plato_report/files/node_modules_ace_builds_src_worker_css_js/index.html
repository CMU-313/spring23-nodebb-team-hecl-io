<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/ace-builds/src/worker-css.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/ace-builds/src/worker-css.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">61.51</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">8904</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">174.77</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">133.95</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;no use strict&quot;;
!(function(window) {
if (typeof window.window != &quot;undefined&quot; &amp;&amp; window.document)
    return;
if (window.require &amp;&amp; window.define)
    return;

if (!window.console) {
    window.console = function() {
        var msgs = Array.prototype.slice.call(arguments, 0);
        postMessage({type: &quot;log&quot;, data: msgs});
    };
    window.console.error =
    window.console.warn = 
    window.console.log =
    window.console.trace = window.console;
}
window.window = window;
window.ace = window;

window.onerror = function(message, file, line, col, err) {
    postMessage({type: &quot;error&quot;, data: {
        message: message,
        data: err &amp;&amp; err.data,
        file: file,
        line: line, 
        col: col,
        stack: err &amp;&amp; err.stack
    }});
};

window.normalizeModule = function(parentId, moduleName) {
    // normalize plugin requires
    if (moduleName.indexOf(&quot;!&quot;) !== -1) {
        var chunks = moduleName.split(&quot;!&quot;);
        return window.normalizeModule(parentId, chunks[0]) + &quot;!&quot; + window.normalizeModule(parentId, chunks[1]);
    }
    // normalize relative requires
    if (moduleName.charAt(0) == &quot;.&quot;) {
        var base = parentId.split(&quot;/&quot;).slice(0, -1).join(&quot;/&quot;);
        moduleName = (base ? base + &quot;/&quot; : &quot;&quot;) + moduleName;
        
        while (moduleName.indexOf(&quot;.&quot;) !== -1 &amp;&amp; previous != moduleName) {
            var previous = moduleName;
            moduleName = moduleName.replace(/^\.\//, &quot;&quot;).replace(/\/\.\//, &quot;/&quot;).replace(/[^\/]+\/\.\.\//, &quot;&quot;);
        }
    }
    
    return moduleName;
};

window.require = function require(parentId, id) {
    if (!id) {
        id = parentId;
        parentId = null;
    }
    if (!id.charAt)
        throw new Error(&quot;worker.js require() accepts only (parentId, id) as arguments&quot;);

    id = window.normalizeModule(parentId, id);

    var module = window.require.modules[id];
    if (module) {
        if (!module.initialized) {
            module.initialized = true;
            module.exports = module.factory().exports;
        }
        return module.exports;
    }
   
    if (!window.require.tlns)
        return console.log(&quot;unable to load &quot; + id);
    
    var path = resolveModuleId(id, window.require.tlns);
    if (path.slice(-3) != &quot;.js&quot;) path += &quot;.js&quot;;
    
    window.require.id = id;
    window.require.modules[id] = {}; // prevent infinite loop on broken modules
    importScripts(path);
    return window.require(parentId, id);
};
function resolveModuleId(id, paths) {
    var testPath = id, tail = &quot;&quot;;
    while (testPath) {
        var alias = paths[testPath];
        if (typeof alias == &quot;string&quot;) {
            return alias + tail;
        } else if (alias) {
            return  alias.location.replace(/\/*$/, &quot;/&quot;) + (tail || alias.main || alias.name);
        } else if (alias === false) {
            return &quot;&quot;;
        }
        var i = testPath.lastIndexOf(&quot;/&quot;);
        if (i === -1) break;
        tail = testPath.substr(i) + tail;
        testPath = testPath.slice(0, i);
    }
    return id;
}
window.require.modules = {};
window.require.tlns = {};

window.define = function(id, deps, factory) {
    if (arguments.length == 2) {
        factory = deps;
        if (typeof id != &quot;string&quot;) {
            deps = id;
            id = window.require.id;
        }
    } else if (arguments.length == 1) {
        factory = id;
        deps = [];
        id = window.require.id;
    }
    
    if (typeof factory != &quot;function&quot;) {
        window.require.modules[id] = {
            exports: factory,
            initialized: true
        };
        return;
    }

    if (!deps.length)
        // If there is no dependencies, we inject &quot;require&quot;, &quot;exports&quot; and
        // &quot;module&quot; as dependencies, to provide CommonJS compatibility.
        deps = [&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;];

    var req = function(childId) {
        return window.require(id, childId);
    };

    window.require.modules[id] = {
        exports: {},
        factory: function() {
            var module = this;
            var returnExports = factory.apply(this, deps.slice(0, factory.length).map(function(dep) {
                switch (dep) {
                    // Because &quot;require&quot;, &quot;exports&quot; and &quot;module&quot; aren&#039;t actual
                    // dependencies, we must handle them seperately.
                    case &quot;require&quot;: return req;
                    case &quot;exports&quot;: return module.exports;
                    case &quot;module&quot;:  return module;
                    // But for all other dependencies, we can just go ahead and
                    // require them.
                    default:        return req(dep);
                }
            }));
            if (returnExports)
                module.exports = returnExports;
            return module;
        }
    };
};
window.define.amd = {};
window.require.tlns = {};
window.initBaseUrls  = function initBaseUrls(topLevelNamespaces) {
    for (var i in topLevelNamespaces)
        this.require.tlns[i] = topLevelNamespaces[i];
};

window.initSender = function initSender() {

    var EventEmitter = window.require(&quot;ace/lib/event_emitter&quot;).EventEmitter;
    var oop = window.require(&quot;ace/lib/oop&quot;);
    
    var Sender = function() {};
    
    (function() {
        
        oop.implement(this, EventEmitter);
                
        this.callback = function(data, callbackId) {
            postMessage({
                type: &quot;call&quot;,
                id: callbackId,
                data: data
            });
        };
    
        this.emit = function(name, data) {
            postMessage({
                type: &quot;event&quot;,
                name: name,
                data: data
            });
        };
        
    }).call(Sender.prototype);
    
    return new Sender();
};

var main = window.main = null;
var sender = window.sender = null;

window.onmessage = function(e) {
    var msg = e.data;
    if (msg.event &amp;&amp; sender) {
        sender._signal(msg.event, msg.data);
    }
    else if (msg.command) {
        if (main[msg.command])
            main[msg.command].apply(main, msg.args);
        else if (window[msg.command])
            window[msg.command].apply(window, msg.args);
        else
            throw new Error(&quot;Unknown command:&quot; + msg.command);
    }
    else if (msg.init) {
        window.initBaseUrls(msg.tlns);
        sender = window.sender = window.initSender();
        var clazz = this.require(msg.module)[msg.classname];
        main = window.main = new clazz(sender);
    }
};
})(this);

define(&quot;ace/lib/oop&quot;,[], function(require, exports, module){&quot;use strict&quot;;
exports.inherits = function (ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
};
exports.mixin = function (obj, mixin) {
    for (var key in mixin) {
        obj[key] = mixin[key];
    }
    return obj;
};
exports.implement = function (proto, mixin) {
    exports.mixin(proto, mixin);
};

});

define(&quot;ace/lib/lang&quot;,[], function(require, exports, module){&quot;use strict&quot;;
exports.last = function (a) {
    return a[a.length - 1];
};
exports.stringReverse = function (string) {
    return string.split(&quot;&quot;).reverse().join(&quot;&quot;);
};
exports.stringRepeat = function (string, count) {
    var result = &#039;&#039;;
    while (count &gt; 0) {
        if (count &amp; 1)
            result += string;
        if (count &gt;&gt;= 1)
            string += string;
    }
    return result;
};
var trimBeginRegexp = /^\s\s*/;
var trimEndRegexp = /\s\s*$/;
exports.stringTrimLeft = function (string) {
    return string.replace(trimBeginRegexp, &#039;&#039;);
};
exports.stringTrimRight = function (string) {
    return string.replace(trimEndRegexp, &#039;&#039;);
};
exports.copyObject = function (obj) {
    var copy = {};
    for (var key in obj) {
        copy[key] = obj[key];
    }
    return copy;
};
exports.copyArray = function (array) {
    var copy = [];
    for (var i = 0, l = array.length; i &lt; l; i++) {
        if (array[i] &amp;&amp; typeof array[i] == &quot;object&quot;)
            copy[i] = this.copyObject(array[i]);
        else
            copy[i] = array[i];
    }
    return copy;
};
exports.deepCopy = function deepCopy(obj) {
    if (typeof obj !== &quot;object&quot; || !obj)
        return obj;
    var copy;
    if (Array.isArray(obj)) {
        copy = [];
        for (var key = 0; key &lt; obj.length; key++) {
            copy[key] = deepCopy(obj[key]);
        }
        return copy;
    }
    if (Object.prototype.toString.call(obj) !== &quot;[object Object]&quot;)
        return obj;
    copy = {};
    for (var key in obj)
        copy[key] = deepCopy(obj[key]);
    return copy;
};
exports.arrayToMap = function (arr) {
    var map = {};
    for (var i = 0; i &lt; arr.length; i++) {
        map[arr[i]] = 1;
    }
    return map;
};
exports.createMap = function (props) {
    var map = Object.create(null);
    for (var i in props) {
        map[i] = props[i];
    }
    return map;
};
exports.arrayRemove = function (array, value) {
    for (var i = 0; i &lt;= array.length; i++) {
        if (value === array[i]) {
            array.splice(i, 1);
        }
    }
};
exports.escapeRegExp = function (str) {
    return str.replace(/([.*+?^${}()|[\]\/\\])/g, &#039;\\$1&#039;);
};
exports.escapeHTML = function (str) {
    return (&quot;&quot; + str).replace(/&amp;/g, &quot;&amp;#38;&quot;).replace(/&quot;/g, &quot;&amp;#34;&quot;).replace(/&#039;/g, &quot;&amp;#39;&quot;).replace(/&lt;/g, &quot;&amp;#60;&quot;);
};
exports.getMatchOffsets = function (string, regExp) {
    var matches = [];
    string.replace(regExp, function (str) {
        matches.push({
            offset: arguments[arguments.length - 2],
            length: str.length
        });
    });
    return matches;
};
exports.deferredCall = function (fcn) {
    var timer = null;
    var callback = function () {
        timer = null;
        fcn();
    };
    var deferred = function (timeout) {
        deferred.cancel();
        timer = setTimeout(callback, timeout || 0);
        return deferred;
    };
    deferred.schedule = deferred;
    deferred.call = function () {
        this.cancel();
        fcn();
        return deferred;
    };
    deferred.cancel = function () {
        clearTimeout(timer);
        timer = null;
        return deferred;
    };
    deferred.isPending = function () {
        return timer;
    };
    return deferred;
};
exports.delayedCall = function (fcn, defaultTimeout) {
    var timer = null;
    var callback = function () {
        timer = null;
        fcn();
    };
    var _self = function (timeout) {
        if (timer == null)
            timer = setTimeout(callback, timeout || defaultTimeout);
    };
    _self.delay = function (timeout) {
        timer &amp;&amp; clearTimeout(timer);
        timer = setTimeout(callback, timeout || defaultTimeout);
    };
    _self.schedule = _self;
    _self.call = function () {
        this.cancel();
        fcn();
    };
    _self.cancel = function () {
        timer &amp;&amp; clearTimeout(timer);
        timer = null;
    };
    _self.isPending = function () {
        return timer;
    };
    return _self;
};

});

define(&quot;ace/apply_delta&quot;,[], function(require, exports, module){&quot;use strict&quot;;
function throwDeltaError(delta, errorText) {
    console.log(&quot;Invalid Delta:&quot;, delta);
    throw &quot;Invalid Delta: &quot; + errorText;
}
function positionInDocument(docLines, position) {
    return position.row &gt;= 0 &amp;&amp; position.row &lt; docLines.length &amp;&amp;
        position.column &gt;= 0 &amp;&amp; position.column &lt;= docLines[position.row].length;
}
function validateDelta(docLines, delta) {
    if (delta.action != &quot;insert&quot; &amp;&amp; delta.action != &quot;remove&quot;)
        throwDeltaError(delta, &quot;delta.action must be &#039;insert&#039; or &#039;remove&#039;&quot;);
    if (!(delta.lines instanceof Array))
        throwDeltaError(delta, &quot;delta.lines must be an Array&quot;);
    if (!delta.start || !delta.end)
        throwDeltaError(delta, &quot;delta.start/end must be an present&quot;);
    var start = delta.start;
    if (!positionInDocument(docLines, delta.start))
        throwDeltaError(delta, &quot;delta.start must be contained in document&quot;);
    var end = delta.end;
    if (delta.action == &quot;remove&quot; &amp;&amp; !positionInDocument(docLines, end))
        throwDeltaError(delta, &quot;delta.end must contained in document for &#039;remove&#039; actions&quot;);
    var numRangeRows = end.row - start.row;
    var numRangeLastLineChars = (end.column - (numRangeRows == 0 ? start.column : 0));
    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars)
        throwDeltaError(delta, &quot;delta.range must match delta lines&quot;);
}
exports.applyDelta = function (docLines, delta, doNotValidate) {
    var row = delta.start.row;
    var startColumn = delta.start.column;
    var line = docLines[row] || &quot;&quot;;
    switch (delta.action) {
        case &quot;insert&quot;:
            var lines = delta.lines;
            if (lines.length === 1) {
                docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
            }
            else {
                var args = [row, 1].concat(delta.lines);
                docLines.splice.apply(docLines, args);
                docLines[row] = line.substring(0, startColumn) + docLines[row];
                docLines[row + delta.lines.length - 1] += line.substring(startColumn);
            }
            break;
        case &quot;remove&quot;:
            var endColumn = delta.end.column;
            var endRow = delta.end.row;
            if (row === endRow) {
                docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
            }
            else {
                docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));
            }
            break;
    }
};

});

define(&quot;ace/lib/event_emitter&quot;,[], function(require, exports, module){&quot;use strict&quot;;
var EventEmitter = {};
var stopPropagation = function () { this.propagationStopped = true; };
var preventDefault = function () { this.defaultPrevented = true; };
EventEmitter._emit =
    EventEmitter._dispatchEvent = function (eventName, e) {
        this._eventRegistry || (this._eventRegistry = {});
        this._defaultHandlers || (this._defaultHandlers = {});
        var listeners = this._eventRegistry[eventName] || [];
        var defaultHandler = this._defaultHandlers[eventName];
        if (!listeners.length &amp;&amp; !defaultHandler)
            return;
        if (typeof e != &quot;object&quot; || !e)
            e = {};
        if (!e.type)
            e.type = eventName;
        if (!e.stopPropagation)
            e.stopPropagation = stopPropagation;
        if (!e.preventDefault)
            e.preventDefault = preventDefault;
        listeners = listeners.slice();
        for (var i = 0; i &lt; listeners.length; i++) {
            listeners[i](e, this);
            if (e.propagationStopped)
                break;
        }
        if (defaultHandler &amp;&amp; !e.defaultPrevented)
            return defaultHandler(e, this);
    };
EventEmitter._signal = function (eventName, e) {
    var listeners = (this._eventRegistry || {})[eventName];
    if (!listeners)
        return;
    listeners = listeners.slice();
    for (var i = 0; i &lt; listeners.length; i++)
        listeners[i](e, this);
};
EventEmitter.once = function (eventName, callback) {
    var _self = this;
    this.on(eventName, function newCallback() {
        _self.off(eventName, newCallback);
        callback.apply(null, arguments);
    });
    if (!callback) {
        return new Promise(function (resolve) {
            callback = resolve;
        });
    }
};
EventEmitter.setDefaultHandler = function (eventName, callback) {
    var handlers = this._defaultHandlers;
    if (!handlers)
        handlers = this._defaultHandlers = { _disabled_: {} };
    if (handlers[eventName]) {
        var old = handlers[eventName];
        var disabled = handlers._disabled_[eventName];
        if (!disabled)
            handlers._disabled_[eventName] = disabled = [];
        disabled.push(old);
        var i = disabled.indexOf(callback);
        if (i != -1)
            disabled.splice(i, 1);
    }
    handlers[eventName] = callback;
};
EventEmitter.removeDefaultHandler = function (eventName, callback) {
    var handlers = this._defaultHandlers;
    if (!handlers)
        return;
    var disabled = handlers._disabled_[eventName];
    if (handlers[eventName] == callback) {
        if (disabled)
            this.setDefaultHandler(eventName, disabled.pop());
    }
    else if (disabled) {
        var i = disabled.indexOf(callback);
        if (i != -1)
            disabled.splice(i, 1);
    }
};
EventEmitter.on =
    EventEmitter.addEventListener = function (eventName, callback, capturing) {
        this._eventRegistry = this._eventRegistry || {};
        var listeners = this._eventRegistry[eventName];
        if (!listeners)
            listeners = this._eventRegistry[eventName] = [];
        if (listeners.indexOf(callback) == -1)
            listeners[capturing ? &quot;unshift&quot; : &quot;push&quot;](callback);
        return callback;
    };
EventEmitter.off =
    EventEmitter.removeListener =
        EventEmitter.removeEventListener = function (eventName, callback) {
            this._eventRegistry = this._eventRegistry || {};
            var listeners = this._eventRegistry[eventName];
            if (!listeners)
                return;
            var index = listeners.indexOf(callback);
            if (index !== -1)
                listeners.splice(index, 1);
        };
EventEmitter.removeAllListeners = function (eventName) {
    if (!eventName)
        this._eventRegistry = this._defaultHandlers = undefined;
    if (this._eventRegistry)
        this._eventRegistry[eventName] = undefined;
    if (this._defaultHandlers)
        this._defaultHandlers[eventName] = undefined;
};
exports.EventEmitter = EventEmitter;

});

define(&quot;ace/range&quot;,[], function(require, exports, module){&quot;use strict&quot;;
var comparePoints = function (p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
};
var Range = function (startRow, startColumn, endRow, endColumn) {
    this.start = {
        row: startRow,
        column: startColumn
    };
    this.end = {
        row: endRow,
        column: endColumn
    };
};
(function () {
    this.isEqual = function (range) {
        return this.start.row === range.start.row &amp;&amp;
            this.end.row === range.end.row &amp;&amp;
            this.start.column === range.start.column &amp;&amp;
            this.end.column === range.end.column;
    };
    this.toString = function () {
        return (&quot;Range: [&quot; + this.start.row + &quot;/&quot; + this.start.column +
            &quot;] -&gt; [&quot; + this.end.row + &quot;/&quot; + this.end.column + &quot;]&quot;);
    };
    this.contains = function (row, column) {
        return this.compare(row, column) == 0;
    };
    this.compareRange = function (range) {
        var cmp, end = range.end, start = range.start;
        cmp = this.compare(end.row, end.column);
        if (cmp == 1) {
            cmp = this.compare(start.row, start.column);
            if (cmp == 1) {
                return 2;
            }
            else if (cmp == 0) {
                return 1;
            }
            else {
                return 0;
            }
        }
        else if (cmp == -1) {
            return -2;
        }
        else {
            cmp = this.compare(start.row, start.column);
            if (cmp == -1) {
                return -1;
            }
            else if (cmp == 1) {
                return 42;
            }
            else {
                return 0;
            }
        }
    };
    this.comparePoint = function (p) {
        return this.compare(p.row, p.column);
    };
    this.containsRange = function (range) {
        return this.comparePoint(range.start) == 0 &amp;&amp; this.comparePoint(range.end) == 0;
    };
    this.intersects = function (range) {
        var cmp = this.compareRange(range);
        return (cmp == -1 || cmp == 0 || cmp == 1);
    };
    this.isEnd = function (row, column) {
        return this.end.row == row &amp;&amp; this.end.column == column;
    };
    this.isStart = function (row, column) {
        return this.start.row == row &amp;&amp; this.start.column == column;
    };
    this.setStart = function (row, column) {
        if (typeof row == &quot;object&quot;) {
            this.start.column = row.column;
            this.start.row = row.row;
        }
        else {
            this.start.row = row;
            this.start.column = column;
        }
    };
    this.setEnd = function (row, column) {
        if (typeof row == &quot;object&quot;) {
            this.end.column = row.column;
            this.end.row = row.row;
        }
        else {
            this.end.row = row;
            this.end.column = column;
        }
    };
    this.inside = function (row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column) || this.isStart(row, column)) {
                return false;
            }
            else {
                return true;
            }
        }
        return false;
    };
    this.insideStart = function (row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column)) {
                return false;
            }
            else {
                return true;
            }
        }
        return false;
    };
    this.insideEnd = function (row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isStart(row, column)) {
                return false;
            }
            else {
                return true;
            }
        }
        return false;
    };
    this.compare = function (row, column) {
        if (!this.isMultiLine()) {
            if (row === this.start.row) {
                return column &lt; this.start.column ? -1 : (column &gt; this.end.column ? 1 : 0);
            }
        }
        if (row &lt; this.start.row)
            return -1;
        if (row &gt; this.end.row)
            return 1;
        if (this.start.row === row)
            return column &gt;= this.start.column ? 0 : -1;
        if (this.end.row === row)
            return column &lt;= this.end.column ? 0 : 1;
        return 0;
    };
    this.compareStart = function (row, column) {
        if (this.start.row == row &amp;&amp; this.start.column == column) {
            return -1;
        }
        else {
            return this.compare(row, column);
        }
    };
    this.compareEnd = function (row, column) {
        if (this.end.row == row &amp;&amp; this.end.column == column) {
            return 1;
        }
        else {
            return this.compare(row, column);
        }
    };
    this.compareInside = function (row, column) {
        if (this.end.row == row &amp;&amp; this.end.column == column) {
            return 1;
        }
        else if (this.start.row == row &amp;&amp; this.start.column == column) {
            return -1;
        }
        else {
            return this.compare(row, column);
        }
    };
    this.clipRows = function (firstRow, lastRow) {
        if (this.end.row &gt; lastRow)
            var end = { row: lastRow + 1, column: 0 };
        else if (this.end.row &lt; firstRow)
            var end = { row: firstRow, column: 0 };
        if (this.start.row &gt; lastRow)
            var start = { row: lastRow + 1, column: 0 };
        else if (this.start.row &lt; firstRow)
            var start = { row: firstRow, column: 0 };
        return Range.fromPoints(start || this.start, end || this.end);
    };
    this.extend = function (row, column) {
        var cmp = this.compare(row, column);
        if (cmp == 0)
            return this;
        else if (cmp == -1)
            var start = { row: row, column: column };
        else
            var end = { row: row, column: column };
        return Range.fromPoints(start || this.start, end || this.end);
    };
    this.isEmpty = function () {
        return (this.start.row === this.end.row &amp;&amp; this.start.column === this.end.column);
    };
    this.isMultiLine = function () {
        return (this.start.row !== this.end.row);
    };
    this.clone = function () {
        return Range.fromPoints(this.start, this.end);
    };
    this.collapseRows = function () {
        if (this.end.column == 0)
            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);
        else
            return new Range(this.start.row, 0, this.end.row, 0);
    };
    this.toScreenRange = function (session) {
        var screenPosStart = session.documentToScreenPosition(this.start);
        var screenPosEnd = session.documentToScreenPosition(this.end);
        return new Range(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);
    };
    this.moveBy = function (row, column) {
        this.start.row += row;
        this.start.column += column;
        this.end.row += row;
        this.end.column += column;
    };
}).call(Range.prototype);
Range.fromPoints = function (start, end) {
    return new Range(start.row, start.column, end.row, end.column);
};
Range.comparePoints = comparePoints;
Range.comparePoints = function (p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
};
exports.Range = Range;

});

define(&quot;ace/anchor&quot;,[], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;./lib/oop&quot;);
var EventEmitter = require(&quot;./lib/event_emitter&quot;).EventEmitter;
var Anchor = exports.Anchor = function (doc, row, column) {
    this.$onChange = this.onChange.bind(this);
    this.attach(doc);
    if (typeof column == &quot;undefined&quot;)
        this.setPosition(row.row, row.column);
    else
        this.setPosition(row, column);
};
(function () {
    oop.implement(this, EventEmitter);
    this.getPosition = function () {
        return this.$clipPositionToDocument(this.row, this.column);
    };
    this.getDocument = function () {
        return this.document;
    };
    this.$insertRight = false;
    this.onChange = function (delta) {
        if (delta.start.row == delta.end.row &amp;&amp; delta.start.row != this.row)
            return;
        if (delta.start.row &gt; this.row)
            return;
        var point = $getTransformedPoint(delta, { row: this.row, column: this.column }, this.$insertRight);
        this.setPosition(point.row, point.column, true);
    };
    function $pointsInOrder(point1, point2, equalPointsInOrder) {
        var bColIsAfter = equalPointsInOrder ? point1.column &lt;= point2.column : point1.column &lt; point2.column;
        return (point1.row &lt; point2.row) || (point1.row == point2.row &amp;&amp; bColIsAfter);
    }
    function $getTransformedPoint(delta, point, moveIfEqual) {
        var deltaIsInsert = delta.action == &quot;insert&quot;;
        var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);
        var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
        var deltaStart = delta.start;
        var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.
        if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
            return {
                row: point.row,
                column: point.column
            };
        }
        if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
            return {
                row: point.row + deltaRowShift,
                column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
            };
        }
        return {
            row: deltaStart.row,
            column: deltaStart.column
        };
    }
    this.setPosition = function (row, column, noClip) {
        var pos;
        if (noClip) {
            pos = {
                row: row,
                column: column
            };
        }
        else {
            pos = this.$clipPositionToDocument(row, column);
        }
        if (this.row == pos.row &amp;&amp; this.column == pos.column)
            return;
        var old = {
            row: this.row,
            column: this.column
        };
        this.row = pos.row;
        this.column = pos.column;
        this._signal(&quot;change&quot;, {
            old: old,
            value: pos
        });
    };
    this.detach = function () {
        this.document.off(&quot;change&quot;, this.$onChange);
    };
    this.attach = function (doc) {
        this.document = doc || this.document;
        this.document.on(&quot;change&quot;, this.$onChange);
    };
    this.$clipPositionToDocument = function (row, column) {
        var pos = {};
        if (row &gt;= this.document.getLength()) {
            pos.row = Math.max(0, this.document.getLength() - 1);
            pos.column = this.document.getLine(pos.row).length;
        }
        else if (row &lt; 0) {
            pos.row = 0;
            pos.column = 0;
        }
        else {
            pos.row = row;
            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
        }
        if (column &lt; 0)
            pos.column = 0;
        return pos;
    };
}).call(Anchor.prototype);

});

define(&quot;ace/document&quot;,[], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;./lib/oop&quot;);
var applyDelta = require(&quot;./apply_delta&quot;).applyDelta;
var EventEmitter = require(&quot;./lib/event_emitter&quot;).EventEmitter;
var Range = require(&quot;./range&quot;).Range;
var Anchor = require(&quot;./anchor&quot;).Anchor;
var Document = function (textOrLines) {
    this.$lines = [&quot;&quot;];
    if (textOrLines.length === 0) {
        this.$lines = [&quot;&quot;];
    }
    else if (Array.isArray(textOrLines)) {
        this.insertMergedLines({ row: 0, column: 0 }, textOrLines);
    }
    else {
        this.insert({ row: 0, column: 0 }, textOrLines);
    }
};
(function () {
    oop.implement(this, EventEmitter);
    this.setValue = function (text) {
        var len = this.getLength() - 1;
        this.remove(new Range(0, 0, len, this.getLine(len).length));
        this.insert({ row: 0, column: 0 }, text || &quot;&quot;);
    };
    this.getValue = function () {
        return this.getAllLines().join(this.getNewLineCharacter());
    };
    this.createAnchor = function (row, column) {
        return new Anchor(this, row, column);
    };
    if (&quot;aaa&quot;.split(/a/).length === 0) {
        this.$split = function (text) {
            return text.replace(/\r\n|\r/g, &quot;\n&quot;).split(&quot;\n&quot;);
        };
    }
    else {
        this.$split = function (text) {
            return text.split(/\r\n|\r|\n/);
        };
    }
    this.$detectNewLine = function (text) {
        var match = text.match(/^.*?(\r\n|\r|\n)/m);
        this.$autoNewLine = match ? match[1] : &quot;\n&quot;;
        this._signal(&quot;changeNewLineMode&quot;);
    };
    this.getNewLineCharacter = function () {
        switch (this.$newLineMode) {
            case &quot;windows&quot;:
                return &quot;\r\n&quot;;
            case &quot;unix&quot;:
                return &quot;\n&quot;;
            default:
                return this.$autoNewLine || &quot;\n&quot;;
        }
    };
    this.$autoNewLine = &quot;&quot;;
    this.$newLineMode = &quot;auto&quot;;
    this.setNewLineMode = function (newLineMode) {
        if (this.$newLineMode === newLineMode)
            return;
        this.$newLineMode = newLineMode;
        this._signal(&quot;changeNewLineMode&quot;);
    };
    this.getNewLineMode = function () {
        return this.$newLineMode;
    };
    this.isNewLine = function (text) {
        return (text == &quot;\r\n&quot; || text == &quot;\r&quot; || text == &quot;\n&quot;);
    };
    this.getLine = function (row) {
        return this.$lines[row] || &quot;&quot;;
    };
    this.getLines = function (firstRow, lastRow) {
        return this.$lines.slice(firstRow, lastRow + 1);
    };
    this.getAllLines = function () {
        return this.getLines(0, this.getLength());
    };
    this.getLength = function () {
        return this.$lines.length;
    };
    this.getTextRange = function (range) {
        return this.getLinesForRange(range).join(this.getNewLineCharacter());
    };
    this.getLinesForRange = function (range) {
        var lines;
        if (range.start.row === range.end.row) {
            lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
        }
        else {
            lines = this.getLines(range.start.row, range.end.row);
            lines[0] = (lines[0] || &quot;&quot;).substring(range.start.column);
            var l = lines.length - 1;
            if (range.end.row - range.start.row == l)
                lines[l] = lines[l].substring(0, range.end.column);
        }
        return lines;
    };
    this.insertLines = function (row, lines) {
        console.warn(&quot;Use of document.insertLines is deprecated. Use the insertFullLines method instead.&quot;);
        return this.insertFullLines(row, lines);
    };
    this.removeLines = function (firstRow, lastRow) {
        console.warn(&quot;Use of document.removeLines is deprecated. Use the removeFullLines method instead.&quot;);
        return this.removeFullLines(firstRow, lastRow);
    };
    this.insertNewLine = function (position) {
        console.warn(&quot;Use of document.insertNewLine is deprecated. Use insertMergedLines(position, [&#039;&#039;, &#039;&#039;]) instead.&quot;);
        return this.insertMergedLines(position, [&quot;&quot;, &quot;&quot;]);
    };
    this.insert = function (position, text) {
        if (this.getLength() &lt;= 1)
            this.$detectNewLine(text);
        return this.insertMergedLines(position, this.$split(text));
    };
    this.insertInLine = function (position, text) {
        var start = this.clippedPos(position.row, position.column);
        var end = this.pos(position.row, position.column + text.length);
        this.applyDelta({
            start: start,
            end: end,
            action: &quot;insert&quot;,
            lines: [text]
        }, true);
        return this.clonePos(end);
    };
    this.clippedPos = function (row, column) {
        var length = this.getLength();
        if (row === undefined) {
            row = length;
        }
        else if (row &lt; 0) {
            row = 0;
        }
        else if (row &gt;= length) {
            row = length - 1;
            column = undefined;
        }
        var line = this.getLine(row);
        if (column == undefined)
            column = line.length;
        column = Math.min(Math.max(column, 0), line.length);
        return { row: row, column: column };
    };
    this.clonePos = function (pos) {
        return { row: pos.row, column: pos.column };
    };
    this.pos = function (row, column) {
        return { row: row, column: column };
    };
    this.$clipPosition = function (position) {
        var length = this.getLength();
        if (position.row &gt;= length) {
            position.row = Math.max(0, length - 1);
            position.column = this.getLine(length - 1).length;
        }
        else {
            position.row = Math.max(0, position.row);
            position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
        }
        return position;
    };
    this.insertFullLines = function (row, lines) {
        row = Math.min(Math.max(row, 0), this.getLength());
        var column = 0;
        if (row &lt; this.getLength()) {
            lines = lines.concat([&quot;&quot;]);
            column = 0;
        }
        else {
            lines = [&quot;&quot;].concat(lines);
            row--;
            column = this.$lines[row].length;
        }
        this.insertMergedLines({ row: row, column: column }, lines);
    };
    this.insertMergedLines = function (position, lines) {
        var start = this.clippedPos(position.row, position.column);
        var end = {
            row: start.row + lines.length - 1,
            column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
        };
        this.applyDelta({
            start: start,
            end: end,
            action: &quot;insert&quot;,
            lines: lines
        });
        return this.clonePos(end);
    };
    this.remove = function (range) {
        var start = this.clippedPos(range.start.row, range.start.column);
        var end = this.clippedPos(range.end.row, range.end.column);
        this.applyDelta({
            start: start,
            end: end,
            action: &quot;remove&quot;,
            lines: this.getLinesForRange({ start: start, end: end })
        });
        return this.clonePos(start);
    };
    this.removeInLine = function (row, startColumn, endColumn) {
        var start = this.clippedPos(row, startColumn);
        var end = this.clippedPos(row, endColumn);
        this.applyDelta({
            start: start,
            end: end,
            action: &quot;remove&quot;,
            lines: this.getLinesForRange({ start: start, end: end })
        }, true);
        return this.clonePos(start);
    };
    this.removeFullLines = function (firstRow, lastRow) {
        firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
        lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);
        var deleteFirstNewLine = lastRow == this.getLength() - 1 &amp;&amp; firstRow &gt; 0;
        var deleteLastNewLine = lastRow &lt; this.getLength() - 1;
        var startRow = (deleteFirstNewLine ? firstRow - 1 : firstRow);
        var startCol = (deleteFirstNewLine ? this.getLine(startRow).length : 0);
        var endRow = (deleteLastNewLine ? lastRow + 1 : lastRow);
        var endCol = (deleteLastNewLine ? 0 : this.getLine(endRow).length);
        var range = new Range(startRow, startCol, endRow, endCol);
        var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
        this.applyDelta({
            start: range.start,
            end: range.end,
            action: &quot;remove&quot;,
            lines: this.getLinesForRange(range)
        });
        return deletedLines;
    };
    this.removeNewLine = function (row) {
        if (row &lt; this.getLength() - 1 &amp;&amp; row &gt;= 0) {
            this.applyDelta({
                start: this.pos(row, this.getLine(row).length),
                end: this.pos(row + 1, 0),
                action: &quot;remove&quot;,
                lines: [&quot;&quot;, &quot;&quot;]
            });
        }
    };
    this.replace = function (range, text) {
        if (!(range instanceof Range))
            range = Range.fromPoints(range.start, range.end);
        if (text.length === 0 &amp;&amp; range.isEmpty())
            return range.start;
        if (text == this.getTextRange(range))
            return range.end;
        this.remove(range);
        var end;
        if (text) {
            end = this.insert(range.start, text);
        }
        else {
            end = range.start;
        }
        return end;
    };
    this.applyDeltas = function (deltas) {
        for (var i = 0; i &lt; deltas.length; i++) {
            this.applyDelta(deltas[i]);
        }
    };
    this.revertDeltas = function (deltas) {
        for (var i = deltas.length - 1; i &gt;= 0; i--) {
            this.revertDelta(deltas[i]);
        }
    };
    this.applyDelta = function (delta, doNotValidate) {
        var isInsert = delta.action == &quot;insert&quot;;
        if (isInsert ? delta.lines.length &lt;= 1 &amp;&amp; !delta.lines[0]
            : !Range.comparePoints(delta.start, delta.end)) {
            return;
        }
        if (isInsert &amp;&amp; delta.lines.length &gt; 20000) {
            this.$splitAndapplyLargeDelta(delta, 20000);
        }
        else {
            applyDelta(this.$lines, delta, doNotValidate);
            this._signal(&quot;change&quot;, delta);
        }
    };
    this.$safeApplyDelta = function (delta) {
        var docLength = this.$lines.length;
        if (delta.action == &quot;remove&quot; &amp;&amp; delta.start.row &lt; docLength &amp;&amp; delta.end.row &lt; docLength
            || delta.action == &quot;insert&quot; &amp;&amp; delta.start.row &lt;= docLength) {
            this.applyDelta(delta);
        }
    };
    this.$splitAndapplyLargeDelta = function (delta, MAX) {
        var lines = delta.lines;
        var l = lines.length - MAX + 1;
        var row = delta.start.row;
        var column = delta.start.column;
        for (var from = 0, to = 0; from &lt; l; from = to) {
            to += MAX - 1;
            var chunk = lines.slice(from, to);
            chunk.push(&quot;&quot;);
            this.applyDelta({
                start: this.pos(row + from, column),
                end: this.pos(row + to, column = 0),
                action: delta.action,
                lines: chunk
            }, true);
        }
        delta.lines = lines.slice(from);
        delta.start.row = row + from;
        delta.start.column = column;
        this.applyDelta(delta, true);
    };
    this.revertDelta = function (delta) {
        this.$safeApplyDelta({
            start: this.clonePos(delta.start),
            end: this.clonePos(delta.end),
            action: (delta.action == &quot;insert&quot; ? &quot;remove&quot; : &quot;insert&quot;),
            lines: delta.lines.slice()
        });
    };
    this.indexToPosition = function (index, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        for (var i = startRow || 0, l = lines.length; i &lt; l; i++) {
            index -= lines[i].length + newlineLength;
            if (index &lt; 0)
                return { row: i, column: index + lines[i].length + newlineLength };
        }
        return { row: l - 1, column: index + lines[l - 1].length + newlineLength };
    };
    this.positionToIndex = function (pos, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        var index = 0;
        var row = Math.min(pos.row, lines.length);
        for (var i = startRow || 0; i &lt; row; ++i)
            index += lines[i].length + newlineLength;
        return index + pos.column;
    };
}).call(Document.prototype);
exports.Document = Document;

});

define(&quot;ace/worker/mirror&quot;,[], function(require, exports, module) {
&quot;use strict&quot;;

var Document = require(&quot;../document&quot;).Document;
var lang = require(&quot;../lib/lang&quot;);
    
var Mirror = exports.Mirror = function(sender) {
    this.sender = sender;
    var doc = this.doc = new Document(&quot;&quot;);
    
    var deferredUpdate = this.deferredUpdate = lang.delayedCall(this.onUpdate.bind(this));
    
    var _self = this;
    sender.on(&quot;change&quot;, function(e) {
        var data = e.data;
        if (data[0].start) {
            doc.applyDeltas(data);
        } else {
            for (var i = 0; i &lt; data.length; i += 2) {
                var d, err; 
                if (Array.isArray(data[i+1])) {
                    d = {action: &quot;insert&quot;, start: data[i], lines: data[i+1]};
                } else {
                    d = {action: &quot;remove&quot;, start: data[i], end: data[i+1]};
                }
                
                if ((d.action == &quot;insert&quot; ? d.start : d.end).row &gt;= doc.$lines.length) {
                    err = new Error(&quot;Invalid delta&quot;);
                    err.data = {
                        path: _self.$path,
                        linesLength: doc.$lines.length,
                        start: d.start,
                        end: d.end
                    };
                    throw err;
                }

                doc.applyDelta(d, true);
            }
        }
        if (_self.$timeout)
            return deferredUpdate.schedule(_self.$timeout);
        _self.onUpdate();
    });
};

(function() {
    
    this.$timeout = 500;
    
    this.setTimeout = function(timeout) {
        this.$timeout = timeout;
    };
    
    this.setValue = function(value) {
        this.doc.setValue(value);
        this.deferredUpdate.schedule(this.$timeout);
    };
    
    this.getValue = function(callbackId) {
        this.sender.callback(this.doc.getValue(), callbackId);
    };
    
    this.onUpdate = function() {
    };
    
    this.isPending = function() {
        return this.deferredUpdate.isPending();
    };
    
}).call(Mirror.prototype);

});

define(&quot;ace/mode/css/csslint&quot;,[], function(require, exports, module) {

var CSSLint = (function(){
  var module = module || {},
      exports = exports || {};
var parserlib = (function () {
var require;
require=(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=&quot;function&quot;==typeof require&amp;&amp;require;if(!f&amp;&amp;c)return c(i,!0);if(u)return u(i,!0);var a=new Error(&quot;Cannot find module &#039;&quot;+i+&quot;&#039;&quot;);throw a.code=&quot;MODULE_NOT_FOUND&quot;,a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=&quot;function&quot;==typeof require&amp;&amp;require,i=0;i&lt;t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){

&quot;use strict&quot;;

var Colors = module.exports = {
    __proto__               : null,
    aliceblue               : &quot;#f0f8ff&quot;,
    antiquewhite            : &quot;#faebd7&quot;,
    aqua                    : &quot;#00ffff&quot;,
    aquamarine              : &quot;#7fffd4&quot;,
    azure                   : &quot;#f0ffff&quot;,
    beige                   : &quot;#f5f5dc&quot;,
    bisque                  : &quot;#ffe4c4&quot;,
    black                   : &quot;#000000&quot;,
    blanchedalmond          : &quot;#ffebcd&quot;,
    blue                    : &quot;#0000ff&quot;,
    blueviolet              : &quot;#8a2be2&quot;,
    brown                   : &quot;#a52a2a&quot;,
    burlywood               : &quot;#deb887&quot;,
    cadetblue               : &quot;#5f9ea0&quot;,
    chartreuse              : &quot;#7fff00&quot;,
    chocolate               : &quot;#d2691e&quot;,
    coral                   : &quot;#ff7f50&quot;,
    cornflowerblue          : &quot;#6495ed&quot;,
    cornsilk                : &quot;#fff8dc&quot;,
    crimson                 : &quot;#dc143c&quot;,
    cyan                    : &quot;#00ffff&quot;,
    darkblue                : &quot;#00008b&quot;,
    darkcyan                : &quot;#008b8b&quot;,
    darkgoldenrod           : &quot;#b8860b&quot;,
    darkgray                : &quot;#a9a9a9&quot;,
    darkgreen               : &quot;#006400&quot;,
    darkgrey                : &quot;#a9a9a9&quot;,
    darkkhaki               : &quot;#bdb76b&quot;,
    darkmagenta             : &quot;#8b008b&quot;,
    darkolivegreen          : &quot;#556b2f&quot;,
    darkorange              : &quot;#ff8c00&quot;,
    darkorchid              : &quot;#9932cc&quot;,
    darkred                 : &quot;#8b0000&quot;,
    darksalmon              : &quot;#e9967a&quot;,
    darkseagreen            : &quot;#8fbc8f&quot;,
    darkslateblue           : &quot;#483d8b&quot;,
    darkslategray           : &quot;#2f4f4f&quot;,
    darkslategrey           : &quot;#2f4f4f&quot;,
    darkturquoise           : &quot;#00ced1&quot;,
    darkviolet              : &quot;#9400d3&quot;,
    deeppink                : &quot;#ff1493&quot;,
    deepskyblue             : &quot;#00bfff&quot;,
    dimgray                 : &quot;#696969&quot;,
    dimgrey                 : &quot;#696969&quot;,
    dodgerblue              : &quot;#1e90ff&quot;,
    firebrick               : &quot;#b22222&quot;,
    floralwhite             : &quot;#fffaf0&quot;,
    forestgreen             : &quot;#228b22&quot;,
    fuchsia                 : &quot;#ff00ff&quot;,
    gainsboro               : &quot;#dcdcdc&quot;,
    ghostwhite              : &quot;#f8f8ff&quot;,
    gold                    : &quot;#ffd700&quot;,
    goldenrod               : &quot;#daa520&quot;,
    gray                    : &quot;#808080&quot;,
    green                   : &quot;#008000&quot;,
    greenyellow             : &quot;#adff2f&quot;,
    grey                    : &quot;#808080&quot;,
    honeydew                : &quot;#f0fff0&quot;,
    hotpink                 : &quot;#ff69b4&quot;,
    indianred               : &quot;#cd5c5c&quot;,
    indigo                  : &quot;#4b0082&quot;,
    ivory                   : &quot;#fffff0&quot;,
    khaki                   : &quot;#f0e68c&quot;,
    lavender                : &quot;#e6e6fa&quot;,
    lavenderblush           : &quot;#fff0f5&quot;,
    lawngreen               : &quot;#7cfc00&quot;,
    lemonchiffon            : &quot;#fffacd&quot;,
    lightblue               : &quot;#add8e6&quot;,
    lightcoral              : &quot;#f08080&quot;,
    lightcyan               : &quot;#e0ffff&quot;,
    lightgoldenrodyellow    : &quot;#fafad2&quot;,
    lightgray               : &quot;#d3d3d3&quot;,
    lightgreen              : &quot;#90ee90&quot;,
    lightgrey               : &quot;#d3d3d3&quot;,
    lightpink               : &quot;#ffb6c1&quot;,
    lightsalmon             : &quot;#ffa07a&quot;,
    lightseagreen           : &quot;#20b2aa&quot;,
    lightskyblue            : &quot;#87cefa&quot;,
    lightslategray          : &quot;#778899&quot;,
    lightslategrey          : &quot;#778899&quot;,
    lightsteelblue          : &quot;#b0c4de&quot;,
    lightyellow             : &quot;#ffffe0&quot;,
    lime                    : &quot;#00ff00&quot;,
    limegreen               : &quot;#32cd32&quot;,
    linen                   : &quot;#faf0e6&quot;,
    magenta                 : &quot;#ff00ff&quot;,
    maroon                  : &quot;#800000&quot;,
    mediumaquamarine        : &quot;#66cdaa&quot;,
    mediumblue              : &quot;#0000cd&quot;,
    mediumorchid            : &quot;#ba55d3&quot;,
    mediumpurple            : &quot;#9370db&quot;,
    mediumseagreen          : &quot;#3cb371&quot;,
    mediumslateblue         : &quot;#7b68ee&quot;,
    mediumspringgreen       : &quot;#00fa9a&quot;,
    mediumturquoise         : &quot;#48d1cc&quot;,
    mediumvioletred         : &quot;#c71585&quot;,
    midnightblue            : &quot;#191970&quot;,
    mintcream               : &quot;#f5fffa&quot;,
    mistyrose               : &quot;#ffe4e1&quot;,
    moccasin                : &quot;#ffe4b5&quot;,
    navajowhite             : &quot;#ffdead&quot;,
    navy                    : &quot;#000080&quot;,
    oldlace                 : &quot;#fdf5e6&quot;,
    olive                   : &quot;#808000&quot;,
    olivedrab               : &quot;#6b8e23&quot;,
    orange                  : &quot;#ffa500&quot;,
    orangered               : &quot;#ff4500&quot;,
    orchid                  : &quot;#da70d6&quot;,
    palegoldenrod           : &quot;#eee8aa&quot;,
    palegreen               : &quot;#98fb98&quot;,
    paleturquoise           : &quot;#afeeee&quot;,
    palevioletred           : &quot;#db7093&quot;,
    papayawhip              : &quot;#ffefd5&quot;,
    peachpuff               : &quot;#ffdab9&quot;,
    peru                    : &quot;#cd853f&quot;,
    pink                    : &quot;#ffc0cb&quot;,
    plum                    : &quot;#dda0dd&quot;,
    powderblue              : &quot;#b0e0e6&quot;,
    purple                  : &quot;#800080&quot;,
    rebeccapurple           : &quot;#663399&quot;,
    red                     : &quot;#ff0000&quot;,
    rosybrown               : &quot;#bc8f8f&quot;,
    royalblue               : &quot;#4169e1&quot;,
    saddlebrown             : &quot;#8b4513&quot;,
    salmon                  : &quot;#fa8072&quot;,
    sandybrown              : &quot;#f4a460&quot;,
    seagreen                : &quot;#2e8b57&quot;,
    seashell                : &quot;#fff5ee&quot;,
    sienna                  : &quot;#a0522d&quot;,
    silver                  : &quot;#c0c0c0&quot;,
    skyblue                 : &quot;#87ceeb&quot;,
    slateblue               : &quot;#6a5acd&quot;,
    slategray               : &quot;#708090&quot;,
    slategrey               : &quot;#708090&quot;,
    snow                    : &quot;#fffafa&quot;,
    springgreen             : &quot;#00ff7f&quot;,
    steelblue               : &quot;#4682b4&quot;,
    tan                     : &quot;#d2b48c&quot;,
    teal                    : &quot;#008080&quot;,
    thistle                 : &quot;#d8bfd8&quot;,
    tomato                  : &quot;#ff6347&quot;,
    turquoise               : &quot;#40e0d0&quot;,
    violet                  : &quot;#ee82ee&quot;,
    wheat                   : &quot;#f5deb3&quot;,
    white                   : &quot;#ffffff&quot;,
    whitesmoke              : &quot;#f5f5f5&quot;,
    yellow                  : &quot;#ffff00&quot;,
    yellowgreen             : &quot;#9acd32&quot;,
    currentColor            : &quot;The value of the &#039;color&#039; property.&quot;,
    activeborder            : &quot;Active window border.&quot;,
    activecaption           : &quot;Active window caption.&quot;,
    appworkspace            : &quot;Background color of multiple document interface.&quot;,
    background              : &quot;Desktop background.&quot;,
    buttonface              : &quot;The face background color for 3-D elements that appear 3-D due to one layer of surrounding border.&quot;,
    buttonhighlight         : &quot;The color of the border facing the light source for 3-D elements that appear 3-D due to one layer of surrounding border.&quot;,
    buttonshadow            : &quot;The color of the border away from the light source for 3-D elements that appear 3-D due to one layer of surrounding border.&quot;,
    buttontext              : &quot;Text on push buttons.&quot;,
    captiontext             : &quot;Text in caption, size box, and scrollbar arrow box.&quot;,
    graytext                : &quot;Grayed (disabled) text. This color is set to #000 if the current display driver does not support a solid gray color.&quot;,
    greytext                : &quot;Greyed (disabled) text. This color is set to #000 if the current display driver does not support a solid grey color.&quot;,
    highlight               : &quot;Item(s) selected in a control.&quot;,
    highlighttext           : &quot;Text of item(s) selected in a control.&quot;,
    inactiveborder          : &quot;Inactive window border.&quot;,
    inactivecaption         : &quot;Inactive window caption.&quot;,
    inactivecaptiontext     : &quot;Color of text in an inactive caption.&quot;,
    infobackground          : &quot;Background color for tooltip controls.&quot;,
    infotext                : &quot;Text color for tooltip controls.&quot;,
    menu                    : &quot;Menu background.&quot;,
    menutext                : &quot;Text in menus.&quot;,
    scrollbar               : &quot;Scroll bar gray area.&quot;,
    threeddarkshadow        : &quot;The color of the darker (generally outer) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.&quot;,
    threedface              : &quot;The face background color for 3-D elements that appear 3-D due to two concentric layers of surrounding border.&quot;,
    threedhighlight         : &quot;The color of the lighter (generally outer) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.&quot;,
    threedlightshadow       : &quot;The color of the darker (generally inner) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.&quot;,
    threedshadow            : &quot;The color of the lighter (generally inner) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.&quot;,
    window                  : &quot;Window background.&quot;,
    windowframe             : &quot;Window frame.&quot;,
    windowtext              : &quot;Text in windows.&quot;
};

},{}],2:[function(require,module,exports){
&quot;use strict&quot;;

module.exports = Combinator;

var SyntaxUnit = require(&quot;../util/SyntaxUnit&quot;);

var Parser = require(&quot;./Parser&quot;);
function Combinator(text, line, col) {

    SyntaxUnit.call(this, text, line, col, Parser.COMBINATOR_TYPE);
    this.type = &quot;unknown&quot;;
    if (/^\s+$/.test(text)) {
        this.type = &quot;descendant&quot;;
    } else if (text === &quot;&gt;&quot;) {
        this.type = &quot;child&quot;;
    } else if (text === &quot;+&quot;) {
        this.type = &quot;adjacent-sibling&quot;;
    } else if (text === &quot;~&quot;) {
        this.type = &quot;sibling&quot;;
    }

}

Combinator.prototype = new SyntaxUnit();
Combinator.prototype.constructor = Combinator;


},{&quot;../util/SyntaxUnit&quot;:26,&quot;./Parser&quot;:6}],3:[function(require,module,exports){
&quot;use strict&quot;;

module.exports = Matcher;

var StringReader = require(&quot;../util/StringReader&quot;);
var SyntaxError = require(&quot;../util/SyntaxError&quot;);
function Matcher(matchFunc, toString) {
    this.match = function(expression) {
        var result;
        expression.mark();
        result = matchFunc(expression);
        if (result) {
            expression.drop();
        } else {
            expression.restore();
        }
        return result;
    };
    this.toString = typeof toString === &quot;function&quot; ? toString : function() {
        return toString;
    };
}
Matcher.prec = {
    MOD:    5,
    SEQ:    4,
    ANDAND: 3,
    OROR:   2,
    ALT:    1
};
Matcher.parse = function(str) {
    var reader, eat, expr, oror, andand, seq, mod, term, result;
    reader = new StringReader(str);
    eat = function(matcher) {
        var result = reader.readMatch(matcher);
        if (result === null) {
            throw new SyntaxError(
                &quot;Expected &quot; + matcher, reader.getLine(), reader.getCol());
        }
        return result;
    };
    expr = function() {
        var m = [ oror() ];
        while (reader.readMatch(&quot; | &quot;) !== null) {
            m.push(oror());
        }
        return m.length === 1 ? m[0] : Matcher.alt.apply(Matcher, m);
    };
    oror = function() {
        var m = [ andand() ];
        while (reader.readMatch(&quot; || &quot;) !== null) {
            m.push(andand());
        }
        return m.length === 1 ? m[0] : Matcher.oror.apply(Matcher, m);
    };
    andand = function() {
        var m = [ seq() ];
        while (reader.readMatch(&quot; &amp;&amp; &quot;) !== null) {
            m.push(seq());
        }
        return m.length === 1 ? m[0] : Matcher.andand.apply(Matcher, m);
    };
    seq = function() {
        var m = [ mod() ];
        while (reader.readMatch(/^ (?![&amp;|\]])/) !== null) {
            m.push(mod());
        }
        return m.length === 1 ? m[0] : Matcher.seq.apply(Matcher, m);
    };
    mod = function() {
        var m = term();
        if (reader.readMatch(&quot;?&quot;) !== null) {
            return m.question();
        } else if (reader.readMatch(&quot;*&quot;) !== null) {
            return m.star();
        } else if (reader.readMatch(&quot;+&quot;) !== null) {
            return m.plus();
        } else if (reader.readMatch(&quot;#&quot;) !== null) {
            return m.hash();
        } else if (reader.readMatch(/^\{\s*/) !== null) {
            var min = eat(/^\d+/);
            eat(/^\s*,\s*/);
            var max = eat(/^\d+/);
            eat(/^\s*\}/);
            return m.braces(Number(min), Number(max));
        }
        return m;
    };
    term = function() {
        if (reader.readMatch(&quot;[ &quot;) !== null) {
            var m = expr();
            eat(&quot; ]&quot;);
            return m;
        }
        return Matcher.fromType(eat(/^[^ ?*+#{]+/));
    };
    result = expr();
    if (!reader.eof()) {
        throw new SyntaxError(
            &quot;Expected end of string&quot;, reader.getLine(), reader.getCol());
    }
    return result;
};
Matcher.cast = function(m) {
    if (m instanceof Matcher) {
        return m;
    }
    return Matcher.parse(m);
};
Matcher.fromType = function(type) {
    var ValidationTypes = require(&quot;./ValidationTypes&quot;);
    return new Matcher(function(expression) {
        return expression.hasNext() &amp;&amp; ValidationTypes.isType(expression, type);
    }, type);
};
Matcher.seq = function() {
    var ms = Array.prototype.slice.call(arguments).map(Matcher.cast);
    if (ms.length === 1) {
        return ms[0];
    }
    return new Matcher(function(expression) {
        var i, result = true;
        for (i = 0; result &amp;&amp; i &lt; ms.length; i++) {
            result = ms[i].match(expression);
        }
        return result;
    }, function(prec) {
        var p = Matcher.prec.SEQ;
        var s = ms.map(function(m) {
            return m.toString(p);
        }).join(&quot; &quot;);
        if (prec &gt; p) {
            s = &quot;[ &quot; + s + &quot; ]&quot;;
        }
        return s;
    });
};
Matcher.alt = function() {
    var ms = Array.prototype.slice.call(arguments).map(Matcher.cast);
    if (ms.length === 1) {
        return ms[0];
    }
    return new Matcher(function(expression) {
        var i, result = false;
        for (i = 0; !result &amp;&amp; i &lt; ms.length; i++) {
            result = ms[i].match(expression);
        }
        return result;
    }, function(prec) {
        var p = Matcher.prec.ALT;
        var s = ms.map(function(m) {
            return m.toString(p);
        }).join(&quot; | &quot;);
        if (prec &gt; p) {
            s = &quot;[ &quot; + s + &quot; ]&quot;;
        }
        return s;
    });
};
Matcher.many = function(required) {
    var ms = Array.prototype.slice.call(arguments, 1).reduce(function(acc, v) {
        if (v.expand) {
            var ValidationTypes = require(&quot;./ValidationTypes&quot;);
            acc.push.apply(acc, ValidationTypes.complex[v.expand].options);
        } else {
            acc.push(Matcher.cast(v));
        }
        return acc;
    }, []);

    if (required === true) {
        required = ms.map(function() {
            return true;
        });
    }

    var result = new Matcher(function(expression) {
        var seen = [], max = 0, pass = 0;
        var success = function(matchCount) {
            if (pass === 0) {
                max = Math.max(matchCount, max);
                return matchCount === ms.length;
            } else {
                return matchCount === max;
            }
        };
        var tryMatch = function(matchCount) {
            for (var i = 0; i &lt; ms.length; i++) {
                if (seen[i]) {
                    continue;
                }
                expression.mark();
                if (ms[i].match(expression)) {
                    seen[i] = true;
                    if (tryMatch(matchCount + (required === false || required[i] ? 1 : 0))) {
                        expression.drop();
                        return true;
                    }
                    expression.restore();
                    seen[i] = false;
                } else {
                    expression.drop();
                }
            }
            return success(matchCount);
        };
        if (!tryMatch(0)) {
            pass++;
            tryMatch(0);
        }

        if (required === false) {
            return max &gt; 0;
        }
        for (var i = 0; i &lt; ms.length; i++) {
            if (required[i] &amp;&amp; !seen[i]) {
                return false;
            }
        }
        return true;
    }, function(prec) {
        var p = required === false ? Matcher.prec.OROR : Matcher.prec.ANDAND;
        var s = ms.map(function(m, i) {
            if (required !== false &amp;&amp; !required[i]) {
                return m.toString(Matcher.prec.MOD) + &quot;?&quot;;
            }
            return m.toString(p);
        }).join(required === false ? &quot; || &quot; : &quot; &amp;&amp; &quot;);
        if (prec &gt; p) {
            s = &quot;[ &quot; + s + &quot; ]&quot;;
        }
        return s;
    });
    result.options = ms;
    return result;
};
Matcher.andand = function() {
    var args = Array.prototype.slice.call(arguments);
    args.unshift(true);
    return Matcher.many.apply(Matcher, args);
};
Matcher.oror = function() {
    var args = Array.prototype.slice.call(arguments);
    args.unshift(false);
    return Matcher.many.apply(Matcher, args);
};
Matcher.prototype = {
    constructor: Matcher,
    match: function() {
        throw new Error(&quot;unimplemented&quot;);
    },
    toString: function() {
        throw new Error(&quot;unimplemented&quot;);
    },
    func: function() {
        return this.match.bind(this);
    },
    then: function(m) {
        return Matcher.seq(this, m);
    },
    or: function(m) {
        return Matcher.alt(this, m);
    },
    andand: function(m) {
        return Matcher.many(true, this, m);
    },
    oror: function(m) {
        return Matcher.many(false, this, m);
    },
    star: function() {
        return this.braces(0, Infinity, &quot;*&quot;);
    },
    plus: function() {
        return this.braces(1, Infinity, &quot;+&quot;);
    },
    question: function() {
        return this.braces(0, 1, &quot;?&quot;);
    },
    hash: function() {
        return this.braces(1, Infinity, &quot;#&quot;, Matcher.cast(&quot;,&quot;));
    },
    braces: function(min, max, marker, optSep) {
        var m1 = this, m2 = optSep ? optSep.then(this) : this;
        if (!marker) {
            marker = &quot;{&quot; + min + &quot;,&quot; + max + &quot;}&quot;;
        }
        return new Matcher(function(expression) {
            var result = true, i;
            for (i = 0; i &lt; max; i++) {
                if (i &gt; 0 &amp;&amp; optSep) {
                    result = m2.match(expression);
                } else {
                    result = m1.match(expression);
                }
                if (!result) {
                    break;
                }
            }
            return i &gt;= min;
        }, function() {
            return m1.toString(Matcher.prec.MOD) + marker;
        });
    }
};

},{&quot;../util/StringReader&quot;:24,&quot;../util/SyntaxError&quot;:25,&quot;./ValidationTypes&quot;:21}],4:[function(require,module,exports){
&quot;use strict&quot;;

module.exports = MediaFeature;

var SyntaxUnit = require(&quot;../util/SyntaxUnit&quot;);

var Parser = require(&quot;./Parser&quot;);
function MediaFeature(name, value) {

    SyntaxUnit.call(this, &quot;(&quot; + name + (value !== null ? &quot;:&quot; + value : &quot;&quot;) + &quot;)&quot;, name.startLine, name.startCol, Parser.MEDIA_FEATURE_TYPE);
    this.name = name;
    this.value = value;
}

MediaFeature.prototype = new SyntaxUnit();
MediaFeature.prototype.constructor = MediaFeature;


},{&quot;../util/SyntaxUnit&quot;:26,&quot;./Parser&quot;:6}],5:[function(require,module,exports){
&quot;use strict&quot;;

module.exports = MediaQuery;

var SyntaxUnit = require(&quot;../util/SyntaxUnit&quot;);

var Parser = require(&quot;./Parser&quot;);
function MediaQuery(modifier, mediaType, features, line, col) {

    SyntaxUnit.call(this, (modifier ? modifier + &quot; &quot; : &quot;&quot;) + (mediaType ? mediaType : &quot;&quot;) + (mediaType &amp;&amp; features.length &gt; 0 ? &quot; and &quot; : &quot;&quot;) + features.join(&quot; and &quot;), line, col, Parser.MEDIA_QUERY_TYPE);
    this.modifier = modifier;
    this.mediaType = mediaType;
    this.features = features;

}

MediaQuery.prototype = new SyntaxUnit();
MediaQuery.prototype.constructor = MediaQuery;


},{&quot;../util/SyntaxUnit&quot;:26,&quot;./Parser&quot;:6}],6:[function(require,module,exports){
&quot;use strict&quot;;

module.exports = Parser;

var EventTarget = require(&quot;../util/EventTarget&quot;);
var SyntaxError = require(&quot;../util/SyntaxError&quot;);
var SyntaxUnit = require(&quot;../util/SyntaxUnit&quot;);

var Combinator = require(&quot;./Combinator&quot;);
var MediaFeature = require(&quot;./MediaFeature&quot;);
var MediaQuery = require(&quot;./MediaQuery&quot;);
var PropertyName = require(&quot;./PropertyName&quot;);
var PropertyValue = require(&quot;./PropertyValue&quot;);
var PropertyValuePart = require(&quot;./PropertyValuePart&quot;);
var Selector = require(&quot;./Selector&quot;);
var SelectorPart = require(&quot;./SelectorPart&quot;);
var SelectorSubPart = require(&quot;./SelectorSubPart&quot;);
var TokenStream = require(&quot;./TokenStream&quot;);
var Tokens = require(&quot;./Tokens&quot;);
var Validation = require(&quot;./Validation&quot;);
function Parser(options) {
    EventTarget.call(this);


    this.options = options || {};

    this._tokenStream = null;
}
Parser.DEFAULT_TYPE = 0;
Parser.COMBINATOR_TYPE = 1;
Parser.MEDIA_FEATURE_TYPE = 2;
Parser.MEDIA_QUERY_TYPE = 3;
Parser.PROPERTY_NAME_TYPE = 4;
Parser.PROPERTY_VALUE_TYPE = 5;
Parser.PROPERTY_VALUE_PART_TYPE = 6;
Parser.SELECTOR_TYPE = 7;
Parser.SELECTOR_PART_TYPE = 8;
Parser.SELECTOR_SUB_PART_TYPE = 9;

Parser.prototype = function() {

    var proto = new EventTarget(),  // new prototype
        prop,
        additions =  {
            __proto__: null,
            constructor: Parser,
            DEFAULT_TYPE : 0,
            COMBINATOR_TYPE : 1,
            MEDIA_FEATURE_TYPE : 2,
            MEDIA_QUERY_TYPE : 3,
            PROPERTY_NAME_TYPE : 4,
            PROPERTY_VALUE_TYPE : 5,
            PROPERTY_VALUE_PART_TYPE : 6,
            SELECTOR_TYPE : 7,
            SELECTOR_PART_TYPE : 8,
            SELECTOR_SUB_PART_TYPE : 9,

            _stylesheet: function() {

                var tokenStream = this._tokenStream,
                    count,
                    token,
                    tt;

                this.fire(&quot;startstylesheet&quot;);
                this._charset();

                this._skipCruft();
                while (tokenStream.peek() === Tokens.IMPORT_SYM) {
                    this._import();
                    this._skipCruft();
                }
                while (tokenStream.peek() === Tokens.NAMESPACE_SYM) {
                    this._namespace();
                    this._skipCruft();
                }
                tt = tokenStream.peek();
                while (tt &gt; Tokens.EOF) {

                    try {

                        switch (tt) {
                            case Tokens.MEDIA_SYM:
                                this._media();
                                this._skipCruft();
                                break;
                            case Tokens.PAGE_SYM:
                                this._page();
                                this._skipCruft();
                                break;
                            case Tokens.FONT_FACE_SYM:
                                this._font_face();
                                this._skipCruft();
                                break;
                            case Tokens.KEYFRAMES_SYM:
                                this._keyframes();
                                this._skipCruft();
                                break;
                            case Tokens.VIEWPORT_SYM:
                                this._viewport();
                                this._skipCruft();
                                break;
                            case Tokens.DOCUMENT_SYM:
                                this._document();
                                this._skipCruft();
                                break;
                            case Tokens.SUPPORTS_SYM:
                                this._supports();
                                this._skipCruft();
                                break;
                            case Tokens.UNKNOWN_SYM:  // unknown @ rule
                                tokenStream.get();
                                if (!this.options.strict) {
                                    this.fire({
                                        type:       &quot;error&quot;,
                                        error:      null,
                                        message:    &quot;Unknown @ rule: &quot; + tokenStream.LT(0).value + &quot;.&quot;,
                                        line:       tokenStream.LT(0).startLine,
                                        col:        tokenStream.LT(0).startCol
                                    });
                                    count = 0;
                                    while (tokenStream.advance([Tokens.LBRACE, Tokens.RBRACE]) === Tokens.LBRACE) {
                                        count++;    // keep track of nesting depth
                                    }

                                    while (count) {
                                        tokenStream.advance([Tokens.RBRACE]);
                                        count--;
                                    }

                                } else {
                                    throw new SyntaxError(&quot;Unknown @ rule.&quot;, tokenStream.LT(0).startLine, tokenStream.LT(0).startCol);
                                }
                                break;
                            case Tokens.S:
                                this._readWhitespace();
                                break;
                            default:
                                if (!this._ruleset()) {
                                    switch (tt) {
                                        case Tokens.CHARSET_SYM:
                                            token = tokenStream.LT(1);
                                            this._charset(false);
                                            throw new SyntaxError(&quot;@charset not allowed here.&quot;, token.startLine, token.startCol);
                                        case Tokens.IMPORT_SYM:
                                            token = tokenStream.LT(1);
                                            this._import(false);
                                            throw new SyntaxError(&quot;@import not allowed here.&quot;, token.startLine, token.startCol);
                                        case Tokens.NAMESPACE_SYM:
                                            token = tokenStream.LT(1);
                                            this._namespace(false);
                                            throw new SyntaxError(&quot;@namespace not allowed here.&quot;, token.startLine, token.startCol);
                                        default:
                                            tokenStream.get();  // get the last token
                                            this._unexpectedToken(tokenStream.token());
                                    }

                                }
                        }
                    } catch (ex) {
                        if (ex instanceof SyntaxError &amp;&amp; !this.options.strict) {
                            this.fire({
                                type:       &quot;error&quot;,
                                error:      ex,
                                message:    ex.message,
                                line:       ex.line,
                                col:        ex.col
                            });
                        } else {
                            throw ex;
                        }
                    }

                    tt = tokenStream.peek();
                }

                if (tt !== Tokens.EOF) {
                    this._unexpectedToken(tokenStream.token());
                }

                this.fire(&quot;endstylesheet&quot;);
            },

            _charset: function(emit) {
                var tokenStream = this._tokenStream,
                    charset,
                    token,
                    line,
                    col;

                if (tokenStream.match(Tokens.CHARSET_SYM)) {
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;

                    this._readWhitespace();
                    tokenStream.mustMatch(Tokens.STRING);

                    token = tokenStream.token();
                    charset = token.value;

                    this._readWhitespace();
                    tokenStream.mustMatch(Tokens.SEMICOLON);

                    if (emit !== false) {
                        this.fire({
                            type:   &quot;charset&quot;,
                            charset:charset,
                            line:   line,
                            col:    col
                        });
                    }
                }
            },

            _import: function(emit) {

                var tokenStream = this._tokenStream,
                    uri,
                    importToken,
                    mediaList   = [];
                tokenStream.mustMatch(Tokens.IMPORT_SYM);
                importToken = tokenStream.token();
                this._readWhitespace();

                tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);
                uri = tokenStream.token().value.replace(/^(?:url\()?[&quot;&#039;]?([^&quot;&#039;]+?)[&quot;&#039;]?\)?$/, &quot;$1&quot;);

                this._readWhitespace();

                mediaList = this._media_query_list();
                tokenStream.mustMatch(Tokens.SEMICOLON);
                this._readWhitespace();

                if (emit !== false) {
                    this.fire({
                        type:   &quot;import&quot;,
                        uri:    uri,
                        media:  mediaList,
                        line:   importToken.startLine,
                        col:    importToken.startCol
                    });
                }

            },

            _namespace: function(emit) {

                var tokenStream = this._tokenStream,
                    line,
                    col,
                    prefix,
                    uri;
                tokenStream.mustMatch(Tokens.NAMESPACE_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;
                this._readWhitespace();
                if (tokenStream.match(Tokens.IDENT)) {
                    prefix = tokenStream.token().value;
                    this._readWhitespace();
                }

                tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);
                uri = tokenStream.token().value.replace(/(?:url\()?[&quot;&#039;]([^&quot;&#039;]+)[&quot;&#039;]\)?/, &quot;$1&quot;);

                this._readWhitespace();
                tokenStream.mustMatch(Tokens.SEMICOLON);
                this._readWhitespace();

                if (emit !== false) {
                    this.fire({
                        type:   &quot;namespace&quot;,
                        prefix: prefix,
                        uri:    uri,
                        line:   line,
                        col:    col
                    });
                }

            },

            _supports: function(emit) {
                var tokenStream = this._tokenStream,
                    line,
                    col;

                if (tokenStream.match(Tokens.SUPPORTS_SYM)) {
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;

                    this._readWhitespace();
                    this._supports_condition();
                    this._readWhitespace();

                    tokenStream.mustMatch(Tokens.LBRACE);
                    this._readWhitespace();

                    if (emit !== false) {
                        this.fire({
                            type:   &quot;startsupports&quot;,
                            line:   line,
                            col:    col
                        });
                    }

                    while (true) {
                        if (!this._ruleset()) {
                            break;
                        }
                    }

                    tokenStream.mustMatch(Tokens.RBRACE);
                    this._readWhitespace();

                    this.fire({
                        type:   &quot;endsupports&quot;,
                        line:   line,
                        col:    col
                    });
                }
            },

            _supports_condition: function() {
                var tokenStream = this._tokenStream,
                    ident;

                if (tokenStream.match(Tokens.IDENT)) {
                    ident = tokenStream.token().value.toLowerCase();

                    if (ident === &quot;not&quot;) {
                        tokenStream.mustMatch(Tokens.S);
                        this._supports_condition_in_parens();
                    } else {
                        tokenStream.unget();
                    }
                } else {
                    this._supports_condition_in_parens();
                    this._readWhitespace();

                    while (tokenStream.peek() === Tokens.IDENT) {
                        ident = tokenStream.LT(1).value.toLowerCase();
                        if (ident === &quot;and&quot; || ident === &quot;or&quot;) {
                            tokenStream.mustMatch(Tokens.IDENT);
                            this._readWhitespace();
                            this._supports_condition_in_parens();
                            this._readWhitespace();
                        }
                    }
                }
            },

            _supports_condition_in_parens: function() {
                var tokenStream = this._tokenStream,
                    ident;

                if (tokenStream.match(Tokens.LPAREN)) {
                    this._readWhitespace();
                    if (tokenStream.match(Tokens.IDENT)) {
                        ident = tokenStream.token().value.toLowerCase();
                        if (ident === &quot;not&quot;) {
                            this._readWhitespace();
                            this._supports_condition();
                            this._readWhitespace();
                            tokenStream.mustMatch(Tokens.RPAREN);
                        } else {
                            tokenStream.unget();
                            this._supports_declaration_condition(false);
                        }
                    } else {
                        this._supports_condition();
                        this._readWhitespace();
                        tokenStream.mustMatch(Tokens.RPAREN);
                    }
                } else {
                    this._supports_declaration_condition();
                }
            },

            _supports_declaration_condition: function(requireStartParen) {
                var tokenStream = this._tokenStream;

                if (requireStartParen !== false) {
                    tokenStream.mustMatch(Tokens.LPAREN);
                }
                this._readWhitespace();
                this._declaration();
                tokenStream.mustMatch(Tokens.RPAREN);
            },

            _media: function() {
                var tokenStream     = this._tokenStream,
                    line,
                    col,
                    mediaList;  // = [];
                tokenStream.mustMatch(Tokens.MEDIA_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;

                this._readWhitespace();

                mediaList = this._media_query_list();

                tokenStream.mustMatch(Tokens.LBRACE);
                this._readWhitespace();

                this.fire({
                    type:   &quot;startmedia&quot;,
                    media:  mediaList,
                    line:   line,
                    col:    col
                });

                while (true) {
                    if (tokenStream.peek() === Tokens.PAGE_SYM) {
                        this._page();
                    } else if (tokenStream.peek() === Tokens.FONT_FACE_SYM) {
                        this._font_face();
                    } else if (tokenStream.peek() === Tokens.VIEWPORT_SYM) {
                        this._viewport();
                    } else if (tokenStream.peek() === Tokens.DOCUMENT_SYM) {
                        this._document();
                    } else if (tokenStream.peek() === Tokens.SUPPORTS_SYM) {
                        this._supports();
                    } else if (tokenStream.peek() === Tokens.MEDIA_SYM) {
                        this._media();
                    } else if (!this._ruleset()) {
                        break;
                    }
                }

                tokenStream.mustMatch(Tokens.RBRACE);
                this._readWhitespace();

                this.fire({
                    type:   &quot;endmedia&quot;,
                    media:  mediaList,
                    line:   line,
                    col:    col
                });
            },
            _media_query_list: function() {
                var tokenStream = this._tokenStream,
                    mediaList   = [];


                this._readWhitespace();

                if (tokenStream.peek() === Tokens.IDENT || tokenStream.peek() === Tokens.LPAREN) {
                    mediaList.push(this._media_query());
                }

                while (tokenStream.match(Tokens.COMMA)) {
                    this._readWhitespace();
                    mediaList.push(this._media_query());
                }

                return mediaList;
            },
            _media_query: function() {
                var tokenStream = this._tokenStream,
                    type        = null,
                    ident       = null,
                    token       = null,
                    expressions = [];

                if (tokenStream.match(Tokens.IDENT)) {
                    ident = tokenStream.token().value.toLowerCase();
                    if (ident !== &quot;only&quot; &amp;&amp; ident !== &quot;not&quot;) {
                        tokenStream.unget();
                        ident = null;
                    } else {
                        token = tokenStream.token();
                    }
                }

                this._readWhitespace();

                if (tokenStream.peek() === Tokens.IDENT) {
                    type = this._media_type();
                    if (token === null) {
                        token = tokenStream.token();
                    }
                } else if (tokenStream.peek() === Tokens.LPAREN) {
                    if (token === null) {
                        token = tokenStream.LT(1);
                    }
                    expressions.push(this._media_expression());
                }

                if (type === null &amp;&amp; expressions.length === 0) {
                    return null;
                } else {
                    this._readWhitespace();
                    while (tokenStream.match(Tokens.IDENT)) {
                        if (tokenStream.token().value.toLowerCase() !== &quot;and&quot;) {
                            this._unexpectedToken(tokenStream.token());
                        }

                        this._readWhitespace();
                        expressions.push(this._media_expression());
                    }
                }

                return new MediaQuery(ident, type, expressions, token.startLine, token.startCol);
            },
            _media_type: function() {
                return this._media_feature();
            },
            _media_expression: function() {
                var tokenStream = this._tokenStream,
                    feature     = null,
                    token,
                    expression  = null;

                tokenStream.mustMatch(Tokens.LPAREN);
                this._readWhitespace();

                feature = this._media_feature();
                this._readWhitespace();

                if (tokenStream.match(Tokens.COLON)) {
                    this._readWhitespace();
                    token = tokenStream.LT(1);
                    expression = this._expression();
                }

                tokenStream.mustMatch(Tokens.RPAREN);
                this._readWhitespace();

                return new MediaFeature(feature, expression ? new SyntaxUnit(expression, token.startLine, token.startCol) : null);
            },
            _media_feature: function() {
                var tokenStream = this._tokenStream;

                this._readWhitespace();

                tokenStream.mustMatch(Tokens.IDENT);

                return SyntaxUnit.fromToken(tokenStream.token());
            },
            _page: function() {
                var tokenStream = this._tokenStream,
                    line,
                    col,
                    identifier  = null,
                    pseudoPage  = null;
                tokenStream.mustMatch(Tokens.PAGE_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;

                this._readWhitespace();

                if (tokenStream.match(Tokens.IDENT)) {
                    identifier = tokenStream.token().value;
                    if (identifier.toLowerCase() === &quot;auto&quot;) {
                        this._unexpectedToken(tokenStream.token());
                    }
                }
                if (tokenStream.peek() === Tokens.COLON) {
                    pseudoPage = this._pseudo_page();
                }

                this._readWhitespace();

                this.fire({
                    type:   &quot;startpage&quot;,
                    id:     identifier,
                    pseudo: pseudoPage,
                    line:   line,
                    col:    col
                });

                this._readDeclarations(true, true);

                this.fire({
                    type:   &quot;endpage&quot;,
                    id:     identifier,
                    pseudo: pseudoPage,
                    line:   line,
                    col:    col
                });

            },
            _margin: function() {
                var tokenStream = this._tokenStream,
                    line,
                    col,
                    marginSym   = this._margin_sym();

                if (marginSym) {
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;

                    this.fire({
                        type: &quot;startpagemargin&quot;,
                        margin: marginSym,
                        line:   line,
                        col:    col
                    });

                    this._readDeclarations(true);

                    this.fire({
                        type: &quot;endpagemargin&quot;,
                        margin: marginSym,
                        line:   line,
                        col:    col
                    });
                    return true;
                } else {
                    return false;
                }
            },
            _margin_sym: function() {

                var tokenStream = this._tokenStream;

                if (tokenStream.match([Tokens.TOPLEFTCORNER_SYM, Tokens.TOPLEFT_SYM,
                    Tokens.TOPCENTER_SYM, Tokens.TOPRIGHT_SYM, Tokens.TOPRIGHTCORNER_SYM,
                    Tokens.BOTTOMLEFTCORNER_SYM, Tokens.BOTTOMLEFT_SYM,
                    Tokens.BOTTOMCENTER_SYM, Tokens.BOTTOMRIGHT_SYM,
                    Tokens.BOTTOMRIGHTCORNER_SYM, Tokens.LEFTTOP_SYM,
                    Tokens.LEFTMIDDLE_SYM, Tokens.LEFTBOTTOM_SYM, Tokens.RIGHTTOP_SYM,
                    Tokens.RIGHTMIDDLE_SYM, Tokens.RIGHTBOTTOM_SYM])) {
                    return SyntaxUnit.fromToken(tokenStream.token());
                } else {
                    return null;
                }

            },

            _pseudo_page: function() {

                var tokenStream = this._tokenStream;

                tokenStream.mustMatch(Tokens.COLON);
                tokenStream.mustMatch(Tokens.IDENT);

                return tokenStream.token().value;
            },

            _font_face: function() {
                var tokenStream = this._tokenStream,
                    line,
                    col;
                tokenStream.mustMatch(Tokens.FONT_FACE_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;

                this._readWhitespace();

                this.fire({
                    type:   &quot;startfontface&quot;,
                    line:   line,
                    col:    col
                });

                this._readDeclarations(true);

                this.fire({
                    type:   &quot;endfontface&quot;,
                    line:   line,
                    col:    col
                });
            },

            _viewport: function() {
                var tokenStream = this._tokenStream,
                    line,
                    col;

                tokenStream.mustMatch(Tokens.VIEWPORT_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;

                this._readWhitespace();

                this.fire({
                    type:   &quot;startviewport&quot;,
                    line:   line,
                    col:    col
                });

                this._readDeclarations(true);

                this.fire({
                    type:   &quot;endviewport&quot;,
                    line:   line,
                    col:    col
                });

            },

            _document: function() {

                var tokenStream = this._tokenStream,
                    token,
                    functions = [],
                    prefix = &quot;&quot;;

                tokenStream.mustMatch(Tokens.DOCUMENT_SYM);
                token = tokenStream.token();
                if (/^@-([^-]+)-/.test(token.value)) {
                    prefix = RegExp.$1;
                }

                this._readWhitespace();
                functions.push(this._document_function());

                while (tokenStream.match(Tokens.COMMA)) {
                    this._readWhitespace();
                    functions.push(this._document_function());
                }

                tokenStream.mustMatch(Tokens.LBRACE);
                this._readWhitespace();

                this.fire({
                    type:      &quot;startdocument&quot;,
                    functions: functions,
                    prefix:    prefix,
                    line:      token.startLine,
                    col:       token.startCol
                });

                var ok = true;
                while (ok) {
                    switch (tokenStream.peek()) {
                        case Tokens.PAGE_SYM:
                            this._page();
                            break;
                        case Tokens.FONT_FACE_SYM:
                            this._font_face();
                            break;
                        case Tokens.VIEWPORT_SYM:
                            this._viewport();
                            break;
                        case Tokens.MEDIA_SYM:
                            this._media();
                            break;
                        case Tokens.KEYFRAMES_SYM:
                            this._keyframes();
                            break;
                        case Tokens.DOCUMENT_SYM:
                            this._document();
                            break;
                        default:
                            ok = Boolean(this._ruleset());
                    }
                }

                tokenStream.mustMatch(Tokens.RBRACE);
                token = tokenStream.token();
                this._readWhitespace();

                this.fire({
                    type:      &quot;enddocument&quot;,
                    functions: functions,
                    prefix:    prefix,
                    line:      token.startLine,
                    col:       token.startCol
                });
            },

            _document_function: function() {

                var tokenStream = this._tokenStream,
                    value;

                if (tokenStream.match(Tokens.URI)) {
                    value = tokenStream.token().value;
                    this._readWhitespace();
                } else {
                    value = this._function();
                }

                return value;
            },

            _operator: function(inFunction) {

                var tokenStream = this._tokenStream,
                    token       = null;

                if (tokenStream.match([Tokens.SLASH, Tokens.COMMA]) ||
                    inFunction &amp;&amp; tokenStream.match([Tokens.PLUS, Tokens.STAR, Tokens.MINUS])) {
                    token =  tokenStream.token();
                    this._readWhitespace();
                }
                return token ? PropertyValuePart.fromToken(token) : null;

            },

            _combinator: function() {

                var tokenStream = this._tokenStream,
                    value       = null,
                    token;

                if (tokenStream.match([Tokens.PLUS, Tokens.GREATER, Tokens.TILDE])) {
                    token = tokenStream.token();
                    value = new Combinator(token.value, token.startLine, token.startCol);
                    this._readWhitespace();
                }

                return value;
            },

            _unary_operator: function() {

                var tokenStream = this._tokenStream;

                if (tokenStream.match([Tokens.MINUS, Tokens.PLUS])) {
                    return tokenStream.token().value;
                } else {
                    return null;
                }
            },

            _property: function() {

                var tokenStream  = this._tokenStream,
                    value        = null,
                    hack         = null,
                    propertyName = &quot;&quot;,
                    token,
                    line,
                    col;
                if (tokenStream.peek() === Tokens.STAR &amp;&amp; this.options.starHack) {
                    tokenStream.get();
                    token = tokenStream.token();
                    hack = token.value;
                    line = token.startLine;
                    col = token.startCol;
                }
                if (tokenStream.peek() === Tokens.MINUS) {
                    tokenStream.get();
                    token = tokenStream.token();
                    propertyName = token.value;
                    line = token.startLine;
                    col = token.startCol;
                }

                if (tokenStream.match(Tokens.IDENT)) {
                    token = tokenStream.token();
                    propertyName += token.value;
                    if (propertyName.charAt(0) === &quot;_&quot; &amp;&amp; this.options.underscoreHack) {
                        hack = &quot;_&quot;;
                        propertyName = propertyName.substring(1);
                    }

                    value = new PropertyName(propertyName, hack, line || token.startLine, col || token.startCol);
                    this._readWhitespace();
                } else {
                    var tt = tokenStream.peek();
                    if (tt !== Tokens.EOF &amp;&amp; tt !== Tokens.RBRACE) {
                        this._unexpectedToken(tokenStream.LT(1));
                    }
                }

                return value;
            },
            _ruleset: function() {

                var tokenStream = this._tokenStream,
                    tt,
                    selectors;
                try {
                    selectors = this._selectors_group();
                } catch (ex) {
                    if (ex instanceof SyntaxError &amp;&amp; !this.options.strict) {
                        this.fire({
                            type:       &quot;error&quot;,
                            error:      ex,
                            message:    ex.message,
                            line:       ex.line,
                            col:        ex.col
                        });
                        tt = tokenStream.advance([Tokens.RBRACE]);
                        if (tt === Tokens.RBRACE) {
                        } else {
                            throw ex;
                        }

                    } else {
                        throw ex;
                    }
                    return true;
                }
                if (selectors) {

                    this.fire({
                        type:       &quot;startrule&quot;,
                        selectors:  selectors,
                        line:       selectors[0].line,
                        col:        selectors[0].col
                    });

                    this._readDeclarations(true);

                    this.fire({
                        type:       &quot;endrule&quot;,
                        selectors:  selectors,
                        line:       selectors[0].line,
                        col:        selectors[0].col
                    });

                }

                return selectors;

            },
            _selectors_group: function() {
                var tokenStream = this._tokenStream,
                    selectors   = [],
                    selector;

                selector = this._selector();
                if (selector !== null) {

                    selectors.push(selector);
                    while (tokenStream.match(Tokens.COMMA)) {
                        this._readWhitespace();
                        selector = this._selector();
                        if (selector !== null) {
                            selectors.push(selector);
                        } else {
                            this._unexpectedToken(tokenStream.LT(1));
                        }
                    }
                }

                return selectors.length ? selectors : null;
            },
            _selector: function() {

                var tokenStream = this._tokenStream,
                    selector    = [],
                    nextSelector = null,
                    combinator  = null,
                    ws          = null;
                nextSelector = this._simple_selector_sequence();
                if (nextSelector === null) {
                    return null;
                }

                selector.push(nextSelector);

                do {
                    combinator = this._combinator();

                    if (combinator !== null) {
                        selector.push(combinator);
                        nextSelector = this._simple_selector_sequence();
                        if (nextSelector === null) {
                            this._unexpectedToken(tokenStream.LT(1));
                        } else {
                            selector.push(nextSelector);
                        }
                    } else {
                        if (this._readWhitespace()) {
                            ws = new Combinator(tokenStream.token().value, tokenStream.token().startLine, tokenStream.token().startCol);
                            combinator = this._combinator();
                            nextSelector = this._simple_selector_sequence();
                            if (nextSelector === null) {
                                if (combinator !== null) {
                                    this._unexpectedToken(tokenStream.LT(1));
                                }
                            } else {

                                if (combinator !== null) {
                                    selector.push(combinator);
                                } else {
                                    selector.push(ws);
                                }

                                selector.push(nextSelector);
                            }
                        } else {
                            break;
                        }

                    }
                } while (true);

                return new Selector(selector, selector[0].line, selector[0].col);
            },
            _simple_selector_sequence: function() {

                var tokenStream = this._tokenStream,
                    elementName = null,
                    modifiers   = [],
                    selectorText = &quot;&quot;,
                    components  = [
                        function() {
                            return tokenStream.match(Tokens.HASH) ?
                                    new SelectorSubPart(tokenStream.token().value, &quot;id&quot;, tokenStream.token().startLine, tokenStream.token().startCol) :
                                    null;
                        },
                        this._class,
                        this._attrib,
                        this._pseudo,
                        this._negation
                    ],
                    i           = 0,
                    len         = components.length,
                    component   = null,
                    line,
                    col;
                line = tokenStream.LT(1).startLine;
                col = tokenStream.LT(1).startCol;

                elementName = this._type_selector();
                if (!elementName) {
                    elementName = this._universal();
                }

                if (elementName !== null) {
                    selectorText += elementName;
                }

                while (true) {
                    if (tokenStream.peek() === Tokens.S) {
                        break;
                    }
                    while (i &lt; len &amp;&amp; component === null) {
                        component = components[i++].call(this);
                    }

                    if (component === null) {
                        if (selectorText === &quot;&quot;) {
                            return null;
                        } else {
                            break;
                        }
                    } else {
                        i = 0;
                        modifiers.push(component);
                        selectorText += component.toString();
                        component = null;
                    }
                }


                return selectorText !== &quot;&quot; ?
                        new SelectorPart(elementName, modifiers, selectorText, line, col) :
                        null;
            },
            _type_selector: function() {

                var tokenStream = this._tokenStream,
                    ns          = this._namespace_prefix(),
                    elementName = this._element_name();

                if (!elementName) {
                    if (ns) {
                        tokenStream.unget();
                        if (ns.length &gt; 1) {
                            tokenStream.unget();
                        }
                    }

                    return null;
                } else {
                    if (ns) {
                        elementName.text = ns + elementName.text;
                        elementName.col -= ns.length;
                    }
                    return elementName;
                }
            },
            _class: function() {

                var tokenStream = this._tokenStream,
                    token;

                if (tokenStream.match(Tokens.DOT)) {
                    tokenStream.mustMatch(Tokens.IDENT);
                    token = tokenStream.token();
                    return new SelectorSubPart(&quot;.&quot; + token.value, &quot;class&quot;, token.startLine, token.startCol - 1);
                } else {
                    return null;
                }

            },
            _element_name: function() {

                var tokenStream = this._tokenStream,
                    token;

                if (tokenStream.match(Tokens.IDENT)) {
                    token = tokenStream.token();
                    return new SelectorSubPart(token.value, &quot;elementName&quot;, token.startLine, token.startCol);

                } else {
                    return null;
                }
            },
            _namespace_prefix: function() {
                var tokenStream = this._tokenStream,
                    value       = &quot;&quot;;
                if (tokenStream.LA(1) === Tokens.PIPE || tokenStream.LA(2) === Tokens.PIPE) {

                    if (tokenStream.match([Tokens.IDENT, Tokens.STAR])) {
                        value += tokenStream.token().value;
                    }

                    tokenStream.mustMatch(Tokens.PIPE);
                    value += &quot;|&quot;;

                }

                return value.length ? value : null;
            },
            _universal: function() {
                var tokenStream = this._tokenStream,
                    value       = &quot;&quot;,
                    ns;

                ns = this._namespace_prefix();
                if (ns) {
                    value += ns;
                }

                if (tokenStream.match(Tokens.STAR)) {
                    value += &quot;*&quot;;
                }

                return value.length ? value : null;

            },
            _attrib: function() {

                var tokenStream = this._tokenStream,
                    value       = null,
                    ns,
                    token;

                if (tokenStream.match(Tokens.LBRACKET)) {
                    token = tokenStream.token();
                    value = token.value;
                    value += this._readWhitespace();

                    ns = this._namespace_prefix();

                    if (ns) {
                        value += ns;
                    }

                    tokenStream.mustMatch(Tokens.IDENT);
                    value += tokenStream.token().value;
                    value += this._readWhitespace();

                    if (tokenStream.match([Tokens.PREFIXMATCH, Tokens.SUFFIXMATCH, Tokens.SUBSTRINGMATCH,
                        Tokens.EQUALS, Tokens.INCLUDES, Tokens.DASHMATCH])) {

                        value += tokenStream.token().value;
                        value += this._readWhitespace();

                        tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);
                        value += tokenStream.token().value;
                        value += this._readWhitespace();
                    }

                    tokenStream.mustMatch(Tokens.RBRACKET);

                    return new SelectorSubPart(value + &quot;]&quot;, &quot;attribute&quot;, token.startLine, token.startCol);
                } else {
                    return null;
                }
            },
            _pseudo: function() {

                var tokenStream = this._tokenStream,
                    pseudo      = null,
                    colons      = &quot;:&quot;,
                    line,
                    col;

                if (tokenStream.match(Tokens.COLON)) {

                    if (tokenStream.match(Tokens.COLON)) {
                        colons += &quot;:&quot;;
                    }

                    if (tokenStream.match(Tokens.IDENT)) {
                        pseudo = tokenStream.token().value;
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol - colons.length;
                    } else if (tokenStream.peek() === Tokens.FUNCTION) {
                        line = tokenStream.LT(1).startLine;
                        col = tokenStream.LT(1).startCol - colons.length;
                        pseudo = this._functional_pseudo();
                    }

                    if (pseudo) {
                        pseudo = new SelectorSubPart(colons + pseudo, &quot;pseudo&quot;, line, col);
                    } else {
                        var startLine = tokenStream.LT(1).startLine,
                            startCol  = tokenStream.LT(0).startCol;
                        throw new SyntaxError(&quot;Expected a `FUNCTION` or `IDENT` after colon at line &quot; + startLine + &quot;, col &quot; + startCol + &quot;.&quot;, startLine, startCol);
                    }
                }

                return pseudo;
            },
            _functional_pseudo: function() {

                var tokenStream = this._tokenStream,
                    value = null;

                if (tokenStream.match(Tokens.FUNCTION)) {
                    value = tokenStream.token().value;
                    value += this._readWhitespace();
                    value += this._expression();
                    tokenStream.mustMatch(Tokens.RPAREN);
                    value += &quot;)&quot;;
                }

                return value;
            },
            _expression: function() {

                var tokenStream = this._tokenStream,
                    value       = &quot;&quot;;

                while (tokenStream.match([Tokens.PLUS, Tokens.MINUS, Tokens.DIMENSION,
                    Tokens.NUMBER, Tokens.STRING, Tokens.IDENT, Tokens.LENGTH,
                    Tokens.FREQ, Tokens.ANGLE, Tokens.TIME,
                    Tokens.RESOLUTION, Tokens.SLASH])) {

                    value += tokenStream.token().value;
                    value += this._readWhitespace();
                }

                return value.length ? value : null;

            },
            _negation: function() {

                var tokenStream = this._tokenStream,
                    line,
                    col,
                    value       = &quot;&quot;,
                    arg,
                    subpart     = null;

                if (tokenStream.match(Tokens.NOT)) {
                    value = tokenStream.token().value;
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;
                    value += this._readWhitespace();
                    arg = this._negation_arg();
                    value += arg;
                    value += this._readWhitespace();
                    tokenStream.match(Tokens.RPAREN);
                    value += tokenStream.token().value;

                    subpart = new SelectorSubPart(value, &quot;not&quot;, line, col);
                    subpart.args.push(arg);
                }

                return subpart;
            },
            _negation_arg: function() {

                var tokenStream = this._tokenStream,
                    args        = [
                        this._type_selector,
                        this._universal,
                        function() {
                            return tokenStream.match(Tokens.HASH) ?
                                    new SelectorSubPart(tokenStream.token().value, &quot;id&quot;, tokenStream.token().startLine, tokenStream.token().startCol) :
                                    null;
                        },
                        this._class,
                        this._attrib,
                        this._pseudo
                    ],
                    arg         = null,
                    i           = 0,
                    len         = args.length,
                    line,
                    col,
                    part;

                line = tokenStream.LT(1).startLine;
                col = tokenStream.LT(1).startCol;

                while (i &lt; len &amp;&amp; arg === null) {

                    arg = args[i].call(this);
                    i++;
                }
                if (arg === null) {
                    this._unexpectedToken(tokenStream.LT(1));
                }
                if (arg.type === &quot;elementName&quot;) {
                    part = new SelectorPart(arg, [], arg.toString(), line, col);
                } else {
                    part = new SelectorPart(null, [arg], arg.toString(), line, col);
                }

                return part;
            },

            _declaration: function() {

                var tokenStream  = this._tokenStream,
                    property     = null,
                    expr         = null,
                    prio         = null,
                    invalid      = null,
                    propertyName = &quot;&quot;;

                property = this._property();
                if (property !== null) {

                    tokenStream.mustMatch(Tokens.COLON);
                    this._readWhitespace();

                    expr = this._expr();
                    if (!expr || expr.length === 0) {
                        this._unexpectedToken(tokenStream.LT(1));
                    }

                    prio = this._prio();
                    propertyName = property.toString();
                    if (this.options.starHack &amp;&amp; property.hack === &quot;*&quot; ||
                            this.options.underscoreHack &amp;&amp; property.hack === &quot;_&quot;) {

                        propertyName = property.text;
                    }

                    try {
                        this._validateProperty(propertyName, expr);
                    } catch (ex) {
                        invalid = ex;
                    }

                    this.fire({
                        type:       &quot;property&quot;,
                        property:   property,
                        value:      expr,
                        important:  prio,
                        line:       property.line,
                        col:        property.col,
                        invalid:    invalid
                    });

                    return true;
                } else {
                    return false;
                }
            },

            _prio: function() {

                var tokenStream = this._tokenStream,
                    result      = tokenStream.match(Tokens.IMPORTANT_SYM);

                this._readWhitespace();
                return result;
            },

            _expr: function(inFunction) {

                var values      = [],
                    value       = null,
                    operator    = null;

                value = this._term(inFunction);
                if (value !== null) {

                    values.push(value);

                    do {
                        operator = this._operator(inFunction);
                        if (operator) {
                            values.push(operator);
                        } /*else {
                            values.push(new PropertyValue(valueParts, valueParts[0].line, valueParts[0].col));
                            valueParts = [];
                        }*/

                        value = this._term(inFunction);

                        if (value === null) {
                            break;
                        } else {
                            values.push(value);
                        }
                    } while (true);
                }

                return values.length &gt; 0 ? new PropertyValue(values, values[0].line, values[0].col) : null;
            },

            _term: function(inFunction) {

                var tokenStream = this._tokenStream,
                    unary       = null,
                    value       = null,
                    endChar     = null,
                    part        = null,
                    token,
                    line,
                    col;
                unary = this._unary_operator();
                if (unary !== null) {
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;
                }
                if (tokenStream.peek() === Tokens.IE_FUNCTION &amp;&amp; this.options.ieFilters) {

                    value = this._ie_function();
                    if (unary === null) {
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol;
                    }
                } else if (inFunction &amp;&amp; tokenStream.match([Tokens.LPAREN, Tokens.LBRACE, Tokens.LBRACKET])) {

                    token = tokenStream.token();
                    endChar = token.endChar;
                    value = token.value + this._expr(inFunction).text;
                    if (unary === null) {
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol;
                    }
                    tokenStream.mustMatch(Tokens.type(endChar));
                    value += endChar;
                    this._readWhitespace();
                } else if (tokenStream.match([Tokens.NUMBER, Tokens.PERCENTAGE, Tokens.LENGTH,
                    Tokens.ANGLE, Tokens.TIME,
                    Tokens.FREQ, Tokens.STRING, Tokens.IDENT, Tokens.URI, Tokens.UNICODE_RANGE])) {

                    value = tokenStream.token().value;
                    if (unary === null) {
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol;
                        part = PropertyValuePart.fromToken(tokenStream.token());
                    }
                    this._readWhitespace();
                } else {
                    token = this._hexcolor();
                    if (token === null) {
                        if (unary === null) {
                            line = tokenStream.LT(1).startLine;
                            col = tokenStream.LT(1).startCol;
                        }
                        if (value === null) {
                            if (tokenStream.LA(3) === Tokens.EQUALS &amp;&amp; this.options.ieFilters) {
                                value = this._ie_function();
                            } else {
                                value = this._function();
                            }
                        }

                    } else {
                        value = token.value;
                        if (unary === null) {
                            line = token.startLine;
                            col = token.startCol;
                        }
                    }

                }

                return part !== null ? part : value !== null ?
                        new PropertyValuePart(unary !== null ? unary + value : value, line, col) :
                        null;

            },

            _function: function() {

                var tokenStream = this._tokenStream,
                    functionText = null,
                    expr        = null,
                    lt;

                if (tokenStream.match(Tokens.FUNCTION)) {
                    functionText = tokenStream.token().value;
                    this._readWhitespace();
                    expr = this._expr(true);
                    functionText += expr;
                    if (this.options.ieFilters &amp;&amp; tokenStream.peek() === Tokens.EQUALS) {
                        do {

                            if (this._readWhitespace()) {
                                functionText += tokenStream.token().value;
                            }
                            if (tokenStream.LA(0) === Tokens.COMMA) {
                                functionText += tokenStream.token().value;
                            }

                            tokenStream.match(Tokens.IDENT);
                            functionText += tokenStream.token().value;

                            tokenStream.match(Tokens.EQUALS);
                            functionText += tokenStream.token().value;
                            lt = tokenStream.peek();
                            while (lt !== Tokens.COMMA &amp;&amp; lt !== Tokens.S &amp;&amp; lt !== Tokens.RPAREN) {
                                tokenStream.get();
                                functionText += tokenStream.token().value;
                                lt = tokenStream.peek();
                            }
                        } while (tokenStream.match([Tokens.COMMA, Tokens.S]));
                    }

                    tokenStream.match(Tokens.RPAREN);
                    functionText += &quot;)&quot;;
                    this._readWhitespace();
                }

                return functionText;
            },

            _ie_function: function() {

                var tokenStream = this._tokenStream,
                    functionText = null,
                    lt;
                if (tokenStream.match([Tokens.IE_FUNCTION, Tokens.FUNCTION])) {
                    functionText = tokenStream.token().value;

                    do {

                        if (this._readWhitespace()) {
                            functionText += tokenStream.token().value;
                        }
                        if (tokenStream.LA(0) === Tokens.COMMA) {
                            functionText += tokenStream.token().value;
                        }

                        tokenStream.match(Tokens.IDENT);
                        functionText += tokenStream.token().value;

                        tokenStream.match(Tokens.EQUALS);
                        functionText += tokenStream.token().value;
                        lt = tokenStream.peek();
                        while (lt !== Tokens.COMMA &amp;&amp; lt !== Tokens.S &amp;&amp; lt !== Tokens.RPAREN) {
                            tokenStream.get();
                            functionText += tokenStream.token().value;
                            lt = tokenStream.peek();
                        }
                    } while (tokenStream.match([Tokens.COMMA, Tokens.S]));

                    tokenStream.match(Tokens.RPAREN);
                    functionText += &quot;)&quot;;
                    this._readWhitespace();
                }

                return functionText;
            },

            _hexcolor: function() {

                var tokenStream = this._tokenStream,
                    token = null,
                    color;

                if (tokenStream.match(Tokens.HASH)) {

                    token = tokenStream.token();
                    color = token.value;
                    if (!/#[a-f0-9]{3,6}/i.test(color)) {
                        throw new SyntaxError(&quot;Expected a hex color but found &#039;&quot; + color + &quot;&#039; at line &quot; + token.startLine + &quot;, col &quot; + token.startCol + &quot;.&quot;, token.startLine, token.startCol);
                    }
                    this._readWhitespace();
                }

                return token;
            },

            _keyframes: function() {
                var tokenStream = this._tokenStream,
                    token,
                    tt,
                    name,
                    prefix = &quot;&quot;;

                tokenStream.mustMatch(Tokens.KEYFRAMES_SYM);
                token = tokenStream.token();
                if (/^@-([^-]+)-/.test(token.value)) {
                    prefix = RegExp.$1;
                }

                this._readWhitespace();
                name = this._keyframe_name();

                this._readWhitespace();
                tokenStream.mustMatch(Tokens.LBRACE);

                this.fire({
                    type:   &quot;startkeyframes&quot;,
                    name:   name,
                    prefix: prefix,
                    line:   token.startLine,
                    col:    token.startCol
                });

                this._readWhitespace();
                tt = tokenStream.peek();
                while (tt === Tokens.IDENT || tt === Tokens.PERCENTAGE) {
                    this._keyframe_rule();
                    this._readWhitespace();
                    tt = tokenStream.peek();
                }

                this.fire({
                    type:   &quot;endkeyframes&quot;,
                    name:   name,
                    prefix: prefix,
                    line:   token.startLine,
                    col:    token.startCol
                });

                this._readWhitespace();
                tokenStream.mustMatch(Tokens.RBRACE);
                this._readWhitespace();

            },

            _keyframe_name: function() {
                var tokenStream = this._tokenStream;

                tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);
                return SyntaxUnit.fromToken(tokenStream.token());
            },

            _keyframe_rule: function() {
                var keyList = this._key_list();

                this.fire({
                    type:   &quot;startkeyframerule&quot;,
                    keys:   keyList,
                    line:   keyList[0].line,
                    col:    keyList[0].col
                });

                this._readDeclarations(true);

                this.fire({
                    type:   &quot;endkeyframerule&quot;,
                    keys:   keyList,
                    line:   keyList[0].line,
                    col:    keyList[0].col
                });

            },

            _key_list: function() {
                var tokenStream = this._tokenStream,
                    keyList = [];
                keyList.push(this._key());

                this._readWhitespace();

                while (tokenStream.match(Tokens.COMMA)) {
                    this._readWhitespace();
                    keyList.push(this._key());
                    this._readWhitespace();
                }

                return keyList;
            },

            _key: function() {

                var tokenStream = this._tokenStream,
                    token;

                if (tokenStream.match(Tokens.PERCENTAGE)) {
                    return SyntaxUnit.fromToken(tokenStream.token());
                } else if (tokenStream.match(Tokens.IDENT)) {
                    token = tokenStream.token();

                    if (/from|to/i.test(token.value)) {
                        return SyntaxUnit.fromToken(token);
                    }

                    tokenStream.unget();
                }
                this._unexpectedToken(tokenStream.LT(1));
            },
            _skipCruft: function() {
                while (this._tokenStream.match([Tokens.S, Tokens.CDO, Tokens.CDC])) {
                }
            },
            _readDeclarations: function(checkStart, readMargins) {
                var tokenStream = this._tokenStream,
                    tt;


                this._readWhitespace();

                if (checkStart) {
                    tokenStream.mustMatch(Tokens.LBRACE);
                }

                this._readWhitespace();

                try {

                    while (true) {

                        if (tokenStream.match(Tokens.SEMICOLON) || (readMargins &amp;&amp; this._margin())) {
                        } else if (this._declaration()) {
                            if (!tokenStream.match(Tokens.SEMICOLON)) {
                                break;
                            }
                        } else {
                            break;
                        }
                        this._readWhitespace();
                    }

                    tokenStream.mustMatch(Tokens.RBRACE);
                    this._readWhitespace();

                } catch (ex) {
                    if (ex instanceof SyntaxError &amp;&amp; !this.options.strict) {
                        this.fire({
                            type:       &quot;error&quot;,
                            error:      ex,
                            message:    ex.message,
                            line:       ex.line,
                            col:        ex.col
                        });
                        tt = tokenStream.advance([Tokens.SEMICOLON, Tokens.RBRACE]);
                        if (tt === Tokens.SEMICOLON) {
                            this._readDeclarations(false, readMargins);
                        } else if (tt !== Tokens.EOF &amp;&amp; tt !== Tokens.RBRACE) {
                            throw ex;
                        }

                    } else {
                        throw ex;
                    }
                }

            },
            _readWhitespace: function() {

                var tokenStream = this._tokenStream,
                    ws = &quot;&quot;;

                while (tokenStream.match(Tokens.S)) {
                    ws += tokenStream.token().value;
                }

                return ws;
            },
            _unexpectedToken: function(token) {
                throw new SyntaxError(&quot;Unexpected token &#039;&quot; + token.value + &quot;&#039; at line &quot; + token.startLine + &quot;, col &quot; + token.startCol + &quot;.&quot;, token.startLine, token.startCol);
            },
            _verifyEnd: function() {
                if (this._tokenStream.LA(1) !== Tokens.EOF) {
                    this._unexpectedToken(this._tokenStream.LT(1));
                }
            },
            _validateProperty: function(property, value) {
                Validation.validate(property, value);
            },

            parse: function(input) {
                this._tokenStream = new TokenStream(input, Tokens);
                this._stylesheet();
            },

            parseStyleSheet: function(input) {
                return this.parse(input);
            },

            parseMediaQuery: function(input) {
                this._tokenStream = new TokenStream(input, Tokens);
                var result = this._media_query();
                this._verifyEnd();
                return result;
            },
            parsePropertyValue: function(input) {

                this._tokenStream = new TokenStream(input, Tokens);
                this._readWhitespace();

                var result = this._expr();
                this._readWhitespace();
                this._verifyEnd();
                return result;
            },
            parseRule: function(input) {
                this._tokenStream = new TokenStream(input, Tokens);
                this._readWhitespace();

                var result = this._ruleset();
                this._readWhitespace();
                this._verifyEnd();
                return result;
            },
            parseSelector: function(input) {

                this._tokenStream = new TokenStream(input, Tokens);
                this._readWhitespace();

                var result = this._selector();
                this._readWhitespace();
                this._verifyEnd();
                return result;
            },
            parseStyleAttribute: function(input) {
                input += &quot;}&quot;;   // for error recovery in _readDeclarations()
                this._tokenStream = new TokenStream(input, Tokens);
                this._readDeclarations();
            }
        };
    for (prop in additions) {
        if (Object.prototype.hasOwnProperty.call(additions, prop)) {
            proto[prop] = additions[prop];
        }
    }

    return proto;
}();

},{&quot;../util/EventTarget&quot;:23,&quot;../util/SyntaxError&quot;:25,&quot;../util/SyntaxUnit&quot;:26,&quot;./Combinator&quot;:2,&quot;./MediaFeature&quot;:4,&quot;./MediaQuery&quot;:5,&quot;./PropertyName&quot;:8,&quot;./PropertyValue&quot;:9,&quot;./PropertyValuePart&quot;:11,&quot;./Selector&quot;:13,&quot;./SelectorPart&quot;:14,&quot;./SelectorSubPart&quot;:15,&quot;./TokenStream&quot;:17,&quot;./Tokens&quot;:18,&quot;./Validation&quot;:19}],7:[function(require,module,exports){

&quot;use strict&quot;;

var Properties = module.exports = {
    __proto__: null,
    &quot;align-items&quot;                       : &quot;flex-start | flex-end | center | baseline | stretch&quot;,
    &quot;align-content&quot;                     : &quot;flex-start | flex-end | center | space-between | space-around | stretch&quot;,
    &quot;align-self&quot;                        : &quot;auto | flex-start | flex-end | center | baseline | stretch&quot;,
    &quot;all&quot;                               : &quot;initial | inherit | unset&quot;,
    &quot;-webkit-align-items&quot;               : &quot;flex-start | flex-end | center | baseline | stretch&quot;,
    &quot;-webkit-align-content&quot;             : &quot;flex-start | flex-end | center | space-between | space-around | stretch&quot;,
    &quot;-webkit-align-self&quot;                : &quot;auto | flex-start | flex-end | center | baseline | stretch&quot;,
    &quot;alignment-adjust&quot;                  : &quot;auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical | &lt;percentage&gt; | &lt;length&gt;&quot;,
    &quot;alignment-baseline&quot;                : &quot;auto | baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical&quot;,
    &quot;animation&quot;                         : 1,
    &quot;animation-delay&quot;                   : &quot;&lt;time&gt;#&quot;,
    &quot;animation-direction&quot;               : &quot;&lt;single-animation-direction&gt;#&quot;,
    &quot;animation-duration&quot;                : &quot;&lt;time&gt;#&quot;,
    &quot;animation-fill-mode&quot;               : &quot;[ none | forwards | backwards | both ]#&quot;,
    &quot;animation-iteration-count&quot;         : &quot;[ &lt;number&gt; | infinite ]#&quot;,
    &quot;animation-name&quot;                    : &quot;[ none | &lt;single-animation-name&gt; ]#&quot;,
    &quot;animation-play-state&quot;              : &quot;[ running | paused ]#&quot;,
    &quot;animation-timing-function&quot;         : 1,
    &quot;-moz-animation-delay&quot;              : &quot;&lt;time&gt;#&quot;,
    &quot;-moz-animation-direction&quot;          : &quot;[ normal | alternate ]#&quot;,
    &quot;-moz-animation-duration&quot;           : &quot;&lt;time&gt;#&quot;,
    &quot;-moz-animation-iteration-count&quot;    : &quot;[ &lt;number&gt; | infinite ]#&quot;,
    &quot;-moz-animation-name&quot;               : &quot;[ none | &lt;single-animation-name&gt; ]#&quot;,
    &quot;-moz-animation-play-state&quot;         : &quot;[ running | paused ]#&quot;,

    &quot;-ms-animation-delay&quot;               : &quot;&lt;time&gt;#&quot;,
    &quot;-ms-animation-direction&quot;           : &quot;[ normal | alternate ]#&quot;,
    &quot;-ms-animation-duration&quot;            : &quot;&lt;time&gt;#&quot;,
    &quot;-ms-animation-iteration-count&quot;     : &quot;[ &lt;number&gt; | infinite ]#&quot;,
    &quot;-ms-animation-name&quot;                : &quot;[ none | &lt;single-animation-name&gt; ]#&quot;,
    &quot;-ms-animation-play-state&quot;          : &quot;[ running | paused ]#&quot;,

    &quot;-webkit-animation-delay&quot;           : &quot;&lt;time&gt;#&quot;,
    &quot;-webkit-animation-direction&quot;       : &quot;[ normal | alternate ]#&quot;,
    &quot;-webkit-animation-duration&quot;        : &quot;&lt;time&gt;#&quot;,
    &quot;-webkit-animation-fill-mode&quot;       : &quot;[ none | forwards | backwards | both ]#&quot;,
    &quot;-webkit-animation-iteration-count&quot; : &quot;[ &lt;number&gt; | infinite ]#&quot;,
    &quot;-webkit-animation-name&quot;            : &quot;[ none | &lt;single-animation-name&gt; ]#&quot;,
    &quot;-webkit-animation-play-state&quot;      : &quot;[ running | paused ]#&quot;,

    &quot;-o-animation-delay&quot;                : &quot;&lt;time&gt;#&quot;,
    &quot;-o-animation-direction&quot;            : &quot;[ normal | alternate ]#&quot;,
    &quot;-o-animation-duration&quot;             : &quot;&lt;time&gt;#&quot;,
    &quot;-o-animation-iteration-count&quot;      : &quot;[ &lt;number&gt; | infinite ]#&quot;,
    &quot;-o-animation-name&quot;                 : &quot;[ none | &lt;single-animation-name&gt; ]#&quot;,
    &quot;-o-animation-play-state&quot;           : &quot;[ running | paused ]#&quot;,

    &quot;appearance&quot;                        : &quot;none | auto&quot;,
    &quot;-moz-appearance&quot;                   : &quot;none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized&quot;,
    &quot;-ms-appearance&quot;                    : &quot;none | icon | window | desktop | workspace | document | tooltip | dialog | button | push-button | hyperlink | radio | radio-button | checkbox | menu-item | tab | menu | menubar | pull-down-menu | pop-up-menu | list-menu | radio-group | checkbox-group | outline-tree | range | field | combo-box | signature | password | normal&quot;,
    &quot;-webkit-appearance&quot;                : &quot;none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical&quot;,
    &quot;-o-appearance&quot;                     : &quot;none | window | desktop | workspace | document | tooltip | dialog | button | push-button | hyperlink | radio | radio-button | checkbox | menu-item | tab | menu | menubar | pull-down-menu | pop-up-menu | list-menu | radio-group | checkbox-group | outline-tree | range | field | combo-box | signature | password | normal&quot;,

    &quot;azimuth&quot;                           : &quot;&lt;azimuth&gt;&quot;,
    &quot;backface-visibility&quot;               : &quot;visible | hidden&quot;,
    &quot;background&quot;                        : 1,
    &quot;background-attachment&quot;             : &quot;&lt;attachment&gt;#&quot;,
    &quot;background-clip&quot;                   : &quot;&lt;box&gt;#&quot;,
    &quot;background-color&quot;                  : &quot;&lt;color&gt;&quot;,
    &quot;background-image&quot;                  : &quot;&lt;bg-image&gt;#&quot;,
    &quot;background-origin&quot;                 : &quot;&lt;box&gt;#&quot;,
    &quot;background-position&quot;               : &quot;&lt;bg-position&gt;&quot;,
    &quot;background-repeat&quot;                 : &quot;&lt;repeat-style&gt;#&quot;,
    &quot;background-size&quot;                   : &quot;&lt;bg-size&gt;#&quot;,
    &quot;baseline-shift&quot;                    : &quot;baseline | sub | super | &lt;percentage&gt; | &lt;length&gt;&quot;,
    &quot;behavior&quot;                          : 1,
    &quot;binding&quot;                           : 1,
    &quot;bleed&quot;                             : &quot;&lt;length&gt;&quot;,
    &quot;bookmark-label&quot;                    : &quot;&lt;content&gt; | &lt;attr&gt; | &lt;string&gt;&quot;,
    &quot;bookmark-level&quot;                    : &quot;none | &lt;integer&gt;&quot;,
    &quot;bookmark-state&quot;                    : &quot;open | closed&quot;,
    &quot;bookmark-target&quot;                   : &quot;none | &lt;uri&gt; | &lt;attr&gt;&quot;,
    &quot;border&quot;                            : &quot;&lt;border-width&gt; || &lt;border-style&gt; || &lt;color&gt;&quot;,
    &quot;border-bottom&quot;                     : &quot;&lt;border-width&gt; || &lt;border-style&gt; || &lt;color&gt;&quot;,
    &quot;border-bottom-color&quot;               : &quot;&lt;color&gt;&quot;,
    &quot;border-bottom-left-radius&quot;         :  &quot;&lt;x-one-radius&gt;&quot;,
    &quot;border-bottom-right-radius&quot;        :  &quot;&lt;x-one-radius&gt;&quot;,
    &quot;border-bottom-style&quot;               : &quot;&lt;border-style&gt;&quot;,
    &quot;border-bottom-width&quot;               : &quot;&lt;border-width&gt;&quot;,
    &quot;border-collapse&quot;                   : &quot;collapse | separate&quot;,
    &quot;border-color&quot;                      : &quot;&lt;color&gt;{1,4}&quot;,
    &quot;border-image&quot;                      : 1,
    &quot;border-image-outset&quot;               : &quot;[ &lt;length&gt; | &lt;number&gt; ]{1,4}&quot;,
    &quot;border-image-repeat&quot;               : &quot;[ stretch | repeat | round | space ]{1,2}&quot;,
    &quot;border-image-slice&quot;                : &quot;&lt;border-image-slice&gt;&quot;,
    &quot;border-image-source&quot;               : &quot;&lt;image&gt; | none&quot;,
    &quot;border-image-width&quot;                : &quot;[ &lt;length&gt; | &lt;percentage&gt; | &lt;number&gt; | auto ]{1,4}&quot;,
    &quot;border-left&quot;                       : &quot;&lt;border-width&gt; || &lt;border-style&gt; || &lt;color&gt;&quot;,
    &quot;border-left-color&quot;                 : &quot;&lt;color&gt;&quot;,
    &quot;border-left-style&quot;                 : &quot;&lt;border-style&gt;&quot;,
    &quot;border-left-width&quot;                 : &quot;&lt;border-width&gt;&quot;,
    &quot;border-radius&quot;                     : &quot;&lt;border-radius&gt;&quot;,
    &quot;border-right&quot;                      : &quot;&lt;border-width&gt; || &lt;border-style&gt; || &lt;color&gt;&quot;,
    &quot;border-right-color&quot;                : &quot;&lt;color&gt;&quot;,
    &quot;border-right-style&quot;                : &quot;&lt;border-style&gt;&quot;,
    &quot;border-right-width&quot;                : &quot;&lt;border-width&gt;&quot;,
    &quot;border-spacing&quot;                    : &quot;&lt;length&gt;{1,2}&quot;,
    &quot;border-style&quot;                      : &quot;&lt;border-style&gt;{1,4}&quot;,
    &quot;border-top&quot;                        : &quot;&lt;border-width&gt; || &lt;border-style&gt; || &lt;color&gt;&quot;,
    &quot;border-top-color&quot;                  : &quot;&lt;color&gt;&quot;,
    &quot;border-top-left-radius&quot;            : &quot;&lt;x-one-radius&gt;&quot;,
    &quot;border-top-right-radius&quot;           : &quot;&lt;x-one-radius&gt;&quot;,
    &quot;border-top-style&quot;                  : &quot;&lt;border-style&gt;&quot;,
    &quot;border-top-width&quot;                  : &quot;&lt;border-width&gt;&quot;,
    &quot;border-width&quot;                      : &quot;&lt;border-width&gt;{1,4}&quot;,
    &quot;bottom&quot;                            : &quot;&lt;margin-width&gt;&quot;,
    &quot;-moz-box-align&quot;                    : &quot;start | end | center | baseline | stretch&quot;,
    &quot;-moz-box-decoration-break&quot;         : &quot;slice | clone&quot;,
    &quot;-moz-box-direction&quot;                : &quot;normal | reverse&quot;,
    &quot;-moz-box-flex&quot;                     : &quot;&lt;number&gt;&quot;,
    &quot;-moz-box-flex-group&quot;               : &quot;&lt;integer&gt;&quot;,
    &quot;-moz-box-lines&quot;                    : &quot;single | multiple&quot;,
    &quot;-moz-box-ordinal-group&quot;            : &quot;&lt;integer&gt;&quot;,
    &quot;-moz-box-orient&quot;                   : &quot;horizontal | vertical | inline-axis | block-axis&quot;,
    &quot;-moz-box-pack&quot;                     : &quot;start | end | center | justify&quot;,
    &quot;-o-box-decoration-break&quot;           : &quot;slice | clone&quot;,
    &quot;-webkit-box-align&quot;                 : &quot;start | end | center | baseline | stretch&quot;,
    &quot;-webkit-box-decoration-break&quot;      : &quot;slice | clone&quot;,
    &quot;-webkit-box-direction&quot;             : &quot;normal | reverse&quot;,
    &quot;-webkit-box-flex&quot;                  : &quot;&lt;number&gt;&quot;,
    &quot;-webkit-box-flex-group&quot;            : &quot;&lt;integer&gt;&quot;,
    &quot;-webkit-box-lines&quot;                 : &quot;single | multiple&quot;,
    &quot;-webkit-box-ordinal-group&quot;         : &quot;&lt;integer&gt;&quot;,
    &quot;-webkit-box-orient&quot;                : &quot;horizontal | vertical | inline-axis | block-axis&quot;,
    &quot;-webkit-box-pack&quot;                  : &quot;start | end | center | justify&quot;,
    &quot;box-decoration-break&quot;              : &quot;slice | clone&quot;,
    &quot;box-shadow&quot;                        : &quot;&lt;box-shadow&gt;&quot;,
    &quot;box-sizing&quot;                        : &quot;content-box | border-box&quot;,
    &quot;break-after&quot;                       : &quot;auto | always | avoid | left | right | page | column | avoid-page | avoid-column&quot;,
    &quot;break-before&quot;                      : &quot;auto | always | avoid | left | right | page | column | avoid-page | avoid-column&quot;,
    &quot;break-inside&quot;                      : &quot;auto | avoid | avoid-page | avoid-column&quot;,
    &quot;caption-side&quot;                      : &quot;top | bottom&quot;,
    &quot;clear&quot;                             : &quot;none | right | left | both&quot;,
    &quot;clip&quot;                              : &quot;&lt;shape&gt; | auto&quot;,
    &quot;-webkit-clip-path&quot;                 : &quot;&lt;clip-source&gt; | &lt;clip-path&gt; | none&quot;,
    &quot;clip-path&quot;                         : &quot;&lt;clip-source&gt; | &lt;clip-path&gt; | none&quot;,
    &quot;clip-rule&quot;                         : &quot;nonzero | evenodd&quot;,
    &quot;color&quot;                             : &quot;&lt;color&gt;&quot;,
    &quot;color-interpolation&quot;               : &quot;auto | sRGB | linearRGB&quot;,
    &quot;color-interpolation-filters&quot;       : &quot;auto | sRGB | linearRGB&quot;,
    &quot;color-profile&quot;                     : 1,
    &quot;color-rendering&quot;                   : &quot;auto | optimizeSpeed | optimizeQuality&quot;,
    &quot;column-count&quot;                      : &quot;&lt;integer&gt; | auto&quot;,                       // https    ://www.w3.org/TR/css3-multicol/
    &quot;column-fill&quot;                       : &quot;auto | balance&quot;,
    &quot;column-gap&quot;                        : &quot;&lt;length&gt; | normal&quot;,
    &quot;column-rule&quot;                       : &quot;&lt;border-width&gt; || &lt;border-style&gt; || &lt;color&gt;&quot;,
    &quot;column-rule-color&quot;                 : &quot;&lt;color&gt;&quot;,
    &quot;column-rule-style&quot;                 : &quot;&lt;border-style&gt;&quot;,
    &quot;column-rule-width&quot;                 : &quot;&lt;border-width&gt;&quot;,
    &quot;column-span&quot;                       : &quot;none | all&quot;,
    &quot;column-width&quot;                      : &quot;&lt;length&gt; | auto&quot;,
    &quot;columns&quot;                           : 1,
    &quot;content&quot;                           : 1,
    &quot;counter-increment&quot;                 : 1,
    &quot;counter-reset&quot;                     : 1,
    &quot;crop&quot;                              : &quot;&lt;shape&gt; | auto&quot;,
    &quot;cue&quot;                               : &quot;cue-after | cue-before&quot;,
    &quot;cue-after&quot;                         : 1,
    &quot;cue-before&quot;                        : 1,
    &quot;cursor&quot;                            : 1,
    &quot;direction&quot;                         : &quot;ltr | rtl&quot;,
    &quot;display&quot;                           : &quot;inline | block | list-item | inline-block | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | grid | inline-grid | run-in | ruby | ruby-base | ruby-text | ruby-base-container | ruby-text-container | contents | none | -moz-box | -moz-inline-block | -moz-inline-box | -moz-inline-grid | -moz-inline-stack | -moz-inline-table | -moz-grid | -moz-grid-group | -moz-grid-line | -moz-groupbox | -moz-deck | -moz-popup | -moz-stack | -moz-marker | -webkit-box | -webkit-inline-box | -ms-flexbox | -ms-inline-flexbox | flex | -webkit-flex | inline-flex | -webkit-inline-flex&quot;,
    &quot;dominant-baseline&quot;                 : &quot;auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge&quot;,
    &quot;drop-initial-after-adjust&quot;         : &quot;central | middle | after-edge | text-after-edge | ideographic | alphabetic | mathematical | &lt;percentage&gt; | &lt;length&gt;&quot;,
    &quot;drop-initial-after-align&quot;          : &quot;baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical&quot;,
    &quot;drop-initial-before-adjust&quot;        : &quot;before-edge | text-before-edge | central | middle | hanging | mathematical | &lt;percentage&gt; | &lt;length&gt;&quot;,
    &quot;drop-initial-before-align&quot;         : &quot;caps-height | baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical&quot;,
    &quot;drop-initial-size&quot;                 : &quot;auto | line | &lt;length&gt; | &lt;percentage&gt;&quot;,
    &quot;drop-initial-value&quot;                : &quot;&lt;integer&gt;&quot;,
    &quot;elevation&quot;                         : &quot;&lt;angle&gt; | below | level | above | higher | lower&quot;,
    &quot;empty-cells&quot;                       : &quot;show | hide&quot;,
    &quot;enable-background&quot;                 : 1,
    &quot;fill&quot;                              : &quot;&lt;paint&gt;&quot;,
    &quot;fill-opacity&quot;                      : &quot;&lt;opacity-value&gt;&quot;,
    &quot;fill-rule&quot;                         : &quot;nonzero | evenodd&quot;,
    &quot;filter&quot;                            : &quot;&lt;filter-function-list&gt; | none&quot;,
    &quot;fit&quot;                               : &quot;fill | hidden | meet | slice&quot;,
    &quot;fit-position&quot;                      : 1,
    &quot;flex&quot;                              : &quot;&lt;flex&gt;&quot;,
    &quot;flex-basis&quot;                        : &quot;&lt;width&gt;&quot;,
    &quot;flex-direction&quot;                    : &quot;row | row-reverse | column | column-reverse&quot;,
    &quot;flex-flow&quot;                         : &quot;&lt;flex-direction&gt; || &lt;flex-wrap&gt;&quot;,
    &quot;flex-grow&quot;                         : &quot;&lt;number&gt;&quot;,
    &quot;flex-shrink&quot;                       : &quot;&lt;number&gt;&quot;,
    &quot;flex-wrap&quot;                         : &quot;nowrap | wrap | wrap-reverse&quot;,
    &quot;-webkit-flex&quot;                      : &quot;&lt;flex&gt;&quot;,
    &quot;-webkit-flex-basis&quot;                : &quot;&lt;width&gt;&quot;,
    &quot;-webkit-flex-direction&quot;            : &quot;row | row-reverse | column | column-reverse&quot;,
    &quot;-webkit-flex-flow&quot;                 : &quot;&lt;flex-direction&gt; || &lt;flex-wrap&gt;&quot;,
    &quot;-webkit-flex-grow&quot;                 : &quot;&lt;number&gt;&quot;,
    &quot;-webkit-flex-shrink&quot;               : &quot;&lt;number&gt;&quot;,
    &quot;-webkit-flex-wrap&quot;                 : &quot;nowrap | wrap | wrap-reverse&quot;,
    &quot;-ms-flex&quot;                          : &quot;&lt;flex&gt;&quot;,
    &quot;-ms-flex-align&quot;                    : &quot;start | end | center | stretch | baseline&quot;,
    &quot;-ms-flex-direction&quot;                : &quot;row | row-reverse | column | column-reverse&quot;,
    &quot;-ms-flex-order&quot;                    : &quot;&lt;number&gt;&quot;,
    &quot;-ms-flex-pack&quot;                     : &quot;start | end | center | justify | distribute&quot;,
    &quot;-ms-flex-wrap&quot;                     : &quot;nowrap | wrap | wrap-reverse&quot;,
    &quot;float&quot;                             : &quot;left | right | none&quot;,
    &quot;float-offset&quot;                      : 1,
    &quot;flood-color&quot;                       : 1,
    &quot;flood-opacity&quot;                     : &quot;&lt;opacity-value&gt;&quot;,
    &quot;font&quot;                              : &quot;&lt;font-shorthand&gt; | caption | icon | menu | message-box | small-caption | status-bar&quot;,
    &quot;font-family&quot;                       : &quot;&lt;font-family&gt;&quot;,
    &quot;font-feature-settings&quot;             : &quot;&lt;feature-tag-value&gt; | normal&quot;,
    &quot;font-kerning&quot;                      : &quot;auto | normal | none&quot;,
    &quot;font-size&quot;                         : &quot;&lt;font-size&gt;&quot;,
    &quot;font-size-adjust&quot;                  : &quot;&lt;number&gt; | none&quot;,
    &quot;font-stretch&quot;                      : &quot;&lt;font-stretch&gt;&quot;,
    &quot;font-style&quot;                        : &quot;&lt;font-style&gt;&quot;,
    &quot;font-variant&quot;                      : &quot;&lt;font-variant&gt; | normal | none&quot;,
    &quot;font-variant-alternates&quot;           : &quot;&lt;font-variant-alternates&gt; | normal&quot;,
    &quot;font-variant-caps&quot;                 : &quot;&lt;font-variant-caps&gt; | normal&quot;,
    &quot;font-variant-east-asian&quot;           : &quot;&lt;font-variant-east-asian&gt; | normal&quot;,
    &quot;font-variant-ligatures&quot;            : &quot;&lt;font-variant-ligatures&gt; | normal | none&quot;,
    &quot;font-variant-numeric&quot;              : &quot;&lt;font-variant-numeric&gt; | normal&quot;,
    &quot;font-variant-position&quot;             : &quot;normal | sub | super&quot;,
    &quot;font-weight&quot;                       : &quot;&lt;font-weight&gt;&quot;,
    &quot;gap&quot;                               : &quot;[ &lt;length&gt; | &lt;percentage&gt; ]{1,2}&quot;,
    &quot;glyph-orientation-horizontal&quot;      : &quot;&lt;glyph-angle&gt;&quot;,
    &quot;glyph-orientation-vertical&quot;        : &quot;auto | &lt;glyph-angle&gt;&quot;,
    &quot;grid&quot;                              : 1,
    &quot;grid-area&quot;                         : 1,
    &quot;grid-auto-columns&quot;                 : 1,
    &quot;grid-auto-flow&quot;                    : 1,
    &quot;grid-auto-position&quot;                : 1,
    &quot;grid-auto-rows&quot;                    : 1,
    &quot;grid-cell-stacking&quot;                : &quot;columns | rows | layer&quot;,
    &quot;grid-column&quot;                       : 1,
    &quot;grid-columns&quot;                      : 1,
    &quot;grid-column-align&quot;                 : &quot;start | end | center | stretch&quot;,
    &quot;grid-column-sizing&quot;                : 1,
    &quot;grid-column-start&quot;                 : 1,
    &quot;grid-column-end&quot;                   : 1,
    &quot;grid-column-span&quot;                  : &quot;&lt;integer&gt;&quot;,
    &quot;grid-flow&quot;                         : &quot;none | rows | columns&quot;,
    &quot;grid-gap&quot;                          : &quot;[ &lt;length&gt; | &lt;percentage&gt; ]{1,2}&quot;,
    &quot;grid-layer&quot;                        : &quot;&lt;integer&gt;&quot;,
    &quot;grid-row&quot;                          : 1,
    &quot;grid-rows&quot;                         : 1,
    &quot;grid-row-align&quot;                    : &quot;start | end | center | stretch&quot;,
    &quot;grid-row-gap&quot;                      : 1,
    &quot;grid-row-start&quot;                    : 1,
    &quot;grid-row-end&quot;                      : 1,
    &quot;grid-row-span&quot;                     : &quot;&lt;integer&gt;&quot;,
    &quot;grid-row-sizing&quot;                   : 1,
    &quot;grid-template&quot;                     : 1,
    &quot;grid-template-areas&quot;               : 1,
    &quot;grid-template-columns&quot;             : 1,
    &quot;grid-template-rows&quot;                : 1,
    &quot;hanging-punctuation&quot;               : 1,
    &quot;height&quot;                            : &quot;&lt;margin-width&gt; | &lt;content-sizing&gt;&quot;,
    &quot;hyphenate-after&quot;                   : &quot;&lt;integer&gt; | auto&quot;,
    &quot;hyphenate-before&quot;                  : &quot;&lt;integer&gt; | auto&quot;,
    &quot;hyphenate-character&quot;               : &quot;&lt;string&gt; | auto&quot;,
    &quot;hyphenate-lines&quot;                   : &quot;no-limit | &lt;integer&gt;&quot;,
    &quot;hyphenate-resource&quot;                : 1,
    &quot;hyphens&quot;                           : &quot;none | manual | auto&quot;,
    &quot;icon&quot;                              : 1,
    &quot;image-orientation&quot;                 : &quot;angle | auto&quot;,
    &quot;image-rendering&quot;                   : &quot;auto | optimizeSpeed | optimizeQuality&quot;,
    &quot;image-resolution&quot;                  : 1,
    &quot;ime-mode&quot;                          : &quot;auto | normal | active | inactive | disabled&quot;,
    &quot;inline-box-align&quot;                  : &quot;last | &lt;integer&gt;&quot;,
    &quot;justify-content&quot;                   : &quot;flex-start | flex-end | center | space-between | space-around | space-evenly | stretch&quot;,
    &quot;-webkit-justify-content&quot;           : &quot;flex-start | flex-end | center | space-between | space-around | space-evenly | stretch&quot;,
    &quot;kerning&quot;                           : &quot;auto | &lt;length&gt;&quot;,
    &quot;left&quot;                              : &quot;&lt;margin-width&gt;&quot;,
    &quot;letter-spacing&quot;                    : &quot;&lt;length&gt; | normal&quot;,
    &quot;line-height&quot;                       : &quot;&lt;line-height&gt;&quot;,
    &quot;line-break&quot;                        : &quot;auto | loose | normal | strict&quot;,
    &quot;line-stacking&quot;                     : 1,
    &quot;line-stacking-ruby&quot;                : &quot;exclude-ruby | include-ruby&quot;,
    &quot;line-stacking-shift&quot;               : &quot;consider-shifts | disregard-shifts&quot;,
    &quot;line-stacking-strategy&quot;            : &quot;inline-line-height | block-line-height | max-height | grid-height&quot;,
    &quot;list-style&quot;                        : 1,
    &quot;list-style-image&quot;                  : &quot;&lt;uri&gt; | none&quot;,
    &quot;list-style-position&quot;               : &quot;inside | outside&quot;,
    &quot;list-style-type&quot;                   : &quot;disc | circle | square | decimal | decimal-leading-zero | lower-roman | upper-roman | lower-greek | lower-latin | upper-latin | armenian | georgian | lower-alpha | upper-alpha | none&quot;,
    &quot;margin&quot;                            : &quot;&lt;margin-width&gt;{1,4}&quot;,
    &quot;margin-bottom&quot;                     : &quot;&lt;margin-width&gt;&quot;,
    &quot;margin-left&quot;                       : &quot;&lt;margin-width&gt;&quot;,
    &quot;margin-right&quot;                      : &quot;&lt;margin-width&gt;&quot;,
    &quot;margin-top&quot;                        : &quot;&lt;margin-width&gt;&quot;,
    &quot;mark&quot;                              : 1,
    &quot;mark-after&quot;                        : 1,
    &quot;mark-before&quot;                       : 1,
    &quot;marker&quot;                            : 1,
    &quot;marker-end&quot;                        : 1,
    &quot;marker-mid&quot;                        : 1,
    &quot;marker-start&quot;                      : 1,
    &quot;marks&quot;                             : 1,
    &quot;marquee-direction&quot;                 : 1,
    &quot;marquee-play-count&quot;                : 1,
    &quot;marquee-speed&quot;                     : 1,
    &quot;marquee-style&quot;                     : 1,
    &quot;mask&quot;                              : 1,
    &quot;max-height&quot;                        : &quot;&lt;length&gt; | &lt;percentage&gt; | &lt;content-sizing&gt; | none&quot;,
    &quot;max-width&quot;                         : &quot;&lt;length&gt; | &lt;percentage&gt; | &lt;content-sizing&gt; | none&quot;,
    &quot;min-height&quot;                        : &quot;&lt;length&gt; | &lt;percentage&gt; | &lt;content-sizing&gt; | contain-floats | -moz-contain-floats | -webkit-contain-floats&quot;,
    &quot;min-width&quot;                         : &quot;&lt;length&gt; | &lt;percentage&gt; | &lt;content-sizing&gt; | contain-floats | -moz-contain-floats | -webkit-contain-floats&quot;,
    &quot;mix-blend-mode&quot;                    : &quot;&lt;blend-mode&gt;&quot;,
    &quot;move-to&quot;                           : 1,
    &quot;nav-down&quot;                          : 1,
    &quot;nav-index&quot;                         : 1,
    &quot;nav-left&quot;                          : 1,
    &quot;nav-right&quot;                         : 1,
    &quot;nav-up&quot;                            : 1,
    &quot;object-fit&quot;                        : &quot;fill | contain | cover | none | scale-down&quot;,
    &quot;object-position&quot;                   : &quot;&lt;position&gt;&quot;,
    &quot;opacity&quot;                           : &quot;&lt;opacity-value&gt;&quot;,
    &quot;order&quot;                             : &quot;&lt;integer&gt;&quot;,
    &quot;-webkit-order&quot;                     : &quot;&lt;integer&gt;&quot;,
    &quot;orphans&quot;                           : &quot;&lt;integer&gt;&quot;,
    &quot;outline&quot;                           : 1,
    &quot;outline-color&quot;                     : &quot;&lt;color&gt; | invert&quot;,
    &quot;outline-offset&quot;                    : 1,
    &quot;outline-style&quot;                     : &quot;&lt;border-style&gt;&quot;,
    &quot;outline-width&quot;                     : &quot;&lt;border-width&gt;&quot;,
    &quot;overflow&quot;                          : &quot;visible | hidden | scroll | auto&quot;,
    &quot;overflow-style&quot;                    : 1,
    &quot;overflow-wrap&quot;                     : &quot;normal | break-word&quot;,
    &quot;overflow-x&quot;                        : 1,
    &quot;overflow-y&quot;                        : 1,
    &quot;padding&quot;                           : &quot;&lt;padding-width&gt;{1,4}&quot;,
    &quot;padding-bottom&quot;                    : &quot;&lt;padding-width&gt;&quot;,
    &quot;padding-left&quot;                      : &quot;&lt;padding-width&gt;&quot;,
    &quot;padding-right&quot;                     : &quot;&lt;padding-width&gt;&quot;,
    &quot;padding-top&quot;                       : &quot;&lt;padding-width&gt;&quot;,
    &quot;page&quot;                              : 1,
    &quot;page-break-after&quot;                  : &quot;auto | always | avoid | left | right&quot;,
    &quot;page-break-before&quot;                 : &quot;auto | always | avoid | left | right&quot;,
    &quot;page-break-inside&quot;                 : &quot;auto | avoid&quot;,
    &quot;page-policy&quot;                       : 1,
    &quot;pause&quot;                             : 1,
    &quot;pause-after&quot;                       : 1,
    &quot;pause-before&quot;                      : 1,
    &quot;perspective&quot;                       : 1,
    &quot;perspective-origin&quot;                : 1,
    &quot;phonemes&quot;                          : 1,
    &quot;pitch&quot;                             : 1,
    &quot;pitch-range&quot;                       : 1,
    &quot;play-during&quot;                       : 1,
    &quot;pointer-events&quot;                    : &quot;auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all&quot;,
    &quot;position&quot;                          : &quot;static | relative | absolute | fixed | sticky | -webkit-sticky&quot;,
    &quot;presentation-level&quot;                : 1,
    &quot;punctuation-trim&quot;                  : 1,
    &quot;quotes&quot;                            : 1,
    &quot;rendering-intent&quot;                  : 1,
    &quot;resize&quot;                            : 1,
    &quot;rest&quot;                              : 1,
    &quot;rest-after&quot;                        : 1,
    &quot;rest-before&quot;                       : 1,
    &quot;richness&quot;                          : 1,
    &quot;right&quot;                             : &quot;&lt;margin-width&gt;&quot;,
    &quot;rotation&quot;                          : 1,
    &quot;rotation-point&quot;                    : 1,
    &quot;ruby-align&quot;                        : 1,
    &quot;ruby-overhang&quot;                     : 1,
    &quot;ruby-position&quot;                     : 1,
    &quot;ruby-span&quot;                         : 1,
    &quot;shape-rendering&quot;                   : &quot;auto | optimizeSpeed | crispEdges | geometricPrecision&quot;,
    &quot;size&quot;                              : 1,
    &quot;speak&quot;                             : &quot;normal | none | spell-out&quot;,
    &quot;speak-header&quot;                      : &quot;once | always&quot;,
    &quot;speak-numeral&quot;                     : &quot;digits | continuous&quot;,
    &quot;speak-punctuation&quot;                 : &quot;code | none&quot;,
    &quot;speech-rate&quot;                       : 1,
    &quot;src&quot;                               : 1,
    &quot;stop-color&quot;                        : 1,
    &quot;stop-opacity&quot;                      : &quot;&lt;opacity-value&gt;&quot;,
    &quot;stress&quot;                            : 1,
    &quot;string-set&quot;                        : 1,
    &quot;stroke&quot;                            : &quot;&lt;paint&gt;&quot;,
    &quot;stroke-dasharray&quot;                  : &quot;none | &lt;dasharray&gt;&quot;,
    &quot;stroke-dashoffset&quot;                 : &quot;&lt;percentage&gt; | &lt;length&gt;&quot;,
    &quot;stroke-linecap&quot;                    : &quot;butt | round | square&quot;,
    &quot;stroke-linejoin&quot;                   : &quot;miter | round | bevel&quot;,
    &quot;stroke-miterlimit&quot;                 : &quot;&lt;miterlimit&gt;&quot;,
    &quot;stroke-opacity&quot;                    : &quot;&lt;opacity-value&gt;&quot;,
    &quot;stroke-width&quot;                      : &quot;&lt;percentage&gt; | &lt;length&gt;&quot;,

    &quot;table-layout&quot;                      : &quot;auto | fixed&quot;,
    &quot;tab-size&quot;                          : &quot;&lt;integer&gt; | &lt;length&gt;&quot;,
    &quot;target&quot;                            : 1,
    &quot;target-name&quot;                       : 1,
    &quot;target-new&quot;                        : 1,
    &quot;target-position&quot;                   : 1,
    &quot;text-align&quot;                        : &quot;left | right | center | justify | match-parent | start | end&quot;,
    &quot;text-align-last&quot;                   : 1,
    &quot;text-anchor&quot;                       : &quot;start | middle | end&quot;,
    &quot;text-decoration&quot;                   : &quot;&lt;text-decoration-line&gt; || &lt;text-decoration-style&gt; || &lt;text-decoration-color&gt;&quot;,
    &quot;text-decoration-color&quot;             : &quot;&lt;text-decoration-color&gt;&quot;,
    &quot;text-decoration-line&quot;              : &quot;&lt;text-decoration-line&gt;&quot;,
    &quot;text-decoration-style&quot;             : &quot;&lt;text-decoration-style&gt;&quot;,
    &quot;text-decoration-skip&quot;              : &quot;none | [ objects || spaces || ink || edges || box-decoration ]&quot;,
    &quot;-webkit-text-decoration-skip&quot;      : &quot;none | [ objects || spaces || ink || edges || box-decoration ]&quot;,
    &quot;text-underline-position&quot;           : &quot;auto | [ under || [ left | right ] ]&quot;,
    &quot;text-emphasis&quot;                     : 1,
    &quot;text-height&quot;                       : 1,
    &quot;text-indent&quot;                       : &quot;&lt;length&gt; | &lt;percentage&gt;&quot;,
    &quot;text-justify&quot;                      : &quot;auto | none | inter-word | inter-ideograph | inter-cluster | distribute | kashida&quot;,
    &quot;text-outline&quot;                      : 1,
    &quot;text-overflow&quot;                     : 1,
    &quot;text-rendering&quot;                    : &quot;auto | optimizeSpeed | optimizeLegibility | geometricPrecision&quot;,
    &quot;text-shadow&quot;                       : 1,
    &quot;text-transform&quot;                    : &quot;capitalize | uppercase | lowercase | none&quot;,
    &quot;text-wrap&quot;                         : &quot;normal | none | avoid&quot;,
    &quot;top&quot;                               : &quot;&lt;margin-width&gt;&quot;,
    &quot;-ms-touch-action&quot;                  : &quot;auto | none | pan-x | pan-y | pan-left | pan-right | pan-up | pan-down | manipulation&quot;,
    &quot;touch-action&quot;                      : &quot;auto | none | pan-x | pan-y | pan-left | pan-right | pan-up | pan-down | manipulation&quot;,
    &quot;transform&quot;                         : 1,
    &quot;transform-origin&quot;                  : 1,
    &quot;transform-style&quot;                   : 1,
    &quot;transition&quot;                        : 1,
    &quot;transition-delay&quot;                  : 1,
    &quot;transition-duration&quot;               : 1,
    &quot;transition-property&quot;               : 1,
    &quot;transition-timing-function&quot;        : 1,
    &quot;unicode-bidi&quot;                      : &quot;normal | embed | isolate | bidi-override | isolate-override | plaintext&quot;,
    &quot;user-modify&quot;                       : &quot;read-only | read-write | write-only&quot;,
    &quot;user-select&quot;                       : &quot;auto | text | none | contain | all&quot;,
    &quot;vertical-align&quot;                    : &quot;auto | use-script | baseline | sub | super | top | text-top | central | middle | bottom | text-bottom | &lt;percentage&gt; | &lt;length&gt;&quot;,
    &quot;visibility&quot;                        : &quot;visible | hidden | collapse&quot;,
    &quot;voice-balance&quot;                     : 1,
    &quot;voice-duration&quot;                    : 1,
    &quot;voice-family&quot;                      : 1,
    &quot;voice-pitch&quot;                       : 1,
    &quot;voice-pitch-range&quot;                 : 1,
    &quot;voice-rate&quot;                        : 1,
    &quot;voice-stress&quot;                      : 1,
    &quot;voice-volume&quot;                      : 1,
    &quot;volume&quot;                            : 1,
    &quot;white-space&quot;                       : &quot;normal | pre | nowrap | pre-wrap | pre-line | -pre-wrap | -o-pre-wrap | -moz-pre-wrap | -hp-pre-wrap&quot;,   // https    ://perishablepress.com/wrapping-content/
    &quot;white-space-collapse&quot;              : 1,
    &quot;widows&quot;                            : &quot;&lt;integer&gt;&quot;,
    &quot;width&quot;                             : &quot;&lt;length&gt; | &lt;percentage&gt; | &lt;content-sizing&gt; | auto&quot;,
    &quot;will-change&quot;                       : &quot;&lt;will-change&gt;&quot;,
    &quot;word-break&quot;                        : &quot;normal | keep-all | break-all | break-word&quot;,
    &quot;word-spacing&quot;                      : &quot;&lt;length&gt; | normal&quot;,
    &quot;word-wrap&quot;                         : &quot;normal | break-word&quot;,
    &quot;writing-mode&quot;                      : &quot;horizontal-tb | vertical-rl | vertical-lr | lr-tb | rl-tb | tb-rl | bt-rl | tb-lr | bt-lr | lr-bt | rl-bt | lr | rl | tb&quot;,
    &quot;z-index&quot;                           : &quot;&lt;integer&gt; | auto&quot;,
    &quot;zoom&quot;                              : &quot;&lt;number&gt; | &lt;percentage&gt; | normal&quot;
};

},{}],8:[function(require,module,exports){
&quot;use strict&quot;;

module.exports = PropertyName;

var SyntaxUnit = require(&quot;../util/SyntaxUnit&quot;);

var Parser = require(&quot;./Parser&quot;);
function PropertyName(text, hack, line, col) {

    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_NAME_TYPE);
    this.hack = hack;

}

PropertyName.prototype = new SyntaxUnit();
PropertyName.prototype.constructor = PropertyName;
PropertyName.prototype.toString = function() {
    return (this.hack ? this.hack : &quot;&quot;) + this.text;
};

},{&quot;../util/SyntaxUnit&quot;:26,&quot;./Parser&quot;:6}],9:[function(require,module,exports){
&quot;use strict&quot;;

module.exports = PropertyValue;

var SyntaxUnit = require(&quot;../util/SyntaxUnit&quot;);

var Parser = require(&quot;./Parser&quot;);
function PropertyValue(parts, line, col) {

    SyntaxUnit.call(this, parts.join(&quot; &quot;), line, col, Parser.PROPERTY_VALUE_TYPE);
    this.parts = parts;

}

PropertyValue.prototype = new SyntaxUnit();
PropertyValue.prototype.constructor = PropertyValue;


},{&quot;../util/SyntaxUnit&quot;:26,&quot;./Parser&quot;:6}],10:[function(require,module,exports){
&quot;use strict&quot;;

module.exports = PropertyValueIterator;
function PropertyValueIterator(value) {
    this._i = 0;
    this._parts = value.parts;
    this._marks = [];
    this.value = value;

}
PropertyValueIterator.prototype.count = function() {
    return this._parts.length;
};
PropertyValueIterator.prototype.isFirst = function() {
    return this._i === 0;
};
PropertyValueIterator.prototype.hasNext = function() {
    return this._i &lt; this._parts.length;
};
PropertyValueIterator.prototype.mark = function() {
    this._marks.push(this._i);
};
PropertyValueIterator.prototype.peek = function(count) {
    return this.hasNext() ? this._parts[this._i + (count || 0)] : null;
};
PropertyValueIterator.prototype.next = function() {
    return this.hasNext() ? this._parts[this._i++] : null;
};
PropertyValueIterator.prototype.previous = function() {
    return this._i &gt; 0 ? this._parts[--this._i] : null;
};
PropertyValueIterator.prototype.restore = function() {
    if (this._marks.length) {
        this._i = this._marks.pop();
    }
};
PropertyValueIterator.prototype.drop = function() {
    this._marks.pop();
};

},{}],11:[function(require,module,exports){
&quot;use strict&quot;;

module.exports = PropertyValuePart;

var SyntaxUnit = require(&quot;../util/SyntaxUnit&quot;);

var Colors = require(&quot;./Colors&quot;);
var Parser = require(&quot;./Parser&quot;);
var Tokens = require(&quot;./Tokens&quot;);
function PropertyValuePart(text, line, col, optionalHint) {
    var hint = optionalHint || {};

    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_VALUE_PART_TYPE);
    this.type = &quot;unknown&quot;;

    var temp;
    if (/^([+-]?[\d.]+)([a-z]+)$/i.test(text)) {  // dimension
        this.type = &quot;dimension&quot;;
        this.value = Number(RegExp.$1);
        this.units = RegExp.$2;
        switch (this.units.toLowerCase()) {

            case &quot;em&quot;:
            case &quot;rem&quot;:
            case &quot;ex&quot;:
            case &quot;px&quot;:
            case &quot;cm&quot;:
            case &quot;mm&quot;:
            case &quot;in&quot;:
            case &quot;pt&quot;:
            case &quot;pc&quot;:
            case &quot;ch&quot;:
            case &quot;vh&quot;:
            case &quot;vw&quot;:
            case &quot;vmax&quot;:
            case &quot;vmin&quot;:
                this.type = &quot;length&quot;;
                break;

            case &quot;fr&quot;:
                this.type = &quot;grid&quot;;
                break;

            case &quot;deg&quot;:
            case &quot;rad&quot;:
            case &quot;grad&quot;:
            case &quot;turn&quot;:
                this.type = &quot;angle&quot;;
                break;

            case &quot;ms&quot;:
            case &quot;s&quot;:
                this.type = &quot;time&quot;;
                break;

            case &quot;hz&quot;:
            case &quot;khz&quot;:
                this.type = &quot;frequency&quot;;
                break;

            case &quot;dpi&quot;:
            case &quot;dpcm&quot;:
                this.type = &quot;resolution&quot;;
                break;

        }

    } else if (/^([+-]?[\d.]+)%$/i.test(text)) {  // percentage
        this.type = &quot;percentage&quot;;
        this.value = Number(RegExp.$1);
    } else if (/^([+-]?\d+)$/i.test(text)) {  // integer
        this.type = &quot;integer&quot;;
        this.value = Number(RegExp.$1);
    } else if (/^([+-]?[\d.]+)$/i.test(text)) {  // number
        this.type = &quot;number&quot;;
        this.value = Number(RegExp.$1);

    } else if (/^#([a-f0-9]{3,6})/i.test(text)) {  // hexcolor
        this.type = &quot;color&quot;;
        temp = RegExp.$1;
        if (temp.length === 3) {
            this.red    = parseInt(temp.charAt(0) + temp.charAt(0), 16);
            this.green  = parseInt(temp.charAt(1) + temp.charAt(1), 16);
            this.blue   = parseInt(temp.charAt(2) + temp.charAt(2), 16);
        } else {
            this.red    = parseInt(temp.substring(0, 2), 16);
            this.green  = parseInt(temp.substring(2, 4), 16);
            this.blue   = parseInt(temp.substring(4, 6), 16);
        }
    } else if (/^rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i.test(text)) { // rgb() color with absolute numbers
        this.type   = &quot;color&quot;;
        this.red    = Number(RegExp.$1);
        this.green  = Number(RegExp.$2);
        this.blue   = Number(RegExp.$3);
    } else if (/^rgb\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)) { // rgb() color with percentages
        this.type   = &quot;color&quot;;
        this.red    = Number(RegExp.$1) * 255 / 100;
        this.green  = Number(RegExp.$2) * 255 / 100;
        this.blue   = Number(RegExp.$3) * 255 / 100;
    } else if (/^rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/i.test(text)) { // rgba() color with absolute numbers
        this.type   = &quot;color&quot;;
        this.red    = Number(RegExp.$1);
        this.green  = Number(RegExp.$2);
        this.blue   = Number(RegExp.$3);
        this.alpha  = Number(RegExp.$4);
    } else if (/^rgba\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*([\d.]+)\s*\)/i.test(text)) { // rgba() color with percentages
        this.type   = &quot;color&quot;;
        this.red    = Number(RegExp.$1) * 255 / 100;
        this.green  = Number(RegExp.$2) * 255 / 100;
        this.blue   = Number(RegExp.$3) * 255 / 100;
        this.alpha  = Number(RegExp.$4);
    } else if (/^hsl\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)) { // hsl()
        this.type   = &quot;color&quot;;
        this.hue    = Number(RegExp.$1);
        this.saturation = Number(RegExp.$2) / 100;
        this.lightness  = Number(RegExp.$3) / 100;
    } else if (/^hsla\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*([\d.]+)\s*\)/i.test(text)) { // hsla() color with percentages
        this.type   = &quot;color&quot;;
        this.hue    = Number(RegExp.$1);
        this.saturation = Number(RegExp.$2) / 100;
        this.lightness  = Number(RegExp.$3) / 100;
        this.alpha  = Number(RegExp.$4);
    } else if (/^url\((&quot;([^\\&quot;]|\.)*&quot;)\)/i.test(text)) { // URI
        this.type   = &quot;uri&quot;;
        this.uri    = PropertyValuePart.parseString(RegExp.$1);
    } else if (/^([^(]+)\(/i.test(text)) {
        this.type   = &quot;function&quot;;
        this.name   = RegExp.$1;
        this.value  = text;
    } else if (/^&quot;([^\n\r\f\\&quot;]|\\\r\n|\\[^\r0-9a-f]|\\[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?)*&quot;/i.test(text)) {    // double-quoted string
        this.type   = &quot;string&quot;;
        this.value  = PropertyValuePart.parseString(text);
    } else if (/^&#039;([^\n\r\f\\&#039;]|\\\r\n|\\[^\r0-9a-f]|\\[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?)*&#039;/i.test(text)) {    // single-quoted string
        this.type   = &quot;string&quot;;
        this.value  = PropertyValuePart.parseString(text);
    } else if (Colors[text.toLowerCase()]) {  // named color
        this.type   = &quot;color&quot;;
        temp        = Colors[text.toLowerCase()].substring(1);
        this.red    = parseInt(temp.substring(0, 2), 16);
        this.green  = parseInt(temp.substring(2, 4), 16);
        this.blue   = parseInt(temp.substring(4, 6), 16);
    } else if (/^[,/]$/.test(text)) {
        this.type   = &quot;operator&quot;;
        this.value  = text;
    } else if (/^-?[a-z_\u00A0-\uFFFF][a-z0-9\-_\u00A0-\uFFFF]*$/i.test(text)) {
        this.type   = &quot;identifier&quot;;
        this.value  = text;
    }
    this.wasIdent = Boolean(hint.ident);

}

PropertyValuePart.prototype = new SyntaxUnit();
PropertyValuePart.prototype.constructor = PropertyValuePart;
PropertyValuePart.parseString = function(str) {
    str = str.slice(1, -1); // Strip surrounding single/double quotes
    var replacer = function(match, esc) {
        if (/^(\n|\r\n|\r|\f)$/.test(esc)) {
            return &quot;&quot;;
        }
        var m = /^[0-9a-f]{1,6}/i.exec(esc);
        if (m) {
            var codePoint = parseInt(m[0], 16);
            if (String.fromCodePoint) {
                return String.fromCodePoint(codePoint);
            } else {
                return String.fromCharCode(codePoint);
            }
        }
        return esc;
    };
    return str.replace(/\\(\r\n|[^\r0-9a-f]|[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?)/ig,
                       replacer);
};
PropertyValuePart.serializeString = function(value) {
    var replacer = function(match, c) {
        if (c === &quot;\&quot;&quot;) {
            return &quot;\\&quot; + c;
        }
        var cp = String.codePointAt ? String.codePointAt(0) :
            String.charCodeAt(0);
        return &quot;\\&quot; + cp.toString(16) + &quot; &quot;;
    };
    return &quot;\&quot;&quot; + value.replace(/[&quot;\r\n\f]/g, replacer) + &quot;\&quot;&quot;;
};
PropertyValuePart.fromToken = function(token) {
    var part = new PropertyValuePart(token.value, token.startLine, token.startCol, {
        ident: token.type === Tokens.IDENT
    });
    return part;
};

},{&quot;../util/SyntaxUnit&quot;:26,&quot;./Colors&quot;:1,&quot;./Parser&quot;:6,&quot;./Tokens&quot;:18}],12:[function(require,module,exports){
&quot;use strict&quot;;

var Pseudos = module.exports = {
    __proto__:       null,
    &quot;:first-letter&quot;: 1,
    &quot;:first-line&quot;:   1,
    &quot;:before&quot;:       1,
    &quot;:after&quot;:        1
};

Pseudos.ELEMENT = 1;
Pseudos.CLASS = 2;

Pseudos.isElement = function(pseudo) {
    return pseudo.indexOf(&quot;::&quot;) === 0 || Pseudos[pseudo.toLowerCase()] === Pseudos.ELEMENT;
};

},{}],13:[function(require,module,exports){
&quot;use strict&quot;;

module.exports = Selector;

var SyntaxUnit = require(&quot;../util/SyntaxUnit&quot;);

var Parser = require(&quot;./Parser&quot;);
var Specificity = require(&quot;./Specificity&quot;);
function Selector(parts, line, col) {

    SyntaxUnit.call(this, parts.join(&quot; &quot;), line, col, Parser.SELECTOR_TYPE);
    this.parts = parts;
    this.specificity = Specificity.calculate(this);

}

Selector.prototype = new SyntaxUnit();
Selector.prototype.constructor = Selector;


},{&quot;../util/SyntaxUnit&quot;:26,&quot;./Parser&quot;:6,&quot;./Specificity&quot;:16}],14:[function(require,module,exports){
&quot;use strict&quot;;

module.exports = SelectorPart;

var SyntaxUnit = require(&quot;../util/SyntaxUnit&quot;);

var Parser = require(&quot;./Parser&quot;);
function SelectorPart(elementName, modifiers, text, line, col) {

    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_PART_TYPE);
    this.elementName = elementName;
    this.modifiers = modifiers;

}

SelectorPart.prototype = new SyntaxUnit();
SelectorPart.prototype.constructor = SelectorPart;


},{&quot;../util/SyntaxUnit&quot;:26,&quot;./Parser&quot;:6}],15:[function(require,module,exports){
&quot;use strict&quot;;

module.exports = SelectorSubPart;

var SyntaxUnit = require(&quot;../util/SyntaxUnit&quot;);

var Parser = require(&quot;./Parser&quot;);
function SelectorSubPart(text, type, line, col) {

    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_SUB_PART_TYPE);
    this.type = type;
    this.args = [];

}

SelectorSubPart.prototype = new SyntaxUnit();
SelectorSubPart.prototype.constructor = SelectorSubPart;


},{&quot;../util/SyntaxUnit&quot;:26,&quot;./Parser&quot;:6}],16:[function(require,module,exports){
&quot;use strict&quot;;

module.exports = Specificity;

var Pseudos = require(&quot;./Pseudos&quot;);
var SelectorPart = require(&quot;./SelectorPart&quot;);
function Specificity(a, b, c, d) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
}

Specificity.prototype = {
    constructor: Specificity,
    compare: function(other) {
        var comps = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;],
            i, len;

        for (i = 0, len = comps.length; i &lt; len; i++) {
            if (this[comps[i]] &lt; other[comps[i]]) {
                return -1;
            } else if (this[comps[i]] &gt; other[comps[i]]) {
                return 1;
            }
        }

        return 0;
    },
    valueOf: function() {
        return (this.a * 1000) + (this.b * 100) + (this.c * 10) + this.d;
    },
    toString: function() {
        return this.a + &quot;,&quot; + this.b + &quot;,&quot; + this.c + &quot;,&quot; + this.d;
    }

};
Specificity.calculate = function(selector) {

    var i,
        len,
        part,
        b = 0,
        c = 0,
        d = 0;

    function updateValues(part) {

        var i, j, len, num,
            elementName = part.elementName ? part.elementName.text : &quot;&quot;,
            modifier;

        if (elementName &amp;&amp; elementName.charAt(elementName.length - 1) !== &quot;*&quot;) {
            d++;
        }

        for (i = 0, len = part.modifiers.length; i &lt; len; i++) {
            modifier = part.modifiers[i];
            switch (modifier.type) {
                case &quot;class&quot;:
                case &quot;attribute&quot;:
                    c++;
                    break;

                case &quot;id&quot;:
                    b++;
                    break;

                case &quot;pseudo&quot;:
                    if (Pseudos.isElement(modifier.text)) {
                        d++;
                    } else {
                        c++;
                    }
                    break;

                case &quot;not&quot;:
                    for (j = 0, num = modifier.args.length; j &lt; num; j++) {
                        updateValues(modifier.args[j]);
                    }
            }
        }
    }

    for (i = 0, len = selector.parts.length; i &lt; len; i++) {
        part = selector.parts[i];

        if (part instanceof SelectorPart) {
            updateValues(part);
        }
    }

    return new Specificity(0, b, c, d);
};

},{&quot;./Pseudos&quot;:12,&quot;./SelectorPart&quot;:14}],17:[function(require,module,exports){
&quot;use strict&quot;;

module.exports = TokenStream;

var TokenStreamBase = require(&quot;../util/TokenStreamBase&quot;);

var PropertyValuePart = require(&quot;./PropertyValuePart&quot;);
var Tokens = require(&quot;./Tokens&quot;);

var h = /^[0-9a-fA-F]$/,
    nonascii = /^[\u00A0-\uFFFF]$/,
    nl = /\n|\r\n|\r|\f/,
    whitespace = /\u0009|\u000a|\u000c|\u000d|\u0020/;


function isHexDigit(c) {
    return c != null &amp;&amp; h.test(c);
}

function isDigit(c) {
    return c != null &amp;&amp; /\d/.test(c);
}

function isWhitespace(c) {
    return c != null &amp;&amp; whitespace.test(c);
}

function isNewLine(c) {
    return c != null &amp;&amp; nl.test(c);
}

function isNameStart(c) {
    return c != null &amp;&amp; /[a-z_\u00A0-\uFFFF\\]/i.test(c);
}

function isNameChar(c) {
    return c != null &amp;&amp; (isNameStart(c) || /[0-9\-\\]/.test(c));
}

function isIdentStart(c) {
    return c != null &amp;&amp; (isNameStart(c) || /-\\/.test(c));
}

function mix(receiver, supplier) {
    for (var prop in supplier) {
        if (Object.prototype.hasOwnProperty.call(supplier, prop)) {
            receiver[prop] = supplier[prop];
        }
    }
    return receiver;
}

function wouldStartIdent(twoCodePoints) {
    return typeof twoCodePoints === &quot;string&quot; &amp;&amp;
        (twoCodePoints[0] === &quot;-&quot; &amp;&amp; isNameStart(twoCodePoints[1]) || isNameStart(twoCodePoints[0]));
}

function wouldStartUnsignedNumber(twoCodePoints) {
    return typeof twoCodePoints === &quot;string&quot; &amp;&amp;
        (isDigit(twoCodePoints[0]) || (twoCodePoints[0] === &quot;.&quot; &amp;&amp; isDigit(twoCodePoints[1])));
}
function TokenStream(input) {
    TokenStreamBase.call(this, input, Tokens);
}

TokenStream.prototype = mix(new TokenStreamBase(), {
    _getToken: function() {

        var c,
            reader = this._reader,
            token   = null,
            startLine   = reader.getLine(),
            startCol    = reader.getCol();

        c = reader.read();

        while (c) {
            switch (c) {
                case &quot;/&quot;:

                    if (reader.peek() === &quot;*&quot;) {
                        token = this.commentToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;
                case &quot;|&quot;:
                case &quot;~&quot;:
                case &quot;^&quot;:
                case &quot;$&quot;:
                case &quot;*&quot;:
                    if (reader.peek() === &quot;=&quot;) {
                        token = this.comparisonToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;
                case &quot;\&quot;&quot;:
                case &quot;&#039;&quot;:
                    token = this.stringToken(c, startLine, startCol);
                    break;
                case &quot;#&quot;:
                    if (isNameChar(reader.peek())) {
                        token = this.hashToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;
                case &quot;.&quot;:
                    if (isDigit(reader.peek())) {
                        token = this.numberToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;
                case &quot;-&quot;:
                    if (wouldStartUnsignedNumber(reader.peekCount(2))) {
                        token = this.numberToken(c, startLine, startCol);
                        break;
                    } else if (reader.peekCount(2) === &quot;-&gt;&quot;) {
                        token = this.htmlCommentEndToken(c, startLine, startCol);
                    } else {
                        token = this._getDefaultToken(c, startLine, startCol);
                    }
                    break;
                case &quot;+&quot;:
                    if (wouldStartUnsignedNumber(reader.peekCount(2))) {
                        token = this.numberToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;
                case &quot;!&quot;:
                    token = this.importantToken(c, startLine, startCol);
                    break;
                case &quot;@&quot;:
                    token = this.atRuleToken(c, startLine, startCol);
                    break;
                case &quot;:&quot;:
                    token = this.notToken(c, startLine, startCol);
                    break;
                case &quot;&lt;&quot;:
                    token = this.htmlCommentStartToken(c, startLine, startCol);
                    break;
                case &quot;\\&quot;:
                    if (/[^\r\n\f]/.test(reader.peek())) {
                        token = this.identOrFunctionToken(this.readEscape(c, true), startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;
                case &quot;U&quot;:
                case &quot;u&quot;:
                    if (reader.peek() === &quot;+&quot;) {
                        token = this.unicodeRangeToken(c, startLine, startCol);
                    } else {
                        token = this._getDefaultToken(c, startLine, startCol);
                    }
                    break;

                default:
                    token = this._getDefaultToken(c, startLine, startCol);

            }
            break;
        }

        if (!token &amp;&amp; c === null) {
            token = this.createToken(Tokens.EOF, null, startLine, startCol);
        }

        return token;
    },
    _getDefaultToken: function(c, startLine, startCol) {
        var reader = this._reader,
            token   = null;

        if (isDigit(c)) {
            token = this.numberToken(c, startLine, startCol);
        } else
        if (isWhitespace(c)) {
            token = this.whitespaceToken(c, startLine, startCol);
        } else
        if (wouldStartIdent(c + reader.peekCount(1))) {
            token = this.identOrFunctionToken(c, startLine, startCol);
        } else {
            token = this.charToken(c, startLine, startCol);
        }

        return token;
    },
    createToken: function(tt, value, startLine, startCol, options) {
        var reader = this._reader;
        options = options || {};

        return {
            value:      value,
            type:       tt,
            channel:    options.channel,
            endChar:    options.endChar,
            hide:       options.hide || false,
            startLine:  startLine,
            startCol:   startCol,
            endLine:    reader.getLine(),
            endCol:     reader.getCol()
        };
    },
    atRuleToken: function(first, startLine, startCol) {
        var rule    = first,
            reader  = this._reader,
            tt      = Tokens.CHAR,
            ident;
        reader.mark();
        ident = this.readName();
        rule = first + ident;
        tt = Tokens.type(rule.toLowerCase());
        if (tt === Tokens.CHAR || tt === Tokens.UNKNOWN) {
            if (rule.length &gt; 1) {
                tt = Tokens.UNKNOWN_SYM;
            } else {
                tt = Tokens.CHAR;
                rule = first;
                reader.reset();
            }
        }

        return this.createToken(tt, rule, startLine, startCol);
    },
    charToken: function(c, startLine, startCol) {
        var tt = Tokens.type(c);
        var opts = {};

        if (tt === -1) {
            tt = Tokens.CHAR;
        } else {
            opts.endChar = Tokens[tt].endChar;
        }

        return this.createToken(tt, c, startLine, startCol, opts);
    },
    commentToken: function(first, startLine, startCol) {
        var comment = this.readComment(first);

        return this.createToken(Tokens.COMMENT, comment, startLine, startCol);
    },
    comparisonToken: function(c, startLine, startCol) {
        var reader  = this._reader,
            comparison  = c + reader.read(),
            tt      = Tokens.type(comparison) || Tokens.CHAR;

        return this.createToken(tt, comparison, startLine, startCol);
    },
    hashToken: function(first, startLine, startCol) {
        var name    = this.readName(first);

        return this.createToken(Tokens.HASH, name, startLine, startCol);
    },
    htmlCommentStartToken: function(first, startLine, startCol) {
        var reader      = this._reader,
            text        = first;

        reader.mark();
        text += reader.readCount(3);

        if (text === &quot;&lt;!--&quot;) {
            return this.createToken(Tokens.CDO, text, startLine, startCol);
        } else {
            reader.reset();
            return this.charToken(first, startLine, startCol);
        }
    },
    htmlCommentEndToken: function(first, startLine, startCol) {
        var reader      = this._reader,
            text        = first;

        reader.mark();
        text += reader.readCount(2);

        if (text === &quot;--&gt;&quot;) {
            return this.createToken(Tokens.CDC, text, startLine, startCol);
        } else {
            reader.reset();
            return this.charToken(first, startLine, startCol);
        }
    },
    identOrFunctionToken: function(first, startLine, startCol) {
        var reader  = this._reader,
            ident   = this.readName(first),
            tt      = Tokens.IDENT,
            uriFns  = [&quot;url(&quot;, &quot;url-prefix(&quot;, &quot;domain(&quot;],
            uri;
        if (reader.peek() === &quot;(&quot;) {
            ident += reader.read();
            if (uriFns.indexOf(ident.toLowerCase()) &gt; -1) {
                reader.mark();
                uri = this.readURI(ident);
                if (uri === null) {
                    reader.reset();
                    tt = Tokens.FUNCTION;
                } else {
                    tt = Tokens.URI;
                    ident = uri;
                }
            } else {
                tt = Tokens.FUNCTION;
            }
        } else if (reader.peek() === &quot;:&quot;) {  // might be an IE function
            if (ident.toLowerCase() === &quot;progid&quot;) {
                ident += reader.readTo(&quot;(&quot;);
                tt = Tokens.IE_FUNCTION;
            }
        }

        return this.createToken(tt, ident, startLine, startCol);
    },
    importantToken: function(first, startLine, startCol) {
        var reader      = this._reader,
            important   = first,
            tt          = Tokens.CHAR,
            temp,
            c;

        reader.mark();
        c = reader.read();

        while (c) {
            if (c === &quot;/&quot;) {
                if (reader.peek() !== &quot;*&quot;) {
                    break;
                } else {
                    temp = this.readComment(c);
                    if (temp === &quot;&quot;) {    // broken!
                        break;
                    }
                }
            } else if (isWhitespace(c)) {
                important += c + this.readWhitespace();
            } else if (/i/i.test(c)) {
                temp = reader.readCount(8);
                if (/mportant/i.test(temp)) {
                    important += c + temp;
                    tt = Tokens.IMPORTANT_SYM;

                }
                break;  // we&#039;re done
            } else {
                break;
            }

            c = reader.read();
        }

        if (tt === Tokens.CHAR) {
            reader.reset();
            return this.charToken(first, startLine, startCol);
        } else {
            return this.createToken(tt, important, startLine, startCol);
        }


    },
    notToken: function(first, startLine, startCol) {
        var reader      = this._reader,
            text        = first;

        reader.mark();
        text += reader.readCount(4);

        if (text.toLowerCase() === &quot;:not(&quot;) {
            return this.createToken(Tokens.NOT, text, startLine, startCol);
        } else {
            reader.reset();
            return this.charToken(first, startLine, startCol);
        }
    },
    numberToken: function(first, startLine, startCol) {
        var reader  = this._reader,
            value   = this.readNumber(first),
            ident,
            tt      = Tokens.NUMBER,
            c       = reader.peek();

        if (isIdentStart(c)) {
            ident = this.readName(reader.read());
            value += ident;

            if (/^em$|^ex$|^px$|^gd$|^rem$|^vw$|^vh$|^fr$|^vmax$|^vmin$|^ch$|^cm$|^mm$|^in$|^pt$|^pc$/i.test(ident)) {
                tt = Tokens.LENGTH;
            } else if (/^deg|^rad$|^grad$|^turn$/i.test(ident)) {
                tt = Tokens.ANGLE;
            } else if (/^ms$|^s$/i.test(ident)) {
                tt = Tokens.TIME;
            } else if (/^hz$|^khz$/i.test(ident)) {
                tt = Tokens.FREQ;
            } else if (/^dpi$|^dpcm$/i.test(ident)) {
                tt = Tokens.RESOLUTION;
            } else {
                tt = Tokens.DIMENSION;
            }

        } else if (c === &quot;%&quot;) {
            value += reader.read();
            tt = Tokens.PERCENTAGE;
        }

        return this.createToken(tt, value, startLine, startCol);
    },
    stringToken: function(first, startLine, startCol) {
        var delim   = first,
            string  = first,
            reader  = this._reader,
            tt      = Tokens.STRING,
            c       = reader.read(),
            i;

        while (c) {
            string += c;

            if (c === &quot;\\&quot;) {
                c = reader.read();
                if (c === null) {
                    break;  // premature EOF after backslash
                } else if (/[^\r\n\f0-9a-f]/i.test(c)) {
                    string += c;
                } else {
                    for (i = 0; isHexDigit(c) &amp;&amp; i &lt; 6; i++) {
                        string += c;
                        c = reader.read();
                    }
                    if (c === &quot;\r&quot; &amp;&amp; reader.peek() === &quot;\n&quot;) {
                        string += c;
                        c = reader.read();
                    }
                    if (isWhitespace(c)) {
                        string += c;
                    } else {
                        continue;
                    }
                }
            } else if (c === delim) {
                break; // delimiter found.
            } else if (isNewLine(reader.peek())) {
                tt = Tokens.INVALID;
                break;
            }
            c = reader.read();
        }
        if (c === null) {
            tt = Tokens.INVALID;
        }

        return this.createToken(tt, string, startLine, startCol);
    },

    unicodeRangeToken: function(first, startLine, startCol) {
        var reader  = this._reader,
            value   = first,
            temp,
            tt      = Tokens.CHAR;
        if (reader.peek() === &quot;+&quot;) {
            reader.mark();
            value += reader.read();
            value += this.readUnicodeRangePart(true);
            if (value.length === 2) {
                reader.reset();
            } else {

                tt = Tokens.UNICODE_RANGE;
                if (value.indexOf(&quot;?&quot;) === -1) {

                    if (reader.peek() === &quot;-&quot;) {
                        reader.mark();
                        temp = reader.read();
                        temp += this.readUnicodeRangePart(false);
                        if (temp.length === 1) {
                            reader.reset();
                        } else {
                            value += temp;
                        }
                    }

                }
            }
        }

        return this.createToken(tt, value, startLine, startCol);
    },
    whitespaceToken: function(first, startLine, startCol) {
        var value   = first + this.readWhitespace();
        return this.createToken(Tokens.S, value, startLine, startCol);
    },

    readUnicodeRangePart: function(allowQuestionMark) {
        var reader  = this._reader,
            part = &quot;&quot;,
            c       = reader.peek();
        while (isHexDigit(c) &amp;&amp; part.length &lt; 6) {
            reader.read();
            part += c;
            c = reader.peek();
        }
        if (allowQuestionMark) {
            while (c === &quot;?&quot; &amp;&amp; part.length &lt; 6) {
                reader.read();
                part += c;
                c = reader.peek();
            }
        }

        return part;
    },

    readWhitespace: function() {
        var reader  = this._reader,
            whitespace = &quot;&quot;,
            c       = reader.peek();

        while (isWhitespace(c)) {
            reader.read();
            whitespace += c;
            c = reader.peek();
        }

        return whitespace;
    },
    readNumber: function(first) {
        var reader  = this._reader,
            number  = first,
            hasDot  = first === &quot;.&quot;,
            c       = reader.peek();


        while (c) {
            if (isDigit(c)) {
                number += reader.read();
            } else if (c === &quot;.&quot;) {
                if (hasDot) {
                    break;
                } else {
                    hasDot = true;
                    number += reader.read();
                }
            } else {
                break;
            }

            c = reader.peek();
        }

        return number;
    },
    readString: function() {
        var token = this.stringToken(this._reader.read(), 0, 0);
        return token.type === Tokens.INVALID ? null : token.value;
    },
    readURI: function(first) {
        var reader  = this._reader,
            uri     = first,
            inner   = &quot;&quot;,
            c       = reader.peek();
        while (c &amp;&amp; isWhitespace(c)) {
            reader.read();
            c = reader.peek();
        }
        if (c === &quot;&#039;&quot; || c === &quot;\&quot;&quot;) {
            inner = this.readString();
            if (inner !== null) {
                inner = PropertyValuePart.parseString(inner);
            }
        } else {
            inner = this.readUnquotedURL();
        }

        c = reader.peek();
        while (c &amp;&amp; isWhitespace(c)) {
            reader.read();
            c = reader.peek();
        }
        if (inner === null || c !== &quot;)&quot;) {
            uri = null;
        } else {
            uri += PropertyValuePart.serializeString(inner) + reader.read();
        }

        return uri;
    },
    readUnquotedURL: function(first) {
        var reader  = this._reader,
            url     = first || &quot;&quot;,
            c;

        for (c = reader.peek(); c; c = reader.peek()) {
            if (nonascii.test(c) || /^[-!#$%&amp;*-[\]-~]$/.test(c)) {
                url += c;
                reader.read();
            } else if (c === &quot;\\&quot;) {
                if (/^[^\r\n\f]$/.test(reader.peek(2))) {
                    url += this.readEscape(reader.read(), true);
                } else {
                    break; // bad escape sequence.
                }
            } else {
                break; // bad character
            }
        }

        return url;
    },

    readName: function(first) {
        var reader  = this._reader,
            ident   = first || &quot;&quot;,
            c;

        for (c = reader.peek(); c; c = reader.peek()) {
            if (c === &quot;\\&quot;) {
                if (/^[^\r\n\f]$/.test(reader.peek(2))) {
                    ident += this.readEscape(reader.read(), true);
                } else {
                    break;
                }
            } else if (isNameChar(c)) {
                ident += reader.read();
            } else {
                break;
            }
        }

        return ident;
    },

    readEscape: function(first, unescape) {
        var reader  = this._reader,
            cssEscape = first || &quot;&quot;,
            i       = 0,
            c       = reader.peek();

        if (isHexDigit(c)) {
            do {
                cssEscape += reader.read();
                c = reader.peek();
            } while (c &amp;&amp; isHexDigit(c) &amp;&amp; ++i &lt; 6);
        }

        if (cssEscape.length === 1) {
            if (/^[^\r\n\f0-9a-f]$/.test(c)) {
                reader.read();
                if (unescape) {
                    return c;
                }
            } else {
                throw new Error(&quot;Bad escape sequence.&quot;);
            }
        } else if (c === &quot;\r&quot;) {
            reader.read();
            if (reader.peek() === &quot;\n&quot;) {
                c += reader.read();
            }
        } else if (/^[ \t\n\f]$/.test(c)) {
            reader.read();
        } else {
            c = &quot;&quot;;
        }

        if (unescape) {
            var cp = parseInt(cssEscape.slice(first.length), 16);
            return String.fromCodePoint ? String.fromCodePoint(cp) :
                String.fromCharCode(cp);
        }
        return cssEscape + c;
    },

    readComment: function(first) {
        var reader  = this._reader,
            comment = first || &quot;&quot;,
            c       = reader.read();

        if (c === &quot;*&quot;) {
            while (c) {
                comment += c;
                if (comment.length &gt; 2 &amp;&amp; c === &quot;*&quot; &amp;&amp; reader.peek() === &quot;/&quot;) {
                    comment += reader.read();
                    break;
                }

                c = reader.read();
            }

            return comment;
        } else {
            return &quot;&quot;;
        }

    }
});

},{&quot;../util/TokenStreamBase&quot;:27,&quot;./PropertyValuePart&quot;:11,&quot;./Tokens&quot;:18}],18:[function(require,module,exports){
&quot;use strict&quot;;

var Tokens = module.exports = [
    { name: &quot;CDO&quot; },
    { name: &quot;CDC&quot; },
    { name: &quot;S&quot;, whitespace: true/*, channel: &quot;ws&quot;*/ },
    { name: &quot;COMMENT&quot;, comment: true, hide: true, channel: &quot;comment&quot; },
    { name: &quot;INCLUDES&quot;, text: &quot;~=&quot; },
    { name: &quot;DASHMATCH&quot;, text: &quot;|=&quot; },
    { name: &quot;PREFIXMATCH&quot;, text: &quot;^=&quot; },
    { name: &quot;SUFFIXMATCH&quot;, text: &quot;$=&quot; },
    { name: &quot;SUBSTRINGMATCH&quot;, text: &quot;*=&quot; },
    { name: &quot;STRING&quot; },
    { name: &quot;IDENT&quot; },
    { name: &quot;HASH&quot; },
    { name: &quot;IMPORT_SYM&quot;, text: &quot;@import&quot; },
    { name: &quot;PAGE_SYM&quot;, text: &quot;@page&quot; },
    { name: &quot;MEDIA_SYM&quot;, text: &quot;@media&quot; },
    { name: &quot;FONT_FACE_SYM&quot;, text: &quot;@font-face&quot; },
    { name: &quot;CHARSET_SYM&quot;, text: &quot;@charset&quot; },
    { name: &quot;NAMESPACE_SYM&quot;, text: &quot;@namespace&quot; },
    { name: &quot;SUPPORTS_SYM&quot;, text: &quot;@supports&quot; },
    { name: &quot;VIEWPORT_SYM&quot;, text: [&quot;@viewport&quot;, &quot;@-ms-viewport&quot;, &quot;@-o-viewport&quot;] },
    { name: &quot;DOCUMENT_SYM&quot;, text: [&quot;@document&quot;, &quot;@-moz-document&quot;] },
    { name: &quot;UNKNOWN_SYM&quot; },
    { name: &quot;KEYFRAMES_SYM&quot;, text: [ &quot;@keyframes&quot;, &quot;@-webkit-keyframes&quot;, &quot;@-moz-keyframes&quot;, &quot;@-o-keyframes&quot; ] },
    { name: &quot;IMPORTANT_SYM&quot; },
    { name: &quot;LENGTH&quot; },
    { name: &quot;ANGLE&quot; },
    { name: &quot;TIME&quot; },
    { name: &quot;FREQ&quot; },
    { name: &quot;DIMENSION&quot; },
    { name: &quot;PERCENTAGE&quot; },
    { name: &quot;NUMBER&quot; },
    { name: &quot;URI&quot; },
    { name: &quot;FUNCTION&quot; },
    { name: &quot;UNICODE_RANGE&quot; },
    { name: &quot;INVALID&quot; },
    { name: &quot;PLUS&quot;, text: &quot;+&quot; },
    { name: &quot;GREATER&quot;, text: &quot;&gt;&quot; },
    { name: &quot;COMMA&quot;, text: &quot;,&quot; },
    { name: &quot;TILDE&quot;, text: &quot;~&quot; },
    { name: &quot;NOT&quot; },
    { name: &quot;TOPLEFTCORNER_SYM&quot;, text: &quot;@top-left-corner&quot; },
    { name: &quot;TOPLEFT_SYM&quot;, text: &quot;@top-left&quot; },
    { name: &quot;TOPCENTER_SYM&quot;, text: &quot;@top-center&quot; },
    { name: &quot;TOPRIGHT_SYM&quot;, text: &quot;@top-right&quot; },
    { name: &quot;TOPRIGHTCORNER_SYM&quot;, text: &quot;@top-right-corner&quot; },
    { name: &quot;BOTTOMLEFTCORNER_SYM&quot;, text: &quot;@bottom-left-corner&quot; },
    { name: &quot;BOTTOMLEFT_SYM&quot;, text: &quot;@bottom-left&quot; },
    { name: &quot;BOTTOMCENTER_SYM&quot;, text: &quot;@bottom-center&quot; },
    { name: &quot;BOTTOMRIGHT_SYM&quot;, text: &quot;@bottom-right&quot; },
    { name: &quot;BOTTOMRIGHTCORNER_SYM&quot;, text: &quot;@bottom-right-corner&quot; },
    { name: &quot;LEFTTOP_SYM&quot;, text: &quot;@left-top&quot; },
    { name: &quot;LEFTMIDDLE_SYM&quot;, text: &quot;@left-middle&quot; },
    { name: &quot;LEFTBOTTOM_SYM&quot;, text: &quot;@left-bottom&quot; },
    { name: &quot;RIGHTTOP_SYM&quot;, text: &quot;@right-top&quot; },
    { name: &quot;RIGHTMIDDLE_SYM&quot;, text: &quot;@right-middle&quot; },
    { name: &quot;RIGHTBOTTOM_SYM&quot;, text: &quot;@right-bottom&quot; },
    { name: &quot;RESOLUTION&quot;, state: &quot;media&quot; },
    { name: &quot;IE_FUNCTION&quot; },
    { name: &quot;CHAR&quot; },
    {
        name: &quot;PIPE&quot;,
        text: &quot;|&quot;
    },
    {
        name: &quot;SLASH&quot;,
        text: &quot;/&quot;
    },
    {
        name: &quot;MINUS&quot;,
        text: &quot;-&quot;
    },
    {
        name: &quot;STAR&quot;,
        text: &quot;*&quot;
    },

    {
        name: &quot;LBRACE&quot;,
        endChar: &quot;}&quot;,
        text: &quot;{&quot;
    },
    {
        name: &quot;RBRACE&quot;,
        text: &quot;}&quot;
    },
    {
        name: &quot;LBRACKET&quot;,
        endChar: &quot;]&quot;,
        text: &quot;[&quot;
    },
    {
        name: &quot;RBRACKET&quot;,
        text: &quot;]&quot;
    },
    {
        name: &quot;EQUALS&quot;,
        text: &quot;=&quot;
    },
    {
        name: &quot;COLON&quot;,
        text: &quot;:&quot;
    },
    {
        name: &quot;SEMICOLON&quot;,
        text: &quot;;&quot;
    },
    {
        name: &quot;LPAREN&quot;,
        endChar: &quot;)&quot;,
        text: &quot;(&quot;
    },
    {
        name: &quot;RPAREN&quot;,
        text: &quot;)&quot;
    },
    {
        name: &quot;DOT&quot;,
        text: &quot;.&quot;
    }
];

(function() {
    var nameMap = [],
        typeMap = Object.create(null);

    Tokens.UNKNOWN = -1;
    Tokens.unshift({ name:&quot;EOF&quot; });
    for (var i = 0, len = Tokens.length; i &lt; len; i++) {
        nameMap.push(Tokens[i].name);
        Tokens[Tokens[i].name] = i;
        if (Tokens[i].text) {
            if (Tokens[i].text instanceof Array) {
                for (var j = 0; j &lt; Tokens[i].text.length; j++) {
                    typeMap[Tokens[i].text[j]] = i;
                }
            } else {
                typeMap[Tokens[i].text] = i;
            }
        }
    }

    Tokens.name = function(tt) {
        return nameMap[tt];
    };

    Tokens.type = function(c) {
        return typeMap[c] || -1;
    };
})();

},{}],19:[function(require,module,exports){

&quot;use strict&quot;;

var Matcher = require(&quot;./Matcher&quot;);
var Properties = require(&quot;./Properties&quot;);
var ValidationTypes = require(&quot;./ValidationTypes&quot;);
var ValidationError = require(&quot;./ValidationError&quot;);
var PropertyValueIterator = require(&quot;./PropertyValueIterator&quot;);

var Validation = module.exports = {

    validate: function(property, value) {
        var name        = property.toString().toLowerCase(),
            expression  = new PropertyValueIterator(value),
            spec        = Properties[name],
            part;

        if (!spec) {
            if (name.indexOf(&quot;-&quot;) !== 0) {    // vendor prefixed are ok
                throw new ValidationError(&quot;Unknown property &#039;&quot; + property + &quot;&#039;.&quot;, property.line, property.col);
            }
        } else if (typeof spec !== &quot;number&quot;) {
            if (ValidationTypes.isAny(expression, &quot;inherit | initial | unset&quot;)) {
                if (expression.hasNext()) {
                    part = expression.next();
                    throw new ValidationError(&quot;Expected end of value but found &#039;&quot; + part + &quot;&#039;.&quot;, part.line, part.col);
                }
                return;
            }
            this.singleProperty(spec, expression);

        }

    },

    singleProperty: function(types, expression) {

        var result      = false,
            value       = expression.value,
            part;

        result = Matcher.parse(types).match(expression);

        if (!result) {
            if (expression.hasNext() &amp;&amp; !expression.isFirst()) {
                part = expression.peek();
                throw new ValidationError(&quot;Expected end of value but found &#039;&quot; + part + &quot;&#039;.&quot;, part.line, part.col);
            } else {
                throw new ValidationError(&quot;Expected (&quot; + ValidationTypes.describe(types) + &quot;) but found &#039;&quot; + value + &quot;&#039;.&quot;, value.line, value.col);
            }
        } else if (expression.hasNext()) {
            part = expression.next();
            throw new ValidationError(&quot;Expected end of value but found &#039;&quot; + part + &quot;&#039;.&quot;, part.line, part.col);
        }

    }

};

},{&quot;./Matcher&quot;:3,&quot;./Properties&quot;:7,&quot;./PropertyValueIterator&quot;:10,&quot;./ValidationError&quot;:20,&quot;./ValidationTypes&quot;:21}],20:[function(require,module,exports){
&quot;use strict&quot;;

module.exports = ValidationError;
function ValidationError(message, line, col) {
    this.col = col;
    this.line = line;
    this.message = message;

}
ValidationError.prototype = new Error();

},{}],21:[function(require,module,exports){
&quot;use strict&quot;;

var ValidationTypes = module.exports;

var Matcher = require(&quot;./Matcher&quot;);

function copy(to, from) {
    Object.keys(from).forEach(function(prop) {
        to[prop] = from[prop];
    });
}
copy(ValidationTypes, {

    isLiteral: function (part, literals) {
        var text = part.text.toString().toLowerCase(),
            args = literals.split(&quot; | &quot;),
            i,
            len,
            found = false;

        for (i = 0, len = args.length; i &lt; len &amp;&amp; !found; i++) {
            if (args[i].charAt(0) === &quot;&lt;&quot;) {
                found = this.simple[args[i]](part);
            } else if (args[i].slice(-2) === &quot;()&quot;) {
                found = (part.type === &quot;function&quot; &amp;&amp;
                         part.name === args[i].slice(0, -2));
            } else if (text === args[i].toLowerCase()) {
                found = true;
            }
        }

        return found;
    },

    isSimple: function(type) {
        return Boolean(this.simple[type]);
    },

    isComplex: function(type) {
        return Boolean(this.complex[type]);
    },

    describe: function(type) {
        if (this.complex[type] instanceof Matcher) {
            return this.complex[type].toString(0);
        }
        return type;
    },
    isAny: function (expression, types) {
        var args = types.split(&quot; | &quot;),
            i,
            len,
            found = false;

        for (i = 0, len = args.length; i &lt; len &amp;&amp; !found &amp;&amp; expression.hasNext(); i++) {
            found = this.isType(expression, args[i]);
        }

        return found;
    },
    isAnyOfGroup: function(expression, types) {
        var args = types.split(&quot; || &quot;),
            i,
            len,
            found = false;

        for (i = 0, len = args.length; i &lt; len &amp;&amp; !found; i++) {
            found = this.isType(expression, args[i]);
        }

        return found ? args[i - 1] : false;
    },
    isType: function (expression, type) {
        var part = expression.peek(),
            result = false;

        if (type.charAt(0) !== &quot;&lt;&quot;) {
            result = this.isLiteral(part, type);
            if (result) {
                expression.next();
            }
        } else if (this.simple[type]) {
            result = this.simple[type](part);
            if (result) {
                expression.next();
            }
        } else if (this.complex[type] instanceof Matcher) {
            result = this.complex[type].match(expression);
        } else {
            result = this.complex[type](expression);
        }

        return result;
    },


    simple: {
        __proto__: null,

        &quot;&lt;absolute-size&gt;&quot;:
            &quot;xx-small | x-small | small | medium | large | x-large | xx-large&quot;,

        &quot;&lt;animateable-feature&gt;&quot;:
            &quot;scroll-position | contents | &lt;animateable-feature-name&gt;&quot;,

        &quot;&lt;animateable-feature-name&gt;&quot;: function(part) {
            return this[&quot;&lt;ident&gt;&quot;](part) &amp;&amp;
                !/^(unset|initial|inherit|will-change|auto|scroll-position|contents)$/i.test(part);
        },

        &quot;&lt;angle&gt;&quot;: function(part) {
            return part.type === &quot;angle&quot;;
        },

        &quot;&lt;attachment&gt;&quot;: &quot;scroll | fixed | local&quot;,

        &quot;&lt;attr&gt;&quot;: &quot;attr()&quot;,
        &quot;&lt;basic-shape&gt;&quot;: &quot;inset() | circle() | ellipse() | polygon()&quot;,

        &quot;&lt;bg-image&gt;&quot;: &quot;&lt;image&gt; | &lt;gradient&gt; | none&quot;,

        &quot;&lt;border-style&gt;&quot;:
            &quot;none | hidden | dotted | dashed | solid | double | groove | &quot; +
            &quot;ridge | inset | outset&quot;,

        &quot;&lt;border-width&gt;&quot;: &quot;&lt;length&gt; | thin | medium | thick&quot;,

        &quot;&lt;box&gt;&quot;: &quot;padding-box | border-box | content-box&quot;,

        &quot;&lt;clip-source&gt;&quot;: &quot;&lt;uri&gt;&quot;,

        &quot;&lt;color&gt;&quot;: function(part) {
            return part.type === &quot;color&quot; || String(part) === &quot;transparent&quot; || String(part) === &quot;currentColor&quot;;
        },
        &quot;&lt;color-svg&gt;&quot;: function(part) {
            return part.type === &quot;color&quot;;
        },

        &quot;&lt;content&gt;&quot;: &quot;content()&quot;,
        &quot;&lt;content-sizing&gt;&quot;:
            &quot;fill-available | -moz-available | -webkit-fill-available | &quot; +
            &quot;max-content | -moz-max-content | -webkit-max-content | &quot; +
            &quot;min-content | -moz-min-content | -webkit-min-content | &quot; +
            &quot;fit-content | -moz-fit-content | -webkit-fit-content&quot;,

        &quot;&lt;feature-tag-value&gt;&quot;: function(part) {
            return part.type === &quot;function&quot; &amp;&amp; /^[A-Z0-9]{4}$/i.test(part);
        },
        &quot;&lt;filter-function&gt;&quot;:
            &quot;blur() | brightness() | contrast() | custom() | &quot; +
            &quot;drop-shadow() | grayscale() | hue-rotate() | invert() | &quot; +
            &quot;opacity() | saturate() | sepia()&quot;,

        &quot;&lt;flex-basis&gt;&quot;: &quot;&lt;width&gt;&quot;,

        &quot;&lt;flex-direction&gt;&quot;: &quot;row | row-reverse | column | column-reverse&quot;,

        &quot;&lt;flex-grow&gt;&quot;: &quot;&lt;number&gt;&quot;,

        &quot;&lt;flex-shrink&gt;&quot;: &quot;&lt;number&gt;&quot;,

        &quot;&lt;flex-wrap&gt;&quot;: &quot;nowrap | wrap | wrap-reverse&quot;,

        &quot;&lt;font-size&gt;&quot;:
            &quot;&lt;absolute-size&gt; | &lt;relative-size&gt; | &lt;length&gt; | &lt;percentage&gt;&quot;,

        &quot;&lt;font-stretch&gt;&quot;:
            &quot;normal | ultra-condensed | extra-condensed | condensed | &quot; +
            &quot;semi-condensed | semi-expanded | expanded | extra-expanded | &quot; +
            &quot;ultra-expanded&quot;,

        &quot;&lt;font-style&gt;&quot;: &quot;normal | italic | oblique&quot;,

        &quot;&lt;font-variant-caps&gt;&quot;:
            &quot;small-caps | all-small-caps | petite-caps | all-petite-caps | &quot; +
            &quot;unicase | titling-caps&quot;,

        &quot;&lt;font-variant-css21&gt;&quot;: &quot;normal | small-caps&quot;,

        &quot;&lt;font-weight&gt;&quot;:
            &quot;normal | bold | bolder | lighter | &quot; +
            &quot;100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900&quot;,

        &quot;&lt;generic-family&gt;&quot;:
            &quot;serif | sans-serif | cursive | fantasy | monospace&quot;,

        &quot;&lt;geometry-box&gt;&quot;: &quot;&lt;shape-box&gt; | fill-box | stroke-box | view-box&quot;,

        &quot;&lt;glyph-angle&gt;&quot;: function(part) {
            return part.type === &quot;angle&quot; &amp;&amp; part.units === &quot;deg&quot;;
        },

        &quot;&lt;gradient&gt;&quot;: function(part) {
            return part.type === &quot;function&quot; &amp;&amp; /^(?:-(?:ms|moz|o|webkit)-)?(?:repeating-)?(?:radial-|linear-)?gradient/i.test(part);
        },

        &quot;&lt;icccolor&gt;&quot;:
            &quot;cielab() | cielch() | cielchab() | &quot; +
            &quot;icc-color() | icc-named-color()&quot;,
        &quot;&lt;ident&gt;&quot;: function(part) {
            return part.type === &quot;identifier&quot; || part.wasIdent;
        },

        &quot;&lt;ident-not-generic-family&gt;&quot;: function(part) {
            return this[&quot;&lt;ident&gt;&quot;](part) &amp;&amp; !this[&quot;&lt;generic-family&gt;&quot;](part);
        },

        &quot;&lt;image&gt;&quot;: &quot;&lt;uri&gt;&quot;,

        &quot;&lt;integer&gt;&quot;: function(part) {
            return part.type === &quot;integer&quot;;
        },

        &quot;&lt;length&gt;&quot;: function(part) {
            if (part.type === &quot;function&quot; &amp;&amp; /^(?:-(?:ms|moz|o|webkit)-)?calc/i.test(part)) {
                return true;
            } else {
                return part.type === &quot;length&quot; || part.type === &quot;number&quot; || part.type === &quot;integer&quot; || String(part) === &quot;0&quot;;
            }
        },

        &quot;&lt;line&gt;&quot;: function(part) {
            return part.type === &quot;integer&quot;;
        },

        &quot;&lt;line-height&gt;&quot;: &quot;&lt;number&gt; | &lt;length&gt; | &lt;percentage&gt; | normal&quot;,

        &quot;&lt;margin-width&gt;&quot;: &quot;&lt;length&gt; | &lt;percentage&gt; | auto&quot;,

        &quot;&lt;miterlimit&gt;&quot;: function(part) {
            return this[&quot;&lt;number&gt;&quot;](part) &amp;&amp; part.value &gt;= 1;
        },

        &quot;&lt;nonnegative-length-or-percentage&gt;&quot;: function(part) {
            return (this[&quot;&lt;length&gt;&quot;](part) || this[&quot;&lt;percentage&gt;&quot;](part)) &amp;&amp;
                (String(part) === &quot;0&quot; || part.type === &quot;function&quot; || (part.value) &gt;= 0);
        },

        &quot;&lt;nonnegative-number-or-percentage&gt;&quot;: function(part) {
            return (this[&quot;&lt;number&gt;&quot;](part) || this[&quot;&lt;percentage&gt;&quot;](part)) &amp;&amp;
                (String(part) === &quot;0&quot; || part.type === &quot;function&quot; || (part.value) &gt;= 0);
        },

        &quot;&lt;number&gt;&quot;: function(part) {
            return part.type === &quot;number&quot; || this[&quot;&lt;integer&gt;&quot;](part);
        },

        &quot;&lt;opacity-value&gt;&quot;: function(part) {
            return this[&quot;&lt;number&gt;&quot;](part) &amp;&amp; part.value &gt;= 0 &amp;&amp; part.value &lt;= 1;
        },

        &quot;&lt;padding-width&gt;&quot;: &quot;&lt;nonnegative-length-or-percentage&gt;&quot;,

        &quot;&lt;percentage&gt;&quot;: function(part) {
            return part.type === &quot;percentage&quot; || String(part) === &quot;0&quot;;
        },

        &quot;&lt;relative-size&gt;&quot;: &quot;smaller | larger&quot;,

        &quot;&lt;shape&gt;&quot;: &quot;rect() | inset-rect()&quot;,

        &quot;&lt;shape-box&gt;&quot;: &quot;&lt;box&gt; | margin-box&quot;,

        &quot;&lt;single-animation-direction&gt;&quot;:
            &quot;normal | reverse | alternate | alternate-reverse&quot;,

        &quot;&lt;single-animation-name&gt;&quot;: function(part) {
            return this[&quot;&lt;ident&gt;&quot;](part) &amp;&amp;
                /^-?[a-z_][-a-z0-9_]+$/i.test(part) &amp;&amp;
                !/^(none|unset|initial|inherit)$/i.test(part);
        },

        &quot;&lt;string&gt;&quot;: function(part) {
            return part.type === &quot;string&quot;;
        },

        &quot;&lt;time&gt;&quot;: function(part) {
            return part.type === &quot;time&quot;;
        },

        &quot;&lt;uri&gt;&quot;: function(part) {
            return part.type === &quot;uri&quot;;
        },

        &quot;&lt;width&gt;&quot;: &quot;&lt;margin-width&gt;&quot;
    },

    complex: {
        __proto__: null,

        &quot;&lt;azimuth&gt;&quot;:
            &quot;&lt;angle&gt;&quot; +
            &quot; | &quot; +
            &quot;[ [ left-side | far-left | left | center-left | center | &quot; +
            &quot;center-right | right | far-right | right-side ] || behind ]&quot; +
            &quot; | &quot; +
            &quot;leftwards | rightwards&quot;,

        &quot;&lt;bg-position&gt;&quot;: &quot;&lt;position&gt;#&quot;,

        &quot;&lt;bg-size&gt;&quot;:
            &quot;[ &lt;length&gt; | &lt;percentage&gt; | auto ]{1,2} | cover | contain&quot;,

        &quot;&lt;blend-mode&gt;&quot;:
            &quot;normal | multiply | screen | overlay | darken | lighten | color-dodge | &quot; +
            &quot;color-burn | hard-light | soft-light | difference | exclusion | hue | &quot; +
            &quot;saturation | color | luminosity&quot;,

        &quot;&lt;border-image-slice&gt;&quot;:
        Matcher.many([true /* first element is required */],
                     Matcher.cast(&quot;&lt;nonnegative-number-or-percentage&gt;&quot;),
                     Matcher.cast(&quot;&lt;nonnegative-number-or-percentage&gt;&quot;),
                     Matcher.cast(&quot;&lt;nonnegative-number-or-percentage&gt;&quot;),
                     Matcher.cast(&quot;&lt;nonnegative-number-or-percentage&gt;&quot;),
                     &quot;fill&quot;),

        &quot;&lt;border-radius&gt;&quot;:
            &quot;&lt;nonnegative-length-or-percentage&gt;{1,4} &quot; +
            &quot;[ / &lt;nonnegative-length-or-percentage&gt;{1,4} ]?&quot;,

        &quot;&lt;box-shadow&gt;&quot;: &quot;none | &lt;shadow&gt;#&quot;,

        &quot;&lt;clip-path&gt;&quot;: &quot;&lt;basic-shape&gt; || &lt;geometry-box&gt;&quot;,

        &quot;&lt;dasharray&gt;&quot;:
        Matcher.cast(&quot;&lt;nonnegative-length-or-percentage&gt;&quot;)
            .braces(1, Infinity, &quot;#&quot;, Matcher.cast(&quot;,&quot;).question()),

        &quot;&lt;family-name&gt;&quot;:
            &quot;&lt;string&gt; | &lt;ident-not-generic-family&gt; &lt;ident&gt;*&quot;,

        &quot;&lt;filter-function-list&gt;&quot;: &quot;[ &lt;filter-function&gt; | &lt;uri&gt; ]+&quot;,
        &quot;&lt;flex&gt;&quot;:
            &quot;none | [ &lt;flex-grow&gt; &lt;flex-shrink&gt;? || &lt;flex-basis&gt; ]&quot;,

        &quot;&lt;font-family&gt;&quot;: &quot;[ &lt;generic-family&gt; | &lt;family-name&gt; ]#&quot;,

        &quot;&lt;font-shorthand&gt;&quot;:
            &quot;[ &lt;font-style&gt; || &lt;font-variant-css21&gt; || &quot; +
            &quot;&lt;font-weight&gt; || &lt;font-stretch&gt; ]? &lt;font-size&gt; &quot; +
            &quot;[ / &lt;line-height&gt; ]? &lt;font-family&gt;&quot;,

        &quot;&lt;font-variant-alternates&gt;&quot;:
            &quot;stylistic() || &quot; +
            &quot;historical-forms || &quot; +
            &quot;styleset() || &quot; +
            &quot;character-variant() || &quot; +
            &quot;swash() || &quot; +
            &quot;ornaments() || &quot; +
            &quot;annotation()&quot;,

        &quot;&lt;font-variant-ligatures&gt;&quot;:
            &quot;[ common-ligatures | no-common-ligatures ] || &quot; +
            &quot;[ discretionary-ligatures | no-discretionary-ligatures ] || &quot; +
            &quot;[ historical-ligatures | no-historical-ligatures ] || &quot; +
            &quot;[ contextual | no-contextual ]&quot;,

        &quot;&lt;font-variant-numeric&gt;&quot;:
            &quot;[ lining-nums | oldstyle-nums ] || &quot; +
            &quot;[ proportional-nums | tabular-nums ] || &quot; +
            &quot;[ diagonal-fractions | stacked-fractions ] || &quot; +
            &quot;ordinal || slashed-zero&quot;,

        &quot;&lt;font-variant-east-asian&gt;&quot;:
            &quot;[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ] || &quot; +
            &quot;[ full-width | proportional-width ] || &quot; +
            &quot;ruby&quot;,
        &quot;&lt;paint&gt;&quot;: &quot;&lt;paint-basic&gt; | &lt;uri&gt; &lt;paint-basic&gt;?&quot;,
        &quot;&lt;paint-basic&gt;&quot;: &quot;none | currentColor | &lt;color-svg&gt; &lt;icccolor&gt;?&quot;,

        &quot;&lt;position&gt;&quot;:
            &quot;[ center | [ left | right ] [ &lt;percentage&gt; | &lt;length&gt; ]? ] &amp;&amp; &quot; +
            &quot;[ center | [ top | bottom ] [ &lt;percentage&gt; | &lt;length&gt; ]? ]&quot; +
            &quot; | &quot; +
            &quot;[ left | center | right | &lt;percentage&gt; | &lt;length&gt; ] &quot; +
            &quot;[ top | center | bottom | &lt;percentage&gt; | &lt;length&gt; ]&quot; +
            &quot; | &quot; +
            &quot;[ left | center | right | top | bottom | &lt;percentage&gt; | &lt;length&gt; ]&quot;,

        &quot;&lt;repeat-style&gt;&quot;:
            &quot;repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}&quot;,

        &quot;&lt;shadow&gt;&quot;:
        Matcher.many([true /* length is required */],
                     Matcher.cast(&quot;&lt;length&gt;&quot;).braces(2, 4), &quot;inset&quot;, &quot;&lt;color&gt;&quot;),

        &quot;&lt;text-decoration-color&gt;&quot;:
           &quot;&lt;color&gt;&quot;,

        &quot;&lt;text-decoration-line&gt;&quot;:
            &quot;none | [ underline || overline || line-through || blink ]&quot;,

        &quot;&lt;text-decoration-style&gt;&quot;:
            &quot;solid | double | dotted | dashed | wavy&quot;,

        &quot;&lt;will-change&gt;&quot;:
            &quot;auto | &lt;animateable-feature&gt;#&quot;,

        &quot;&lt;x-one-radius&gt;&quot;:
            &quot;[ &lt;length&gt; | &lt;percentage&gt; ]{1,2}&quot;
    }
});

Object.keys(ValidationTypes.simple).forEach(function(nt) {
    var rule = ValidationTypes.simple[nt];
    if (typeof rule === &quot;string&quot;) {
        ValidationTypes.simple[nt] = function(part) {
            return ValidationTypes.isLiteral(part, rule);
        };
    }
});

Object.keys(ValidationTypes.complex).forEach(function(nt) {
    var rule = ValidationTypes.complex[nt];
    if (typeof rule === &quot;string&quot;) {
        ValidationTypes.complex[nt] = Matcher.parse(rule);
    }
});
ValidationTypes.complex[&quot;&lt;font-variant&gt;&quot;] =
    Matcher.oror({ expand: &quot;&lt;font-variant-ligatures&gt;&quot; },
                 { expand: &quot;&lt;font-variant-alternates&gt;&quot; },
                 &quot;&lt;font-variant-caps&gt;&quot;,
                 { expand: &quot;&lt;font-variant-numeric&gt;&quot; },
                 { expand: &quot;&lt;font-variant-east-asian&gt;&quot; });

},{&quot;./Matcher&quot;:3}],22:[function(require,module,exports){
&quot;use strict&quot;;

module.exports = {
    Colors            : require(&quot;./Colors&quot;),
    Combinator        : require(&quot;./Combinator&quot;),
    Parser            : require(&quot;./Parser&quot;),
    PropertyName      : require(&quot;./PropertyName&quot;),
    PropertyValue     : require(&quot;./PropertyValue&quot;),
    PropertyValuePart : require(&quot;./PropertyValuePart&quot;),
    Matcher           : require(&quot;./Matcher&quot;),
    MediaFeature      : require(&quot;./MediaFeature&quot;),
    MediaQuery        : require(&quot;./MediaQuery&quot;),
    Selector          : require(&quot;./Selector&quot;),
    SelectorPart      : require(&quot;./SelectorPart&quot;),
    SelectorSubPart   : require(&quot;./SelectorSubPart&quot;),
    Specificity       : require(&quot;./Specificity&quot;),
    TokenStream       : require(&quot;./TokenStream&quot;),
    Tokens            : require(&quot;./Tokens&quot;),
    ValidationError   : require(&quot;./ValidationError&quot;)
};

},{&quot;./Colors&quot;:1,&quot;./Combinator&quot;:2,&quot;./Matcher&quot;:3,&quot;./MediaFeature&quot;:4,&quot;./MediaQuery&quot;:5,&quot;./Parser&quot;:6,&quot;./PropertyName&quot;:8,&quot;./PropertyValue&quot;:9,&quot;./PropertyValuePart&quot;:11,&quot;./Selector&quot;:13,&quot;./SelectorPart&quot;:14,&quot;./SelectorSubPart&quot;:15,&quot;./Specificity&quot;:16,&quot;./TokenStream&quot;:17,&quot;./Tokens&quot;:18,&quot;./ValidationError&quot;:20}],23:[function(require,module,exports){
&quot;use strict&quot;;

module.exports = EventTarget;
function EventTarget() {
    this._listeners = Object.create(null);
}

EventTarget.prototype = {
    constructor: EventTarget,
    addListener: function(type, listener) {
        if (!this._listeners[type]) {
            this._listeners[type] = [];
        }

        this._listeners[type].push(listener);
    },
    fire: function(event) {
        if (typeof event === &quot;string&quot;) {
            event = { type: event };
        }
        if (typeof event.target !== &quot;undefined&quot;) {
            event.target = this;
        }

        if (typeof event.type === &quot;undefined&quot;) {
            throw new Error(&quot;Event object missing &#039;type&#039; property.&quot;);
        }

        if (this._listeners[event.type]) {
            var listeners = this._listeners[event.type].concat();
            for (var i = 0, len = listeners.length; i &lt; len; i++) {
                listeners[i].call(this, event);
            }
        }
    },
    removeListener: function(type, listener) {
        if (this._listeners[type]) {
            var listeners = this._listeners[type];
            for (var i = 0, len = listeners.length; i &lt; len; i++) {
                if (listeners[i] === listener) {
                    listeners.splice(i, 1);
                    break;
                }
            }


        }
    }
};

},{}],24:[function(require,module,exports){
&quot;use strict&quot;;

module.exports = StringReader;
function StringReader(text) {
    this._input = text.replace(/(\r\n?|\n)/g, &quot;\n&quot;);
    this._line = 1;
    this._col = 1;
    this._cursor = 0;
}

StringReader.prototype = {
    constructor: StringReader,
    getCol: function() {
        return this._col;
    },
    getLine: function() {
        return this._line;
    },
    eof: function() {
        return this._cursor === this._input.length;
    },
    peek: function(count) {
        var c = null;
        count = typeof count === &quot;undefined&quot; ? 1 : count;
        if (this._cursor &lt; this._input.length) {
            c = this._input.charAt(this._cursor + count - 1);
        }

        return c;
    },
    read: function() {
        var c = null;
        if (this._cursor &lt; this._input.length) {
            if (this._input.charAt(this._cursor) === &quot;\n&quot;) {
                this._line++;
                this._col = 1;
            } else {
                this._col++;
            }
            c = this._input.charAt(this._cursor++);
        }

        return c;
    },
    mark: function() {
        this._bookmark = {
            cursor: this._cursor,
            line:   this._line,
            col:    this._col
        };
    },

    reset: function() {
        if (this._bookmark) {
            this._cursor = this._bookmark.cursor;
            this._line = this._bookmark.line;
            this._col = this._bookmark.col;
            delete this._bookmark;
        }
    },
    peekCount: function(count) {
        count = typeof count === &quot;undefined&quot; ? 1 : Math.max(count, 0);
        return this._input.substring(this._cursor, this._cursor + count);
    },
    readTo: function(pattern) {

        var buffer = &quot;&quot;,
            c;
        while (buffer.length &lt; pattern.length || buffer.lastIndexOf(pattern) !== buffer.length - pattern.length) {
            c = this.read();
            if (c) {
                buffer += c;
            } else {
                throw new Error(&quot;Expected \&quot;&quot; + pattern + &quot;\&quot; at line &quot; + this._line  + &quot;, col &quot; + this._col + &quot;.&quot;);
            }
        }

        return buffer;

    },
    readWhile: function(filter) {

        var buffer = &quot;&quot;,
            c = this.peek();

        while (c !== null &amp;&amp; filter(c)) {
            buffer += this.read();
            c = this.peek();
        }

        return buffer;

    },
    readMatch: function(matcher) {

        var source = this._input.substring(this._cursor),
            value = null;
        if (typeof matcher === &quot;string&quot;) {
            if (source.slice(0, matcher.length) === matcher) {
                value = this.readCount(matcher.length);
            }
        } else if (matcher instanceof RegExp) {
            if (matcher.test(source)) {
                value = this.readCount(RegExp.lastMatch.length);
            }
        }

        return value;
    },
    readCount: function(count) {
        var buffer = &quot;&quot;;

        while (count--) {
            buffer += this.read();
        }

        return buffer;
    }

};

},{}],25:[function(require,module,exports){
&quot;use strict&quot;;

module.exports = SyntaxError;
function SyntaxError(message, line, col) {
    Error.call(this);
    this.name = this.constructor.name;
    this.col = col;
    this.line = line;
    this.message = message;

}
SyntaxError.prototype = Object.create(Error.prototype); // jshint ignore:line
SyntaxError.prototype.constructor = SyntaxError; // jshint ignore:line

},{}],26:[function(require,module,exports){
&quot;use strict&quot;;

module.exports = SyntaxUnit;
function SyntaxUnit(text, line, col, type) {
    this.col = col;
    this.line = line;
    this.text = text;
    this.type = type;
}
SyntaxUnit.fromToken = function(token) {
    return new SyntaxUnit(token.value, token.startLine, token.startCol);
};

SyntaxUnit.prototype = {
    constructor: SyntaxUnit,
    valueOf: function() {
        return this.toString();
    },
    toString: function() {
        return this.text;
    }

};

},{}],27:[function(require,module,exports){
&quot;use strict&quot;;

module.exports = TokenStreamBase;

var StringReader = require(&quot;./StringReader&quot;);
var SyntaxError = require(&quot;./SyntaxError&quot;);
function TokenStreamBase(input, tokenData) {
    this._reader = new StringReader(input ? input.toString() : &quot;&quot;);
    this._token = null;
    this._tokenData = tokenData;
    this._lt = [];
    this._ltIndex = 0;

    this._ltIndexCache = [];
}
TokenStreamBase.createTokenData = function(tokens) {

    var nameMap     = [],
        typeMap     = Object.create(null),
        tokenData   = tokens.concat([]),
        i           = 0,
        len         = tokenData.length + 1;

    tokenData.UNKNOWN = -1;
    tokenData.unshift({ name:&quot;EOF&quot; });

    for (; i &lt; len; i++) {
        nameMap.push(tokenData[i].name);
        tokenData[tokenData[i].name] = i;
        if (tokenData[i].text) {
            typeMap[tokenData[i].text] = i;
        }
    }

    tokenData.name = function(tt) {
        return nameMap[tt];
    };

    tokenData.type = function(c) {
        return typeMap[c];
    };

    return tokenData;
};

TokenStreamBase.prototype = {
    constructor: TokenStreamBase,
    match: function(tokenTypes, channel) {
        if (!(tokenTypes instanceof Array)) {
            tokenTypes = [tokenTypes];
        }

        var tt  = this.get(channel),
            i   = 0,
            len = tokenTypes.length;

        while (i &lt; len) {
            if (tt === tokenTypes[i++]) {
                return true;
            }
        }
        this.unget();
        return false;
    },
    mustMatch: function(tokenTypes) {

        var token;
        if (!(tokenTypes instanceof Array)) {
            tokenTypes = [tokenTypes];
        }

        if (!this.match.apply(this, arguments)) {
            token = this.LT(1);
            throw new SyntaxError(&quot;Expected &quot; + this._tokenData[tokenTypes[0]].name +
                &quot; at line &quot; + token.startLine + &quot;, col &quot; + token.startCol + &quot;.&quot;, token.startLine, token.startCol);
        }
    },
    advance: function(tokenTypes, channel) {

        while (this.LA(0) !== 0 &amp;&amp; !this.match(tokenTypes, channel)) {
            this.get();
        }

        return this.LA(0);
    },
    get: function(channel) {

        var tokenInfo = this._tokenData,
            i         = 0,
            token,
            info;
        if (this._lt.length &amp;&amp; this._ltIndex &gt;= 0 &amp;&amp; this._ltIndex &lt; this._lt.length) {

            i++;
            this._token = this._lt[this._ltIndex++];
            info = tokenInfo[this._token.type];
            while ((typeof info.channel !== &quot;undefined&quot; &amp;&amp; channel !== info.channel) &amp;&amp;
                    this._ltIndex &lt; this._lt.length) {
                this._token = this._lt[this._ltIndex++];
                info = tokenInfo[this._token.type];
                i++;
            }
            if ((typeof info.channel === &quot;undefined&quot; || channel === info.channel) &amp;&amp;
                    this._ltIndex &lt;= this._lt.length) {
                this._ltIndexCache.push(i);
                return this._token.type;
            }
        }
        token = this._getToken();
        if (token.type &gt; -1 &amp;&amp; !tokenInfo[token.type].hide) {
            token.channel = tokenInfo[token.type].channel;
            this._token = token;
            this._lt.push(token);
            this._ltIndexCache.push(this._lt.length - this._ltIndex + i);
            if (this._lt.length &gt; 5) {
                this._lt.shift();
            }
            if (this._ltIndexCache.length &gt; 5) {
                this._ltIndexCache.shift();
            }
            this._ltIndex = this._lt.length;
        }
        info = tokenInfo[token.type];
        if (info &amp;&amp;
                (info.hide ||
                (typeof info.channel !== &quot;undefined&quot; &amp;&amp; channel !== info.channel))) {
            return this.get(channel);
        } else {
            return token.type;
        }
    },
    LA: function(index) {
        var total = index,
            tt;
        if (index &gt; 0) {
            if (index &gt; 5) {
                throw new Error(&quot;Too much lookahead.&quot;);
            }
            while (total) {
                tt = this.get();
                total--;
            }
            while (total &lt; index) {
                this.unget();
                total++;
            }
        } else if (index &lt; 0) {

            if (this._lt[this._ltIndex + index]) {
                tt = this._lt[this._ltIndex + index].type;
            } else {
                throw new Error(&quot;Too much lookbehind.&quot;);
            }

        } else {
            tt = this._token.type;
        }

        return tt;

    },
    LT: function(index) {
        this.LA(index);
        return this._lt[this._ltIndex + index - 1];
    },
    peek: function() {
        return this.LA(1);
    },
    token: function() {
        return this._token;
    },
    tokenName: function(tokenType) {
        if (tokenType &lt; 0 || tokenType &gt; this._tokenData.length) {
            return &quot;UNKNOWN_TOKEN&quot;;
        } else {
            return this._tokenData[tokenType].name;
        }
    },
    tokenType: function(tokenName) {
        return this._tokenData[tokenName] || -1;
    },
    unget: function() {
        if (this._ltIndexCache.length) {
            this._ltIndex -= this._ltIndexCache.pop();//--;
            this._token = this._lt[this._ltIndex - 1];
        } else {
            throw new Error(&quot;Too much lookahead.&quot;);
        }
    }

};


},{&quot;./StringReader&quot;:24,&quot;./SyntaxError&quot;:25}],28:[function(require,module,exports){
&quot;use strict&quot;;

module.exports = {
    StringReader    : require(&quot;./StringReader&quot;),
    SyntaxError     : require(&quot;./SyntaxError&quot;),
    SyntaxUnit      : require(&quot;./SyntaxUnit&quot;),
    EventTarget     : require(&quot;./EventTarget&quot;),
    TokenStreamBase : require(&quot;./TokenStreamBase&quot;)
};

},{&quot;./EventTarget&quot;:23,&quot;./StringReader&quot;:24,&quot;./SyntaxError&quot;:25,&quot;./SyntaxUnit&quot;:26,&quot;./TokenStreamBase&quot;:27}],&quot;parserlib&quot;:[function(require,module,exports){
&quot;use strict&quot;;

module.exports = {
    css  : require(&quot;./css&quot;),
    util : require(&quot;./util&quot;)
};

},{&quot;./css&quot;:22,&quot;./util&quot;:28}]},{},[]);

return require(&#039;parserlib&#039;);
})();
var clone = (function() {
&#039;use strict&#039;;

function _instanceof(obj, type) {
  return type != null &amp;&amp; obj instanceof type;
}

var nativeMap;
try {
  nativeMap = Map;
} catch(_) {
  nativeMap = function() {};
}

var nativeSet;
try {
  nativeSet = Set;
} catch(_) {
  nativeSet = function() {};
}

var nativePromise;
try {
  nativePromise = Promise;
} catch(_) {
  nativePromise = function() {};
}
function clone(parent, circular, depth, prototype, includeNonEnumerable) {
  if (typeof circular === &#039;object&#039;) {
    depth = circular.depth;
    prototype = circular.prototype;
    includeNonEnumerable = circular.includeNonEnumerable;
    circular = circular.circular;
  }
  var allParents = [];
  var allChildren = [];

  var useBuffer = typeof Buffer != &#039;undefined&#039;;

  if (typeof circular == &#039;undefined&#039;)
    circular = true;

  if (typeof depth == &#039;undefined&#039;)
    depth = Infinity;
  function _clone(parent, depth) {
    if (parent === null)
      return null;

    if (depth === 0)
      return parent;

    var child;
    var proto;
    if (typeof parent != &#039;object&#039;) {
      return parent;
    }

    if (_instanceof(parent, nativeMap)) {
      child = new nativeMap();
    } else if (_instanceof(parent, nativeSet)) {
      child = new nativeSet();
    } else if (_instanceof(parent, nativePromise)) {
      child = new nativePromise(function (resolve, reject) {
        parent.then(function(value) {
          resolve(_clone(value, depth - 1));
        }, function(err) {
          reject(_clone(err, depth - 1));
        });
      });
    } else if (clone.__isArray(parent)) {
      child = [];
    } else if (clone.__isRegExp(parent)) {
      child = new RegExp(parent.source, __getRegExpFlags(parent));
      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
    } else if (clone.__isDate(parent)) {
      child = new Date(parent.getTime());
    } else if (useBuffer &amp;&amp; Buffer.isBuffer(parent)) {
      if (Buffer.allocUnsafe) {
        child = Buffer.allocUnsafe(parent.length);
      } else {
        child = new Buffer(parent.length);
      }
      parent.copy(child);
      return child;
    } else if (_instanceof(parent, Error)) {
      child = Object.create(parent);
    } else {
      if (typeof prototype == &#039;undefined&#039;) {
        proto = Object.getPrototypeOf(parent);
        child = Object.create(proto);
      }
      else {
        child = Object.create(prototype);
        proto = prototype;
      }
    }

    if (circular) {
      var index = allParents.indexOf(parent);

      if (index != -1) {
        return allChildren[index];
      }
      allParents.push(parent);
      allChildren.push(child);
    }

    if (_instanceof(parent, nativeMap)) {
      parent.forEach(function(value, key) {
        var keyChild = _clone(key, depth - 1);
        var valueChild = _clone(value, depth - 1);
        child.set(keyChild, valueChild);
      });
    }
    if (_instanceof(parent, nativeSet)) {
      parent.forEach(function(value) {
        var entryChild = _clone(value, depth - 1);
        child.add(entryChild);
      });
    }

    for (var i in parent) {
      var attrs;
      if (proto) {
        attrs = Object.getOwnPropertyDescriptor(proto, i);
      }

      if (attrs &amp;&amp; attrs.set == null) {
        continue;
      }
      child[i] = _clone(parent[i], depth - 1);
    }

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(parent);
      for (var i = 0; i &lt; symbols.length; i++) {
        var symbol = symbols[i];
        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);
        if (descriptor &amp;&amp; !descriptor.enumerable &amp;&amp; !includeNonEnumerable) {
          continue;
        }
        child[symbol] = _clone(parent[symbol], depth - 1);
        if (!descriptor.enumerable) {
          Object.defineProperty(child, symbol, {
            enumerable: false
          });
        }
      }
    }

    if (includeNonEnumerable) {
      var allPropertyNames = Object.getOwnPropertyNames(parent);
      for (var i = 0; i &lt; allPropertyNames.length; i++) {
        var propertyName = allPropertyNames[i];
        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);
        if (descriptor &amp;&amp; descriptor.enumerable) {
          continue;
        }
        child[propertyName] = _clone(parent[propertyName], depth - 1);
        Object.defineProperty(child, propertyName, {
          enumerable: false
        });
      }
    }

    return child;
  }

  return _clone(parent, depth);
}
clone.clonePrototype = function clonePrototype(parent) {
  if (parent === null)
    return null;

  var c = function () {};
  c.prototype = parent;
  return new c();
};

function __objToStr(o) {
  return Object.prototype.toString.call(o);
}
clone.__objToStr = __objToStr;

function __isDate(o) {
  return typeof o === &#039;object&#039; &amp;&amp; __objToStr(o) === &#039;[object Date]&#039;;
}
clone.__isDate = __isDate;

function __isArray(o) {
  return typeof o === &#039;object&#039; &amp;&amp; __objToStr(o) === &#039;[object Array]&#039;;
}
clone.__isArray = __isArray;

function __isRegExp(o) {
  return typeof o === &#039;object&#039; &amp;&amp; __objToStr(o) === &#039;[object RegExp]&#039;;
}
clone.__isRegExp = __isRegExp;

function __getRegExpFlags(re) {
  var flags = &#039;&#039;;
  if (re.global) flags += &#039;g&#039;;
  if (re.ignoreCase) flags += &#039;i&#039;;
  if (re.multiline) flags += &#039;m&#039;;
  return flags;
}
clone.__getRegExpFlags = __getRegExpFlags;

return clone;
})();

if (typeof module === &#039;object&#039; &amp;&amp; module.exports) {
  module.exports = clone;
}

var CSSLint = (function() {
    &quot;use strict&quot;;

    var rules           = [],
        formatters      = [],
        embeddedRuleset = /\/\*\s*csslint([^\*]*)\*\//,
        api             = new parserlib.util.EventTarget();

    api.version = &quot;1.0.5&quot;;
    api.addRule = function(rule) {
        rules.push(rule);
        rules[rule.id] = rule;
    };
    api.clearRules = function() {
        rules = [];
    };
    api.getRules = function() {
        return [].concat(rules).sort(function(a, b) {
            return a.id &gt; b.id ? 1 : 0;
        });
    };
    api.getRuleset = function() {
        var ruleset = {},
            i = 0,
            len = rules.length;

        while (i &lt; len) {
            ruleset[rules[i++].id] = 1;    // by default, everything is a warning
        }

        return ruleset;
    };
    function applyEmbeddedRuleset(text, ruleset) {
        var valueMap,
            embedded = text &amp;&amp; text.match(embeddedRuleset),
            rules = embedded &amp;&amp; embedded[1];

        if (rules) {
            valueMap = {
                &quot;true&quot;: 2,  // true is error
                &quot;&quot;: 1,      // blank is warning
                &quot;false&quot;: 0, // false is ignore

                &quot;2&quot;: 2,     // explicit error
                &quot;1&quot;: 1,     // explicit warning
                &quot;0&quot;: 0      // explicit ignore
            };

            rules.toLowerCase().split(&quot;,&quot;).forEach(function(rule) {
                var pair = rule.split(&quot;:&quot;),
                    property = pair[0] || &quot;&quot;,
                    value = pair[1] || &quot;&quot;;

                ruleset[property.trim()] = valueMap[value.trim()];
            });
        }

        return ruleset;
    }
    api.addFormatter = function(formatter) {
        formatters[formatter.id] = formatter;
    };
    api.getFormatter = function(formatId) {
        return formatters[formatId];
    };
    api.format = function(results, filename, formatId, options) {
        var formatter = api.getFormatter(formatId),
            result = null;

        if (formatter) {
            result = formatter.startFormat();
            result += formatter.formatResults(results, filename, options || {});
            result += formatter.endFormat();
        }

        return result;
    };
    api.hasFormat = function(formatId) {
        return formatters.hasOwnProperty(formatId);
    };
    api.verify = function(text, ruleset) {

        var i = 0,
            reporter,
            lines,
            allow = {},
            ignore = [],
            report,
            parser = new parserlib.css.Parser({
                starHack: true,
                ieFilters: true,
                underscoreHack: true,
                strict: false
            });
        lines = text.replace(/\n\r?/g, &quot;$split$&quot;).split(&quot;$split$&quot;);
        CSSLint.Util.forEach(lines, function (line, lineno) {
            var allowLine = line &amp;&amp; line.match(/\/\*[ \t]*csslint[ \t]+allow:[ \t]*([^\*]*)\*\//i),
                allowRules = allowLine &amp;&amp; allowLine[1],
                allowRuleset = {};

            if (allowRules) {
                allowRules.toLowerCase().split(&quot;,&quot;).forEach(function(allowRule) {
                    allowRuleset[allowRule.trim()] = true;
                });
                if (Object.keys(allowRuleset).length &gt; 0) {
                    allow[lineno + 1] = allowRuleset;
                }
            }
        });

        var ignoreStart = null,
            ignoreEnd = null;
        CSSLint.Util.forEach(lines, function (line, lineno) {
            if (ignoreStart === null &amp;&amp; line.match(/\/\*[ \t]*csslint[ \t]+ignore:start[ \t]*\*\//i)) {
                ignoreStart = lineno;
            }

            if (line.match(/\/\*[ \t]*csslint[ \t]+ignore:end[ \t]*\*\//i)) {
                ignoreEnd = lineno;
            }

            if (ignoreStart !== null &amp;&amp; ignoreEnd !== null) {
                ignore.push([ignoreStart, ignoreEnd]);
                ignoreStart = ignoreEnd = null;
            }
        });
        if (ignoreStart !== null) {
            ignore.push([ignoreStart, lines.length]);
        }

        if (!ruleset) {
            ruleset = api.getRuleset();
        }

        if (embeddedRuleset.test(text)) {
            ruleset = clone(ruleset);
            ruleset = applyEmbeddedRuleset(text, ruleset);
        }

        reporter = new Reporter(lines, ruleset, allow, ignore);

        ruleset.errors = 2;       // always report parsing errors as errors
        for (i in ruleset) {
            if (ruleset.hasOwnProperty(i) &amp;&amp; ruleset[i]) {
                if (rules[i]) {
                    rules[i].init(parser, reporter);
                }
            }
        }
        try {
            parser.parse(text);
        } catch (ex) {
            reporter.error(&quot;Fatal error, cannot continue: &quot; + ex.message, ex.line, ex.col, {});
        }

        report = {
            messages    : reporter.messages,
            stats       : reporter.stats,
            ruleset     : reporter.ruleset,
            allow       : reporter.allow,
            ignore      : reporter.ignore
        };
        report.messages.sort(function (a, b) {
            if (a.rollup &amp;&amp; !b.rollup) {
                return 1;
            } else if (!a.rollup &amp;&amp; b.rollup) {
                return -1;
            } else {
                return a.line - b.line;
            }
        });

        return report;
    };

    return api;

})();
function Reporter(lines, ruleset, allow, ignore) {
    &quot;use strict&quot;;
    this.messages = [];
    this.stats = [];
    this.lines = lines;
    this.ruleset = ruleset;
    this.allow = allow;
    if (!this.allow) {
        this.allow = {};
    }
    this.ignore = ignore;
    if (!this.ignore) {
        this.ignore = [];
    }
}

Reporter.prototype = {
    constructor: Reporter,
    error: function(message, line, col, rule) {
        &quot;use strict&quot;;
        this.messages.push({
            type    : &quot;error&quot;,
            line    : line,
            col     : col,
            message : message,
            evidence: this.lines[line-1],
            rule    : rule || {}
        });
    },
    warn: function(message, line, col, rule) {
        &quot;use strict&quot;;
        this.report(message, line, col, rule);
    },
    report: function(message, line, col, rule) {
        &quot;use strict&quot;;
        if (this.allow.hasOwnProperty(line) &amp;&amp; this.allow[line].hasOwnProperty(rule.id)) {
            return;
        }

        if (this.isIgnored(line)) {
            return;
        }

        this.messages.push({
            type    : this.ruleset[rule.id] === 2 ? &quot;error&quot; : &quot;warning&quot;,
            line    : line,
            col     : col,
            message : message,
            evidence: this.lines[line-1],
            rule    : rule
        });
    },
    info: function(message, line, col, rule) {
        &quot;use strict&quot;;
        this.messages.push({
            type    : &quot;info&quot;,
            line    : line,
            col     : col,
            message : message,
            evidence: this.lines[line-1],
            rule    : rule
        });
    },
    rollupError: function(message, rule) {
        &quot;use strict&quot;;
        this.messages.push({
            type    : &quot;error&quot;,
            rollup  : true,
            message : message,
            rule    : rule
        });
    },
    rollupWarn: function(message, rule) {
        &quot;use strict&quot;;
        this.messages.push({
            type    : &quot;warning&quot;,
            rollup  : true,
            message : message,
            rule    : rule
        });
    },
    stat: function(name, value) {
        &quot;use strict&quot;;
        this.stats[name] = value;
    },
    isIgnored: function(line) {
        &quot;use strict&quot;;
        var ignore = false;
        CSSLint.Util.forEach(this.ignore, function (range) {
            if (range[0] &lt;= line &amp;&amp; line &lt;= range[1]) {
                ignore = true;
            }
        });
        return ignore;
    }
};
CSSLint._Reporter = Reporter;
CSSLint.Util = {
    mix: function(receiver, supplier) {
        &quot;use strict&quot;;
        var prop;

        for (prop in supplier) {
            if (supplier.hasOwnProperty(prop)) {
                receiver[prop] = supplier[prop];
            }
        }

        return prop;
    },
    indexOf: function(values, value) {
        &quot;use strict&quot;;
        if (values.indexOf) {
            return values.indexOf(value);
        } else {
            for (var i=0, len=values.length; i &lt; len; i++) {
                if (values[i] === value) {
                    return i;
                }
            }
            return -1;
        }
    },
    forEach: function(values, func) {
        &quot;use strict&quot;;
        if (values.forEach) {
            return values.forEach(func);
        } else {
            for (var i=0, len=values.length; i &lt; len; i++) {
                func(values[i], i, values);
            }
        }
    }
};
CSSLint.addRule({
    id: &quot;box-model&quot;,
    name: &quot;Beware of broken box size&quot;,
    desc: &quot;Don&#039;t use width or height when using padding or border.&quot;,
    url: &quot;https://github.com/CSSLint/csslint/wiki/Beware-of-box-model-size&quot;,
    browsers: &quot;All&quot;,
    init: function(parser, reporter) {
        &quot;use strict&quot;;
        var rule = this,
            widthProperties = {
                border: 1,
                &quot;border-left&quot;: 1,
                &quot;border-right&quot;: 1,
                padding: 1,
                &quot;padding-left&quot;: 1,
                &quot;padding-right&quot;: 1
            },
            heightProperties = {
                border: 1,
                &quot;border-bottom&quot;: 1,
                &quot;border-top&quot;: 1,
                padding: 1,
                &quot;padding-bottom&quot;: 1,
                &quot;padding-top&quot;: 1
            },
            properties,
            boxSizing = false;

        function startRule() {
            properties = {};
            boxSizing = false;
        }

        function endRule() {
            var prop, value;

            if (!boxSizing) {
                if (properties.height) {
                    for (prop in heightProperties) {
                        if (heightProperties.hasOwnProperty(prop) &amp;&amp; properties[prop]) {
                            value = properties[prop].value;
                            if (!(prop === &quot;padding&quot; &amp;&amp; value.parts.length === 2 &amp;&amp; value.parts[0].value === 0)) {
                                reporter.report(&quot;Using height with &quot; + prop + &quot; can sometimes make elements larger than you expect.&quot;, properties[prop].line, properties[prop].col, rule);
                            }
                        }
                    }
                }

                if (properties.width) {
                    for (prop in widthProperties) {
                        if (widthProperties.hasOwnProperty(prop) &amp;&amp; properties[prop]) {
                            value = properties[prop].value;

                            if (!(prop === &quot;padding&quot; &amp;&amp; value.parts.length === 2 &amp;&amp; value.parts[1].value === 0)) {
                                reporter.report(&quot;Using width with &quot; + prop + &quot; can sometimes make elements larger than you expect.&quot;, properties[prop].line, properties[prop].col, rule);
                            }
                        }
                    }
                }
            }
        }

        parser.addListener(&quot;startrule&quot;, startRule);
        parser.addListener(&quot;startfontface&quot;, startRule);
        parser.addListener(&quot;startpage&quot;, startRule);
        parser.addListener(&quot;startpagemargin&quot;, startRule);
        parser.addListener(&quot;startkeyframerule&quot;, startRule);
        parser.addListener(&quot;startviewport&quot;, startRule);

        parser.addListener(&quot;property&quot;, function(event) {
            var name = event.property.text.toLowerCase();

            if (heightProperties[name] || widthProperties[name]) {
                if (!/^0\S*$/.test(event.value) &amp;&amp; !(name === &quot;border&quot; &amp;&amp; event.value.toString() === &quot;none&quot;)) {
                    properties[name] = {
                        line: event.property.line,
                        col: event.property.col,
                        value: event.value
                    };
                }
            } else {
                if (/^(width|height)/i.test(name) &amp;&amp; /^(length|percentage)/.test(event.value.parts[0].type)) {
                    properties[name] = 1;
                } else if (name === &quot;box-sizing&quot;) {
                    boxSizing = true;
                }
            }

        });

        parser.addListener(&quot;endrule&quot;, endRule);
        parser.addListener(&quot;endfontface&quot;, endRule);
        parser.addListener(&quot;endpage&quot;, endRule);
        parser.addListener(&quot;endpagemargin&quot;, endRule);
        parser.addListener(&quot;endkeyframerule&quot;, endRule);
        parser.addListener(&quot;endviewport&quot;, endRule);
    }

});

CSSLint.addRule({
    id: &quot;bulletproof-font-face&quot;,
    name: &quot;Use the bulletproof @font-face syntax&quot;,
    desc: &quot;Use the bulletproof @font-face syntax to avoid 404&#039;s in old IE (http://www.fontspring.com/blog/the-new-bulletproof-font-face-syntax).&quot;,
    url: &quot;https://github.com/CSSLint/csslint/wiki/Bulletproof-font-face&quot;,
    browsers: &quot;All&quot;,
    init: function(parser, reporter) {
        &quot;use strict&quot;;
        var rule = this,
            fontFaceRule = false,
            firstSrc = true,
            ruleFailed = false,
            line, col;
        parser.addListener(&quot;startfontface&quot;, function() {
            fontFaceRule = true;
        });

        parser.addListener(&quot;property&quot;, function(event) {
            if (!fontFaceRule) {
                return;
            }

            var propertyName = event.property.toString().toLowerCase(),
                value = event.value.toString();
            line = event.line;
            col = event.col;
            if (propertyName === &quot;src&quot;) {
                var regex = /^\s?url\([&#039;&quot;].+\.eot\?.*[&#039;&quot;]\)\s*format\([&#039;&quot;]embedded-opentype[&#039;&quot;]\).*$/i;
                if (!value.match(regex) &amp;&amp; firstSrc) {
                    ruleFailed = true;
                    firstSrc = false;
                } else if (value.match(regex) &amp;&amp; !firstSrc) {
                    ruleFailed = false;
                }
            }


        });
        parser.addListener(&quot;endfontface&quot;, function() {
            fontFaceRule = false;

            if (ruleFailed) {
                reporter.report(&quot;@font-face declaration doesn&#039;t follow the fontspring bulletproof syntax.&quot;, line, col, rule);
            }
        });
    }
});

CSSLint.addRule({
    id: &quot;compatible-vendor-prefixes&quot;,
    name: &quot;Require compatible vendor prefixes&quot;,
    desc: &quot;Include all compatible vendor prefixes to reach a wider range of users.&quot;,
    url: &quot;https://github.com/CSSLint/csslint/wiki/Require-compatible-vendor-prefixes&quot;,
    browsers: &quot;All&quot;,
    init: function (parser, reporter) {
        &quot;use strict&quot;;
        var rule = this,
            compatiblePrefixes,
            properties,
            prop,
            variations,
            prefixed,
            i,
            len,
            inKeyFrame = false,
            arrayPush = Array.prototype.push,
            applyTo = [];
        compatiblePrefixes = {
            &quot;animation&quot;                  : &quot;webkit&quot;,
            &quot;animation-delay&quot;            : &quot;webkit&quot;,
            &quot;animation-direction&quot;        : &quot;webkit&quot;,
            &quot;animation-duration&quot;         : &quot;webkit&quot;,
            &quot;animation-fill-mode&quot;        : &quot;webkit&quot;,
            &quot;animation-iteration-count&quot;  : &quot;webkit&quot;,
            &quot;animation-name&quot;             : &quot;webkit&quot;,
            &quot;animation-play-state&quot;       : &quot;webkit&quot;,
            &quot;animation-timing-function&quot;  : &quot;webkit&quot;,
            &quot;appearance&quot;                 : &quot;webkit moz&quot;,
            &quot;border-end&quot;                 : &quot;webkit moz&quot;,
            &quot;border-end-color&quot;           : &quot;webkit moz&quot;,
            &quot;border-end-style&quot;           : &quot;webkit moz&quot;,
            &quot;border-end-width&quot;           : &quot;webkit moz&quot;,
            &quot;border-image&quot;               : &quot;webkit moz o&quot;,
            &quot;border-radius&quot;              : &quot;webkit&quot;,
            &quot;border-start&quot;               : &quot;webkit moz&quot;,
            &quot;border-start-color&quot;         : &quot;webkit moz&quot;,
            &quot;border-start-style&quot;         : &quot;webkit moz&quot;,
            &quot;border-start-width&quot;         : &quot;webkit moz&quot;,
            &quot;box-align&quot;                  : &quot;webkit moz&quot;,
            &quot;box-direction&quot;              : &quot;webkit moz&quot;,
            &quot;box-flex&quot;                   : &quot;webkit moz&quot;,
            &quot;box-lines&quot;                  : &quot;webkit&quot;,
            &quot;box-ordinal-group&quot;          : &quot;webkit moz&quot;,
            &quot;box-orient&quot;                 : &quot;webkit moz&quot;,
            &quot;box-pack&quot;                   : &quot;webkit moz&quot;,
            &quot;box-sizing&quot;                 : &quot;&quot;,
            &quot;box-shadow&quot;                 : &quot;&quot;,
            &quot;column-count&quot;               : &quot;webkit moz ms&quot;,
            &quot;column-gap&quot;                 : &quot;webkit moz ms&quot;,
            &quot;column-rule&quot;                : &quot;webkit moz ms&quot;,
            &quot;column-rule-color&quot;          : &quot;webkit moz ms&quot;,
            &quot;column-rule-style&quot;          : &quot;webkit moz ms&quot;,
            &quot;column-rule-width&quot;          : &quot;webkit moz ms&quot;,
            &quot;column-width&quot;               : &quot;webkit moz ms&quot;,
            &quot;flex&quot;                       : &quot;webkit ms&quot;,
            &quot;flex-basis&quot;                 : &quot;webkit&quot;,
            &quot;flex-direction&quot;             : &quot;webkit ms&quot;,
            &quot;flex-flow&quot;                  : &quot;webkit&quot;,
            &quot;flex-grow&quot;                  : &quot;webkit&quot;,
            &quot;flex-shrink&quot;                : &quot;webkit&quot;,
            &quot;hyphens&quot;                    : &quot;epub moz&quot;,
            &quot;line-break&quot;                 : &quot;webkit ms&quot;,
            &quot;margin-end&quot;                 : &quot;webkit moz&quot;,
            &quot;margin-start&quot;               : &quot;webkit moz&quot;,
            &quot;marquee-speed&quot;              : &quot;webkit wap&quot;,
            &quot;marquee-style&quot;              : &quot;webkit wap&quot;,
            &quot;padding-end&quot;                : &quot;webkit moz&quot;,
            &quot;padding-start&quot;              : &quot;webkit moz&quot;,
            &quot;tab-size&quot;                   : &quot;moz o&quot;,
            &quot;text-size-adjust&quot;           : &quot;webkit ms&quot;,
            &quot;transform&quot;                  : &quot;webkit ms&quot;,
            &quot;transform-origin&quot;           : &quot;webkit ms&quot;,
            &quot;transition&quot;                 : &quot;&quot;,
            &quot;transition-delay&quot;           : &quot;&quot;,
            &quot;transition-duration&quot;        : &quot;&quot;,
            &quot;transition-property&quot;        : &quot;&quot;,
            &quot;transition-timing-function&quot; : &quot;&quot;,
            &quot;user-modify&quot;                : &quot;webkit moz&quot;,
            &quot;user-select&quot;                : &quot;webkit moz ms&quot;,
            &quot;word-break&quot;                 : &quot;epub ms&quot;,
            &quot;writing-mode&quot;               : &quot;epub ms&quot;
        };


        for (prop in compatiblePrefixes) {
            if (compatiblePrefixes.hasOwnProperty(prop)) {
                variations = [];
                prefixed = compatiblePrefixes[prop].split(&quot; &quot;);
                for (i = 0, len = prefixed.length; i &lt; len; i++) {
                    variations.push(&quot;-&quot; + prefixed[i] + &quot;-&quot; + prop);
                }
                compatiblePrefixes[prop] = variations;
                arrayPush.apply(applyTo, variations);
            }
        }

        parser.addListener(&quot;startrule&quot;, function () {
            properties = [];
        });

        parser.addListener(&quot;startkeyframes&quot;, function (event) {
            inKeyFrame = event.prefix || true;
        });

        parser.addListener(&quot;endkeyframes&quot;, function () {
            inKeyFrame = false;
        });

        parser.addListener(&quot;property&quot;, function (event) {
            var name = event.property;
            if (CSSLint.Util.indexOf(applyTo, name.text) &gt; -1) {
                if (!inKeyFrame || typeof inKeyFrame !== &quot;string&quot; ||
                        name.text.indexOf(&quot;-&quot; + inKeyFrame + &quot;-&quot;) !== 0) {
                    properties.push(name);
                }
            }
        });

        parser.addListener(&quot;endrule&quot;, function () {
            if (!properties.length) {
                return;
            }

            var propertyGroups = {},
                i,
                len,
                name,
                prop,
                variations,
                value,
                full,
                actual,
                item,
                propertiesSpecified;

            for (i = 0, len = properties.length; i &lt; len; i++) {
                name = properties[i];

                for (prop in compatiblePrefixes) {
                    if (compatiblePrefixes.hasOwnProperty(prop)) {
                        variations = compatiblePrefixes[prop];
                        if (CSSLint.Util.indexOf(variations, name.text) &gt; -1) {
                            if (!propertyGroups[prop]) {
                                propertyGroups[prop] = {
                                    full: variations.slice(0),
                                    actual: [],
                                    actualNodes: []
                                };
                            }
                            if (CSSLint.Util.indexOf(propertyGroups[prop].actual, name.text) === -1) {
                                propertyGroups[prop].actual.push(name.text);
                                propertyGroups[prop].actualNodes.push(name);
                            }
                        }
                    }
                }
            }

            for (prop in propertyGroups) {
                if (propertyGroups.hasOwnProperty(prop)) {
                    value = propertyGroups[prop];
                    full = value.full;
                    actual = value.actual;

                    if (full.length &gt; actual.length) {
                        for (i = 0, len = full.length; i &lt; len; i++) {
                            item = full[i];
                            if (CSSLint.Util.indexOf(actual, item) === -1) {
                                propertiesSpecified = (actual.length === 1) ? actual[0] : (actual.length === 2) ? actual.join(&quot; and &quot;) : actual.join(&quot;, &quot;);
                                reporter.report(&quot;The property &quot; + item + &quot; is compatible with &quot; + propertiesSpecified + &quot; and should be included as well.&quot;, value.actualNodes[0].line, value.actualNodes[0].col, rule);
                            }
                        }

                    }
                }
            }
        });
    }
});

CSSLint.addRule({
    id: &quot;display-property-grouping&quot;,
    name: &quot;Require properties appropriate for display&quot;,
    desc: &quot;Certain properties shouldn&#039;t be used with certain display property values.&quot;,
    url: &quot;https://github.com/CSSLint/csslint/wiki/Require-properties-appropriate-for-display&quot;,
    browsers: &quot;All&quot;,
    init: function(parser, reporter) {
        &quot;use strict&quot;;
        var rule = this;

        var propertiesToCheck = {
                display: 1,
                &quot;float&quot;: &quot;none&quot;,
                height: 1,
                width: 1,
                margin: 1,
                &quot;margin-left&quot;: 1,
                &quot;margin-right&quot;: 1,
                &quot;margin-bottom&quot;: 1,
                &quot;margin-top&quot;: 1,
                padding: 1,
                &quot;padding-left&quot;: 1,
                &quot;padding-right&quot;: 1,
                &quot;padding-bottom&quot;: 1,
                &quot;padding-top&quot;: 1,
                &quot;vertical-align&quot;: 1
            },
            properties;

        function reportProperty(name, display, msg) {
            if (properties[name]) {
                if (typeof propertiesToCheck[name] !== &quot;string&quot; || properties[name].value.toLowerCase() !== propertiesToCheck[name]) {
                    reporter.report(msg || name + &quot; can&#039;t be used with display: &quot; + display + &quot;.&quot;, properties[name].line, properties[name].col, rule);
                }
            }
        }

        function startRule() {
            properties = {};
        }

        function endRule() {

            var display = properties.display ? properties.display.value : null;
            if (display) {
                switch (display) {

                    case &quot;inline&quot;:
                        reportProperty(&quot;height&quot;, display);
                        reportProperty(&quot;width&quot;, display);
                        reportProperty(&quot;margin&quot;, display);
                        reportProperty(&quot;margin-top&quot;, display);
                        reportProperty(&quot;margin-bottom&quot;, display);
                        reportProperty(&quot;float&quot;, display, &quot;display:inline has no effect on floated elements (but may be used to fix the IE6 double-margin bug).&quot;);
                        break;

                    case &quot;block&quot;:
                        reportProperty(&quot;vertical-align&quot;, display);
                        break;

                    case &quot;inline-block&quot;:
                        reportProperty(&quot;float&quot;, display);
                        break;

                    default:
                        if (display.indexOf(&quot;table-&quot;) === 0) {
                            reportProperty(&quot;margin&quot;, display);
                            reportProperty(&quot;margin-left&quot;, display);
                            reportProperty(&quot;margin-right&quot;, display);
                            reportProperty(&quot;margin-top&quot;, display);
                            reportProperty(&quot;margin-bottom&quot;, display);
                            reportProperty(&quot;float&quot;, display);
                        }
                }
            }

        }

        parser.addListener(&quot;startrule&quot;, startRule);
        parser.addListener(&quot;startfontface&quot;, startRule);
        parser.addListener(&quot;startkeyframerule&quot;, startRule);
        parser.addListener(&quot;startpagemargin&quot;, startRule);
        parser.addListener(&quot;startpage&quot;, startRule);
        parser.addListener(&quot;startviewport&quot;, startRule);

        parser.addListener(&quot;property&quot;, function(event) {
            var name = event.property.text.toLowerCase();

            if (propertiesToCheck[name]) {
                properties[name] = {
                    value: event.value.text,
                    line: event.property.line,
                    col: event.property.col
                };
            }
        });

        parser.addListener(&quot;endrule&quot;, endRule);
        parser.addListener(&quot;endfontface&quot;, endRule);
        parser.addListener(&quot;endkeyframerule&quot;, endRule);
        parser.addListener(&quot;endpagemargin&quot;, endRule);
        parser.addListener(&quot;endpage&quot;, endRule);
        parser.addListener(&quot;endviewport&quot;, endRule);

    }

});

CSSLint.addRule({
    id: &quot;duplicate-background-images&quot;,
    name: &quot;Disallow duplicate background images&quot;,
    desc: &quot;Every background-image should be unique. Use a common class for e.g. sprites.&quot;,
    url: &quot;https://github.com/CSSLint/csslint/wiki/Disallow-duplicate-background-images&quot;,
    browsers: &quot;All&quot;,
    init: function(parser, reporter) {
        &quot;use strict&quot;;
        var rule = this,
            stack = {};

        parser.addListener(&quot;property&quot;, function(event) {
            var name = event.property.text,
                value = event.value,
                i, len;

            if (name.match(/background/i)) {
                for (i=0, len=value.parts.length; i &lt; len; i++) {
                    if (value.parts[i].type === &quot;uri&quot;) {
                        if (typeof stack[value.parts[i].uri] === &quot;undefined&quot;) {
                            stack[value.parts[i].uri] = event;
                        } else {
                            reporter.report(&quot;Background image &#039;&quot; + value.parts[i].uri + &quot;&#039; was used multiple times, first declared at line &quot; + stack[value.parts[i].uri].line + &quot;, col &quot; + stack[value.parts[i].uri].col + &quot;.&quot;, event.line, event.col, rule);
                        }
                    }
                }
            }
        });
    }
});

CSSLint.addRule({
    id: &quot;duplicate-properties&quot;,
    name: &quot;Disallow duplicate properties&quot;,
    desc: &quot;Duplicate properties must appear one after the other.&quot;,
    url: &quot;https://github.com/CSSLint/csslint/wiki/Disallow-duplicate-properties&quot;,
    browsers: &quot;All&quot;,
    init: function(parser, reporter) {
        &quot;use strict&quot;;
        var rule = this,
            properties,
            lastProperty;

        function startRule() {
            properties = {};
        }

        parser.addListener(&quot;startrule&quot;, startRule);
        parser.addListener(&quot;startfontface&quot;, startRule);
        parser.addListener(&quot;startpage&quot;, startRule);
        parser.addListener(&quot;startpagemargin&quot;, startRule);
        parser.addListener(&quot;startkeyframerule&quot;, startRule);
        parser.addListener(&quot;startviewport&quot;, startRule);

        parser.addListener(&quot;property&quot;, function(event) {
            var property = event.property,
                name = property.text.toLowerCase();

            if (properties[name] &amp;&amp; (lastProperty !== name || properties[name] === event.value.text)) {
                reporter.report(&quot;Duplicate property &#039;&quot; + event.property + &quot;&#039; found.&quot;, event.line, event.col, rule);
            }

            properties[name] = event.value.text;
            lastProperty = name;

        });


    }

});

CSSLint.addRule({
    id: &quot;empty-rules&quot;,
    name: &quot;Disallow empty rules&quot;,
    desc: &quot;Rules without any properties specified should be removed.&quot;,
    url: &quot;https://github.com/CSSLint/csslint/wiki/Disallow-empty-rules&quot;,
    browsers: &quot;All&quot;,
    init: function(parser, reporter) {
        &quot;use strict&quot;;
        var rule = this,
            count = 0;

        parser.addListener(&quot;startrule&quot;, function() {
            count=0;
        });

        parser.addListener(&quot;property&quot;, function() {
            count++;
        });

        parser.addListener(&quot;endrule&quot;, function(event) {
            var selectors = event.selectors;

            if (count === 0) {
                reporter.report(&quot;Rule is empty.&quot;, selectors[0].line, selectors[0].col, rule);
            }
        });
    }

});

CSSLint.addRule({
    id: &quot;errors&quot;,
    name: &quot;Parsing Errors&quot;,
    desc: &quot;This rule looks for recoverable syntax errors.&quot;,
    browsers: &quot;All&quot;,
    init: function(parser, reporter) {
        &quot;use strict&quot;;
        var rule = this;

        parser.addListener(&quot;error&quot;, function(event) {
            reporter.error(event.message, event.line, event.col, rule);
        });

    }

});

CSSLint.addRule({
    id: &quot;floats&quot;,
    name: &quot;Disallow too many floats&quot;,
    desc: &quot;This rule tests if the float property is used too many times&quot;,
    url: &quot;https://github.com/CSSLint/csslint/wiki/Disallow-too-many-floats&quot;,
    browsers: &quot;All&quot;,
    init: function(parser, reporter) {
        &quot;use strict&quot;;
        var rule = this;
        var count = 0;
        parser.addListener(&quot;property&quot;, function(event) {
            if (!reporter.isIgnored(event.property.line)) {
              if (event.property.text.toLowerCase() === &quot;float&quot; &amp;&amp;
                      event.value.text.toLowerCase() !== &quot;none&quot;) {
                  count++;
              }
            }
        });
        parser.addListener(&quot;endstylesheet&quot;, function() {
            reporter.stat(&quot;floats&quot;, count);
            if (count &gt;= 10) {
                reporter.rollupWarn(&quot;Too many floats (&quot; + count + &quot;), you&#039;re probably using them for layout. Consider using a grid system instead.&quot;, rule);
            }
        });
    }

});

CSSLint.addRule({
    id: &quot;font-faces&quot;,
    name: &quot;Don&#039;t use too many web fonts&quot;,
    desc: &quot;Too many different web fonts in the same stylesheet.&quot;,
    url: &quot;https://github.com/CSSLint/csslint/wiki/Don%27t-use-too-many-web-fonts&quot;,
    browsers: &quot;All&quot;,
    init: function(parser, reporter) {
        &quot;use strict&quot;;
        var rule = this,
            count = 0;


        parser.addListener(&quot;startfontface&quot;, function(event) {
            if (!reporter.isIgnored(event.line)) {
                count++;
            }
        });

        parser.addListener(&quot;endstylesheet&quot;, function() {
            if (count &gt; 5) {
                reporter.rollupWarn(&quot;Too many @font-face declarations (&quot; + count + &quot;).&quot;, rule);
            }
        });
    }

});

CSSLint.addRule({
    id: &quot;font-sizes&quot;,
    name: &quot;Disallow too many font sizes&quot;,
    desc: &quot;Checks the number of font-size declarations.&quot;,
    url: &quot;https://github.com/CSSLint/csslint/wiki/Don%27t-use-too-many-font-size-declarations&quot;,
    browsers: &quot;All&quot;,
    init: function(parser, reporter) {
        &quot;use strict&quot;;
        var rule = this,
            count = 0;
        parser.addListener(&quot;property&quot;, function(event) {
            if (!reporter.isIgnored(event.property.line)) {
                if (event.property.toString() === &quot;font-size&quot;) {
                    count++;
                }
            }
        });
        parser.addListener(&quot;endstylesheet&quot;, function() {
            reporter.stat(&quot;font-sizes&quot;, count);
            if (count &gt;= 10) {
                reporter.rollupWarn(&quot;Too many font-size declarations (&quot; + count + &quot;), abstraction needed.&quot;, rule);
            }
        });
    }

});

CSSLint.addRule({
    id: &quot;gradients&quot;,
    name: &quot;Require all gradient definitions&quot;,
    desc: &quot;When using a vendor-prefixed gradient, make sure to use them all.&quot;,
    url: &quot;https://github.com/CSSLint/csslint/wiki/Require-all-gradient-definitions&quot;,
    browsers: &quot;All&quot;,
    init: function(parser, reporter) {
        &quot;use strict&quot;;
        var rule = this,
            gradients;

        parser.addListener(&quot;startrule&quot;, function() {
            gradients = {
                moz: 0,
                webkit: 0,
                oldWebkit: 0,
                o: 0
            };
        });

        parser.addListener(&quot;property&quot;, function(event) {

            if (/\-(moz|o|webkit)(?:\-(?:linear|radial))\-gradient/i.test(event.value)) {
                gradients[RegExp.$1] = 1;
            } else if (/\-webkit\-gradient/i.test(event.value)) {
                gradients.oldWebkit = 1;
            }

        });

        parser.addListener(&quot;endrule&quot;, function(event) {
            var missing = [];

            if (!gradients.moz) {
                missing.push(&quot;Firefox 3.6+&quot;);
            }

            if (!gradients.webkit) {
                missing.push(&quot;Webkit (Safari 5+, Chrome)&quot;);
            }

            if (!gradients.oldWebkit) {
                missing.push(&quot;Old Webkit (Safari 4+, Chrome)&quot;);
            }

            if (!gradients.o) {
                missing.push(&quot;Opera 11.1+&quot;);
            }

            if (missing.length &amp;&amp; missing.length &lt; 4) {
                reporter.report(&quot;Missing vendor-prefixed CSS gradients for &quot; + missing.join(&quot;, &quot;) + &quot;.&quot;, event.selectors[0].line, event.selectors[0].col, rule);
            }

        });

    }

});

CSSLint.addRule({
    id: &quot;ids&quot;,
    name: &quot;Disallow IDs in selectors&quot;,
    desc: &quot;Selectors should not contain IDs.&quot;,
    url: &quot;https://github.com/CSSLint/csslint/wiki/Disallow-IDs-in-selectors&quot;,
    browsers: &quot;All&quot;,
    init: function(parser, reporter) {
        &quot;use strict&quot;;
        var rule = this;
        parser.addListener(&quot;startrule&quot;, function(event) {
            var selectors = event.selectors,
                selector,
                part,
                modifier,
                idCount,
                i, j, k;

            for (i=0; i &lt; selectors.length; i++) {
                selector = selectors[i];
                idCount = 0;

                for (j=0; j &lt; selector.parts.length; j++) {
                    part = selector.parts[j];
                    if (part.type === parser.SELECTOR_PART_TYPE) {
                        for (k=0; k &lt; part.modifiers.length; k++) {
                            modifier = part.modifiers[k];
                            if (modifier.type === &quot;id&quot;) {
                                idCount++;
                            }
                        }
                    }
                }

                if (idCount === 1) {
                    reporter.report(&quot;Don&#039;t use IDs in selectors.&quot;, selector.line, selector.col, rule);
                } else if (idCount &gt; 1) {
                    reporter.report(idCount + &quot; IDs in the selector, really?&quot;, selector.line, selector.col, rule);
                }
            }

        });
    }

});

CSSLint.addRule({
    id: &quot;import-ie-limit&quot;,
    name: &quot;@import limit on IE6-IE9&quot;,
    desc: &quot;IE6-9 supports up to 31 @import per stylesheet&quot;,
    browsers: &quot;IE6, IE7, IE8, IE9&quot;,
    init: function(parser, reporter) {
        &quot;use strict&quot;;
        var rule = this,
            MAX_IMPORT_COUNT = 31,
            count = 0;

        function startPage() {
            count = 0;
        }

        parser.addListener(&quot;startpage&quot;, startPage);

        parser.addListener(&quot;import&quot;, function() {
            count++;
        });

        parser.addListener(&quot;endstylesheet&quot;, function() {
            if (count &gt; MAX_IMPORT_COUNT) {
                reporter.rollupError(
                    &quot;Too many @import rules (&quot; + count + &quot;). IE6-9 supports up to 31 import per stylesheet.&quot;,
                    rule
                );
            }
        });
    }

});

CSSLint.addRule({
    id: &quot;import&quot;,
    name: &quot;Disallow @import&quot;,
    desc: &quot;Don&#039;t use @import, use &lt;link&gt; instead.&quot;,
    url: &quot;https://github.com/CSSLint/csslint/wiki/Disallow-%40import&quot;,
    browsers: &quot;All&quot;,
    init: function(parser, reporter) {
        &quot;use strict&quot;;
        var rule = this;

        parser.addListener(&quot;import&quot;, function(event) {
            reporter.report(&quot;@import prevents parallel downloads, use &lt;link&gt; instead.&quot;, event.line, event.col, rule);
        });

    }

});

CSSLint.addRule({
    id: &quot;important&quot;,
    name: &quot;Disallow !important&quot;,
    desc: &quot;Be careful when using !important declaration&quot;,
    url: &quot;https://github.com/CSSLint/csslint/wiki/Disallow-%21important&quot;,
    browsers: &quot;All&quot;,
    init: function(parser, reporter) {
        &quot;use strict&quot;;
        var rule = this,
            count = 0;
        parser.addListener(&quot;property&quot;, function(event) {
            if (!reporter.isIgnored(event.line)) {
                if (event.important === true) {
                    count++;
                    reporter.report(&quot;Use of !important&quot;, event.line, event.col, rule);
                }
            }
        });
        parser.addListener(&quot;endstylesheet&quot;, function() {
            reporter.stat(&quot;important&quot;, count);
            if (count &gt;= 10) {
                reporter.rollupWarn(&quot;Too many !important declarations (&quot; + count + &quot;), try to use less than 10 to avoid specificity issues.&quot;, rule);
            }
        });
    }

});

CSSLint.addRule({
    id: &quot;known-properties&quot;,
    name: &quot;Require use of known properties&quot;,
    desc: &quot;Properties should be known (listed in CSS3 specification) or be a vendor-prefixed property.&quot;,
    url: &quot;https://github.com/CSSLint/csslint/wiki/Require-use-of-known-properties&quot;,
    browsers: &quot;All&quot;,
    init: function(parser, reporter) {
        &quot;use strict&quot;;
        var rule = this;

        parser.addListener(&quot;property&quot;, function(event) {
            if (event.invalid) {
                reporter.report(event.invalid.message, event.line, event.col, rule);
            }

        });
    }

});

CSSLint.addRule({
    id: &quot;order-alphabetical&quot;,
    name: &quot;Alphabetical order&quot;,
    desc: &quot;Assure properties are in alphabetical order&quot;,
    browsers: &quot;All&quot;,
    init: function(parser, reporter) {
        &quot;use strict&quot;;
        var rule = this,
            properties;

        var startRule = function () {
            properties = [];
        };

        var endRule = function(event) {
            var currentProperties = properties.join(&quot;,&quot;),
                expectedProperties = properties.sort().join(&quot;,&quot;);

            if (currentProperties !== expectedProperties) {
                reporter.report(&quot;Rule doesn&#039;t have all its properties in alphabetical order.&quot;, event.line, event.col, rule);
            }
        };

        parser.addListener(&quot;startrule&quot;, startRule);
        parser.addListener(&quot;startfontface&quot;, startRule);
        parser.addListener(&quot;startpage&quot;, startRule);
        parser.addListener(&quot;startpagemargin&quot;, startRule);
        parser.addListener(&quot;startkeyframerule&quot;, startRule);
        parser.addListener(&quot;startviewport&quot;, startRule);

        parser.addListener(&quot;property&quot;, function(event) {
            var name = event.property.text,
                lowerCasePrefixLessName = name.toLowerCase().replace(/^-.*?-/, &quot;&quot;);

            properties.push(lowerCasePrefixLessName);
        });

        parser.addListener(&quot;endrule&quot;, endRule);
        parser.addListener(&quot;endfontface&quot;, endRule);
        parser.addListener(&quot;endpage&quot;, endRule);
        parser.addListener(&quot;endpagemargin&quot;, endRule);
        parser.addListener(&quot;endkeyframerule&quot;, endRule);
        parser.addListener(&quot;endviewport&quot;, endRule);
    }

});

CSSLint.addRule({
    id: &quot;outline-none&quot;,
    name: &quot;Disallow outline: none&quot;,
    desc: &quot;Use of outline: none or outline: 0 should be limited to :focus rules.&quot;,
    url: &quot;https://github.com/CSSLint/csslint/wiki/Disallow-outline%3Anone&quot;,
    browsers: &quot;All&quot;,
    tags: [&quot;Accessibility&quot;],
    init: function(parser, reporter) {
        &quot;use strict&quot;;
        var rule = this,
            lastRule;

        function startRule(event) {
            if (event.selectors) {
                lastRule = {
                    line: event.line,
                    col: event.col,
                    selectors: event.selectors,
                    propCount: 0,
                    outline: false
                };
            } else {
                lastRule = null;
            }
        }

        function endRule() {
            if (lastRule) {
                if (lastRule.outline) {
                    if (lastRule.selectors.toString().toLowerCase().indexOf(&quot;:focus&quot;) === -1) {
                        reporter.report(&quot;Outlines should only be modified using :focus.&quot;, lastRule.line, lastRule.col, rule);
                    } else if (lastRule.propCount === 1) {
                        reporter.report(&quot;Outlines shouldn&#039;t be hidden unless other visual changes are made.&quot;, lastRule.line, lastRule.col, rule);
                    }
                }
            }
        }

        parser.addListener(&quot;startrule&quot;, startRule);
        parser.addListener(&quot;startfontface&quot;, startRule);
        parser.addListener(&quot;startpage&quot;, startRule);
        parser.addListener(&quot;startpagemargin&quot;, startRule);
        parser.addListener(&quot;startkeyframerule&quot;, startRule);
        parser.addListener(&quot;startviewport&quot;, startRule);

        parser.addListener(&quot;property&quot;, function(event) {
            var name = event.property.text.toLowerCase(),
                value = event.value;

            if (lastRule) {
                lastRule.propCount++;
                if (name === &quot;outline&quot; &amp;&amp; (value.toString() === &quot;none&quot; || value.toString() === &quot;0&quot;)) {
                    lastRule.outline = true;
                }
            }

        });

        parser.addListener(&quot;endrule&quot;, endRule);
        parser.addListener(&quot;endfontface&quot;, endRule);
        parser.addListener(&quot;endpage&quot;, endRule);
        parser.addListener(&quot;endpagemargin&quot;, endRule);
        parser.addListener(&quot;endkeyframerule&quot;, endRule);
        parser.addListener(&quot;endviewport&quot;, endRule);

    }

});

CSSLint.addRule({
    id: &quot;overqualified-elements&quot;,
    name: &quot;Disallow overqualified elements&quot;,
    desc: &quot;Don&#039;t use classes or IDs with elements (a.foo or a#foo).&quot;,
    url: &quot;https://github.com/CSSLint/csslint/wiki/Disallow-overqualified-elements&quot;,
    browsers: &quot;All&quot;,
    init: function(parser, reporter) {
        &quot;use strict&quot;;
        var rule = this,
            classes = {};

        parser.addListener(&quot;startrule&quot;, function(event) {
            var selectors = event.selectors,
                selector,
                part,
                modifier,
                i, j, k;

            for (i=0; i &lt; selectors.length; i++) {
                selector = selectors[i];

                for (j=0; j &lt; selector.parts.length; j++) {
                    part = selector.parts[j];
                    if (part.type === parser.SELECTOR_PART_TYPE) {
                        for (k=0; k &lt; part.modifiers.length; k++) {
                            modifier = part.modifiers[k];
                            if (part.elementName &amp;&amp; modifier.type === &quot;id&quot;) {
                                reporter.report(&quot;Element (&quot; + part + &quot;) is overqualified, just use &quot; + modifier + &quot; without element name.&quot;, part.line, part.col, rule);
                            } else if (modifier.type === &quot;class&quot;) {

                                if (!classes[modifier]) {
                                    classes[modifier] = [];
                                }
                                classes[modifier].push({
                                    modifier: modifier,
                                    part: part
                                });
                            }
                        }
                    }
                }
            }
        });

        parser.addListener(&quot;endstylesheet&quot;, function() {

            var prop;
            for (prop in classes) {
                if (classes.hasOwnProperty(prop)) {
                    if (classes[prop].length === 1 &amp;&amp; classes[prop][0].part.elementName) {
                        reporter.report(&quot;Element (&quot; + classes[prop][0].part + &quot;) is overqualified, just use &quot; + classes[prop][0].modifier + &quot; without element name.&quot;, classes[prop][0].part.line, classes[prop][0].part.col, rule);
                    }
                }
            }
        });
    }

});

CSSLint.addRule({
    id: &quot;regex-selectors&quot;,
    name: &quot;Disallow selectors that look like regexs&quot;,
    desc: &quot;Selectors that look like regular expressions are slow and should be avoided.&quot;,
    url: &quot;https://github.com/CSSLint/csslint/wiki/Disallow-selectors-that-look-like-regular-expressions&quot;,
    browsers: &quot;All&quot;,
    init: function(parser, reporter) {
        &quot;use strict&quot;;
        var rule = this;

        parser.addListener(&quot;startrule&quot;, function(event) {
            var selectors = event.selectors,
                selector,
                part,
                modifier,
                i, j, k;

            for (i=0; i &lt; selectors.length; i++) {
                selector = selectors[i];
                for (j=0; j &lt; selector.parts.length; j++) {
                    part = selector.parts[j];
                    if (part.type === parser.SELECTOR_PART_TYPE) {
                        for (k=0; k &lt; part.modifiers.length; k++) {
                            modifier = part.modifiers[k];
                            if (modifier.type === &quot;attribute&quot;) {
                                if (/([~\|\^\$\*]=)/.test(modifier)) {
                                    reporter.report(&quot;Attribute selectors with &quot; + RegExp.$1 + &quot; are slow!&quot;, modifier.line, modifier.col, rule);
                                }
                            }

                        }
                    }
                }
            }
        });
    }

});

CSSLint.addRule({
    id: &quot;rules-count&quot;,
    name: &quot;Rules Count&quot;,
    desc: &quot;Track how many rules there are.&quot;,
    browsers: &quot;All&quot;,
    init: function(parser, reporter) {
        &quot;use strict&quot;;
        var count = 0;
        parser.addListener(&quot;startrule&quot;, function() {
            count++;
        });

        parser.addListener(&quot;endstylesheet&quot;, function() {
            reporter.stat(&quot;rule-count&quot;, count);
        });
    }

});

CSSLint.addRule({
    id: &quot;selector-max-approaching&quot;,
    name: &quot;Warn when approaching the 4095 selector limit for IE&quot;,
    desc: &quot;Will warn when selector count is &gt;= 3800 selectors.&quot;,
    browsers: &quot;IE&quot;,
    init: function(parser, reporter) {
        &quot;use strict&quot;;
        var rule = this, count = 0;

        parser.addListener(&quot;startrule&quot;, function(event) {
            count += event.selectors.length;
        });

        parser.addListener(&quot;endstylesheet&quot;, function() {
            if (count &gt;= 3800) {
                reporter.report(&quot;You have &quot; + count + &quot; selectors. Internet Explorer supports a maximum of 4095 selectors per stylesheet. Consider refactoring.&quot;, 0, 0, rule);
            }
        });
    }

});

CSSLint.addRule({
    id: &quot;selector-max&quot;,
    name: &quot;Error when past the 4095 selector limit for IE&quot;,
    desc: &quot;Will error when selector count is &gt; 4095.&quot;,
    browsers: &quot;IE&quot;,
    init: function(parser, reporter) {
        &quot;use strict&quot;;
        var rule = this, count = 0;

        parser.addListener(&quot;startrule&quot;, function(event) {
            count += event.selectors.length;
        });

        parser.addListener(&quot;endstylesheet&quot;, function() {
            if (count &gt; 4095) {
                reporter.report(&quot;You have &quot; + count + &quot; selectors. Internet Explorer supports a maximum of 4095 selectors per stylesheet. Consider refactoring.&quot;, 0, 0, rule);
            }
        });
    }

});

CSSLint.addRule({
    id: &quot;selector-newline&quot;,
    name: &quot;Disallow new-line characters in selectors&quot;,
    desc: &quot;New-line characters in selectors are usually a forgotten comma and not a descendant combinator.&quot;,
    browsers: &quot;All&quot;,
    init: function(parser, reporter) {
        &quot;use strict&quot;;
        var rule = this;

        function startRule(event) {
            var i, len, selector, p, n, pLen, part, part2, type, currentLine, nextLine,
                selectors = event.selectors;

            for (i = 0, len = selectors.length; i &lt; len; i++) {
                selector = selectors[i];
                for (p = 0, pLen = selector.parts.length; p &lt; pLen; p++) {
                    for (n = p + 1; n &lt; pLen; n++) {
                        part = selector.parts[p];
                        part2 = selector.parts[n];
                        type = part.type;
                        currentLine = part.line;
                        nextLine = part2.line;

                        if (type === &quot;descendant&quot; &amp;&amp; nextLine &gt; currentLine) {
                            reporter.report(&quot;newline character found in selector (forgot a comma?)&quot;, currentLine, selectors[i].parts[0].col, rule);
                        }
                    }
                }

            }
        }

        parser.addListener(&quot;startrule&quot;, startRule);

    }
});

CSSLint.addRule({
    id: &quot;shorthand&quot;,
    name: &quot;Require shorthand properties&quot;,
    desc: &quot;Use shorthand properties where possible.&quot;,
    url: &quot;https://github.com/CSSLint/csslint/wiki/Require-shorthand-properties&quot;,
    browsers: &quot;All&quot;,
    init: function(parser, reporter) {
        &quot;use strict&quot;;
        var rule = this,
            prop, i, len,
            propertiesToCheck = {},
            properties,
            mapping = {
                &quot;margin&quot;: [
                    &quot;margin-top&quot;,
                    &quot;margin-bottom&quot;,
                    &quot;margin-left&quot;,
                    &quot;margin-right&quot;
                ],
                &quot;padding&quot;: [
                    &quot;padding-top&quot;,
                    &quot;padding-bottom&quot;,
                    &quot;padding-left&quot;,
                    &quot;padding-right&quot;
                ]
            };
        for (prop in mapping) {
            if (mapping.hasOwnProperty(prop)) {
                for (i=0, len=mapping[prop].length; i &lt; len; i++) {
                    propertiesToCheck[mapping[prop][i]] = prop;
                }
            }
        }

        function startRule() {
            properties = {};
        }
        function endRule(event) {

            var prop, i, len, total;
            for (prop in mapping) {
                if (mapping.hasOwnProperty(prop)) {
                    total=0;

                    for (i=0, len=mapping[prop].length; i &lt; len; i++) {
                        total += properties[mapping[prop][i]] ? 1 : 0;
                    }

                    if (total === mapping[prop].length) {
                        reporter.report(&quot;The properties &quot; + mapping[prop].join(&quot;, &quot;) + &quot; can be replaced by &quot; + prop + &quot;.&quot;, event.line, event.col, rule);
                    }
                }
            }
        }

        parser.addListener(&quot;startrule&quot;, startRule);
        parser.addListener(&quot;startfontface&quot;, startRule);
        parser.addListener(&quot;property&quot;, function(event) {
            var name = event.property.toString().toLowerCase();

            if (propertiesToCheck[name]) {
                properties[name] = 1;
            }
        });

        parser.addListener(&quot;endrule&quot;, endRule);
        parser.addListener(&quot;endfontface&quot;, endRule);

    }

});

CSSLint.addRule({
    id: &quot;star-property-hack&quot;,
    name: &quot;Disallow properties with a star prefix&quot;,
    desc: &quot;Checks for the star property hack (targets IE6/7)&quot;,
    url: &quot;https://github.com/CSSLint/csslint/wiki/Disallow-star-hack&quot;,
    browsers: &quot;All&quot;,
    init: function(parser, reporter) {
        &quot;use strict&quot;;
        var rule = this;
        parser.addListener(&quot;property&quot;, function(event) {
            var property = event.property;

            if (property.hack === &quot;*&quot;) {
                reporter.report(&quot;Property with star prefix found.&quot;, event.property.line, event.property.col, rule);
            }
        });
    }
});

CSSLint.addRule({
    id: &quot;text-indent&quot;,
    name: &quot;Disallow negative text-indent&quot;,
    desc: &quot;Checks for text indent less than -99px&quot;,
    url: &quot;https://github.com/CSSLint/csslint/wiki/Disallow-negative-text-indent&quot;,
    browsers: &quot;All&quot;,
    init: function(parser, reporter) {
        &quot;use strict&quot;;
        var rule = this,
            textIndent,
            direction;


        function startRule() {
            textIndent = false;
            direction = &quot;inherit&quot;;
        }
        function endRule() {
            if (textIndent &amp;&amp; direction !== &quot;ltr&quot;) {
                reporter.report(&quot;Negative text-indent doesn&#039;t work well with RTL. If you use text-indent for image replacement explicitly set direction for that item to ltr.&quot;, textIndent.line, textIndent.col, rule);
            }
        }

        parser.addListener(&quot;startrule&quot;, startRule);
        parser.addListener(&quot;startfontface&quot;, startRule);
        parser.addListener(&quot;property&quot;, function(event) {
            var name = event.property.toString().toLowerCase(),
                value = event.value;

            if (name === &quot;text-indent&quot; &amp;&amp; value.parts[0].value &lt; -99) {
                textIndent = event.property;
            } else if (name === &quot;direction&quot; &amp;&amp; value.toString() === &quot;ltr&quot;) {
                direction = &quot;ltr&quot;;
            }
        });

        parser.addListener(&quot;endrule&quot;, endRule);
        parser.addListener(&quot;endfontface&quot;, endRule);

    }

});

CSSLint.addRule({
    id: &quot;underscore-property-hack&quot;,
    name: &quot;Disallow properties with an underscore prefix&quot;,
    desc: &quot;Checks for the underscore property hack (targets IE6)&quot;,
    url: &quot;https://github.com/CSSLint/csslint/wiki/Disallow-underscore-hack&quot;,
    browsers: &quot;All&quot;,
    init: function(parser, reporter) {
        &quot;use strict&quot;;
        var rule = this;
        parser.addListener(&quot;property&quot;, function(event) {
            var property = event.property;

            if (property.hack === &quot;_&quot;) {
                reporter.report(&quot;Property with underscore prefix found.&quot;, event.property.line, event.property.col, rule);
            }
        });
    }
});

CSSLint.addRule({
    id: &quot;universal-selector&quot;,
    name: &quot;Disallow universal selector&quot;,
    desc: &quot;The universal selector (*) is known to be slow.&quot;,
    url: &quot;https://github.com/CSSLint/csslint/wiki/Disallow-universal-selector&quot;,
    browsers: &quot;All&quot;,
    init: function(parser, reporter) {
        &quot;use strict&quot;;
        var rule = this;

        parser.addListener(&quot;startrule&quot;, function(event) {
            var selectors = event.selectors,
                selector,
                part,
                i;

            for (i=0; i &lt; selectors.length; i++) {
                selector = selectors[i];

                part = selector.parts[selector.parts.length-1];
                if (part.elementName === &quot;*&quot;) {
                    reporter.report(rule.desc, part.line, part.col, rule);
                }
            }
        });
    }

});

CSSLint.addRule({
    id: &quot;unqualified-attributes&quot;,
    name: &quot;Disallow unqualified attribute selectors&quot;,
    desc: &quot;Unqualified attribute selectors are known to be slow.&quot;,
    url: &quot;https://github.com/CSSLint/csslint/wiki/Disallow-unqualified-attribute-selectors&quot;,
    browsers: &quot;All&quot;,
    init: function(parser, reporter) {
        &quot;use strict&quot;;

        var rule = this;

        parser.addListener(&quot;startrule&quot;, function(event) {

            var selectors = event.selectors,
                selectorContainsClassOrId = false,
                selector,
                part,
                modifier,
                i, k;

            for (i=0; i &lt; selectors.length; i++) {
                selector = selectors[i];

                part = selector.parts[selector.parts.length-1];
                if (part.type === parser.SELECTOR_PART_TYPE) {
                    for (k=0; k &lt; part.modifiers.length; k++) {
                        modifier = part.modifiers[k];

                        if (modifier.type === &quot;class&quot; || modifier.type === &quot;id&quot;) {
                            selectorContainsClassOrId = true;
                            break;
                        }
                    }

                    if (!selectorContainsClassOrId) {
                        for (k=0; k &lt; part.modifiers.length; k++) {
                            modifier = part.modifiers[k];
                            if (modifier.type === &quot;attribute&quot; &amp;&amp; (!part.elementName || part.elementName === &quot;*&quot;)) {
                                reporter.report(rule.desc, part.line, part.col, rule);
                            }
                        }
                    }
                }

            }
        });
    }

});

CSSLint.addRule({
    id: &quot;vendor-prefix&quot;,
    name: &quot;Require standard property with vendor prefix&quot;,
    desc: &quot;When using a vendor-prefixed property, make sure to include the standard one.&quot;,
    url: &quot;https://github.com/CSSLint/csslint/wiki/Require-standard-property-with-vendor-prefix&quot;,
    browsers: &quot;All&quot;,
    init: function(parser, reporter) {
        &quot;use strict&quot;;
        var rule = this,
            properties,
            num,
            propertiesToCheck = {
                &quot;-webkit-border-radius&quot;: &quot;border-radius&quot;,
                &quot;-webkit-border-top-left-radius&quot;: &quot;border-top-left-radius&quot;,
                &quot;-webkit-border-top-right-radius&quot;: &quot;border-top-right-radius&quot;,
                &quot;-webkit-border-bottom-left-radius&quot;: &quot;border-bottom-left-radius&quot;,
                &quot;-webkit-border-bottom-right-radius&quot;: &quot;border-bottom-right-radius&quot;,

                &quot;-o-border-radius&quot;: &quot;border-radius&quot;,
                &quot;-o-border-top-left-radius&quot;: &quot;border-top-left-radius&quot;,
                &quot;-o-border-top-right-radius&quot;: &quot;border-top-right-radius&quot;,
                &quot;-o-border-bottom-left-radius&quot;: &quot;border-bottom-left-radius&quot;,
                &quot;-o-border-bottom-right-radius&quot;: &quot;border-bottom-right-radius&quot;,

                &quot;-moz-border-radius&quot;: &quot;border-radius&quot;,
                &quot;-moz-border-radius-topleft&quot;: &quot;border-top-left-radius&quot;,
                &quot;-moz-border-radius-topright&quot;: &quot;border-top-right-radius&quot;,
                &quot;-moz-border-radius-bottomleft&quot;: &quot;border-bottom-left-radius&quot;,
                &quot;-moz-border-radius-bottomright&quot;: &quot;border-bottom-right-radius&quot;,

                &quot;-moz-column-count&quot;: &quot;column-count&quot;,
                &quot;-webkit-column-count&quot;: &quot;column-count&quot;,

                &quot;-moz-column-gap&quot;: &quot;column-gap&quot;,
                &quot;-webkit-column-gap&quot;: &quot;column-gap&quot;,

                &quot;-moz-column-rule&quot;: &quot;column-rule&quot;,
                &quot;-webkit-column-rule&quot;: &quot;column-rule&quot;,

                &quot;-moz-column-rule-style&quot;: &quot;column-rule-style&quot;,
                &quot;-webkit-column-rule-style&quot;: &quot;column-rule-style&quot;,

                &quot;-moz-column-rule-color&quot;: &quot;column-rule-color&quot;,
                &quot;-webkit-column-rule-color&quot;: &quot;column-rule-color&quot;,

                &quot;-moz-column-rule-width&quot;: &quot;column-rule-width&quot;,
                &quot;-webkit-column-rule-width&quot;: &quot;column-rule-width&quot;,

                &quot;-moz-column-width&quot;: &quot;column-width&quot;,
                &quot;-webkit-column-width&quot;: &quot;column-width&quot;,

                &quot;-webkit-column-span&quot;: &quot;column-span&quot;,
                &quot;-webkit-columns&quot;: &quot;columns&quot;,

                &quot;-moz-box-shadow&quot;: &quot;box-shadow&quot;,
                &quot;-webkit-box-shadow&quot;: &quot;box-shadow&quot;,

                &quot;-moz-transform&quot;: &quot;transform&quot;,
                &quot;-webkit-transform&quot;: &quot;transform&quot;,
                &quot;-o-transform&quot;: &quot;transform&quot;,
                &quot;-ms-transform&quot;: &quot;transform&quot;,

                &quot;-moz-transform-origin&quot;: &quot;transform-origin&quot;,
                &quot;-webkit-transform-origin&quot;: &quot;transform-origin&quot;,
                &quot;-o-transform-origin&quot;: &quot;transform-origin&quot;,
                &quot;-ms-transform-origin&quot;: &quot;transform-origin&quot;,

                &quot;-moz-box-sizing&quot;: &quot;box-sizing&quot;,
                &quot;-webkit-box-sizing&quot;: &quot;box-sizing&quot;
            };
        function startRule() {
            properties = {};
            num = 1;
        }
        function endRule() {
            var prop,
                i,
                len,
                needed,
                actual,
                needsStandard = [];

            for (prop in properties) {
                if (propertiesToCheck[prop]) {
                    needsStandard.push({
                        actual: prop,
                        needed: propertiesToCheck[prop]
                    });
                }
            }

            for (i=0, len=needsStandard.length; i &lt; len; i++) {
                needed = needsStandard[i].needed;
                actual = needsStandard[i].actual;

                if (!properties[needed]) {
                    reporter.report(&quot;Missing standard property &#039;&quot; + needed + &quot;&#039; to go along with &#039;&quot; + actual + &quot;&#039;.&quot;, properties[actual][0].name.line, properties[actual][0].name.col, rule);
                } else {
                    if (properties[needed][0].pos &lt; properties[actual][0].pos) {
                        reporter.report(&quot;Standard property &#039;&quot; + needed + &quot;&#039; should come after vendor-prefixed property &#039;&quot; + actual + &quot;&#039;.&quot;, properties[actual][0].name.line, properties[actual][0].name.col, rule);
                    }
                }
            }

        }

        parser.addListener(&quot;startrule&quot;, startRule);
        parser.addListener(&quot;startfontface&quot;, startRule);
        parser.addListener(&quot;startpage&quot;, startRule);
        parser.addListener(&quot;startpagemargin&quot;, startRule);
        parser.addListener(&quot;startkeyframerule&quot;, startRule);
        parser.addListener(&quot;startviewport&quot;, startRule);

        parser.addListener(&quot;property&quot;, function(event) {
            var name = event.property.text.toLowerCase();

            if (!properties[name]) {
                properties[name] = [];
            }

            properties[name].push({
                name: event.property,
                value: event.value,
                pos: num++
            });
        });

        parser.addListener(&quot;endrule&quot;, endRule);
        parser.addListener(&quot;endfontface&quot;, endRule);
        parser.addListener(&quot;endpage&quot;, endRule);
        parser.addListener(&quot;endpagemargin&quot;, endRule);
        parser.addListener(&quot;endkeyframerule&quot;, endRule);
        parser.addListener(&quot;endviewport&quot;, endRule);
    }

});

CSSLint.addRule({
    id: &quot;zero-units&quot;,
    name: &quot;Disallow units for 0 values&quot;,
    desc: &quot;You don&#039;t need to specify units when a value is 0.&quot;,
    url: &quot;https://github.com/CSSLint/csslint/wiki/Disallow-units-for-zero-values&quot;,
    browsers: &quot;All&quot;,
    init: function(parser, reporter) {
        &quot;use strict&quot;;
        var rule = this;
        parser.addListener(&quot;property&quot;, function(event) {
            var parts = event.value.parts,
                i = 0,
                len = parts.length;

            while (i &lt; len) {
                if ((parts[i].units || parts[i].type === &quot;percentage&quot;) &amp;&amp; parts[i].value === 0 &amp;&amp; parts[i].type !== &quot;time&quot;) {
                    reporter.report(&quot;Values of 0 shouldn&#039;t have units specified.&quot;, parts[i].line, parts[i].col, rule);
                }
                i++;
            }

        });

    }

});

(function() {
    &quot;use strict&quot;;
    var xmlEscape = function(str) {
        if (!str || str.constructor !== String) {
            return &quot;&quot;;
        }

        return str.replace(/[&quot;&amp;&gt;&lt;]/g, function(match) {
            switch (match) {
                case &quot;\&quot;&quot;:
                    return &quot;&amp;quot;&quot;;
                case &quot;&amp;&quot;:
                    return &quot;&amp;amp;&quot;;
                case &quot;&lt;&quot;:
                    return &quot;&amp;lt;&quot;;
                case &quot;&gt;&quot;:
                    return &quot;&amp;gt;&quot;;
            }
        });
    };

    CSSLint.addFormatter({
        id: &quot;checkstyle-xml&quot;,
        name: &quot;Checkstyle XML format&quot;,
        startFormat: function() {
            return &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&lt;checkstyle&gt;&quot;;
        },
        endFormat: function() {
            return &quot;&lt;/checkstyle&gt;&quot;;
        },
        readError: function(filename, message) {
            return &quot;&lt;file name=\&quot;&quot; + xmlEscape(filename) + &quot;\&quot;&gt;&lt;error line=\&quot;0\&quot; column=\&quot;0\&quot; severty=\&quot;error\&quot; message=\&quot;&quot; + xmlEscape(message) + &quot;\&quot;&gt;&lt;/error&gt;&lt;/file&gt;&quot;;
        },
        formatResults: function(results, filename/*, options*/) {
            var messages = results.messages,
                output = [];
            var generateSource = function(rule) {
                if (!rule || !(&quot;name&quot; in rule)) {
                    return &quot;&quot;;
                }
                return &quot;net.csslint.&quot; + rule.name.replace(/\s/g, &quot;&quot;);
            };


            if (messages.length &gt; 0) {
                output.push(&quot;&lt;file name=\&quot;&quot;+filename+&quot;\&quot;&gt;&quot;);
                CSSLint.Util.forEach(messages, function (message) {
                    if (!message.rollup) {
                        output.push(&quot;&lt;error line=\&quot;&quot; + message.line + &quot;\&quot; column=\&quot;&quot; + message.col + &quot;\&quot; severity=\&quot;&quot; + message.type + &quot;\&quot;&quot; +
                          &quot; message=\&quot;&quot; + xmlEscape(message.message) + &quot;\&quot; source=\&quot;&quot; + generateSource(message.rule) +&quot;\&quot;/&gt;&quot;);
                    }
                });
                output.push(&quot;&lt;/file&gt;&quot;);
            }

            return output.join(&quot;&quot;);
        }
    });

}());

CSSLint.addFormatter({
    id: &quot;compact&quot;,
    name: &quot;Compact, &#039;porcelain&#039; format&quot;,
    startFormat: function() {
        &quot;use strict&quot;;
        return &quot;&quot;;
    },
    endFormat: function() {
        &quot;use strict&quot;;
        return &quot;&quot;;
    },
    formatResults: function(results, filename, options) {
        &quot;use strict&quot;;
        var messages = results.messages,
            output = &quot;&quot;;
        options = options || {};
        var capitalize = function(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        };

        if (messages.length === 0) {
            return options.quiet ? &quot;&quot; : filename + &quot;: Lint Free!&quot;;
        }

        CSSLint.Util.forEach(messages, function(message) {
            if (message.rollup) {
                output += filename + &quot;: &quot; + capitalize(message.type) + &quot; - &quot; + message.message + &quot; (&quot; + message.rule.id + &quot;)\n&quot;;
            } else {
                output += filename + &quot;: line &quot; + message.line +
                    &quot;, col &quot; + message.col + &quot;, &quot; + capitalize(message.type) + &quot; - &quot; + message.message + &quot; (&quot; + message.rule.id + &quot;)\n&quot;;
            }
        });

        return output;
    }
});

CSSLint.addFormatter({
    id: &quot;csslint-xml&quot;,
    name: &quot;CSSLint XML format&quot;,
    startFormat: function() {
        &quot;use strict&quot;;
        return &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&lt;csslint&gt;&quot;;
    },
    endFormat: function() {
        &quot;use strict&quot;;
        return &quot;&lt;/csslint&gt;&quot;;
    },
    formatResults: function(results, filename/*, options*/) {
        &quot;use strict&quot;;
        var messages = results.messages,
            output = [];
        var escapeSpecialCharacters = function(str) {
            if (!str || str.constructor !== String) {
                return &quot;&quot;;
            }
            return str.replace(/&quot;/g, &quot;&#039;&quot;).replace(/&amp;/g, &quot;&amp;amp;&quot;).replace(/&lt;/g, &quot;&amp;lt;&quot;).replace(/&gt;/g, &quot;&amp;gt;&quot;);
        };

        if (messages.length &gt; 0) {
            output.push(&quot;&lt;file name=\&quot;&quot;+filename+&quot;\&quot;&gt;&quot;);
            CSSLint.Util.forEach(messages, function (message) {
                if (message.rollup) {
                    output.push(&quot;&lt;issue severity=\&quot;&quot; + message.type + &quot;\&quot; reason=\&quot;&quot; + escapeSpecialCharacters(message.message) + &quot;\&quot; evidence=\&quot;&quot; + escapeSpecialCharacters(message.evidence) + &quot;\&quot;/&gt;&quot;);
                } else {
                    output.push(&quot;&lt;issue line=\&quot;&quot; + message.line + &quot;\&quot; char=\&quot;&quot; + message.col + &quot;\&quot; severity=\&quot;&quot; + message.type + &quot;\&quot;&quot; +
                        &quot; reason=\&quot;&quot; + escapeSpecialCharacters(message.message) + &quot;\&quot; evidence=\&quot;&quot; + escapeSpecialCharacters(message.evidence) + &quot;\&quot;/&gt;&quot;);
                }
            });
            output.push(&quot;&lt;/file&gt;&quot;);
        }

        return output.join(&quot;&quot;);
    }
});

CSSLint.addFormatter({
    id: &quot;json&quot;,
    name: &quot;JSON&quot;,
    startFormat: function() {
        &quot;use strict&quot;;
        this.json = [];
        return &quot;&quot;;
    },
    endFormat: function() {
        &quot;use strict&quot;;
        var ret = &quot;&quot;;
        if (this.json.length &gt; 0) {
            if (this.json.length === 1) {
                ret = JSON.stringify(this.json[0]);
            } else {
                ret = JSON.stringify(this.json);
            }
        }
        return ret;
    },
    formatResults: function(results, filename, options) {
        &quot;use strict&quot;;
        if (results.messages.length &gt; 0 || !options.quiet) {
            this.json.push({
                filename: filename,
                messages: results.messages,
                stats: results.stats
            });
        }
        return &quot;&quot;;
    }
});

CSSLint.addFormatter({
    id: &quot;junit-xml&quot;,
    name: &quot;JUNIT XML format&quot;,
    startFormat: function() {
        &quot;use strict&quot;;
        return &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&lt;testsuites&gt;&quot;;
    },
    endFormat: function() {
        &quot;use strict&quot;;
        return &quot;&lt;/testsuites&gt;&quot;;
    },
    formatResults: function(results, filename/*, options*/) {
        &quot;use strict&quot;;

        var messages = results.messages,
            output = [],
            tests = {
                &quot;error&quot;: 0,
                &quot;failure&quot;: 0
            };
        var generateSource = function(rule) {
            if (!rule || !(&quot;name&quot; in rule)) {
                return &quot;&quot;;
            }
            return &quot;net.csslint.&quot; + rule.name.replace(/\s/g, &quot;&quot;);
        };
        var escapeSpecialCharacters = function(str) {

            if (!str || str.constructor !== String) {
                return &quot;&quot;;
            }

            return str.replace(/&quot;/g, &quot;&#039;&quot;).replace(/&lt;/g, &quot;&amp;lt;&quot;).replace(/&gt;/g, &quot;&amp;gt;&quot;);

        };

        if (messages.length &gt; 0) {

            messages.forEach(function (message) {
                var type = message.type === &quot;warning&quot; ? &quot;error&quot; : message.type;
                if (!message.rollup) {
                    output.push(&quot;&lt;testcase time=\&quot;0\&quot; name=\&quot;&quot; + generateSource(message.rule) + &quot;\&quot;&gt;&quot;);
                    output.push(&quot;&lt;&quot; + type + &quot; message=\&quot;&quot; + escapeSpecialCharacters(message.message) + &quot;\&quot;&gt;&lt;![CDATA[&quot; + message.line + &quot;:&quot; + message.col + &quot;:&quot; + escapeSpecialCharacters(message.evidence) + &quot;]]&gt;&lt;/&quot; + type + &quot;&gt;&quot;);
                    output.push(&quot;&lt;/testcase&gt;&quot;);

                    tests[type] += 1;

                }

            });

            output.unshift(&quot;&lt;testsuite time=\&quot;0\&quot; tests=\&quot;&quot; + messages.length + &quot;\&quot; skipped=\&quot;0\&quot; errors=\&quot;&quot; + tests.error + &quot;\&quot; failures=\&quot;&quot; + tests.failure + &quot;\&quot; package=\&quot;net.csslint\&quot; name=\&quot;&quot; + filename + &quot;\&quot;&gt;&quot;);
            output.push(&quot;&lt;/testsuite&gt;&quot;);

        }

        return output.join(&quot;&quot;);

    }
});

CSSLint.addFormatter({
    id: &quot;lint-xml&quot;,
    name: &quot;Lint XML format&quot;,
    startFormat: function() {
        &quot;use strict&quot;;
        return &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&lt;lint&gt;&quot;;
    },
    endFormat: function() {
        &quot;use strict&quot;;
        return &quot;&lt;/lint&gt;&quot;;
    },
    formatResults: function(results, filename/*, options*/) {
        &quot;use strict&quot;;
        var messages = results.messages,
            output = [];
        var escapeSpecialCharacters = function(str) {
            if (!str || str.constructor !== String) {
                return &quot;&quot;;
            }
            return str.replace(/&quot;/g, &quot;&#039;&quot;).replace(/&amp;/g, &quot;&amp;amp;&quot;).replace(/&lt;/g, &quot;&amp;lt;&quot;).replace(/&gt;/g, &quot;&amp;gt;&quot;);
        };

        if (messages.length &gt; 0) {

            output.push(&quot;&lt;file name=\&quot;&quot;+filename+&quot;\&quot;&gt;&quot;);
            CSSLint.Util.forEach(messages, function (message) {
                if (message.rollup) {
                    output.push(&quot;&lt;issue severity=\&quot;&quot; + message.type + &quot;\&quot; reason=\&quot;&quot; + escapeSpecialCharacters(message.message) + &quot;\&quot; evidence=\&quot;&quot; + escapeSpecialCharacters(message.evidence) + &quot;\&quot;/&gt;&quot;);
                } else {
                    var rule = &quot;&quot;;
                    if (message.rule &amp;&amp; message.rule.id) {
                        rule = &quot;rule=\&quot;&quot; + escapeSpecialCharacters(message.rule.id) + &quot;\&quot; &quot;;
                    }
                    output.push(&quot;&lt;issue &quot; + rule + &quot;line=\&quot;&quot; + message.line + &quot;\&quot; char=\&quot;&quot; + message.col + &quot;\&quot; severity=\&quot;&quot; + message.type + &quot;\&quot;&quot; +
                        &quot; reason=\&quot;&quot; + escapeSpecialCharacters(message.message) + &quot;\&quot; evidence=\&quot;&quot; + escapeSpecialCharacters(message.evidence) + &quot;\&quot;/&gt;&quot;);
                }
            });
            output.push(&quot;&lt;/file&gt;&quot;);
        }

        return output.join(&quot;&quot;);
    }
});

CSSLint.addFormatter({
    id: &quot;text&quot;,
    name: &quot;Plain Text&quot;,
    startFormat: function() {
        &quot;use strict&quot;;
        return &quot;&quot;;
    },
    endFormat: function() {
        &quot;use strict&quot;;
        return &quot;&quot;;
    },
    formatResults: function(results, filename, options) {
        &quot;use strict&quot;;
        var messages = results.messages,
            output = &quot;&quot;;
        options = options || {};

        if (messages.length === 0) {
            return options.quiet ? &quot;&quot; : &quot;\n\ncsslint: No errors in &quot; + filename + &quot;.&quot;;
        }

        output = &quot;\n\ncsslint: There &quot;;
        if (messages.length === 1) {
            output += &quot;is 1 problem&quot;;
        } else {
            output += &quot;are &quot; + messages.length + &quot; problems&quot;;
        }
        output += &quot; in &quot; + filename + &quot;.&quot;;

        var pos = filename.lastIndexOf(&quot;/&quot;),
            shortFilename = filename;

        if (pos === -1) {
            pos = filename.lastIndexOf(&quot;\\&quot;);
        }
        if (pos &gt; -1) {
            shortFilename = filename.substring(pos+1);
        }

        CSSLint.Util.forEach(messages, function (message, i) {
            output = output + &quot;\n\n&quot; + shortFilename;
            if (message.rollup) {
                output += &quot;\n&quot; + (i+1) + &quot;: &quot; + message.type;
                output += &quot;\n&quot; + message.message;
            } else {
                output += &quot;\n&quot; + (i+1) + &quot;: &quot; + message.type + &quot; at line &quot; + message.line + &quot;, col &quot; + message.col;
                output += &quot;\n&quot; + message.message;
                output += &quot;\n&quot; + message.evidence;
            }
        });

        return output;
    }
});

return CSSLint;
})();


module.exports.CSSLint = CSSLint;

});

define(&quot;ace/mode/css_worker&quot;,[], function(require, exports, module) {
&quot;use strict&quot;;

var oop = require(&quot;../lib/oop&quot;);
var lang = require(&quot;../lib/lang&quot;);
var Mirror = require(&quot;../worker/mirror&quot;).Mirror;
var CSSLint = require(&quot;./css/csslint&quot;).CSSLint;

var Worker = exports.Worker = function(sender) {
    Mirror.call(this, sender);
    this.setTimeout(400);
    this.ruleset = null;
    this.setDisabledRules(&quot;ids|order-alphabetical&quot;);
    this.setInfoRules(
      &quot;adjoining-classes|zero-units|gradients|box-model|&quot; +
      &quot;import|outline-none|vendor-prefix&quot;
    );
};

oop.inherits(Worker, Mirror);

(function() {
    this.setInfoRules = function(ruleNames) {
        if (typeof ruleNames == &quot;string&quot;)
            ruleNames = ruleNames.split(&quot;|&quot;);
        this.infoRules = lang.arrayToMap(ruleNames);
        this.doc.getValue() &amp;&amp; this.deferredUpdate.schedule(100);
    };

    this.setDisabledRules = function(ruleNames) {
        if (!ruleNames) {
            this.ruleset = null;
        } else {
            if (typeof ruleNames == &quot;string&quot;)
                ruleNames = ruleNames.split(&quot;|&quot;);
            var all = {};

            CSSLint.getRules().forEach(function(x){
                all[x.id] = true;
            });
            ruleNames.forEach(function(x) {
                delete all[x];
            });
            
            this.ruleset = all;
        }
        this.doc.getValue() &amp;&amp; this.deferredUpdate.schedule(100);
    };

    this.onUpdate = function() {
        var value = this.doc.getValue();
        if (!value)
            return this.sender.emit(&quot;annotate&quot;, []);
        var infoRules = this.infoRules;

        var result = CSSLint.verify(value, this.ruleset);
        this.sender.emit(&quot;annotate&quot;, result.messages.map(function(msg) {
            return {
                row: msg.line - 1,
                column: msg.col - 1,
                text: msg.message,
                type: infoRules[msg.rule.id] ? &quot;info&quot; : msg.type,
                rule: msg.rule.name
            };
        }));
    };

}).call(Worker.prototype);

});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
