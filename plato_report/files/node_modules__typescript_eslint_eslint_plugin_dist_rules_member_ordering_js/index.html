<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@typescript-eslint/eslint-plugin/dist/rules/member-ordering.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@typescript-eslint/eslint-plugin/dist/rules/member-ordering.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">64.86</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">752</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">70.35</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.09</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
var __createBinding = (this &amp;&amp; this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (&quot;get&quot; in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this &amp;&amp; this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, &quot;default&quot;, { enumerable: true, value: v });
}) : function(o, v) {
    o[&quot;default&quot;] = v;
});
var __importStar = (this &amp;&amp; this.__importStar) || function (mod) {
    if (mod &amp;&amp; mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== &quot;default&quot; &amp;&amp; Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) {
    return (mod &amp;&amp; mod.__esModule) ? mod : { &quot;default&quot;: mod };
};
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
exports.defaultOrder = void 0;
const utils_1 = require(&quot;@typescript-eslint/utils&quot;);
const natural_compare_lite_1 = __importDefault(require(&quot;natural-compare-lite&quot;));
const util = __importStar(require(&quot;../util&quot;));
const neverConfig = {
    type: &#039;string&#039;,
    enum: [&#039;never&#039;],
};
const arrayConfig = (memberTypes) =&gt; ({
    type: &#039;array&#039;,
    items: {
        oneOf: [
            {
                enum: memberTypes,
            },
            {
                type: &#039;array&#039;,
                items: {
                    enum: memberTypes,
                },
            },
        ],
    },
});
const objectConfig = (memberTypes) =&gt; ({
    type: &#039;object&#039;,
    properties: {
        memberTypes: {
            oneOf: [arrayConfig(memberTypes), neverConfig],
        },
        order: {
            type: &#039;string&#039;,
            enum: [
                &#039;alphabetically&#039;,
                &#039;alphabetically-case-insensitive&#039;,
                &#039;as-written&#039;,
                &#039;natural&#039;,
                &#039;natural-case-insensitive&#039;,
            ],
        },
        optionalityOrder: {
            type: &#039;string&#039;,
            enum: [&#039;optional-first&#039;, &#039;required-first&#039;],
        },
    },
    additionalProperties: false,
});
exports.defaultOrder = [
    // Index signature
    &#039;signature&#039;,
    &#039;call-signature&#039;,
    // Fields
    &#039;public-static-field&#039;,
    &#039;protected-static-field&#039;,
    &#039;private-static-field&#039;,
    &#039;#private-static-field&#039;,
    &#039;public-decorated-field&#039;,
    &#039;protected-decorated-field&#039;,
    &#039;private-decorated-field&#039;,
    &#039;public-instance-field&#039;,
    &#039;protected-instance-field&#039;,
    &#039;private-instance-field&#039;,
    &#039;#private-instance-field&#039;,
    &#039;public-abstract-field&#039;,
    &#039;protected-abstract-field&#039;,
    &#039;public-field&#039;,
    &#039;protected-field&#039;,
    &#039;private-field&#039;,
    &#039;#private-field&#039;,
    &#039;static-field&#039;,
    &#039;instance-field&#039;,
    &#039;abstract-field&#039;,
    &#039;decorated-field&#039;,
    &#039;field&#039;,
    // Static initialization
    &#039;static-initialization&#039;,
    // Constructors
    &#039;public-constructor&#039;,
    &#039;protected-constructor&#039;,
    &#039;private-constructor&#039;,
    &#039;constructor&#039;,
    // Getters
    &#039;public-static-get&#039;,
    &#039;protected-static-get&#039;,
    &#039;private-static-get&#039;,
    &#039;#private-static-get&#039;,
    &#039;public-decorated-get&#039;,
    &#039;protected-decorated-get&#039;,
    &#039;private-decorated-get&#039;,
    &#039;public-instance-get&#039;,
    &#039;protected-instance-get&#039;,
    &#039;private-instance-get&#039;,
    &#039;#private-instance-get&#039;,
    &#039;public-abstract-get&#039;,
    &#039;protected-abstract-get&#039;,
    &#039;public-get&#039;,
    &#039;protected-get&#039;,
    &#039;private-get&#039;,
    &#039;#private-get&#039;,
    &#039;static-get&#039;,
    &#039;instance-get&#039;,
    &#039;abstract-get&#039;,
    &#039;decorated-get&#039;,
    &#039;get&#039;,
    // Setters
    &#039;public-static-set&#039;,
    &#039;protected-static-set&#039;,
    &#039;private-static-set&#039;,
    &#039;#private-static-set&#039;,
    &#039;public-decorated-set&#039;,
    &#039;protected-decorated-set&#039;,
    &#039;private-decorated-set&#039;,
    &#039;public-instance-set&#039;,
    &#039;protected-instance-set&#039;,
    &#039;private-instance-set&#039;,
    &#039;#private-instance-set&#039;,
    &#039;public-abstract-set&#039;,
    &#039;protected-abstract-set&#039;,
    &#039;public-set&#039;,
    &#039;protected-set&#039;,
    &#039;private-set&#039;,
    &#039;#private-set&#039;,
    &#039;static-set&#039;,
    &#039;instance-set&#039;,
    &#039;abstract-set&#039;,
    &#039;decorated-set&#039;,
    &#039;set&#039;,
    // Methods
    &#039;public-static-method&#039;,
    &#039;protected-static-method&#039;,
    &#039;private-static-method&#039;,
    &#039;#private-static-method&#039;,
    &#039;public-decorated-method&#039;,
    &#039;protected-decorated-method&#039;,
    &#039;private-decorated-method&#039;,
    &#039;public-instance-method&#039;,
    &#039;protected-instance-method&#039;,
    &#039;private-instance-method&#039;,
    &#039;#private-instance-method&#039;,
    &#039;public-abstract-method&#039;,
    &#039;protected-abstract-method&#039;,
    &#039;public-method&#039;,
    &#039;protected-method&#039;,
    &#039;private-method&#039;,
    &#039;#private-method&#039;,
    &#039;static-method&#039;,
    &#039;instance-method&#039;,
    &#039;abstract-method&#039;,
    &#039;decorated-method&#039;,
    &#039;method&#039;,
];
const allMemberTypes = Array.from([
    &#039;readonly-signature&#039;,
    &#039;signature&#039;,
    &#039;readonly-field&#039;,
    &#039;field&#039;,
    &#039;method&#039;,
    &#039;call-signature&#039;,
    &#039;constructor&#039;,
    &#039;get&#039;,
    &#039;set&#039;,
    &#039;static-initialization&#039;,
].reduce((all, type) =&gt; {
    all.add(type);
    [&#039;public&#039;, &#039;protected&#039;, &#039;private&#039;, &#039;#private&#039;].forEach(accessibility =&gt; {
        if (type !== &#039;readonly-signature&#039; &amp;&amp;
            type !== &#039;signature&#039; &amp;&amp;
            type !== &#039;static-initialization&#039; &amp;&amp;
            type !== &#039;call-signature&#039; &amp;&amp;
            !(type === &#039;constructor&#039; &amp;&amp; accessibility === &#039;#private&#039;)) {
            all.add(`${accessibility}-${type}`); // e.g. `public-field`
        }
        // Only class instance fields, methods, get and set can have decorators attached to them
        if (accessibility !== &#039;#private&#039; &amp;&amp;
            (type === &#039;readonly-field&#039; ||
                type === &#039;field&#039; ||
                type === &#039;method&#039; ||
                type === &#039;get&#039; ||
                type === &#039;set&#039;)) {
            all.add(`${accessibility}-decorated-${type}`);
            all.add(`decorated-${type}`);
        }
        if (type !== &#039;constructor&#039; &amp;&amp;
            type !== &#039;readonly-signature&#039; &amp;&amp;
            type !== &#039;signature&#039; &amp;&amp;
            type !== &#039;call-signature&#039;) {
            // There is no `static-constructor` or `instance-constructor` or `abstract-constructor`
            if (accessibility === &#039;#private&#039; || accessibility === &#039;private&#039;) {
                [&#039;static&#039;, &#039;instance&#039;].forEach(scope =&gt; {
                    all.add(`${scope}-${type}`);
                    all.add(`${accessibility}-${scope}-${type}`);
                });
            }
            else {
                [&#039;static&#039;, &#039;instance&#039;, &#039;abstract&#039;].forEach(scope =&gt; {
                    all.add(`${scope}-${type}`);
                    all.add(`${accessibility}-${scope}-${type}`);
                });
            }
        }
    });
    return all;
}, new Set()));
const functionExpressions = [
    utils_1.AST_NODE_TYPES.FunctionExpression,
    utils_1.AST_NODE_TYPES.ArrowFunctionExpression,
];
/**
 * Gets the node type.
 *
 * @param node the node to be evaluated.
 */
function getNodeType(node) {
    switch (node.type) {
        case utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition:
        case utils_1.AST_NODE_TYPES.MethodDefinition:
            return node.kind;
        case utils_1.AST_NODE_TYPES.TSMethodSignature:
            return &#039;method&#039;;
        case utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration:
            return &#039;call-signature&#039;;
        case utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration:
            return &#039;constructor&#039;;
        case utils_1.AST_NODE_TYPES.TSAbstractPropertyDefinition:
            return node.readonly ? &#039;readonly-field&#039; : &#039;field&#039;;
        case utils_1.AST_NODE_TYPES.PropertyDefinition:
            return node.value &amp;&amp; functionExpressions.includes(node.value.type)
                ? &#039;method&#039;
                : node.readonly
                    ? &#039;readonly-field&#039;
                    : &#039;field&#039;;
        case utils_1.AST_NODE_TYPES.TSPropertySignature:
            return node.readonly ? &#039;readonly-field&#039; : &#039;field&#039;;
        case utils_1.AST_NODE_TYPES.TSIndexSignature:
            return node.readonly ? &#039;readonly-signature&#039; : &#039;signature&#039;;
        case utils_1.AST_NODE_TYPES.StaticBlock:
            return &#039;static-initialization&#039;;
        default:
            return null;
    }
}
/**
 * Gets the raw string value of a member&#039;s name
 */
function getMemberRawName(member, sourceCode) {
    const { name, type } = util.getNameFromMember(member, sourceCode);
    if (type === util.MemberNameType.Quoted) {
        return name.slice(1, -1);
    }
    if (type === util.MemberNameType.Private) {
        return name.slice(1);
    }
    return name;
}
/**
 * Gets the member name based on the member type.
 *
 * @param node the node to be evaluated.
 * @param sourceCode
 */
function getMemberName(node, sourceCode) {
    switch (node.type) {
        case utils_1.AST_NODE_TYPES.TSPropertySignature:
        case utils_1.AST_NODE_TYPES.TSMethodSignature:
        case utils_1.AST_NODE_TYPES.TSAbstractPropertyDefinition:
        case utils_1.AST_NODE_TYPES.PropertyDefinition:
            return getMemberRawName(node, sourceCode);
        case utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition:
        case utils_1.AST_NODE_TYPES.MethodDefinition:
            return node.kind === &#039;constructor&#039;
                ? &#039;constructor&#039;
                : getMemberRawName(node, sourceCode);
        case utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration:
            return &#039;new&#039;;
        case utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration:
            return &#039;call&#039;;
        case utils_1.AST_NODE_TYPES.TSIndexSignature:
            return util.getNameFromIndexSignature(node);
        case utils_1.AST_NODE_TYPES.StaticBlock:
            return &#039;static block&#039;;
        default:
            return null;
    }
}
/**
 * Returns true if the member is optional based on the member type.
 *
 * @param node the node to be evaluated.
 *
 * @returns Whether the member is optional, or false if it cannot be optional at all.
 */
function isMemberOptional(node) {
    switch (node.type) {
        case utils_1.AST_NODE_TYPES.TSPropertySignature:
        case utils_1.AST_NODE_TYPES.TSMethodSignature:
        case utils_1.AST_NODE_TYPES.TSAbstractPropertyDefinition:
        case utils_1.AST_NODE_TYPES.PropertyDefinition:
        case utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition:
        case utils_1.AST_NODE_TYPES.MethodDefinition:
            return !!node.optional;
    }
    return false;
}
/**
 * Gets the calculated rank using the provided method definition.
 * The algorithm is as follows:
 * - Get the rank based on the accessibility-scope-type name, e.g. public-instance-field
 * - If there is no order for accessibility-scope-type, then strip out the accessibility.
 * - If there is no order for scope-type, then strip out the scope.
 * - If there is no order for type, then return -1
 * @param memberGroups the valid names to be validated.
 * @param orderConfig the current order to be validated.
 *
 * @return Index of the matching member type in the order configuration.
 */
function getRankOrder(memberGroups, orderConfig) {
    let rank = -1;
    const stack = memberGroups.slice(); // Get a copy of the member groups
    while (stack.length &gt; 0 &amp;&amp; rank === -1) {
        const memberGroup = stack.shift();
        rank = orderConfig.findIndex(memberType =&gt; Array.isArray(memberType)
            ? memberType.includes(memberGroup)
            : memberType === memberGroup);
    }
    return rank;
}
function getAccessibility(node) {
    var _a;
    if (&#039;accessibility&#039; in node &amp;&amp; node.accessibility) {
        return node.accessibility;
    }
    if (&#039;key&#039; in node &amp;&amp; ((_a = node.key) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.PrivateIdentifier) {
        return &#039;#private&#039;;
    }
    return &#039;public&#039;;
}
/**
 * Gets the rank of the node given the order.
 * @param node the node to be evaluated.
 * @param orderConfig the current order to be validated.
 * @param supportsModifiers a flag indicating whether the type supports modifiers (scope or accessibility) or not.
 */
function getRank(node, orderConfig, supportsModifiers) {
    const type = getNodeType(node);
    if (type == null) {
        // shouldn&#039;t happen but just in case, put it on the end
        return orderConfig.length - 1;
    }
    const abstract = node.type === utils_1.AST_NODE_TYPES.TSAbstractPropertyDefinition ||
        node.type === utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition;
    const scope = &#039;static&#039; in node &amp;&amp; node.static
        ? &#039;static&#039;
        : abstract
            ? &#039;abstract&#039;
            : &#039;instance&#039;;
    const accessibility = getAccessibility(node);
    // Collect all existing member groups that apply to this node...
    // (e.g. &#039;public-instance-field&#039;, &#039;instance-field&#039;, &#039;public-field&#039;, &#039;constructor&#039; etc.)
    const memberGroups = [];
    if (supportsModifiers) {
        const decorated = &#039;decorators&#039; in node &amp;&amp; node.decorators.length &gt; 0;
        if (decorated &amp;&amp;
            (type === &#039;readonly-field&#039; ||
                type === &#039;field&#039; ||
                type === &#039;method&#039; ||
                type === &#039;get&#039; ||
                type === &#039;set&#039;)) {
            memberGroups.push(`${accessibility}-decorated-${type}`);
            memberGroups.push(`decorated-${type}`);
            if (type === &#039;readonly-field&#039;) {
                memberGroups.push(`${accessibility}-decorated-field`);
                memberGroups.push(`decorated-field`);
            }
        }
        if (type !== &#039;readonly-signature&#039; &amp;&amp;
            type !== &#039;signature&#039; &amp;&amp;
            type !== &#039;static-initialization&#039;) {
            if (type !== &#039;constructor&#039;) {
                // Constructors have no scope
                memberGroups.push(`${accessibility}-${scope}-${type}`);
                memberGroups.push(`${scope}-${type}`);
                if (type === &#039;readonly-field&#039;) {
                    memberGroups.push(`${accessibility}-${scope}-field`);
                    memberGroups.push(`${scope}-field`);
                }
            }
            memberGroups.push(`${accessibility}-${type}`);
            if (type === &#039;readonly-field&#039;) {
                memberGroups.push(`${accessibility}-field`);
            }
        }
    }
    memberGroups.push(type);
    if (type === &#039;readonly-signature&#039;) {
        memberGroups.push(&#039;signature&#039;);
    }
    else if (type === &#039;readonly-field&#039;) {
        memberGroups.push(&#039;field&#039;);
    }
    // ...then get the rank order for those member groups based on the node
    return getRankOrder(memberGroups, orderConfig);
}
/**
 * Gets the lowest possible rank(s) higher than target.
 * e.g. given the following order:
 *   ...
 *   public-static-method
 *   protected-static-method
 *   private-static-method
 *   public-instance-method
 *   protected-instance-method
 *   private-instance-method
 *   ...
 * and considering that a public-instance-method has already been declared, so ranks contains
 * public-instance-method, then the lowest possible rank for public-static-method is
 * public-instance-method.
 * If a lowest possible rank is a member group, a comma separated list of ranks is returned.
 * @param ranks the existing ranks in the object.
 * @param target the target rank.
 * @param order the current order to be validated.
 * @returns the name(s) of the lowest possible rank without dashes (-).
 */
function getLowestRank(ranks, target, order) {
    let lowest = ranks[ranks.length - 1];
    ranks.forEach(rank =&gt; {
        if (rank &gt; target) {
            lowest = Math.min(lowest, rank);
        }
    });
    const lowestRank = order[lowest];
    const lowestRanks = Array.isArray(lowestRank) ? lowestRank : [lowestRank];
    return lowestRanks.map(rank =&gt; rank.replace(/-/g, &#039; &#039;)).join(&#039;, &#039;);
}
exports.default = util.createRule({
    name: &#039;member-ordering&#039;,
    meta: {
        type: &#039;suggestion&#039;,
        docs: {
            description: &#039;Require a consistent member declaration order&#039;,
            recommended: false,
        },
        messages: {
            incorrectOrder: &#039;Member {{member}} should be declared before member {{beforeMember}}.&#039;,
            incorrectGroupOrder: &#039;Member {{name}} should be declared before all {{rank}} definitions.&#039;,
            incorrectRequiredMembersOrder: `Member {{member}} should be declared after all {{optionalOrRequired}} members.`,
        },
        schema: [
            {
                type: &#039;object&#039;,
                properties: {
                    default: {
                        oneOf: [
                            neverConfig,
                            arrayConfig(allMemberTypes),
                            objectConfig(allMemberTypes),
                        ],
                    },
                    classes: {
                        oneOf: [
                            neverConfig,
                            arrayConfig(allMemberTypes),
                            objectConfig(allMemberTypes),
                        ],
                    },
                    classExpressions: {
                        oneOf: [
                            neverConfig,
                            arrayConfig(allMemberTypes),
                            objectConfig(allMemberTypes),
                        ],
                    },
                    interfaces: {
                        oneOf: [
                            neverConfig,
                            arrayConfig([
                                &#039;readonly-signature&#039;,
                                &#039;signature&#039;,
                                &#039;readonly-field&#039;,
                                &#039;field&#039;,
                                &#039;method&#039;,
                                &#039;constructor&#039;,
                            ]),
                            objectConfig([
                                &#039;readonly-signature&#039;,
                                &#039;signature&#039;,
                                &#039;readonly-field&#039;,
                                &#039;field&#039;,
                                &#039;method&#039;,
                                &#039;constructor&#039;,
                            ]),
                        ],
                    },
                    typeLiterals: {
                        oneOf: [
                            neverConfig,
                            arrayConfig([
                                &#039;readonly-signature&#039;,
                                &#039;signature&#039;,
                                &#039;readonly-field&#039;,
                                &#039;field&#039;,
                                &#039;method&#039;,
                                &#039;constructor&#039;,
                            ]),
                            objectConfig([
                                &#039;readonly-signature&#039;,
                                &#039;signature&#039;,
                                &#039;readonly-field&#039;,
                                &#039;field&#039;,
                                &#039;method&#039;,
                                &#039;constructor&#039;,
                            ]),
                        ],
                    },
                },
                additionalProperties: false,
            },
        ],
    },
    defaultOptions: [
        {
            default: exports.defaultOrder,
        },
    ],
    create(context, [options]) {
        /**
         * Checks if the member groups are correctly sorted.
         *
         * @param members Members to be validated.
         * @param groupOrder Group order to be validated.
         * @param supportsModifiers A flag indicating whether the type supports modifiers (scope or accessibility) or not.
         *
         * @return Array of member groups or null if one of the groups is not correctly sorted.
         */
        function checkGroupSort(members, groupOrder, supportsModifiers) {
            const previousRanks = [];
            const memberGroups = [];
            let isCorrectlySorted = true;
            // Find first member which isn&#039;t correctly sorted
            members.forEach(member =&gt; {
                const rank = getRank(member, groupOrder, supportsModifiers);
                const name = getMemberName(member, context.getSourceCode());
                const rankLastMember = previousRanks[previousRanks.length - 1];
                if (rank === -1) {
                    return;
                }
                // Works for 1st item because x &lt; undefined === false for any x (typeof string)
                if (rank &lt; rankLastMember) {
                    context.report({
                        node: member,
                        messageId: &#039;incorrectGroupOrder&#039;,
                        data: {
                            name,
                            rank: getLowestRank(previousRanks, rank, groupOrder),
                        },
                    });
                    isCorrectlySorted = false;
                }
                else if (rank === rankLastMember) {
                    // Same member group --&gt; Push to existing member group array
                    memberGroups[memberGroups.length - 1].push(member);
                }
                else {
                    // New member group --&gt; Create new member group array
                    previousRanks.push(rank);
                    memberGroups.push([member]);
                }
            });
            return isCorrectlySorted ? memberGroups : null;
        }
        /**
         * Checks if the members are alphabetically sorted.
         *
         * @param members Members to be validated.
         * @param caseSensitive indicates if the alpha ordering is case sensitive or not.
         *
         * @return True if all members are correctly sorted.
         */
        function checkAlphaSort(members, order) {
            let previousName = &#039;&#039;;
            let isCorrectlySorted = true;
            // Find first member which isn&#039;t correctly sorted
            members.forEach(member =&gt; {
                const name = getMemberName(member, context.getSourceCode());
                // Note: Not all members have names
                if (name) {
                    if (naturalOutOfOrder(name, previousName, order)) {
                        context.report({
                            node: member,
                            messageId: &#039;incorrectOrder&#039;,
                            data: {
                                member: name,
                                beforeMember: previousName,
                            },
                        });
                        isCorrectlySorted = false;
                    }
                    previousName = name;
                }
            });
            return isCorrectlySorted;
        }
        function naturalOutOfOrder(name, previousName, order) {
            switch (order) {
                case &#039;alphabetically&#039;:
                    return name &lt; previousName;
                case &#039;alphabetically-case-insensitive&#039;:
                    return name.toLowerCase() &lt; previousName.toLowerCase();
                case &#039;natural&#039;:
                    return (0, natural_compare_lite_1.default)(name, previousName) !== 1;
                case &#039;natural-case-insensitive&#039;:
                    return ((0, natural_compare_lite_1.default)(name.toLowerCase(), previousName.toLowerCase()) !== 1);
            }
        }
        /**
         * Checks if the order of optional and required members is correct based
         * on the given &#039;required&#039; parameter.
         *
         * @param members Members to be validated.
         * @param optionalityOrder Where to place optional members, if not intermixed.
         *
         * @return True if all required and optional members are correctly sorted.
         */
        function checkRequiredOrder(members, optionalityOrder) {
            const switchIndex = members.findIndex((member, i) =&gt; i &amp;&amp; isMemberOptional(member) !== isMemberOptional(members[i - 1]));
            const report = (member) =&gt; context.report({
                messageId: &#039;incorrectRequiredMembersOrder&#039;,
                loc: member.loc,
                data: {
                    member: getMemberName(member, context.getSourceCode()),
                    optionalOrRequired: optionalityOrder === &#039;required-first&#039; ? &#039;required&#039; : &#039;optional&#039;,
                },
            });
            // if the optionality of the first item is correct (based on optionalityOrder)
            // then the first 0 inclusive to switchIndex exclusive members all
            // have the correct optionality
            if (isMemberOptional(members[0]) !==
                (optionalityOrder === &#039;optional-first&#039;)) {
                report(members[0]);
                return false;
            }
            for (let i = switchIndex + 1; i &lt; members.length; i++) {
                if (isMemberOptional(members[i]) !==
                    isMemberOptional(members[switchIndex])) {
                    report(members[switchIndex]);
                    return false;
                }
            }
            return true;
        }
        /**
         * Validates if all members are correctly sorted.
         *
         * @param members Members to be validated.
         * @param orderConfig Order config to be validated.
         * @param supportsModifiers A flag indicating whether the type supports modifiers (scope or accessibility) or not.
         */
        function validateMembersOrder(members, orderConfig, supportsModifiers) {
            if (orderConfig === &#039;never&#039;) {
                return;
            }
            // Standardize config
            let order;
            let memberTypes;
            let optionalityOrder;
            // returns true if everything is good and false if an error was reported
            const checkOrder = (memberSet) =&gt; {
                const hasAlphaSort = !!(order &amp;&amp; order !== &#039;as-written&#039;);
                // Check order
                if (Array.isArray(memberTypes)) {
                    const grouped = checkGroupSort(memberSet, memberTypes, supportsModifiers);
                    if (grouped == null) {
                        return false;
                    }
                    if (hasAlphaSort) {
                        return !grouped.some(groupMember =&gt; !checkAlphaSort(groupMember, order));
                    }
                }
                else if (hasAlphaSort) {
                    return checkAlphaSort(memberSet, order);
                }
                return true;
            };
            if (Array.isArray(orderConfig)) {
                memberTypes = orderConfig;
            }
            else {
                order = orderConfig.order;
                memberTypes = orderConfig.memberTypes;
                optionalityOrder = orderConfig.optionalityOrder;
            }
            if (!optionalityOrder) {
                checkOrder(members);
                return;
            }
            const switchIndex = members.findIndex((member, i) =&gt; i &amp;&amp; isMemberOptional(member) !== isMemberOptional(members[i - 1]));
            if (switchIndex !== -1) {
                if (!checkRequiredOrder(members, optionalityOrder)) {
                    return;
                }
                checkOrder(members.slice(0, switchIndex));
                checkOrder(members.slice(switchIndex));
            }
        }
        return {
            ClassDeclaration(node) {
                var _a;
                validateMembersOrder(node.body.body, (_a = options.classes) !== null &amp;&amp; _a !== void 0 ? _a : options.default, true);
            },
            ClassExpression(node) {
                var _a;
                validateMembersOrder(node.body.body, (_a = options.classExpressions) !== null &amp;&amp; _a !== void 0 ? _a : options.default, true);
            },
            TSInterfaceDeclaration(node) {
                var _a;
                validateMembersOrder(node.body.body, (_a = options.interfaces) !== null &amp;&amp; _a !== void 0 ? _a : options.default, false);
            },
            TSTypeLiteral(node) {
                var _a;
                validateMembersOrder(node.members, (_a = options.typeLiterals) !== null &amp;&amp; _a !== void 0 ? _a : options.default, false);
            },
        };
    },
});
//# sourceMappingURL=member-ordering.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
