<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@typescript-eslint/scope-manager/dist/referencer/Referencer.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@typescript-eslint/scope-manager/dist/referencer/Referencer.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">73.38</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">547</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">85.04</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.64</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
var __classPrivateFieldSet = (this &amp;&amp; this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === &quot;m&quot;) throw new TypeError(&quot;Private method is not writable&quot;);
    if (kind === &quot;a&quot; &amp;&amp; !f) throw new TypeError(&quot;Private accessor was defined without a setter&quot;);
    if (typeof state === &quot;function&quot; ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(&quot;Cannot write private member to an object whose class did not declare it&quot;);
    return (kind === &quot;a&quot; ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this &amp;&amp; this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === &quot;a&quot; &amp;&amp; !f) throw new TypeError(&quot;Private accessor was defined without a getter&quot;);
    if (typeof state === &quot;function&quot; ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(&quot;Cannot read private member from an object whose class did not declare it&quot;);
    return kind === &quot;m&quot; ? f : kind === &quot;a&quot; ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Referencer_jsxPragma, _Referencer_jsxFragmentName, _Referencer_hasReferencedJsxFactory, _Referencer_hasReferencedJsxFragmentFactory, _Referencer_lib, _Referencer_emitDecoratorMetadata;
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
exports.Referencer = void 0;
const types_1 = require(&quot;@typescript-eslint/types&quot;);
const assert_1 = require(&quot;../assert&quot;);
const definition_1 = require(&quot;../definition&quot;);
const lib_1 = require(&quot;../lib&quot;);
const ClassVisitor_1 = require(&quot;./ClassVisitor&quot;);
const ExportVisitor_1 = require(&quot;./ExportVisitor&quot;);
const ImportVisitor_1 = require(&quot;./ImportVisitor&quot;);
const PatternVisitor_1 = require(&quot;./PatternVisitor&quot;);
const Reference_1 = require(&quot;./Reference&quot;);
const TypeVisitor_1 = require(&quot;./TypeVisitor&quot;);
const Visitor_1 = require(&quot;./Visitor&quot;);
// Referencing variables and creating bindings.
class Referencer extends Visitor_1.Visitor {
    constructor(options, scopeManager) {
        super(options);
        _Referencer_jsxPragma.set(this, void 0);
        _Referencer_jsxFragmentName.set(this, void 0);
        _Referencer_hasReferencedJsxFactory.set(this, false);
        _Referencer_hasReferencedJsxFragmentFactory.set(this, false);
        _Referencer_lib.set(this, void 0);
        _Referencer_emitDecoratorMetadata.set(this, void 0);
        this.scopeManager = scopeManager;
        __classPrivateFieldSet(this, _Referencer_jsxPragma, options.jsxPragma, &quot;f&quot;);
        __classPrivateFieldSet(this, _Referencer_jsxFragmentName, options.jsxFragmentName, &quot;f&quot;);
        __classPrivateFieldSet(this, _Referencer_lib, options.lib, &quot;f&quot;);
        __classPrivateFieldSet(this, _Referencer_emitDecoratorMetadata, options.emitDecoratorMetadata, &quot;f&quot;);
    }
    currentScope(dontThrowOnNull) {
        if (!dontThrowOnNull) {
            (0, assert_1.assert)(this.scopeManager.currentScope, &#039;aaa&#039;);
        }
        return this.scopeManager.currentScope;
    }
    close(node) {
        while (this.currentScope(true) &amp;&amp; node === this.currentScope().block) {
            this.scopeManager.currentScope = this.currentScope().close(this.scopeManager);
        }
    }
    referencingDefaultValue(pattern, assignments, maybeImplicitGlobal, init) {
        assignments.forEach(assignment =&gt; {
            this.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, assignment.right, maybeImplicitGlobal, init);
        });
    }
    populateGlobalsFromLib(globalScope) {
        for (const lib of __classPrivateFieldGet(this, _Referencer_lib, &quot;f&quot;)) {
            const variables = lib_1.lib[lib];
            /* istanbul ignore if */ if (!variables) {
                throw new Error(`Invalid value for lib provided: ${lib}`);
            }
            for (const [name, variable] of Object.entries(variables)) {
                globalScope.defineImplicitVariable(name, variable);
            }
        }
        // for const assertions (`{} as const` / `&lt;const&gt;{}`)
        globalScope.defineImplicitVariable(&#039;const&#039;, {
            eslintImplicitGlobalSetting: &#039;readonly&#039;,
            isTypeVariable: true,
            isValueVariable: false,
        });
    }
    /**
     * Searches for a variable named &quot;name&quot; in the upper scopes and adds a pseudo-reference from itself to itself
     */
    referenceInSomeUpperScope(name) {
        let scope = this.scopeManager.currentScope;
        while (scope) {
            const variable = scope.set.get(name);
            if (!variable) {
                scope = scope.upper;
                continue;
            }
            scope.referenceValue(variable.identifiers[0]);
            return true;
        }
        return false;
    }
    referenceJsxPragma() {
        if (__classPrivateFieldGet(this, _Referencer_jsxPragma, &quot;f&quot;) == null || __classPrivateFieldGet(this, _Referencer_hasReferencedJsxFactory, &quot;f&quot;)) {
            return;
        }
        __classPrivateFieldSet(this, _Referencer_hasReferencedJsxFactory, this.referenceInSomeUpperScope(__classPrivateFieldGet(this, _Referencer_jsxPragma, &quot;f&quot;)), &quot;f&quot;);
    }
    referenceJsxFragment() {
        if (__classPrivateFieldGet(this, _Referencer_jsxFragmentName, &quot;f&quot;) == null ||
            __classPrivateFieldGet(this, _Referencer_hasReferencedJsxFragmentFactory, &quot;f&quot;)) {
            return;
        }
        __classPrivateFieldSet(this, _Referencer_hasReferencedJsxFragmentFactory, this.referenceInSomeUpperScope(__classPrivateFieldGet(this, _Referencer_jsxFragmentName, &quot;f&quot;)), &quot;f&quot;);
    }
    ///////////////////
    // Visit helpers //
    ///////////////////
    visitClass(node) {
        ClassVisitor_1.ClassVisitor.visit(this, node, __classPrivateFieldGet(this, _Referencer_emitDecoratorMetadata, &quot;f&quot;));
    }
    visitForIn(node) {
        if (node.left.type === types_1.AST_NODE_TYPES.VariableDeclaration &amp;&amp;
            node.left.kind !== &#039;var&#039;) {
            this.scopeManager.nestForScope(node);
        }
        if (node.left.type === types_1.AST_NODE_TYPES.VariableDeclaration) {
            this.visit(node.left);
            this.visitPattern(node.left.declarations[0].id, pattern =&gt; {
                this.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, node.right, null, true);
            });
        }
        else {
            this.visitPattern(node.left, (pattern, info) =&gt; {
                const maybeImplicitGlobal = !this.currentScope().isStrict
                    ? {
                        pattern,
                        node,
                    }
                    : null;
                this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);
                this.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, node.right, maybeImplicitGlobal, false);
            }, { processRightHandNodes: true });
        }
        this.visit(node.right);
        this.visit(node.body);
        this.close(node);
    }
    visitFunctionParameterTypeAnnotation(node) {
        if (&#039;typeAnnotation&#039; in node) {
            this.visitType(node.typeAnnotation);
        }
        else if (node.type === types_1.AST_NODE_TYPES.AssignmentPattern) {
            this.visitType(node.left.typeAnnotation);
        }
        else if (node.type === types_1.AST_NODE_TYPES.TSParameterProperty) {
            this.visitFunctionParameterTypeAnnotation(node.parameter);
        }
    }
    visitFunction(node) {
        // FunctionDeclaration name is defined in upper scope
        // NOTE: Not referring variableScope. It is intended.
        // Since
        //  in ES5, FunctionDeclaration should be in FunctionBody.
        //  in ES6, FunctionDeclaration should be block scoped.
        var _a;
        if (node.type === types_1.AST_NODE_TYPES.FunctionExpression) {
            if (node.id) {
                // FunctionExpression with name creates its special scope;
                // FunctionExpressionNameScope.
                this.scopeManager.nestFunctionExpressionNameScope(node);
            }
        }
        else if (node.id) {
            // id is defined in upper scope
            this.currentScope().defineIdentifier(node.id, new definition_1.FunctionNameDefinition(node.id, node));
        }
        // Consider this function is in the MethodDefinition.
        this.scopeManager.nestFunctionScope(node, false);
        // Process parameter declarations.
        for (const param of node.params) {
            this.visitPattern(param, (pattern, info) =&gt; {
                this.currentScope().defineIdentifier(pattern, new definition_1.ParameterDefinition(pattern, node, info.rest));
                this.referencingDefaultValue(pattern, info.assignments, null, true);
            }, { processRightHandNodes: true });
            this.visitFunctionParameterTypeAnnotation(param);
            (_a = param.decorators) === null || _a === void 0 ? void 0 : _a.forEach(d =&gt; this.visit(d));
        }
        this.visitType(node.returnType);
        this.visitType(node.typeParameters);
        // In TypeScript there are a number of function-like constructs which have no body,
        // so check it exists before traversing
        if (node.body) {
            // Skip BlockStatement to prevent creating BlockStatement scope.
            if (node.body.type === types_1.AST_NODE_TYPES.BlockStatement) {
                this.visitChildren(node.body);
            }
            else {
                this.visit(node.body);
            }
        }
        this.close(node);
    }
    visitProperty(node) {
        if (node.computed) {
            this.visit(node.key);
        }
        this.visit(node.value);
    }
    visitType(node) {
        if (!node) {
            return;
        }
        TypeVisitor_1.TypeVisitor.visit(this, node);
    }
    visitTypeAssertion(node) {
        this.visit(node.expression);
        this.visitType(node.typeAnnotation);
    }
    /////////////////////
    // Visit selectors //
    /////////////////////
    ArrowFunctionExpression(node) {
        this.visitFunction(node);
    }
    AssignmentExpression(node) {
        let left = node.left;
        switch (left.type) {
            case types_1.AST_NODE_TYPES.TSAsExpression:
            case types_1.AST_NODE_TYPES.TSTypeAssertion:
                // explicitly visit the type annotation
                this.visitType(left.typeAnnotation);
            // intentional fallthrough
            case types_1.AST_NODE_TYPES.TSNonNullExpression:
                // unwrap the expression
                left = left.expression;
        }
        if (PatternVisitor_1.PatternVisitor.isPattern(left)) {
            if (node.operator === &#039;=&#039;) {
                this.visitPattern(left, (pattern, info) =&gt; {
                    const maybeImplicitGlobal = !this.currentScope().isStrict
                        ? {
                            pattern,
                            node,
                        }
                        : null;
                    this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);
                    this.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, node.right, maybeImplicitGlobal, false);
                }, { processRightHandNodes: true });
            }
            else if (left.type === types_1.AST_NODE_TYPES.Identifier) {
                this.currentScope().referenceValue(left, Reference_1.ReferenceFlag.ReadWrite, node.right);
            }
        }
        else {
            this.visit(left);
        }
        this.visit(node.right);
    }
    BlockStatement(node) {
        if (this.scopeManager.isES6()) {
            this.scopeManager.nestBlockScope(node);
        }
        this.visitChildren(node);
        this.close(node);
    }
    BreakStatement() {
        // don&#039;t reference the break statement&#039;s label
    }
    CallExpression(node) {
        this.visitChildren(node, [&#039;typeParameters&#039;]);
        this.visitType(node.typeParameters);
    }
    CatchClause(node) {
        this.scopeManager.nestCatchScope(node);
        if (node.param) {
            const param = node.param;
            this.visitPattern(param, (pattern, info) =&gt; {
                this.currentScope().defineIdentifier(pattern, new definition_1.CatchClauseDefinition(param, node));
                this.referencingDefaultValue(pattern, info.assignments, null, true);
            }, { processRightHandNodes: true });
        }
        this.visit(node.body);
        this.close(node);
    }
    ClassExpression(node) {
        this.visitClass(node);
    }
    ClassDeclaration(node) {
        this.visitClass(node);
    }
    ContinueStatement() {
        // don&#039;t reference the continue statement&#039;s label
    }
    ExportAllDeclaration() {
        // this defines no local variables
    }
    ExportDefaultDeclaration(node) {
        if (node.declaration.type === types_1.AST_NODE_TYPES.Identifier) {
            ExportVisitor_1.ExportVisitor.visit(this, node);
        }
        else {
            this.visit(node.declaration);
        }
    }
    ExportNamedDeclaration(node) {
        if (node.declaration) {
            this.visit(node.declaration);
        }
        else {
            ExportVisitor_1.ExportVisitor.visit(this, node);
        }
    }
    ForInStatement(node) {
        this.visitForIn(node);
    }
    ForOfStatement(node) {
        this.visitForIn(node);
    }
    ForStatement(node) {
        // Create ForStatement declaration.
        // NOTE: In ES6, ForStatement dynamically generates per iteration environment. However, this is
        // a static analyzer, we only generate one scope for ForStatement.
        if (node.init &amp;&amp;
            node.init.type === types_1.AST_NODE_TYPES.VariableDeclaration &amp;&amp;
            node.init.kind !== &#039;var&#039;) {
            this.scopeManager.nestForScope(node);
        }
        this.visitChildren(node);
        this.close(node);
    }
    FunctionDeclaration(node) {
        this.visitFunction(node);
    }
    FunctionExpression(node) {
        this.visitFunction(node);
    }
    Identifier(node) {
        this.currentScope().referenceValue(node);
        this.visitType(node.typeAnnotation);
    }
    ImportDeclaration(node) {
        (0, assert_1.assert)(this.scopeManager.isES6() &amp;&amp; this.scopeManager.isModule(), &#039;ImportDeclaration should appear when the mode is ES6 and in the module context.&#039;);
        ImportVisitor_1.ImportVisitor.visit(this, node);
    }
    JSXAttribute(node) {
        this.visit(node.value);
    }
    JSXClosingElement() {
        // should not be counted as a reference
    }
    JSXFragment(node) {
        this.referenceJsxPragma();
        this.referenceJsxFragment();
        this.visitChildren(node);
    }
    JSXIdentifier(node) {
        this.currentScope().referenceValue(node);
    }
    JSXMemberExpression(node) {
        if (node.object.type !== types_1.AST_NODE_TYPES.JSXIdentifier) {
            this.visit(node.object);
        }
        else {
            if (node.object.name !== &#039;this&#039;) {
                this.visit(node.object);
            }
        }
        // we don&#039;t ever reference the property as it&#039;s always going to be a property on the thing
    }
    JSXOpeningElement(node) {
        this.referenceJsxPragma();
        if (node.name.type === types_1.AST_NODE_TYPES.JSXIdentifier) {
            if (node.name.name[0].toUpperCase() === node.name.name[0] ||
                node.name.name === &#039;this&#039;) {
                // lower cased component names are always treated as &quot;intrinsic&quot; names, and are converted to a string,
                // not a variable by JSX transforms:
                // &lt;div /&gt; =&gt; React.createElement(&quot;div&quot;, null)
                // the only case we want to visit a lower-cased component has its name as &quot;this&quot;,
                this.visit(node.name);
            }
        }
        else {
            this.visit(node.name);
        }
        this.visitType(node.typeParameters);
        for (const attr of node.attributes) {
            this.visit(attr);
        }
    }
    LabeledStatement(node) {
        this.visit(node.body);
    }
    MemberExpression(node) {
        this.visit(node.object);
        if (node.computed) {
            this.visit(node.property);
        }
    }
    MetaProperty() {
        // meta properties all builtin globals
    }
    NewExpression(node) {
        this.visitChildren(node, [&#039;typeParameters&#039;]);
        this.visitType(node.typeParameters);
    }
    PrivateIdentifier() {
        // private identifiers are members on classes and thus have no variables to to reference
    }
    Program(node) {
        const globalScope = this.scopeManager.nestGlobalScope(node);
        this.populateGlobalsFromLib(globalScope);
        if (this.scopeManager.isGlobalReturn()) {
            // Force strictness of GlobalScope to false when using node.js scope.
            this.currentScope().isStrict = false;
            this.scopeManager.nestFunctionScope(node, false);
        }
        if (this.scopeManager.isES6() &amp;&amp; this.scopeManager.isModule()) {
            this.scopeManager.nestModuleScope(node);
        }
        if (this.scopeManager.isStrictModeSupported() &amp;&amp;
            this.scopeManager.isImpliedStrict()) {
            this.currentScope().isStrict = true;
        }
        this.visitChildren(node);
        this.close(node);
    }
    Property(node) {
        this.visitProperty(node);
    }
    SwitchStatement(node) {
        this.visit(node.discriminant);
        if (this.scopeManager.isES6()) {
            this.scopeManager.nestSwitchScope(node);
        }
        for (const switchCase of node.cases) {
            this.visit(switchCase);
        }
        this.close(node);
    }
    TaggedTemplateExpression(node) {
        this.visit(node.tag);
        this.visit(node.quasi);
        this.visitType(node.typeParameters);
    }
    TSAsExpression(node) {
        this.visitTypeAssertion(node);
    }
    TSDeclareFunction(node) {
        this.visitFunction(node);
    }
    TSImportEqualsDeclaration(node) {
        this.currentScope().defineIdentifier(node.id, new definition_1.ImportBindingDefinition(node.id, node, node));
        if (node.moduleReference.type === types_1.AST_NODE_TYPES.TSQualifiedName) {
            this.visit(node.moduleReference.left);
        }
        else {
            this.visit(node.moduleReference);
        }
    }
    TSEmptyBodyFunctionExpression(node) {
        this.visitFunction(node);
    }
    TSEnumDeclaration(node) {
        this.currentScope().defineIdentifier(node.id, new definition_1.TSEnumNameDefinition(node.id, node));
        // enum members can be referenced within the enum body
        this.scopeManager.nestTSEnumScope(node);
        // define the enum name again inside the new enum scope
        // references to the enum should not resolve directly to the enum
        this.currentScope().defineIdentifier(node.id, new definition_1.TSEnumNameDefinition(node.id, node));
        for (const member of node.members) {
            // TS resolves literal named members to be actual names
            // enum Foo {
            //   &#039;a&#039; = 1,
            //   b = a, // this references the &#039;a&#039; member
            // }
            if (member.id.type === types_1.AST_NODE_TYPES.Literal &amp;&amp;
                typeof member.id.value === &#039;string&#039;) {
                const name = member.id;
                this.currentScope().defineLiteralIdentifier(name, new definition_1.TSEnumMemberDefinition(name, member));
            }
            else if (!member.computed &amp;&amp;
                member.id.type === types_1.AST_NODE_TYPES.Identifier) {
                this.currentScope().defineIdentifier(member.id, new definition_1.TSEnumMemberDefinition(member.id, member));
            }
            this.visit(member.initializer);
        }
        this.close(node);
    }
    TSInstantiationExpression(node) {
        this.visitChildren(node, [&#039;typeParameters&#039;]);
        this.visitType(node.typeParameters);
    }
    TSInterfaceDeclaration(node) {
        this.visitType(node);
    }
    TSModuleDeclaration(node) {
        if (node.id.type === types_1.AST_NODE_TYPES.Identifier &amp;&amp; !node.global) {
            this.currentScope().defineIdentifier(node.id, new definition_1.TSModuleNameDefinition(node.id, node));
        }
        this.scopeManager.nestTSModuleScope(node);
        this.visit(node.body);
        this.close(node);
    }
    TSSatisfiesExpression(node) {
        this.visitTypeAssertion(node);
    }
    TSTypeAliasDeclaration(node) {
        this.visitType(node);
    }
    TSTypeAssertion(node) {
        this.visitTypeAssertion(node);
    }
    UpdateExpression(node) {
        if (PatternVisitor_1.PatternVisitor.isPattern(node.argument)) {
            this.visitPattern(node.argument, pattern =&gt; {
                this.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.ReadWrite, null);
            });
        }
        else {
            this.visitChildren(node);
        }
    }
    VariableDeclaration(node) {
        const variableTargetScope = node.kind === &#039;var&#039;
            ? this.currentScope().variableScope
            : this.currentScope();
        for (const decl of node.declarations) {
            const init = decl.init;
            this.visitPattern(decl.id, (pattern, info) =&gt; {
                variableTargetScope.defineIdentifier(pattern, new definition_1.VariableDefinition(pattern, decl, node));
                this.referencingDefaultValue(pattern, info.assignments, null, true);
                if (init) {
                    this.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, init, null, true);
                }
            }, { processRightHandNodes: true });
            if (decl.init) {
                this.visit(decl.init);
            }
            if (&#039;typeAnnotation&#039; in decl.id) {
                this.visitType(decl.id.typeAnnotation);
            }
        }
    }
    WithStatement(node) {
        this.visit(node.object);
        // Then nest scope for WithStatement.
        this.scopeManager.nestWithScope(node);
        this.visit(node.body);
        this.close(node);
    }
    ImportAttribute() {
        // import assertions are module metadata and thus have no variables to reference
    }
}
exports.Referencer = Referencer;
_Referencer_jsxPragma = new WeakMap(), _Referencer_jsxFragmentName = new WeakMap(), _Referencer_hasReferencedJsxFactory = new WeakMap(), _Referencer_hasReferencedJsxFragmentFactory = new WeakMap(), _Referencer_lib = new WeakMap(), _Referencer_emitDecoratorMetadata = new WeakMap();
//# sourceMappingURL=Referencer.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
