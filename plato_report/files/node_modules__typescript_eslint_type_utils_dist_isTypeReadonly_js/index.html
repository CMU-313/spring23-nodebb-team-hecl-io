<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@typescript-eslint/type-utils/dist/isTypeReadonly.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@typescript-eslint/type-utils/dist/isTypeReadonly.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">65.88</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">216</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">52.98</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.37</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
var __createBinding = (this &amp;&amp; this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (&quot;get&quot; in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this &amp;&amp; this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, &quot;default&quot;, { enumerable: true, value: v });
}) : function(o, v) {
    o[&quot;default&quot;] = v;
});
var __importStar = (this &amp;&amp; this.__importStar) || function (mod) {
    if (mod &amp;&amp; mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== &quot;default&quot; &amp;&amp; Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
exports.isTypeReadonly = exports.readonlynessOptionsDefaults = exports.readonlynessOptionsSchema = void 0;
const utils_1 = require(&quot;@typescript-eslint/utils&quot;);
const tsutils_1 = require(&quot;tsutils&quot;);
const ts = __importStar(require(&quot;typescript&quot;));
const propertyTypes_1 = require(&quot;./propertyTypes&quot;);
exports.readonlynessOptionsSchema = {
    type: &#039;object&#039;,
    additionalProperties: false,
    properties: {
        treatMethodsAsReadonly: {
            type: &#039;boolean&#039;,
        },
    },
};
exports.readonlynessOptionsDefaults = {
    treatMethodsAsReadonly: false,
};
function hasSymbol(node) {
    return Object.prototype.hasOwnProperty.call(node, &#039;symbol&#039;);
}
function isTypeReadonlyArrayOrTuple(checker, type, options, seenTypes) {
    function checkTypeArguments(arrayType) {
        var _a;
        const typeArguments = 
        // getTypeArguments was only added in TS3.7
        checker.getTypeArguments
            ? checker.getTypeArguments(arrayType)
            : (_a = arrayType.typeArguments) !== null &amp;&amp; _a !== void 0 ? _a : [];
        // this shouldn&#039;t happen in reality as:
        // - tuples require at least 1 type argument
        // - ReadonlyArray requires at least 1 type argument
        /* istanbul ignore if */ if (typeArguments.length === 0) {
            return 3 /* Readonlyness.Readonly */;
        }
        // validate the element types are also readonly
        if (typeArguments.some(typeArg =&gt; isTypeReadonlyRecurser(checker, typeArg, options, seenTypes) ===
            2 /* Readonlyness.Mutable */)) {
            return 2 /* Readonlyness.Mutable */;
        }
        return 3 /* Readonlyness.Readonly */;
    }
    if (checker.isArrayType(type)) {
        const symbol = utils_1.ESLintUtils.nullThrows(type.getSymbol(), utils_1.ESLintUtils.NullThrowsReasons.MissingToken(&#039;symbol&#039;, &#039;array type&#039;));
        const escapedName = symbol.getEscapedName();
        if (escapedName === &#039;Array&#039;) {
            return 2 /* Readonlyness.Mutable */;
        }
        return checkTypeArguments(type);
    }
    if (checker.isTupleType(type)) {
        if (!type.target.readonly) {
            return 2 /* Readonlyness.Mutable */;
        }
        return checkTypeArguments(type);
    }
    return 1 /* Readonlyness.UnknownType */;
}
function isTypeReadonlyObject(checker, type, options, seenTypes) {
    function checkIndexSignature(kind) {
        const indexInfo = checker.getIndexInfoOfType(type, kind);
        if (indexInfo) {
            if (!indexInfo.isReadonly) {
                return 2 /* Readonlyness.Mutable */;
            }
            if (indexInfo.type === type || seenTypes.has(indexInfo.type)) {
                return 3 /* Readonlyness.Readonly */;
            }
            return isTypeReadonlyRecurser(checker, indexInfo.type, options, seenTypes);
        }
        return 1 /* Readonlyness.UnknownType */;
    }
    const properties = type.getProperties();
    if (properties.length) {
        // ensure the properties are marked as readonly
        for (const property of properties) {
            if (options.treatMethodsAsReadonly) {
                if (property.valueDeclaration !== undefined &amp;&amp;
                    hasSymbol(property.valueDeclaration) &amp;&amp;
                    (0, tsutils_1.isSymbolFlagSet)(property.valueDeclaration.symbol, ts.SymbolFlags.Method)) {
                    continue;
                }
                const declarations = property.getDeclarations();
                const lastDeclaration = declarations !== undefined &amp;&amp; declarations.length &gt; 0
                    ? declarations[declarations.length - 1]
                    : undefined;
                if (lastDeclaration !== undefined &amp;&amp;
                    hasSymbol(lastDeclaration) &amp;&amp;
                    (0, tsutils_1.isSymbolFlagSet)(lastDeclaration.symbol, ts.SymbolFlags.Method)) {
                    continue;
                }
            }
            if ((0, tsutils_1.isPropertyReadonlyInType)(type, property.getEscapedName(), checker)) {
                continue;
            }
            const name = ts.getNameOfDeclaration(property.valueDeclaration);
            if (name &amp;&amp; ts.isPrivateIdentifier(name)) {
                continue;
            }
            return 2 /* Readonlyness.Mutable */;
        }
        // all properties were readonly
        // now ensure that all of the values are readonly also.
        // do this after checking property readonly-ness as a perf optimization,
        // as we might be able to bail out early due to a mutable property before
        // doing this deep, potentially expensive check.
        for (const property of properties) {
            const propertyType = utils_1.ESLintUtils.nullThrows((0, propertyTypes_1.getTypeOfPropertyOfType)(checker, type, property), utils_1.ESLintUtils.NullThrowsReasons.MissingToken(`property &quot;${property.name}&quot;`, &#039;type&#039;));
            // handle recursive types.
            // we only need this simple check, because a mutable recursive type will break via the above prop readonly check
            if (seenTypes.has(propertyType)) {
                continue;
            }
            if (isTypeReadonlyRecurser(checker, propertyType, options, seenTypes) ===
                2 /* Readonlyness.Mutable */) {
                return 2 /* Readonlyness.Mutable */;
            }
        }
    }
    const isStringIndexSigReadonly = checkIndexSignature(ts.IndexKind.String);
    if (isStringIndexSigReadonly === 2 /* Readonlyness.Mutable */) {
        return isStringIndexSigReadonly;
    }
    const isNumberIndexSigReadonly = checkIndexSignature(ts.IndexKind.Number);
    if (isNumberIndexSigReadonly === 2 /* Readonlyness.Mutable */) {
        return isNumberIndexSigReadonly;
    }
    return 3 /* Readonlyness.Readonly */;
}
// a helper function to ensure the seenTypes map is always passed down, except by the external caller
function isTypeReadonlyRecurser(checker, type, options, seenTypes) {
    seenTypes.add(type);
    if ((0, tsutils_1.isUnionType)(type)) {
        // all types in the union must be readonly
        const result = (0, tsutils_1.unionTypeParts)(type).every(t =&gt; seenTypes.has(t) ||
            isTypeReadonlyRecurser(checker, t, options, seenTypes) ===
                3 /* Readonlyness.Readonly */);
        const readonlyness = result ? 3 /* Readonlyness.Readonly */ : 2 /* Readonlyness.Mutable */;
        return readonlyness;
    }
    if ((0, tsutils_1.isIntersectionType)(type)) {
        // Special case for handling arrays/tuples (as readonly arrays/tuples always have mutable methods).
        if (type.types.some(t =&gt; checker.isArrayType(t) || checker.isTupleType(t))) {
            const allReadonlyParts = type.types.every(t =&gt; seenTypes.has(t) ||
                isTypeReadonlyRecurser(checker, t, options, seenTypes) ===
                    3 /* Readonlyness.Readonly */);
            return allReadonlyParts ? 3 /* Readonlyness.Readonly */ : 2 /* Readonlyness.Mutable */;
        }
        // Normal case.
        const isReadonlyObject = isTypeReadonlyObject(checker, type, options, seenTypes);
        if (isReadonlyObject !== 1 /* Readonlyness.UnknownType */) {
            return isReadonlyObject;
        }
    }
    if ((0, tsutils_1.isConditionalType)(type)) {
        const result = [type.root.node.trueType, type.root.node.falseType]
            .map(checker.getTypeFromTypeNode)
            .every(t =&gt; seenTypes.has(t) ||
            isTypeReadonlyRecurser(checker, t, options, seenTypes) ===
                3 /* Readonlyness.Readonly */);
        const readonlyness = result ? 3 /* Readonlyness.Readonly */ : 2 /* Readonlyness.Mutable */;
        return readonlyness;
    }
    // all non-object, non-intersection types are readonly.
    // this should only be primitive types
    if (!(0, tsutils_1.isObjectType)(type)) {
        return 3 /* Readonlyness.Readonly */;
    }
    // pure function types are readonly
    if (type.getCallSignatures().length &gt; 0 &amp;&amp;
        type.getProperties().length === 0) {
        return 3 /* Readonlyness.Readonly */;
    }
    const isReadonlyArray = isTypeReadonlyArrayOrTuple(checker, type, options, seenTypes);
    if (isReadonlyArray !== 1 /* Readonlyness.UnknownType */) {
        return isReadonlyArray;
    }
    const isReadonlyObject = isTypeReadonlyObject(checker, type, options, seenTypes);
    /* istanbul ignore else */ if (isReadonlyObject !== 1 /* Readonlyness.UnknownType */) {
        return isReadonlyObject;
    }
    throw new Error(&#039;Unhandled type&#039;);
}
/**
 * Checks if the given type is readonly
 */
function isTypeReadonly(checker, type, options = exports.readonlynessOptionsDefaults) {
    return (isTypeReadonlyRecurser(checker, type, options, new Set()) ===
        3 /* Readonlyness.Readonly */);
}
exports.isTypeReadonly = isTypeReadonly;
//# sourceMappingURL=isTypeReadonly.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
