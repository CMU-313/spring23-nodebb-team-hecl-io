<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@eslint/eslintrc/node_modules/js-yaml/dist/js-yaml.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@eslint/eslintrc/node_modules/js-yaml/dist/js-yaml.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">54.12</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">3873</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">200.23</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">44.87</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */
(function (global, factory) {
  typeof exports === &#039;object&#039; &amp;&amp; typeof module !== &#039;undefined&#039; ? factory(exports) :
  typeof define === &#039;function&#039; &amp;&amp; define.amd ? define([&#039;exports&#039;], factory) :
  (global = typeof globalThis !== &#039;undefined&#039; ? globalThis : global || self, factory(global.jsyaml = {}));
}(this, (function (exports) { &#039;use strict&#039;;

  function isNothing(subject) {
    return (typeof subject === &#039;undefined&#039;) || (subject === null);
  }


  function isObject(subject) {
    return (typeof subject === &#039;object&#039;) &amp;&amp; (subject !== null);
  }


  function toArray(sequence) {
    if (Array.isArray(sequence)) return sequence;
    else if (isNothing(sequence)) return [];

    return [ sequence ];
  }


  function extend(target, source) {
    var index, length, key, sourceKeys;

    if (source) {
      sourceKeys = Object.keys(source);

      for (index = 0, length = sourceKeys.length; index &lt; length; index += 1) {
        key = sourceKeys[index];
        target[key] = source[key];
      }
    }

    return target;
  }


  function repeat(string, count) {
    var result = &#039;&#039;, cycle;

    for (cycle = 0; cycle &lt; count; cycle += 1) {
      result += string;
    }

    return result;
  }


  function isNegativeZero(number) {
    return (number === 0) &amp;&amp; (Number.NEGATIVE_INFINITY === 1 / number);
  }


  var isNothing_1      = isNothing;
  var isObject_1       = isObject;
  var toArray_1        = toArray;
  var repeat_1         = repeat;
  var isNegativeZero_1 = isNegativeZero;
  var extend_1         = extend;

  var common = {
  	isNothing: isNothing_1,
  	isObject: isObject_1,
  	toArray: toArray_1,
  	repeat: repeat_1,
  	isNegativeZero: isNegativeZero_1,
  	extend: extend_1
  };

  // YAML error class. http://stackoverflow.com/questions/8458984


  function formatError(exception, compact) {
    var where = &#039;&#039;, message = exception.reason || &#039;(unknown reason)&#039;;

    if (!exception.mark) return message;

    if (exception.mark.name) {
      where += &#039;in &quot;&#039; + exception.mark.name + &#039;&quot; &#039;;
    }

    where += &#039;(&#039; + (exception.mark.line + 1) + &#039;:&#039; + (exception.mark.column + 1) + &#039;)&#039;;

    if (!compact &amp;&amp; exception.mark.snippet) {
      where += &#039;\n\n&#039; + exception.mark.snippet;
    }

    return message + &#039; &#039; + where;
  }


  function YAMLException$1(reason, mark) {
    // Super constructor
    Error.call(this);

    this.name = &#039;YAMLException&#039;;
    this.reason = reason;
    this.mark = mark;
    this.message = formatError(this, false);

    // Include stack trace in error object
    if (Error.captureStackTrace) {
      // Chrome and NodeJS
      Error.captureStackTrace(this, this.constructor);
    } else {
      // FF, IE 10+ and Safari 6+. Fallback for others
      this.stack = (new Error()).stack || &#039;&#039;;
    }
  }


  // Inherit from Error
  YAMLException$1.prototype = Object.create(Error.prototype);
  YAMLException$1.prototype.constructor = YAMLException$1;


  YAMLException$1.prototype.toString = function toString(compact) {
    return this.name + &#039;: &#039; + formatError(this, compact);
  };


  var exception = YAMLException$1;

  // get snippet for a single line, respecting maxLength
  function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
    var head = &#039;&#039;;
    var tail = &#039;&#039;;
    var maxHalfLength = Math.floor(maxLineLength / 2) - 1;

    if (position - lineStart &gt; maxHalfLength) {
      head = &#039; ... &#039;;
      lineStart = position - maxHalfLength + head.length;
    }

    if (lineEnd - position &gt; maxHalfLength) {
      tail = &#039; ...&#039;;
      lineEnd = position + maxHalfLength - tail.length;
    }

    return {
      str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, &#039;â†’&#039;) + tail,
      pos: position - lineStart + head.length // relative position
    };
  }


  function padStart(string, max) {
    return common.repeat(&#039; &#039;, max - string.length) + string;
  }


  function makeSnippet(mark, options) {
    options = Object.create(options || null);

    if (!mark.buffer) return null;

    if (!options.maxLength) options.maxLength = 79;
    if (typeof options.indent      !== &#039;number&#039;) options.indent      = 1;
    if (typeof options.linesBefore !== &#039;number&#039;) options.linesBefore = 3;
    if (typeof options.linesAfter  !== &#039;number&#039;) options.linesAfter  = 2;

    var re = /\r?\n|\r|\0/g;
    var lineStarts = [ 0 ];
    var lineEnds = [];
    var match;
    var foundLineNo = -1;

    while ((match = re.exec(mark.buffer))) {
      lineEnds.push(match.index);
      lineStarts.push(match.index + match[0].length);

      if (mark.position &lt;= match.index &amp;&amp; foundLineNo &lt; 0) {
        foundLineNo = lineStarts.length - 2;
      }
    }

    if (foundLineNo &lt; 0) foundLineNo = lineStarts.length - 1;

    var result = &#039;&#039;, i, line;
    var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
    var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);

    for (i = 1; i &lt;= options.linesBefore; i++) {
      if (foundLineNo - i &lt; 0) break;
      line = getLine(
        mark.buffer,
        lineStarts[foundLineNo - i],
        lineEnds[foundLineNo - i],
        mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
        maxLineLength
      );
      result = common.repeat(&#039; &#039;, options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) +
        &#039; | &#039; + line.str + &#039;\n&#039; + result;
    }

    line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
    result += common.repeat(&#039; &#039;, options.indent) + padStart((mark.line + 1).toString(), lineNoLength) +
      &#039; | &#039; + line.str + &#039;\n&#039;;
    result += common.repeat(&#039;-&#039;, options.indent + lineNoLength + 3 + line.pos) + &#039;^&#039; + &#039;\n&#039;;

    for (i = 1; i &lt;= options.linesAfter; i++) {
      if (foundLineNo + i &gt;= lineEnds.length) break;
      line = getLine(
        mark.buffer,
        lineStarts[foundLineNo + i],
        lineEnds[foundLineNo + i],
        mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
        maxLineLength
      );
      result += common.repeat(&#039; &#039;, options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) +
        &#039; | &#039; + line.str + &#039;\n&#039;;
    }

    return result.replace(/\n$/, &#039;&#039;);
  }


  var snippet = makeSnippet;

  var TYPE_CONSTRUCTOR_OPTIONS = [
    &#039;kind&#039;,
    &#039;multi&#039;,
    &#039;resolve&#039;,
    &#039;construct&#039;,
    &#039;instanceOf&#039;,
    &#039;predicate&#039;,
    &#039;represent&#039;,
    &#039;representName&#039;,
    &#039;defaultStyle&#039;,
    &#039;styleAliases&#039;
  ];

  var YAML_NODE_KINDS = [
    &#039;scalar&#039;,
    &#039;sequence&#039;,
    &#039;mapping&#039;
  ];

  function compileStyleAliases(map) {
    var result = {};

    if (map !== null) {
      Object.keys(map).forEach(function (style) {
        map[style].forEach(function (alias) {
          result[String(alias)] = style;
        });
      });
    }

    return result;
  }

  function Type$1(tag, options) {
    options = options || {};

    Object.keys(options).forEach(function (name) {
      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
        throw new exception(&#039;Unknown option &quot;&#039; + name + &#039;&quot; is met in definition of &quot;&#039; + tag + &#039;&quot; YAML type.&#039;);
      }
    });

    // TODO: Add tag format check.
    this.options       = options; // keep original options in case user wants to extend this type later
    this.tag           = tag;
    this.kind          = options[&#039;kind&#039;]          || null;
    this.resolve       = options[&#039;resolve&#039;]       || function () { return true; };
    this.construct     = options[&#039;construct&#039;]     || function (data) { return data; };
    this.instanceOf    = options[&#039;instanceOf&#039;]    || null;
    this.predicate     = options[&#039;predicate&#039;]     || null;
    this.represent     = options[&#039;represent&#039;]     || null;
    this.representName = options[&#039;representName&#039;] || null;
    this.defaultStyle  = options[&#039;defaultStyle&#039;]  || null;
    this.multi         = options[&#039;multi&#039;]         || false;
    this.styleAliases  = compileStyleAliases(options[&#039;styleAliases&#039;] || null);

    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
      throw new exception(&#039;Unknown kind &quot;&#039; + this.kind + &#039;&quot; is specified for &quot;&#039; + tag + &#039;&quot; YAML type.&#039;);
    }
  }

  var type = Type$1;

  /*eslint-disable max-len*/





  function compileList(schema, name) {
    var result = [];

    schema[name].forEach(function (currentType) {
      var newIndex = result.length;

      result.forEach(function (previousType, previousIndex) {
        if (previousType.tag === currentType.tag &amp;&amp;
            previousType.kind === currentType.kind &amp;&amp;
            previousType.multi === currentType.multi) {

          newIndex = previousIndex;
        }
      });

      result[newIndex] = currentType;
    });

    return result;
  }


  function compileMap(/* lists... */) {
    var result = {
          scalar: {},
          sequence: {},
          mapping: {},
          fallback: {},
          multi: {
            scalar: [],
            sequence: [],
            mapping: [],
            fallback: []
          }
        }, index, length;

    function collectType(type) {
      if (type.multi) {
        result.multi[type.kind].push(type);
        result.multi[&#039;fallback&#039;].push(type);
      } else {
        result[type.kind][type.tag] = result[&#039;fallback&#039;][type.tag] = type;
      }
    }

    for (index = 0, length = arguments.length; index &lt; length; index += 1) {
      arguments[index].forEach(collectType);
    }
    return result;
  }


  function Schema$1(definition) {
    return this.extend(definition);
  }


  Schema$1.prototype.extend = function extend(definition) {
    var implicit = [];
    var explicit = [];

    if (definition instanceof type) {
      // Schema.extend(type)
      explicit.push(definition);

    } else if (Array.isArray(definition)) {
      // Schema.extend([ type1, type2, ... ])
      explicit = explicit.concat(definition);

    } else if (definition &amp;&amp; (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
      // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })
      if (definition.implicit) implicit = implicit.concat(definition.implicit);
      if (definition.explicit) explicit = explicit.concat(definition.explicit);

    } else {
      throw new exception(&#039;Schema.extend argument should be a Type, [ Type ], &#039; +
        &#039;or a schema definition ({ implicit: [...], explicit: [...] })&#039;);
    }

    implicit.forEach(function (type$1) {
      if (!(type$1 instanceof type)) {
        throw new exception(&#039;Specified list of YAML types (or a single Type object) contains a non-Type object.&#039;);
      }

      if (type$1.loadKind &amp;&amp; type$1.loadKind !== &#039;scalar&#039;) {
        throw new exception(&#039;There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.&#039;);
      }

      if (type$1.multi) {
        throw new exception(&#039;There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.&#039;);
      }
    });

    explicit.forEach(function (type$1) {
      if (!(type$1 instanceof type)) {
        throw new exception(&#039;Specified list of YAML types (or a single Type object) contains a non-Type object.&#039;);
      }
    });

    var result = Object.create(Schema$1.prototype);

    result.implicit = (this.implicit || []).concat(implicit);
    result.explicit = (this.explicit || []).concat(explicit);

    result.compiledImplicit = compileList(result, &#039;implicit&#039;);
    result.compiledExplicit = compileList(result, &#039;explicit&#039;);
    result.compiledTypeMap  = compileMap(result.compiledImplicit, result.compiledExplicit);

    return result;
  };


  var schema = Schema$1;

  var str = new type(&#039;tag:yaml.org,2002:str&#039;, {
    kind: &#039;scalar&#039;,
    construct: function (data) { return data !== null ? data : &#039;&#039;; }
  });

  var seq = new type(&#039;tag:yaml.org,2002:seq&#039;, {
    kind: &#039;sequence&#039;,
    construct: function (data) { return data !== null ? data : []; }
  });

  var map = new type(&#039;tag:yaml.org,2002:map&#039;, {
    kind: &#039;mapping&#039;,
    construct: function (data) { return data !== null ? data : {}; }
  });

  var failsafe = new schema({
    explicit: [
      str,
      seq,
      map
    ]
  });

  function resolveYamlNull(data) {
    if (data === null) return true;

    var max = data.length;

    return (max === 1 &amp;&amp; data === &#039;~&#039;) ||
           (max === 4 &amp;&amp; (data === &#039;null&#039; || data === &#039;Null&#039; || data === &#039;NULL&#039;));
  }

  function constructYamlNull() {
    return null;
  }

  function isNull(object) {
    return object === null;
  }

  var _null = new type(&#039;tag:yaml.org,2002:null&#039;, {
    kind: &#039;scalar&#039;,
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
      canonical: function () { return &#039;~&#039;;    },
      lowercase: function () { return &#039;null&#039;; },
      uppercase: function () { return &#039;NULL&#039;; },
      camelcase: function () { return &#039;Null&#039;; },
      empty:     function () { return &#039;&#039;;     }
    },
    defaultStyle: &#039;lowercase&#039;
  });

  function resolveYamlBoolean(data) {
    if (data === null) return false;

    var max = data.length;

    return (max === 4 &amp;&amp; (data === &#039;true&#039; || data === &#039;True&#039; || data === &#039;TRUE&#039;)) ||
           (max === 5 &amp;&amp; (data === &#039;false&#039; || data === &#039;False&#039; || data === &#039;FALSE&#039;));
  }

  function constructYamlBoolean(data) {
    return data === &#039;true&#039; ||
           data === &#039;True&#039; ||
           data === &#039;TRUE&#039;;
  }

  function isBoolean(object) {
    return Object.prototype.toString.call(object) === &#039;[object Boolean]&#039;;
  }

  var bool = new type(&#039;tag:yaml.org,2002:bool&#039;, {
    kind: &#039;scalar&#039;,
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
      lowercase: function (object) { return object ? &#039;true&#039; : &#039;false&#039;; },
      uppercase: function (object) { return object ? &#039;TRUE&#039; : &#039;FALSE&#039;; },
      camelcase: function (object) { return object ? &#039;True&#039; : &#039;False&#039;; }
    },
    defaultStyle: &#039;lowercase&#039;
  });

  function isHexCode(c) {
    return ((0x30/* 0 */ &lt;= c) &amp;&amp; (c &lt;= 0x39/* 9 */)) ||
           ((0x41/* A */ &lt;= c) &amp;&amp; (c &lt;= 0x46/* F */)) ||
           ((0x61/* a */ &lt;= c) &amp;&amp; (c &lt;= 0x66/* f */));
  }

  function isOctCode(c) {
    return ((0x30/* 0 */ &lt;= c) &amp;&amp; (c &lt;= 0x37/* 7 */));
  }

  function isDecCode(c) {
    return ((0x30/* 0 */ &lt;= c) &amp;&amp; (c &lt;= 0x39/* 9 */));
  }

  function resolveYamlInteger(data) {
    if (data === null) return false;

    var max = data.length,
        index = 0,
        hasDigits = false,
        ch;

    if (!max) return false;

    ch = data[index];

    // sign
    if (ch === &#039;-&#039; || ch === &#039;+&#039;) {
      ch = data[++index];
    }

    if (ch === &#039;0&#039;) {
      // 0
      if (index + 1 === max) return true;
      ch = data[++index];

      // base 2, base 8, base 16

      if (ch === &#039;b&#039;) {
        // base 2
        index++;

        for (; index &lt; max; index++) {
          ch = data[index];
          if (ch === &#039;_&#039;) continue;
          if (ch !== &#039;0&#039; &amp;&amp; ch !== &#039;1&#039;) return false;
          hasDigits = true;
        }
        return hasDigits &amp;&amp; ch !== &#039;_&#039;;
      }


      if (ch === &#039;x&#039;) {
        // base 16
        index++;

        for (; index &lt; max; index++) {
          ch = data[index];
          if (ch === &#039;_&#039;) continue;
          if (!isHexCode(data.charCodeAt(index))) return false;
          hasDigits = true;
        }
        return hasDigits &amp;&amp; ch !== &#039;_&#039;;
      }


      if (ch === &#039;o&#039;) {
        // base 8
        index++;

        for (; index &lt; max; index++) {
          ch = data[index];
          if (ch === &#039;_&#039;) continue;
          if (!isOctCode(data.charCodeAt(index))) return false;
          hasDigits = true;
        }
        return hasDigits &amp;&amp; ch !== &#039;_&#039;;
      }
    }

    // base 10 (except 0)

    // value should not start with `_`;
    if (ch === &#039;_&#039;) return false;

    for (; index &lt; max; index++) {
      ch = data[index];
      if (ch === &#039;_&#039;) continue;
      if (!isDecCode(data.charCodeAt(index))) {
        return false;
      }
      hasDigits = true;
    }

    // Should have digits and should not end with `_`
    if (!hasDigits || ch === &#039;_&#039;) return false;

    return true;
  }

  function constructYamlInteger(data) {
    var value = data, sign = 1, ch;

    if (value.indexOf(&#039;_&#039;) !== -1) {
      value = value.replace(/_/g, &#039;&#039;);
    }

    ch = value[0];

    if (ch === &#039;-&#039; || ch === &#039;+&#039;) {
      if (ch === &#039;-&#039;) sign = -1;
      value = value.slice(1);
      ch = value[0];
    }

    if (value === &#039;0&#039;) return 0;

    if (ch === &#039;0&#039;) {
      if (value[1] === &#039;b&#039;) return sign * parseInt(value.slice(2), 2);
      if (value[1] === &#039;x&#039;) return sign * parseInt(value.slice(2), 16);
      if (value[1] === &#039;o&#039;) return sign * parseInt(value.slice(2), 8);
    }

    return sign * parseInt(value, 10);
  }

  function isInteger(object) {
    return (Object.prototype.toString.call(object)) === &#039;[object Number]&#039; &amp;&amp;
           (object % 1 === 0 &amp;&amp; !common.isNegativeZero(object));
  }

  var int = new type(&#039;tag:yaml.org,2002:int&#039;, {
    kind: &#039;scalar&#039;,
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger,
    represent: {
      binary:      function (obj) { return obj &gt;= 0 ? &#039;0b&#039; + obj.toString(2) : &#039;-0b&#039; + obj.toString(2).slice(1); },
      octal:       function (obj) { return obj &gt;= 0 ? &#039;0o&#039;  + obj.toString(8) : &#039;-0o&#039;  + obj.toString(8).slice(1); },
      decimal:     function (obj) { return obj.toString(10); },
      /* eslint-disable max-len */
      hexadecimal: function (obj) { return obj &gt;= 0 ? &#039;0x&#039; + obj.toString(16).toUpperCase() :  &#039;-0x&#039; + obj.toString(16).toUpperCase().slice(1); }
    },
    defaultStyle: &#039;decimal&#039;,
    styleAliases: {
      binary:      [ 2,  &#039;bin&#039; ],
      octal:       [ 8,  &#039;oct&#039; ],
      decimal:     [ 10, &#039;dec&#039; ],
      hexadecimal: [ 16, &#039;hex&#039; ]
    }
  });

  var YAML_FLOAT_PATTERN = new RegExp(
    // 2.5e4, 2.5 and integers
    &#039;^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?&#039; +
    // .2e4, .2
    // special case, seems not from spec
    &#039;|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?&#039; +
    // .inf
    &#039;|[-+]?\\.(?:inf|Inf|INF)&#039; +
    // .nan
    &#039;|\\.(?:nan|NaN|NAN))$&#039;);

  function resolveYamlFloat(data) {
    if (data === null) return false;

    if (!YAML_FLOAT_PATTERN.test(data) ||
        // Quick hack to not allow integers end with `_`
        // Probably should update regexp &amp; check speed
        data[data.length - 1] === &#039;_&#039;) {
      return false;
    }

    return true;
  }

  function constructYamlFloat(data) {
    var value, sign;

    value  = data.replace(/_/g, &#039;&#039;).toLowerCase();
    sign   = value[0] === &#039;-&#039; ? -1 : 1;

    if (&#039;+-&#039;.indexOf(value[0]) &gt;= 0) {
      value = value.slice(1);
    }

    if (value === &#039;.inf&#039;) {
      return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

    } else if (value === &#039;.nan&#039;) {
      return NaN;
    }
    return sign * parseFloat(value, 10);
  }


  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

  function representYamlFloat(object, style) {
    var res;

    if (isNaN(object)) {
      switch (style) {
        case &#039;lowercase&#039;: return &#039;.nan&#039;;
        case &#039;uppercase&#039;: return &#039;.NAN&#039;;
        case &#039;camelcase&#039;: return &#039;.NaN&#039;;
      }
    } else if (Number.POSITIVE_INFINITY === object) {
      switch (style) {
        case &#039;lowercase&#039;: return &#039;.inf&#039;;
        case &#039;uppercase&#039;: return &#039;.INF&#039;;
        case &#039;camelcase&#039;: return &#039;.Inf&#039;;
      }
    } else if (Number.NEGATIVE_INFINITY === object) {
      switch (style) {
        case &#039;lowercase&#039;: return &#039;-.inf&#039;;
        case &#039;uppercase&#039;: return &#039;-.INF&#039;;
        case &#039;camelcase&#039;: return &#039;-.Inf&#039;;
      }
    } else if (common.isNegativeZero(object)) {
      return &#039;-0.0&#039;;
    }

    res = object.toString(10);

    // JS stringifier can build scientific format without dots: 5e-100,
    // while YAML requres dot: 5.e-100. Fix it with simple hack

    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace(&#039;e&#039;, &#039;.e&#039;) : res;
  }

  function isFloat(object) {
    return (Object.prototype.toString.call(object) === &#039;[object Number]&#039;) &amp;&amp;
           (object % 1 !== 0 || common.isNegativeZero(object));
  }

  var float = new type(&#039;tag:yaml.org,2002:float&#039;, {
    kind: &#039;scalar&#039;,
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat,
    represent: representYamlFloat,
    defaultStyle: &#039;lowercase&#039;
  });

  var json = failsafe.extend({
    implicit: [
      _null,
      bool,
      int,
      float
    ]
  });

  var core = json;

  var YAML_DATE_REGEXP = new RegExp(
    &#039;^([0-9][0-9][0-9][0-9])&#039;          + // [1] year
    &#039;-([0-9][0-9])&#039;                    + // [2] month
    &#039;-([0-9][0-9])$&#039;);                   // [3] day

  var YAML_TIMESTAMP_REGEXP = new RegExp(
    &#039;^([0-9][0-9][0-9][0-9])&#039;          + // [1] year
    &#039;-([0-9][0-9]?)&#039;                   + // [2] month
    &#039;-([0-9][0-9]?)&#039;                   + // [3] day
    &#039;(?:[Tt]|[ \\t]+)&#039;                 + // ...
    &#039;([0-9][0-9]?)&#039;                    + // [4] hour
    &#039;:([0-9][0-9])&#039;                    + // [5] minute
    &#039;:([0-9][0-9])&#039;                    + // [6] second
    &#039;(?:\\.([0-9]*))?&#039;                 + // [7] fraction
    &#039;(?:[ \\t]*(Z|([-+])([0-9][0-9]?)&#039; + // [8] tz [9] tz_sign [10] tz_hour
    &#039;(?::([0-9][0-9]))?))?$&#039;);           // [11] tz_minute

  function resolveYamlTimestamp(data) {
    if (data === null) return false;
    if (YAML_DATE_REGEXP.exec(data) !== null) return true;
    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
    return false;
  }

  function constructYamlTimestamp(data) {
    var match, year, month, day, hour, minute, second, fraction = 0,
        delta = null, tz_hour, tz_minute, date;

    match = YAML_DATE_REGEXP.exec(data);
    if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

    if (match === null) throw new Error(&#039;Date resolve error&#039;);

    // match: [1] year [2] month [3] day

    year = +(match[1]);
    month = +(match[2]) - 1; // JS month starts with 0
    day = +(match[3]);

    if (!match[4]) { // no hour
      return new Date(Date.UTC(year, month, day));
    }

    // match: [4] hour [5] minute [6] second [7] fraction

    hour = +(match[4]);
    minute = +(match[5]);
    second = +(match[6]);

    if (match[7]) {
      fraction = match[7].slice(0, 3);
      while (fraction.length &lt; 3) { // milli-seconds
        fraction += &#039;0&#039;;
      }
      fraction = +fraction;
    }

    // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

    if (match[9]) {
      tz_hour = +(match[10]);
      tz_minute = +(match[11] || 0);
      delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
      if (match[9] === &#039;-&#039;) delta = -delta;
    }

    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

    if (delta) date.setTime(date.getTime() - delta);

    return date;
  }

  function representYamlTimestamp(object /*, style*/) {
    return object.toISOString();
  }

  var timestamp = new type(&#039;tag:yaml.org,2002:timestamp&#039;, {
    kind: &#039;scalar&#039;,
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
  });

  function resolveYamlMerge(data) {
    return data === &#039;&lt;&lt;&#039; || data === null;
  }

  var merge = new type(&#039;tag:yaml.org,2002:merge&#039;, {
    kind: &#039;scalar&#039;,
    resolve: resolveYamlMerge
  });

  /*eslint-disable no-bitwise*/





  // [ 64, 65, 66 ] -&gt; [ padding, CR, LF ]
  var BASE64_MAP = &#039;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r&#039;;


  function resolveYamlBinary(data) {
    if (data === null) return false;

    var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

    // Convert one by one.
    for (idx = 0; idx &lt; max; idx++) {
      code = map.indexOf(data.charAt(idx));

      // Skip CR/LF
      if (code &gt; 64) continue;

      // Fail on illegal characters
      if (code &lt; 0) return false;

      bitlen += 6;
    }

    // If there are any bits left, source was corrupted
    return (bitlen % 8) === 0;
  }

  function constructYamlBinary(data) {
    var idx, tailbits,
        input = data.replace(/[\r\n=]/g, &#039;&#039;), // remove CR/LF &amp; padding to simplify scan
        max = input.length,
        map = BASE64_MAP,
        bits = 0,
        result = [];

    // Collect by 6*4 bits (3 bytes)

    for (idx = 0; idx &lt; max; idx++) {
      if ((idx % 4 === 0) &amp;&amp; idx) {
        result.push((bits &gt;&gt; 16) &amp; 0xFF);
        result.push((bits &gt;&gt; 8) &amp; 0xFF);
        result.push(bits &amp; 0xFF);
      }

      bits = (bits &lt;&lt; 6) | map.indexOf(input.charAt(idx));
    }

    // Dump tail

    tailbits = (max % 4) * 6;

    if (tailbits === 0) {
      result.push((bits &gt;&gt; 16) &amp; 0xFF);
      result.push((bits &gt;&gt; 8) &amp; 0xFF);
      result.push(bits &amp; 0xFF);
    } else if (tailbits === 18) {
      result.push((bits &gt;&gt; 10) &amp; 0xFF);
      result.push((bits &gt;&gt; 2) &amp; 0xFF);
    } else if (tailbits === 12) {
      result.push((bits &gt;&gt; 4) &amp; 0xFF);
    }

    return new Uint8Array(result);
  }

  function representYamlBinary(object /*, style*/) {
    var result = &#039;&#039;, bits = 0, idx, tail,
        max = object.length,
        map = BASE64_MAP;

    // Convert every three bytes to 4 ASCII characters.

    for (idx = 0; idx &lt; max; idx++) {
      if ((idx % 3 === 0) &amp;&amp; idx) {
        result += map[(bits &gt;&gt; 18) &amp; 0x3F];
        result += map[(bits &gt;&gt; 12) &amp; 0x3F];
        result += map[(bits &gt;&gt; 6) &amp; 0x3F];
        result += map[bits &amp; 0x3F];
      }

      bits = (bits &lt;&lt; 8) + object[idx];
    }

    // Dump tail

    tail = max % 3;

    if (tail === 0) {
      result += map[(bits &gt;&gt; 18) &amp; 0x3F];
      result += map[(bits &gt;&gt; 12) &amp; 0x3F];
      result += map[(bits &gt;&gt; 6) &amp; 0x3F];
      result += map[bits &amp; 0x3F];
    } else if (tail === 2) {
      result += map[(bits &gt;&gt; 10) &amp; 0x3F];
      result += map[(bits &gt;&gt; 4) &amp; 0x3F];
      result += map[(bits &lt;&lt; 2) &amp; 0x3F];
      result += map[64];
    } else if (tail === 1) {
      result += map[(bits &gt;&gt; 2) &amp; 0x3F];
      result += map[(bits &lt;&lt; 4) &amp; 0x3F];
      result += map[64];
      result += map[64];
    }

    return result;
  }

  function isBinary(obj) {
    return Object.prototype.toString.call(obj) ===  &#039;[object Uint8Array]&#039;;
  }

  var binary = new type(&#039;tag:yaml.org,2002:binary&#039;, {
    kind: &#039;scalar&#039;,
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
  });

  var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
  var _toString$2       = Object.prototype.toString;

  function resolveYamlOmap(data) {
    if (data === null) return true;

    var objectKeys = [], index, length, pair, pairKey, pairHasKey,
        object = data;

    for (index = 0, length = object.length; index &lt; length; index += 1) {
      pair = object[index];
      pairHasKey = false;

      if (_toString$2.call(pair) !== &#039;[object Object]&#039;) return false;

      for (pairKey in pair) {
        if (_hasOwnProperty$3.call(pair, pairKey)) {
          if (!pairHasKey) pairHasKey = true;
          else return false;
        }
      }

      if (!pairHasKey) return false;

      if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
      else return false;
    }

    return true;
  }

  function constructYamlOmap(data) {
    return data !== null ? data : [];
  }

  var omap = new type(&#039;tag:yaml.org,2002:omap&#039;, {
    kind: &#039;sequence&#039;,
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
  });

  var _toString$1 = Object.prototype.toString;

  function resolveYamlPairs(data) {
    if (data === null) return true;

    var index, length, pair, keys, result,
        object = data;

    result = new Array(object.length);

    for (index = 0, length = object.length; index &lt; length; index += 1) {
      pair = object[index];

      if (_toString$1.call(pair) !== &#039;[object Object]&#039;) return false;

      keys = Object.keys(pair);

      if (keys.length !== 1) return false;

      result[index] = [ keys[0], pair[keys[0]] ];
    }

    return true;
  }

  function constructYamlPairs(data) {
    if (data === null) return [];

    var index, length, pair, keys, result,
        object = data;

    result = new Array(object.length);

    for (index = 0, length = object.length; index &lt; length; index += 1) {
      pair = object[index];

      keys = Object.keys(pair);

      result[index] = [ keys[0], pair[keys[0]] ];
    }

    return result;
  }

  var pairs = new type(&#039;tag:yaml.org,2002:pairs&#039;, {
    kind: &#039;sequence&#039;,
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
  });

  var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;

  function resolveYamlSet(data) {
    if (data === null) return true;

    var key, object = data;

    for (key in object) {
      if (_hasOwnProperty$2.call(object, key)) {
        if (object[key] !== null) return false;
      }
    }

    return true;
  }

  function constructYamlSet(data) {
    return data !== null ? data : {};
  }

  var set = new type(&#039;tag:yaml.org,2002:set&#039;, {
    kind: &#039;mapping&#039;,
    resolve: resolveYamlSet,
    construct: constructYamlSet
  });

  var _default = core.extend({
    implicit: [
      timestamp,
      merge
    ],
    explicit: [
      binary,
      omap,
      pairs,
      set
    ]
  });

  /*eslint-disable max-len,no-use-before-define*/







  var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;


  var CONTEXT_FLOW_IN   = 1;
  var CONTEXT_FLOW_OUT  = 2;
  var CONTEXT_BLOCK_IN  = 3;
  var CONTEXT_BLOCK_OUT = 4;


  var CHOMPING_CLIP  = 1;
  var CHOMPING_STRIP = 2;
  var CHOMPING_KEEP  = 3;


  var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
  var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
  var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
  var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&amp;=\+\$,_\.!~\*&#039;\(\)\[\]])*$/i;


  function _class(obj) { return Object.prototype.toString.call(obj); }

  function is_EOL(c) {
    return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
  }

  function is_WHITE_SPACE(c) {
    return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
  }

  function is_WS_OR_EOL(c) {
    return (c === 0x09/* Tab */) ||
           (c === 0x20/* Space */) ||
           (c === 0x0A/* LF */) ||
           (c === 0x0D/* CR */);
  }

  function is_FLOW_INDICATOR(c) {
    return c === 0x2C/* , */ ||
           c === 0x5B/* [ */ ||
           c === 0x5D/* ] */ ||
           c === 0x7B/* { */ ||
           c === 0x7D/* } */;
  }

  function fromHexCode(c) {
    var lc;

    if ((0x30/* 0 */ &lt;= c) &amp;&amp; (c &lt;= 0x39/* 9 */)) {
      return c - 0x30;
    }

    /*eslint-disable no-bitwise*/
    lc = c | 0x20;

    if ((0x61/* a */ &lt;= lc) &amp;&amp; (lc &lt;= 0x66/* f */)) {
      return lc - 0x61 + 10;
    }

    return -1;
  }

  function escapedHexLen(c) {
    if (c === 0x78/* x */) { return 2; }
    if (c === 0x75/* u */) { return 4; }
    if (c === 0x55/* U */) { return 8; }
    return 0;
  }

  function fromDecimalCode(c) {
    if ((0x30/* 0 */ &lt;= c) &amp;&amp; (c &lt;= 0x39/* 9 */)) {
      return c - 0x30;
    }

    return -1;
  }

  function simpleEscapeSequence(c) {
    /* eslint-disable indent */
    return (c === 0x30/* 0 */) ? &#039;\x00&#039; :
          (c === 0x61/* a */) ? &#039;\x07&#039; :
          (c === 0x62/* b */) ? &#039;\x08&#039; :
          (c === 0x74/* t */) ? &#039;\x09&#039; :
          (c === 0x09/* Tab */) ? &#039;\x09&#039; :
          (c === 0x6E/* n */) ? &#039;\x0A&#039; :
          (c === 0x76/* v */) ? &#039;\x0B&#039; :
          (c === 0x66/* f */) ? &#039;\x0C&#039; :
          (c === 0x72/* r */) ? &#039;\x0D&#039; :
          (c === 0x65/* e */) ? &#039;\x1B&#039; :
          (c === 0x20/* Space */) ? &#039; &#039; :
          (c === 0x22/* &quot; */) ? &#039;\x22&#039; :
          (c === 0x2F/* / */) ? &#039;/&#039; :
          (c === 0x5C/* \ */) ? &#039;\x5C&#039; :
          (c === 0x4E/* N */) ? &#039;\x85&#039; :
          (c === 0x5F/* _ */) ? &#039;\xA0&#039; :
          (c === 0x4C/* L */) ? &#039;\u2028&#039; :
          (c === 0x50/* P */) ? &#039;\u2029&#039; : &#039;&#039;;
  }

  function charFromCodepoint(c) {
    if (c &lt;= 0xFFFF) {
      return String.fromCharCode(c);
    }
    // Encode UTF-16 surrogate pair
    // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
    return String.fromCharCode(
      ((c - 0x010000) &gt;&gt; 10) + 0xD800,
      ((c - 0x010000) &amp; 0x03FF) + 0xDC00
    );
  }

  var simpleEscapeCheck = new Array(256); // integer, for fast access
  var simpleEscapeMap = new Array(256);
  for (var i = 0; i &lt; 256; i++) {
    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
    simpleEscapeMap[i] = simpleEscapeSequence(i);
  }


  function State$1(input, options) {
    this.input = input;

    this.filename  = options[&#039;filename&#039;]  || null;
    this.schema    = options[&#039;schema&#039;]    || _default;
    this.onWarning = options[&#039;onWarning&#039;] || null;
    // (Hidden) Remove? makes the loader to expect YAML 1.1 documents
    // if such documents have no explicit %YAML directive
    this.legacy    = options[&#039;legacy&#039;]    || false;

    this.json      = options[&#039;json&#039;]      || false;
    this.listener  = options[&#039;listener&#039;]  || null;

    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap       = this.schema.compiledTypeMap;

    this.length     = input.length;
    this.position   = 0;
    this.line       = 0;
    this.lineStart  = 0;
    this.lineIndent = 0;

    // position of first leading tab in the current line,
    // used to make sure there are no tabs in the indentation
    this.firstTabInLine = -1;

    this.documents = [];

    /*
    this.version;
    this.checkLineBreaks;
    this.tagMap;
    this.anchorMap;
    this.tag;
    this.anchor;
    this.kind;
    this.result;*/

  }


  function generateError(state, message) {
    var mark = {
      name:     state.filename,
      buffer:   state.input.slice(0, -1), // omit trailing \0
      position: state.position,
      line:     state.line,
      column:   state.position - state.lineStart
    };

    mark.snippet = snippet(mark);

    return new exception(message, mark);
  }

  function throwError(state, message) {
    throw generateError(state, message);
  }

  function throwWarning(state, message) {
    if (state.onWarning) {
      state.onWarning.call(null, generateError(state, message));
    }
  }


  var directiveHandlers = {

    YAML: function handleYamlDirective(state, name, args) {

      var match, major, minor;

      if (state.version !== null) {
        throwError(state, &#039;duplication of %YAML directive&#039;);
      }

      if (args.length !== 1) {
        throwError(state, &#039;YAML directive accepts exactly one argument&#039;);
      }

      match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

      if (match === null) {
        throwError(state, &#039;ill-formed argument of the YAML directive&#039;);
      }

      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);

      if (major !== 1) {
        throwError(state, &#039;unacceptable YAML version of the document&#039;);
      }

      state.version = args[0];
      state.checkLineBreaks = (minor &lt; 2);

      if (minor !== 1 &amp;&amp; minor !== 2) {
        throwWarning(state, &#039;unsupported YAML version of the document&#039;);
      }
    },

    TAG: function handleTagDirective(state, name, args) {

      var handle, prefix;

      if (args.length !== 2) {
        throwError(state, &#039;TAG directive accepts exactly two arguments&#039;);
      }

      handle = args[0];
      prefix = args[1];

      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError(state, &#039;ill-formed tag handle (first argument) of the TAG directive&#039;);
      }

      if (_hasOwnProperty$1.call(state.tagMap, handle)) {
        throwError(state, &#039;there is a previously declared suffix for &quot;&#039; + handle + &#039;&quot; tag handle&#039;);
      }

      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError(state, &#039;ill-formed tag prefix (second argument) of the TAG directive&#039;);
      }

      try {
        prefix = decodeURIComponent(prefix);
      } catch (err) {
        throwError(state, &#039;tag prefix is malformed: &#039; + prefix);
      }

      state.tagMap[handle] = prefix;
    }
  };


  function captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;

    if (start &lt; end) {
      _result = state.input.slice(start, end);

      if (checkJson) {
        for (_position = 0, _length = _result.length; _position &lt; _length; _position += 1) {
          _character = _result.charCodeAt(_position);
          if (!(_character === 0x09 ||
                (0x20 &lt;= _character &amp;&amp; _character &lt;= 0x10FFFF))) {
            throwError(state, &#039;expected valid JSON character&#039;);
          }
        }
      } else if (PATTERN_NON_PRINTABLE.test(_result)) {
        throwError(state, &#039;the stream contains non-printable characters&#039;);
      }

      state.result += _result;
    }
  }

  function mergeMappings(state, destination, source, overridableKeys) {
    var sourceKeys, key, index, quantity;

    if (!common.isObject(source)) {
      throwError(state, &#039;cannot merge mappings; the provided source object is unacceptable&#039;);
    }

    sourceKeys = Object.keys(source);

    for (index = 0, quantity = sourceKeys.length; index &lt; quantity; index += 1) {
      key = sourceKeys[index];

      if (!_hasOwnProperty$1.call(destination, key)) {
        destination[key] = source[key];
        overridableKeys[key] = true;
      }
    }
  }

  function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode,
    startLine, startLineStart, startPos) {

    var index, quantity;

    // The output is a plain object here, so keys can only be strings.
    // We need to convert keyNode to a string, but doing so can hang the process
    // (deeply nested arrays that explode exponentially using aliases).
    if (Array.isArray(keyNode)) {
      keyNode = Array.prototype.slice.call(keyNode);

      for (index = 0, quantity = keyNode.length; index &lt; quantity; index += 1) {
        if (Array.isArray(keyNode[index])) {
          throwError(state, &#039;nested arrays are not supported inside keys&#039;);
        }

        if (typeof keyNode === &#039;object&#039; &amp;&amp; _class(keyNode[index]) === &#039;[object Object]&#039;) {
          keyNode[index] = &#039;[object Object]&#039;;
        }
      }
    }

    // Avoid code execution in load() via toString property
    // (still use its own toString for arrays, timestamps,
    // and whatever user schema extensions happen to have @@toStringTag)
    if (typeof keyNode === &#039;object&#039; &amp;&amp; _class(keyNode) === &#039;[object Object]&#039;) {
      keyNode = &#039;[object Object]&#039;;
    }


    keyNode = String(keyNode);

    if (_result === null) {
      _result = {};
    }

    if (keyTag === &#039;tag:yaml.org,2002:merge&#039;) {
      if (Array.isArray(valueNode)) {
        for (index = 0, quantity = valueNode.length; index &lt; quantity; index += 1) {
          mergeMappings(state, _result, valueNode[index], overridableKeys);
        }
      } else {
        mergeMappings(state, _result, valueNode, overridableKeys);
      }
    } else {
      if (!state.json &amp;&amp;
          !_hasOwnProperty$1.call(overridableKeys, keyNode) &amp;&amp;
          _hasOwnProperty$1.call(_result, keyNode)) {
        state.line = startLine || state.line;
        state.lineStart = startLineStart || state.lineStart;
        state.position = startPos || state.position;
        throwError(state, &#039;duplicated mapping key&#039;);
      }

      // used for this specific key only because Object.defineProperty is slow
      if (keyNode === &#039;__proto__&#039;) {
        Object.defineProperty(_result, keyNode, {
          configurable: true,
          enumerable: true,
          writable: true,
          value: valueNode
        });
      } else {
        _result[keyNode] = valueNode;
      }
      delete overridableKeys[keyNode];
    }

    return _result;
  }

  function readLineBreak(state) {
    var ch;

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x0A/* LF */) {
      state.position++;
    } else if (ch === 0x0D/* CR */) {
      state.position++;
      if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
        state.position++;
      }
    } else {
      throwError(state, &#039;a line break is expected&#039;);
    }

    state.line += 1;
    state.lineStart = state.position;
    state.firstTabInLine = -1;
  }

  function skipSeparationSpace(state, allowComments, checkIndent) {
    var lineBreaks = 0,
        ch = state.input.charCodeAt(state.position);

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        if (ch === 0x09/* Tab */ &amp;&amp; state.firstTabInLine === -1) {
          state.firstTabInLine = state.position;
        }
        ch = state.input.charCodeAt(++state.position);
      }

      if (allowComments &amp;&amp; ch === 0x23/* # */) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0x0A/* LF */ &amp;&amp; ch !== 0x0D/* CR */ &amp;&amp; ch !== 0);
      }

      if (is_EOL(ch)) {
        readLineBreak(state);

        ch = state.input.charCodeAt(state.position);
        lineBreaks++;
        state.lineIndent = 0;

        while (ch === 0x20/* Space */) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
      } else {
        break;
      }
    }

    if (checkIndent !== -1 &amp;&amp; lineBreaks !== 0 &amp;&amp; state.lineIndent &lt; checkIndent) {
      throwWarning(state, &#039;deficient indentation&#039;);
    }

    return lineBreaks;
  }

  function testDocumentSeparator(state) {
    var _position = state.position,
        ch;

    ch = state.input.charCodeAt(_position);

    // Condition state.position === state.lineStart is tested
    // in parent on each call, for efficiency. No needs to test here again.
    if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &amp;&amp;
        ch === state.input.charCodeAt(_position + 1) &amp;&amp;
        ch === state.input.charCodeAt(_position + 2)) {

      _position += 3;

      ch = state.input.charCodeAt(_position);

      if (ch === 0 || is_WS_OR_EOL(ch)) {
        return true;
      }
    }

    return false;
  }

  function writeFoldedLines(state, count) {
    if (count === 1) {
      state.result += &#039; &#039;;
    } else if (count &gt; 1) {
      state.result += common.repeat(&#039;\n&#039;, count - 1);
    }
  }


  function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding,
        following,
        captureStart,
        captureEnd,
        hasPendingContent,
        _line,
        _lineStart,
        _lineIndent,
        _kind = state.kind,
        _result = state.result,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (is_WS_OR_EOL(ch)      ||
        is_FLOW_INDICATOR(ch) ||
        ch === 0x23/* # */    ||
        ch === 0x26/* &amp; */    ||
        ch === 0x2A/* * */    ||
        ch === 0x21/* ! */    ||
        ch === 0x7C/* | */    ||
        ch === 0x3E/* &gt; */    ||
        ch === 0x27/* &#039; */    ||
        ch === 0x22/* &quot; */    ||
        ch === 0x25/* % */    ||
        ch === 0x40/* @ */    ||
        ch === 0x60/* ` */) {
      return false;
    }

    if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection &amp;&amp; is_FLOW_INDICATOR(following)) {
        return false;
      }
    }

    state.kind = &#039;scalar&#039;;
    state.result = &#039;&#039;;
    captureStart = captureEnd = state.position;
    hasPendingContent = false;

    while (ch !== 0) {
      if (ch === 0x3A/* : */) {
        following = state.input.charCodeAt(state.position + 1);

        if (is_WS_OR_EOL(following) ||
            withinFlowCollection &amp;&amp; is_FLOW_INDICATOR(following)) {
          break;
        }

      } else if (ch === 0x23/* # */) {
        preceding = state.input.charCodeAt(state.position - 1);

        if (is_WS_OR_EOL(preceding)) {
          break;
        }

      } else if ((state.position === state.lineStart &amp;&amp; testDocumentSeparator(state)) ||
                 withinFlowCollection &amp;&amp; is_FLOW_INDICATOR(ch)) {
        break;

      } else if (is_EOL(ch)) {
        _line = state.line;
        _lineStart = state.lineStart;
        _lineIndent = state.lineIndent;
        skipSeparationSpace(state, false, -1);

        if (state.lineIndent &gt;= nodeIndent) {
          hasPendingContent = true;
          ch = state.input.charCodeAt(state.position);
          continue;
        } else {
          state.position = captureEnd;
          state.line = _line;
          state.lineStart = _lineStart;
          state.lineIndent = _lineIndent;
          break;
        }
      }

      if (hasPendingContent) {
        captureSegment(state, captureStart, captureEnd, false);
        writeFoldedLines(state, state.line - _line);
        captureStart = captureEnd = state.position;
        hasPendingContent = false;
      }

      if (!is_WHITE_SPACE(ch)) {
        captureEnd = state.position + 1;
      }

      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, captureEnd, false);

    if (state.result) {
      return true;
    }

    state.kind = _kind;
    state.result = _result;
    return false;
  }

  function readSingleQuotedScalar(state, nodeIndent) {
    var ch,
        captureStart, captureEnd;

    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x27/* &#039; */) {
      return false;
    }

    state.kind = &#039;scalar&#039;;
    state.result = &#039;&#039;;
    state.position++;
    captureStart = captureEnd = state.position;

    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 0x27/* &#039; */) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);

        if (ch === 0x27/* &#039; */) {
          captureStart = state.position;
          state.position++;
          captureEnd = state.position;
        } else {
          return true;
        }

      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;

      } else if (state.position === state.lineStart &amp;&amp; testDocumentSeparator(state)) {
        throwError(state, &#039;unexpected end of the document within a single quoted scalar&#039;);

      } else {
        state.position++;
        captureEnd = state.position;
      }
    }

    throwError(state, &#039;unexpected end of the stream within a single quoted scalar&#039;);
  }

  function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart,
        captureEnd,
        hexLength,
        hexResult,
        tmp,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x22/* &quot; */) {
      return false;
    }

    state.kind = &#039;scalar&#039;;
    state.result = &#039;&#039;;
    state.position++;
    captureStart = captureEnd = state.position;

    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 0x22/* &quot; */) {
        captureSegment(state, captureStart, state.position, true);
        state.position++;
        return true;

      } else if (ch === 0x5C/* \ */) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);

        if (is_EOL(ch)) {
          skipSeparationSpace(state, false, nodeIndent);

          // TODO: rework to inline fn with no type cast?
        } else if (ch &lt; 256 &amp;&amp; simpleEscapeCheck[ch]) {
          state.result += simpleEscapeMap[ch];
          state.position++;

        } else if ((tmp = escapedHexLen(ch)) &gt; 0) {
          hexLength = tmp;
          hexResult = 0;

          for (; hexLength &gt; 0; hexLength--) {
            ch = state.input.charCodeAt(++state.position);

            if ((tmp = fromHexCode(ch)) &gt;= 0) {
              hexResult = (hexResult &lt;&lt; 4) + tmp;

            } else {
              throwError(state, &#039;expected hexadecimal character&#039;);
            }
          }

          state.result += charFromCodepoint(hexResult);

          state.position++;

        } else {
          throwError(state, &#039;unknown escape sequence&#039;);
        }

        captureStart = captureEnd = state.position;

      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;

      } else if (state.position === state.lineStart &amp;&amp; testDocumentSeparator(state)) {
        throwError(state, &#039;unexpected end of the document within a double quoted scalar&#039;);

      } else {
        state.position++;
        captureEnd = state.position;
      }
    }

    throwError(state, &#039;unexpected end of the stream within a double quoted scalar&#039;);
  }

  function readFlowCollection(state, nodeIndent) {
    var readNext = true,
        _line,
        _lineStart,
        _pos,
        _tag     = state.tag,
        _result,
        _anchor  = state.anchor,
        following,
        terminator,
        isPair,
        isExplicitPair,
        isMapping,
        overridableKeys = Object.create(null),
        keyNode,
        keyTag,
        valueNode,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x5B/* [ */) {
      terminator = 0x5D;/* ] */
      isMapping = false;
      _result = [];
    } else if (ch === 0x7B/* { */) {
      terminator = 0x7D;/* } */
      isMapping = true;
      _result = {};
    } else {
      return false;
    }

    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }

    ch = state.input.charCodeAt(++state.position);

    while (ch !== 0) {
      skipSeparationSpace(state, true, nodeIndent);

      ch = state.input.charCodeAt(state.position);

      if (ch === terminator) {
        state.position++;
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = isMapping ? &#039;mapping&#039; : &#039;sequence&#039;;
        state.result = _result;
        return true;
      } else if (!readNext) {
        throwError(state, &#039;missed comma between flow collection entries&#039;);
      } else if (ch === 0x2C/* , */) {
        // &quot;flow collection entries can never be completely empty&quot;, as per YAML 1.2, section 7.4
        throwError(state, &quot;expected the node content, but found &#039;,&#039;&quot;);
      }

      keyTag = keyNode = valueNode = null;
      isPair = isExplicitPair = false;

      if (ch === 0x3F/* ? */) {
        following = state.input.charCodeAt(state.position + 1);

        if (is_WS_OR_EOL(following)) {
          isPair = isExplicitPair = true;
          state.position++;
          skipSeparationSpace(state, true, nodeIndent);
        }
      }

      _line = state.line; // Save the current line.
      _lineStart = state.lineStart;
      _pos = state.position;
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      keyTag = state.tag;
      keyNode = state.result;
      skipSeparationSpace(state, true, nodeIndent);

      ch = state.input.charCodeAt(state.position);

      if ((isExplicitPair || state.line === _line) &amp;&amp; ch === 0x3A/* : */) {
        isPair = true;
        ch = state.input.charCodeAt(++state.position);
        skipSeparationSpace(state, true, nodeIndent);
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        valueNode = state.result;
      }

      if (isMapping) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
      } else if (isPair) {
        _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
      } else {
        _result.push(keyNode);
      }

      skipSeparationSpace(state, true, nodeIndent);

      ch = state.input.charCodeAt(state.position);

      if (ch === 0x2C/* , */) {
        readNext = true;
        ch = state.input.charCodeAt(++state.position);
      } else {
        readNext = false;
      }
    }

    throwError(state, &#039;unexpected end of the stream within a flow collection&#039;);
  }

  function readBlockScalar(state, nodeIndent) {
    var captureStart,
        folding,
        chomping       = CHOMPING_CLIP,
        didReadContent = false,
        detectedIndent = false,
        textIndent     = nodeIndent,
        emptyLines     = 0,
        atMoreIndented = false,
        tmp,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x7C/* | */) {
      folding = false;
    } else if (ch === 0x3E/* &gt; */) {
      folding = true;
    } else {
      return false;
    }

    state.kind = &#039;scalar&#039;;
    state.result = &#039;&#039;;

    while (ch !== 0) {
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
        if (CHOMPING_CLIP === chomping) {
          chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
        } else {
          throwError(state, &#039;repeat of a chomping mode identifier&#039;);
        }

      } else if ((tmp = fromDecimalCode(ch)) &gt;= 0) {
        if (tmp === 0) {
          throwError(state, &#039;bad explicit indentation width of a block scalar; it cannot be less than one&#039;);
        } else if (!detectedIndent) {
          textIndent = nodeIndent + tmp - 1;
          detectedIndent = true;
        } else {
          throwError(state, &#039;repeat of an indentation width identifier&#039;);
        }

      } else {
        break;
      }
    }

    if (is_WHITE_SPACE(ch)) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (is_WHITE_SPACE(ch));

      if (ch === 0x23/* # */) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (!is_EOL(ch) &amp;&amp; (ch !== 0));
      }
    }

    while (ch !== 0) {
      readLineBreak(state);
      state.lineIndent = 0;

      ch = state.input.charCodeAt(state.position);

      while ((!detectedIndent || state.lineIndent &lt; textIndent) &amp;&amp;
             (ch === 0x20/* Space */)) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }

      if (!detectedIndent &amp;&amp; state.lineIndent &gt; textIndent) {
        textIndent = state.lineIndent;
      }

      if (is_EOL(ch)) {
        emptyLines++;
        continue;
      }

      // End of the scalar.
      if (state.lineIndent &lt; textIndent) {

        // Perform the chomping.
        if (chomping === CHOMPING_KEEP) {
          state.result += common.repeat(&#039;\n&#039;, didReadContent ? 1 + emptyLines : emptyLines);
        } else if (chomping === CHOMPING_CLIP) {
          if (didReadContent) { // i.e. only if the scalar is not empty.
            state.result += &#039;\n&#039;;
          }
        }

        // Break this `while` cycle and go to the funciton&#039;s epilogue.
        break;
      }

      // Folded style: use fancy rules to handle line breaks.
      if (folding) {

        // Lines starting with white space characters (more-indented lines) are not folded.
        if (is_WHITE_SPACE(ch)) {
          atMoreIndented = true;
          // except for the first content line (cf. Example 8.1)
          state.result += common.repeat(&#039;\n&#039;, didReadContent ? 1 + emptyLines : emptyLines);

        // End of more-indented block.
        } else if (atMoreIndented) {
          atMoreIndented = false;
          state.result += common.repeat(&#039;\n&#039;, emptyLines + 1);

        // Just one line break - perceive as the same line.
        } else if (emptyLines === 0) {
          if (didReadContent) { // i.e. only if we have already read some scalar content.
            state.result += &#039; &#039;;
          }

        // Several line breaks - perceive as different lines.
        } else {
          state.result += common.repeat(&#039;\n&#039;, emptyLines);
        }

      // Literal style: just add exact number of line breaks between content lines.
      } else {
        // Keep all line breaks except the header line break.
        state.result += common.repeat(&#039;\n&#039;, didReadContent ? 1 + emptyLines : emptyLines);
      }

      didReadContent = true;
      detectedIndent = true;
      emptyLines = 0;
      captureStart = state.position;

      while (!is_EOL(ch) &amp;&amp; (ch !== 0)) {
        ch = state.input.charCodeAt(++state.position);
      }

      captureSegment(state, captureStart, state.position, false);
    }

    return true;
  }

  function readBlockSequence(state, nodeIndent) {
    var _line,
        _tag      = state.tag,
        _anchor   = state.anchor,
        _result   = [],
        following,
        detected  = false,
        ch;

    // there is a leading tab before this token, so it can&#039;t be a block sequence/mapping;
    // it can still be flow sequence/mapping or a scalar
    if (state.firstTabInLine !== -1) return false;

    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }

    ch = state.input.charCodeAt(state.position);

    while (ch !== 0) {
      if (state.firstTabInLine !== -1) {
        state.position = state.firstTabInLine;
        throwError(state, &#039;tab characters must not be used in indentation&#039;);
      }

      if (ch !== 0x2D/* - */) {
        break;
      }

      following = state.input.charCodeAt(state.position + 1);

      if (!is_WS_OR_EOL(following)) {
        break;
      }

      detected = true;
      state.position++;

      if (skipSeparationSpace(state, true, -1)) {
        if (state.lineIndent &lt;= nodeIndent) {
          _result.push(null);
          ch = state.input.charCodeAt(state.position);
          continue;
        }
      }

      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
      _result.push(state.result);
      skipSeparationSpace(state, true, -1);

      ch = state.input.charCodeAt(state.position);

      if ((state.line === _line || state.lineIndent &gt; nodeIndent) &amp;&amp; (ch !== 0)) {
        throwError(state, &#039;bad indentation of a sequence entry&#039;);
      } else if (state.lineIndent &lt; nodeIndent) {
        break;
      }
    }

    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = &#039;sequence&#039;;
      state.result = _result;
      return true;
    }
    return false;
  }

  function readBlockMapping(state, nodeIndent, flowIndent) {
    var following,
        allowCompact,
        _line,
        _keyLine,
        _keyLineStart,
        _keyPos,
        _tag          = state.tag,
        _anchor       = state.anchor,
        _result       = {},
        overridableKeys = Object.create(null),
        keyTag        = null,
        keyNode       = null,
        valueNode     = null,
        atExplicitKey = false,
        detected      = false,
        ch;

    // there is a leading tab before this token, so it can&#039;t be a block sequence/mapping;
    // it can still be flow sequence/mapping or a scalar
    if (state.firstTabInLine !== -1) return false;

    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }

    ch = state.input.charCodeAt(state.position);

    while (ch !== 0) {
      if (!atExplicitKey &amp;&amp; state.firstTabInLine !== -1) {
        state.position = state.firstTabInLine;
        throwError(state, &#039;tab characters must not be used in indentation&#039;);
      }

      following = state.input.charCodeAt(state.position + 1);
      _line = state.line; // Save the current line.

      //
      // Explicit notation case. There are two separate blocks:
      // first for the key (denoted by &quot;?&quot;) and second for the value (denoted by &quot;:&quot;)
      //
      if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) &amp;&amp; is_WS_OR_EOL(following)) {

        if (ch === 0x3F/* ? */) {
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = true;
          allowCompact = true;

        } else if (atExplicitKey) {
          // i.e. 0x3A/* : */ === character after the explicit key.
          atExplicitKey = false;
          allowCompact = true;

        } else {
          throwError(state, &#039;incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line&#039;);
        }

        state.position += 1;
        ch = following;

      //
      // Implicit notation case. Flow-style node as the key first, then &quot;:&quot;, and the value.
      //
      } else {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;

        if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
          // Neither implicit nor explicit notation.
          // Reading is done. Go to the epilogue.
          break;
        }

        if (state.line === _line) {
          ch = state.input.charCodeAt(state.position);

          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }

          if (ch === 0x3A/* : */) {
            ch = state.input.charCodeAt(++state.position);

            if (!is_WS_OR_EOL(ch)) {
              throwError(state, &#039;a whitespace character is expected after the key-value separator within a block mapping&#039;);
            }

            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              keyTag = keyNode = valueNode = null;
            }

            detected = true;
            atExplicitKey = false;
            allowCompact = false;
            keyTag = state.tag;
            keyNode = state.result;

          } else if (detected) {
            throwError(state, &#039;can not read an implicit mapping pair; a colon is missed&#039;);

          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true; // Keep the result of `composeNode`.
          }

        } else if (detected) {
          throwError(state, &#039;can not read a block mapping entry; a multiline key may not be an implicit key&#039;);

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }
      }

      //
      // Common reading code for both explicit and implicit notations.
      //
      if (state.line === _line || state.lineIndent &gt; nodeIndent) {
        if (atExplicitKey) {
          _keyLine = state.line;
          _keyLineStart = state.lineStart;
          _keyPos = state.position;
        }

        if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
          if (atExplicitKey) {
            keyNode = state.result;
          } else {
            valueNode = state.result;
          }
        }

        if (!atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }

        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
      }

      if ((state.line === _line || state.lineIndent &gt; nodeIndent) &amp;&amp; (ch !== 0)) {
        throwError(state, &#039;bad indentation of a mapping entry&#039;);
      } else if (state.lineIndent &lt; nodeIndent) {
        break;
      }
    }

    //
    // Epilogue.
    //

    // Special case: last mapping&#039;s node contains only the key in explicit notation.
    if (atExplicitKey) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
    }

    // Expose the resulting mapping.
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = &#039;mapping&#039;;
      state.result = _result;
    }

    return detected;
  }

  function readTagProperty(state) {
    var _position,
        isVerbatim = false,
        isNamed    = false,
        tagHandle,
        tagName,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x21/* ! */) return false;

    if (state.tag !== null) {
      throwError(state, &#039;duplication of a tag property&#039;);
    }

    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x3C/* &lt; */) {
      isVerbatim = true;
      ch = state.input.charCodeAt(++state.position);

    } else if (ch === 0x21/* ! */) {
      isNamed = true;
      tagHandle = &#039;!!&#039;;
      ch = state.input.charCodeAt(++state.position);

    } else {
      tagHandle = &#039;!&#039;;
    }

    _position = state.position;

    if (isVerbatim) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (ch !== 0 &amp;&amp; ch !== 0x3E/* &gt; */);

      if (state.position &lt; state.length) {
        tagName = state.input.slice(_position, state.position);
        ch = state.input.charCodeAt(++state.position);
      } else {
        throwError(state, &#039;unexpected end of the stream within a verbatim tag&#039;);
      }
    } else {
      while (ch !== 0 &amp;&amp; !is_WS_OR_EOL(ch)) {

        if (ch === 0x21/* ! */) {
          if (!isNamed) {
            tagHandle = state.input.slice(_position - 1, state.position + 1);

            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
              throwError(state, &#039;named tag handle cannot contain such characters&#039;);
            }

            isNamed = true;
            _position = state.position + 1;
          } else {
            throwError(state, &#039;tag suffix cannot contain exclamation marks&#039;);
          }
        }

        ch = state.input.charCodeAt(++state.position);
      }

      tagName = state.input.slice(_position, state.position);

      if (PATTERN_FLOW_INDICATORS.test(tagName)) {
        throwError(state, &#039;tag suffix cannot contain flow indicator characters&#039;);
      }
    }

    if (tagName &amp;&amp; !PATTERN_TAG_URI.test(tagName)) {
      throwError(state, &#039;tag name cannot contain such characters: &#039; + tagName);
    }

    try {
      tagName = decodeURIComponent(tagName);
    } catch (err) {
      throwError(state, &#039;tag name is malformed: &#039; + tagName);
    }

    if (isVerbatim) {
      state.tag = tagName;

    } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
      state.tag = state.tagMap[tagHandle] + tagName;

    } else if (tagHandle === &#039;!&#039;) {
      state.tag = &#039;!&#039; + tagName;

    } else if (tagHandle === &#039;!!&#039;) {
      state.tag = &#039;tag:yaml.org,2002:&#039; + tagName;

    } else {
      throwError(state, &#039;undeclared tag handle &quot;&#039; + tagHandle + &#039;&quot;&#039;);
    }

    return true;
  }

  function readAnchorProperty(state) {
    var _position,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x26/* &amp; */) return false;

    if (state.anchor !== null) {
      throwError(state, &#039;duplication of an anchor property&#039;);
    }

    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 &amp;&amp; !is_WS_OR_EOL(ch) &amp;&amp; !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (state.position === _position) {
      throwError(state, &#039;name of an anchor node must contain at least one character&#039;);
    }

    state.anchor = state.input.slice(_position, state.position);
    return true;
  }

  function readAlias(state) {
    var _position, alias,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x2A/* * */) return false;

    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 &amp;&amp; !is_WS_OR_EOL(ch) &amp;&amp; !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (state.position === _position) {
      throwError(state, &#039;name of an alias node must contain at least one character&#039;);
    }

    alias = state.input.slice(_position, state.position);

    if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
      throwError(state, &#039;unidentified alias &quot;&#039; + alias + &#039;&quot;&#039;);
    }

    state.result = state.anchorMap[alias];
    skipSeparationSpace(state, true, -1);
    return true;
  }

  function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles,
        allowBlockScalars,
        allowBlockCollections,
        indentStatus = 1, // 1: this&gt;parent, 0: this=parent, -1: this&lt;parent
        atNewLine  = false,
        hasContent = false,
        typeIndex,
        typeQuantity,
        typeList,
        type,
        flowIndent,
        blockIndent;

    if (state.listener !== null) {
      state.listener(&#039;open&#039;, state);
    }

    state.tag    = null;
    state.anchor = null;
    state.kind   = null;
    state.result = null;

    allowBlockStyles = allowBlockScalars = allowBlockCollections =
      CONTEXT_BLOCK_OUT === nodeContext ||
      CONTEXT_BLOCK_IN  === nodeContext;

    if (allowToSeek) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;

        if (state.lineIndent &gt; parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent &lt; parentIndent) {
          indentStatus = -1;
        }
      }
    }

    if (indentStatus === 1) {
      while (readTagProperty(state) || readAnchorProperty(state)) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          allowBlockCollections = allowBlockStyles;

          if (state.lineIndent &gt; parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent &lt; parentIndent) {
            indentStatus = -1;
          }
        } else {
          allowBlockCollections = false;
        }
      }
    }

    if (allowBlockCollections) {
      allowBlockCollections = atNewLine || allowCompact;
    }

    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
      if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
        flowIndent = parentIndent;
      } else {
        flowIndent = parentIndent + 1;
      }

      blockIndent = state.position - state.lineStart;

      if (indentStatus === 1) {
        if (allowBlockCollections &amp;&amp;
            (readBlockSequence(state, blockIndent) ||
             readBlockMapping(state, blockIndent, flowIndent)) ||
            readFlowCollection(state, flowIndent)) {
          hasContent = true;
        } else {
          if ((allowBlockScalars &amp;&amp; readBlockScalar(state, flowIndent)) ||
              readSingleQuotedScalar(state, flowIndent) ||
              readDoubleQuotedScalar(state, flowIndent)) {
            hasContent = true;

          } else if (readAlias(state)) {
            hasContent = true;

            if (state.tag !== null || state.anchor !== null) {
              throwError(state, &#039;alias node should not have any properties&#039;);
            }

          } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
            hasContent = true;

            if (state.tag === null) {
              state.tag = &#039;?&#039;;
            }
          }

          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else if (indentStatus === 0) {
        // Special case: block sequences are allowed to have same indentation level as the parent.
        // http://www.yaml.org/spec/1.2/spec.html#id2799784
        hasContent = allowBlockCollections &amp;&amp; readBlockSequence(state, blockIndent);
      }
    }

    if (state.tag === null) {
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }

    } else if (state.tag === &#039;?&#039;) {
      // Implicit resolving is not allowed for non-scalar types, and &#039;?&#039;
      // non-specific tag is only automatically assigned to plain scalars.
      //
      // We only need to check kind conformity in case user explicitly assigns &#039;?&#039;
      // tag, for example like this: &quot;!&lt;?&gt; [0]&quot;
      //
      if (state.result !== null &amp;&amp; state.kind !== &#039;scalar&#039;) {
        throwError(state, &#039;unacceptable node kind for !&lt;?&gt; tag; it should be &quot;scalar&quot;, not &quot;&#039; + state.kind + &#039;&quot;&#039;);
      }

      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex &lt; typeQuantity; typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (state.tag !== &#039;!&#039;) {
      if (_hasOwnProperty$1.call(state.typeMap[state.kind || &#039;fallback&#039;], state.tag)) {
        type = state.typeMap[state.kind || &#039;fallback&#039;][state.tag];
      } else {
        // looking for multi type
        type = null;
        typeList = state.typeMap.multi[state.kind || &#039;fallback&#039;];

        for (typeIndex = 0, typeQuantity = typeList.length; typeIndex &lt; typeQuantity; typeIndex += 1) {
          if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
            type = typeList[typeIndex];
            break;
          }
        }
      }

      if (!type) {
        throwError(state, &#039;unknown tag !&lt;&#039; + state.tag + &#039;&gt;&#039;);
      }

      if (state.result !== null &amp;&amp; type.kind !== state.kind) {
        throwError(state, &#039;unacceptable node kind for !&lt;&#039; + state.tag + &#039;&gt; tag; it should be &quot;&#039; + type.kind + &#039;&quot;, not &quot;&#039; + state.kind + &#039;&quot;&#039;);
      }

      if (!type.resolve(state.result, state.tag)) { // `state.result` updated in resolver if matched
        throwError(state, &#039;cannot resolve a node with !&lt;&#039; + state.tag + &#039;&gt; explicit tag&#039;);
      } else {
        state.result = type.construct(state.result, state.tag);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    }

    if (state.listener !== null) {
      state.listener(&#039;close&#039;, state);
    }
    return state.tag !== null ||  state.anchor !== null || hasContent;
  }

  function readDocument(state) {
    var documentStart = state.position,
        _position,
        directiveName,
        directiveArgs,
        hasDirectives = false,
        ch;

    state.version = null;
    state.checkLineBreaks = state.legacy;
    state.tagMap = Object.create(null);
    state.anchorMap = Object.create(null);

    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      skipSeparationSpace(state, true, -1);

      ch = state.input.charCodeAt(state.position);

      if (state.lineIndent &gt; 0 || ch !== 0x25/* % */) {
        break;
      }

      hasDirectives = true;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;

      while (ch !== 0 &amp;&amp; !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveName = state.input.slice(_position, state.position);
      directiveArgs = [];

      if (directiveName.length &lt; 1) {
        throwError(state, &#039;directive name must not be less than one character in length&#039;);
      }

      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x23/* # */) {
          do { ch = state.input.charCodeAt(++state.position); }
          while (ch !== 0 &amp;&amp; !is_EOL(ch));
          break;
        }

        if (is_EOL(ch)) break;

        _position = state.position;

        while (ch !== 0 &amp;&amp; !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        directiveArgs.push(state.input.slice(_position, state.position));
      }

      if (ch !== 0) readLineBreak(state);

      if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
        directiveHandlers[directiveName](state, directiveName, directiveArgs);
      } else {
        throwWarning(state, &#039;unknown document directive &quot;&#039; + directiveName + &#039;&quot;&#039;);
      }
    }

    skipSeparationSpace(state, true, -1);

    if (state.lineIndent === 0 &amp;&amp;
        state.input.charCodeAt(state.position)     === 0x2D/* - */ &amp;&amp;
        state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &amp;&amp;
        state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);

    } else if (hasDirectives) {
      throwError(state, &#039;directives end mark is expected&#039;);
    }

    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
    skipSeparationSpace(state, true, -1);

    if (state.checkLineBreaks &amp;&amp;
        PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
      throwWarning(state, &#039;non-ASCII line breaks are interpreted as content&#039;);
    }

    state.documents.push(state.result);

    if (state.position === state.lineStart &amp;&amp; testDocumentSeparator(state)) {

      if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      }
      return;
    }

    if (state.position &lt; (state.length - 1)) {
      throwError(state, &#039;end of the stream or a document separator is expected&#039;);
    } else {
      return;
    }
  }


  function loadDocuments(input, options) {
    input = String(input);
    options = options || {};

    if (input.length !== 0) {

      // Add tailing `\n` if not exists
      if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &amp;&amp;
          input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
        input += &#039;\n&#039;;
      }

      // Strip BOM
      if (input.charCodeAt(0) === 0xFEFF) {
        input = input.slice(1);
      }
    }

    var state = new State$1(input, options);

    var nullpos = input.indexOf(&#039;\0&#039;);

    if (nullpos !== -1) {
      state.position = nullpos;
      throwError(state, &#039;null byte is not allowed in input&#039;);
    }

    // Use 0 as string terminator. That significantly simplifies bounds check.
    state.input += &#039;\0&#039;;

    while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
      state.lineIndent += 1;
      state.position += 1;
    }

    while (state.position &lt; (state.length - 1)) {
      readDocument(state);
    }

    return state.documents;
  }


  function loadAll$1(input, iterator, options) {
    if (iterator !== null &amp;&amp; typeof iterator === &#039;object&#039; &amp;&amp; typeof options === &#039;undefined&#039;) {
      options = iterator;
      iterator = null;
    }

    var documents = loadDocuments(input, options);

    if (typeof iterator !== &#039;function&#039;) {
      return documents;
    }

    for (var index = 0, length = documents.length; index &lt; length; index += 1) {
      iterator(documents[index]);
    }
  }


  function load$1(input, options) {
    var documents = loadDocuments(input, options);

    if (documents.length === 0) {
      /*eslint-disable no-undefined*/
      return undefined;
    } else if (documents.length === 1) {
      return documents[0];
    }
    throw new exception(&#039;expected a single document in the stream, but found more&#039;);
  }


  var loadAll_1 = loadAll$1;
  var load_1    = load$1;

  var loader = {
  	loadAll: loadAll_1,
  	load: load_1
  };

  /*eslint-disable no-use-before-define*/





  var _toString       = Object.prototype.toString;
  var _hasOwnProperty = Object.prototype.hasOwnProperty;

  var CHAR_BOM                  = 0xFEFF;
  var CHAR_TAB                  = 0x09; /* Tab */
  var CHAR_LINE_FEED            = 0x0A; /* LF */
  var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
  var CHAR_SPACE                = 0x20; /* Space */
  var CHAR_EXCLAMATION          = 0x21; /* ! */
  var CHAR_DOUBLE_QUOTE         = 0x22; /* &quot; */
  var CHAR_SHARP                = 0x23; /* # */
  var CHAR_PERCENT              = 0x25; /* % */
  var CHAR_AMPERSAND            = 0x26; /* &amp; */
  var CHAR_SINGLE_QUOTE         = 0x27; /* &#039; */
  var CHAR_ASTERISK             = 0x2A; /* * */
  var CHAR_COMMA                = 0x2C; /* , */
  var CHAR_MINUS                = 0x2D; /* - */
  var CHAR_COLON                = 0x3A; /* : */
  var CHAR_EQUALS               = 0x3D; /* = */
  var CHAR_GREATER_THAN         = 0x3E; /* &gt; */
  var CHAR_QUESTION             = 0x3F; /* ? */
  var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
  var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
  var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
  var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
  var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
  var CHAR_VERTICAL_LINE        = 0x7C; /* | */
  var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

  var ESCAPE_SEQUENCES = {};

  ESCAPE_SEQUENCES[0x00]   = &#039;\\0&#039;;
  ESCAPE_SEQUENCES[0x07]   = &#039;\\a&#039;;
  ESCAPE_SEQUENCES[0x08]   = &#039;\\b&#039;;
  ESCAPE_SEQUENCES[0x09]   = &#039;\\t&#039;;
  ESCAPE_SEQUENCES[0x0A]   = &#039;\\n&#039;;
  ESCAPE_SEQUENCES[0x0B]   = &#039;\\v&#039;;
  ESCAPE_SEQUENCES[0x0C]   = &#039;\\f&#039;;
  ESCAPE_SEQUENCES[0x0D]   = &#039;\\r&#039;;
  ESCAPE_SEQUENCES[0x1B]   = &#039;\\e&#039;;
  ESCAPE_SEQUENCES[0x22]   = &#039;\\&quot;&#039;;
  ESCAPE_SEQUENCES[0x5C]   = &#039;\\\\&#039;;
  ESCAPE_SEQUENCES[0x85]   = &#039;\\N&#039;;
  ESCAPE_SEQUENCES[0xA0]   = &#039;\\_&#039;;
  ESCAPE_SEQUENCES[0x2028] = &#039;\\L&#039;;
  ESCAPE_SEQUENCES[0x2029] = &#039;\\P&#039;;

  var DEPRECATED_BOOLEANS_SYNTAX = [
    &#039;y&#039;, &#039;Y&#039;, &#039;yes&#039;, &#039;Yes&#039;, &#039;YES&#039;, &#039;on&#039;, &#039;On&#039;, &#039;ON&#039;,
    &#039;n&#039;, &#039;N&#039;, &#039;no&#039;, &#039;No&#039;, &#039;NO&#039;, &#039;off&#039;, &#039;Off&#039;, &#039;OFF&#039;
  ];

  var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;

  function compileStyleMap(schema, map) {
    var result, keys, index, length, tag, style, type;

    if (map === null) return {};

    result = {};
    keys = Object.keys(map);

    for (index = 0, length = keys.length; index &lt; length; index += 1) {
      tag = keys[index];
      style = String(map[tag]);

      if (tag.slice(0, 2) === &#039;!!&#039;) {
        tag = &#039;tag:yaml.org,2002:&#039; + tag.slice(2);
      }
      type = schema.compiledTypeMap[&#039;fallback&#039;][tag];

      if (type &amp;&amp; _hasOwnProperty.call(type.styleAliases, style)) {
        style = type.styleAliases[style];
      }

      result[tag] = style;
    }

    return result;
  }

  function encodeHex(character) {
    var string, handle, length;

    string = character.toString(16).toUpperCase();

    if (character &lt;= 0xFF) {
      handle = &#039;x&#039;;
      length = 2;
    } else if (character &lt;= 0xFFFF) {
      handle = &#039;u&#039;;
      length = 4;
    } else if (character &lt;= 0xFFFFFFFF) {
      handle = &#039;U&#039;;
      length = 8;
    } else {
      throw new exception(&#039;code point within a string may not be greater than 0xFFFFFFFF&#039;);
    }

    return &#039;\\&#039; + handle + common.repeat(&#039;0&#039;, length - string.length) + string;
  }


  var QUOTING_TYPE_SINGLE = 1,
      QUOTING_TYPE_DOUBLE = 2;

  function State(options) {
    this.schema        = options[&#039;schema&#039;] || _default;
    this.indent        = Math.max(1, (options[&#039;indent&#039;] || 2));
    this.noArrayIndent = options[&#039;noArrayIndent&#039;] || false;
    this.skipInvalid   = options[&#039;skipInvalid&#039;] || false;
    this.flowLevel     = (common.isNothing(options[&#039;flowLevel&#039;]) ? -1 : options[&#039;flowLevel&#039;]);
    this.styleMap      = compileStyleMap(this.schema, options[&#039;styles&#039;] || null);
    this.sortKeys      = options[&#039;sortKeys&#039;] || false;
    this.lineWidth     = options[&#039;lineWidth&#039;] || 80;
    this.noRefs        = options[&#039;noRefs&#039;] || false;
    this.noCompatMode  = options[&#039;noCompatMode&#039;] || false;
    this.condenseFlow  = options[&#039;condenseFlow&#039;] || false;
    this.quotingType   = options[&#039;quotingType&#039;] === &#039;&quot;&#039; ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
    this.forceQuotes   = options[&#039;forceQuotes&#039;] || false;
    this.replacer      = typeof options[&#039;replacer&#039;] === &#039;function&#039; ? options[&#039;replacer&#039;] : null;

    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;

    this.tag = null;
    this.result = &#039;&#039;;

    this.duplicates = [];
    this.usedDuplicates = null;
  }

  // Indents every line in a string. Empty lines (\n only) are not indented.
  function indentString(string, spaces) {
    var ind = common.repeat(&#039; &#039;, spaces),
        position = 0,
        next = -1,
        result = &#039;&#039;,
        line,
        length = string.length;

    while (position &lt; length) {
      next = string.indexOf(&#039;\n&#039;, position);
      if (next === -1) {
        line = string.slice(position);
        position = length;
      } else {
        line = string.slice(position, next + 1);
        position = next + 1;
      }

      if (line.length &amp;&amp; line !== &#039;\n&#039;) result += ind;

      result += line;
    }

    return result;
  }

  function generateNextLine(state, level) {
    return &#039;\n&#039; + common.repeat(&#039; &#039;, state.indent * level);
  }

  function testImplicitResolving(state, str) {
    var index, length, type;

    for (index = 0, length = state.implicitTypes.length; index &lt; length; index += 1) {
      type = state.implicitTypes[index];

      if (type.resolve(str)) {
        return true;
      }
    }

    return false;
  }

  // [33] s-white ::= s-space | s-tab
  function isWhitespace(c) {
    return c === CHAR_SPACE || c === CHAR_TAB;
  }

  // Returns true if the character can be printed without escaping.
  // From YAML 1.2: &quot;any allowed characters known to be non-printable
  // should also be escaped. [However,] This isnâ€™t mandatory&quot;
  // Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
  function isPrintable(c) {
    return  (0x00020 &lt;= c &amp;&amp; c &lt;= 0x00007E)
        || ((0x000A1 &lt;= c &amp;&amp; c &lt;= 0x00D7FF) &amp;&amp; c !== 0x2028 &amp;&amp; c !== 0x2029)
        || ((0x0E000 &lt;= c &amp;&amp; c &lt;= 0x00FFFD) &amp;&amp; c !== CHAR_BOM)
        ||  (0x10000 &lt;= c &amp;&amp; c &lt;= 0x10FFFF);
  }

  // [34] ns-char ::= nb-char - s-white
  // [27] nb-char ::= c-printable - b-char - c-byte-order-mark
  // [26] b-char  ::= b-line-feed | b-carriage-return
  // Including s-white (for some reason, examples doesn&#039;t match specs in this aspect)
  // ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark
  function isNsCharOrWhitespace(c) {
    return isPrintable(c)
      &amp;&amp; c !== CHAR_BOM
      // - b-char
      &amp;&amp; c !== CHAR_CARRIAGE_RETURN
      &amp;&amp; c !== CHAR_LINE_FEED;
  }

  // [127]  ns-plain-safe(c) ::= c = flow-out  â‡’ ns-plain-safe-out
  //                             c = flow-in   â‡’ ns-plain-safe-in
  //                             c = block-key â‡’ ns-plain-safe-out
  //                             c = flow-key  â‡’ ns-plain-safe-in
  // [128] ns-plain-safe-out ::= ns-char
  // [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator
  // [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - â€œ:â€ - â€œ#â€ )
  //                            | ( /* An ns-char preceding */ â€œ#â€ )
  //                            | ( â€œ:â€ /* Followed by an ns-plain-safe(c) */ )
  function isPlainSafe(c, prev, inblock) {
    var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
    var cIsNsChar = cIsNsCharOrWhitespace &amp;&amp; !isWhitespace(c);
    return (
      // ns-plain-safe
      inblock ? // c = flow-in
        cIsNsCharOrWhitespace
        : cIsNsCharOrWhitespace
          // - c-flow-indicator
          &amp;&amp; c !== CHAR_COMMA
          &amp;&amp; c !== CHAR_LEFT_SQUARE_BRACKET
          &amp;&amp; c !== CHAR_RIGHT_SQUARE_BRACKET
          &amp;&amp; c !== CHAR_LEFT_CURLY_BRACKET
          &amp;&amp; c !== CHAR_RIGHT_CURLY_BRACKET
    )
      // ns-plain-char
      &amp;&amp; c !== CHAR_SHARP // false on &#039;#&#039;
      &amp;&amp; !(prev === CHAR_COLON &amp;&amp; !cIsNsChar) // false on &#039;: &#039;
      || (isNsCharOrWhitespace(prev) &amp;&amp; !isWhitespace(prev) &amp;&amp; c === CHAR_SHARP) // change to true on &#039;[^ ]#&#039;
      || (prev === CHAR_COLON &amp;&amp; cIsNsChar); // change to true on &#039;:[^ ]&#039;
  }

  // Simplified test for values allowed as the first character in plain style.
  function isPlainSafeFirst(c) {
    // Uses a subset of ns-char - c-indicator
    // where ns-char = nb-char - s-white.
    // No support of ( ( â€œ?â€ | â€œ:â€ | â€œ-â€ ) /* Followed by an ns-plain-safe(c)) */ ) part
    return isPrintable(c) &amp;&amp; c !== CHAR_BOM
      &amp;&amp; !isWhitespace(c) // - s-white
      // - (c-indicator ::=
      // â€œ-â€ | â€œ?â€ | â€œ:â€ | â€œ,â€ | â€œ[â€ | â€œ]â€ | â€œ{â€ | â€œ}â€
      &amp;&amp; c !== CHAR_MINUS
      &amp;&amp; c !== CHAR_QUESTION
      &amp;&amp; c !== CHAR_COLON
      &amp;&amp; c !== CHAR_COMMA
      &amp;&amp; c !== CHAR_LEFT_SQUARE_BRACKET
      &amp;&amp; c !== CHAR_RIGHT_SQUARE_BRACKET
      &amp;&amp; c !== CHAR_LEFT_CURLY_BRACKET
      &amp;&amp; c !== CHAR_RIGHT_CURLY_BRACKET
      // | â€œ#â€ | â€œ&amp;â€ | â€œ*â€ | â€œ!â€ | â€œ|â€ | â€œ=â€ | â€œ&gt;â€ | â€œ&#039;â€ | â€œ&quot;â€
      &amp;&amp; c !== CHAR_SHARP
      &amp;&amp; c !== CHAR_AMPERSAND
      &amp;&amp; c !== CHAR_ASTERISK
      &amp;&amp; c !== CHAR_EXCLAMATION
      &amp;&amp; c !== CHAR_VERTICAL_LINE
      &amp;&amp; c !== CHAR_EQUALS
      &amp;&amp; c !== CHAR_GREATER_THAN
      &amp;&amp; c !== CHAR_SINGLE_QUOTE
      &amp;&amp; c !== CHAR_DOUBLE_QUOTE
      // | â€œ%â€ | â€œ@â€ | â€œ`â€)
      &amp;&amp; c !== CHAR_PERCENT
      &amp;&amp; c !== CHAR_COMMERCIAL_AT
      &amp;&amp; c !== CHAR_GRAVE_ACCENT;
  }

  // Simplified test for values allowed as the last character in plain style.
  function isPlainSafeLast(c) {
    // just not whitespace or colon, it will be checked to be plain character later
    return !isWhitespace(c) &amp;&amp; c !== CHAR_COLON;
  }

  // Same as &#039;string&#039;.codePointAt(pos), but works in older browsers.
  function codePointAt(string, pos) {
    var first = string.charCodeAt(pos), second;
    if (first &gt;= 0xD800 &amp;&amp; first &lt;= 0xDBFF &amp;&amp; pos + 1 &lt; string.length) {
      second = string.charCodeAt(pos + 1);
      if (second &gt;= 0xDC00 &amp;&amp; second &lt;= 0xDFFF) {
        // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
      }
    }
    return first;
  }

  // Determines whether block indentation indicator is required.
  function needIndentIndicator(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
  }

  var STYLE_PLAIN   = 1,
      STYLE_SINGLE  = 2,
      STYLE_LITERAL = 3,
      STYLE_FOLDED  = 4,
      STYLE_DOUBLE  = 5;

  // Determines which scalar styles are possible and returns the preferred style.
  // lineWidth = -1 =&gt; no limit.
  // Pre-conditions: str.length &gt; 0.
  // Post-conditions:
  //    STYLE_PLAIN or STYLE_SINGLE =&gt; no \n are in the string.
  //    STYLE_LITERAL =&gt; no lines are suitable for folding (or lineWidth is -1).
  //    STYLE_FOLDED =&gt; a line &gt; lineWidth and can be folded (and lineWidth != -1).
  function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,
    testAmbiguousType, quotingType, forceQuotes, inblock) {

    var i;
    var char = 0;
    var prevChar = null;
    var hasLineBreak = false;
    var hasFoldableLine = false; // only checked if shouldTrackWidth
    var shouldTrackWidth = lineWidth !== -1;
    var previousLineBreak = -1; // count the first line correctly
    var plain = isPlainSafeFirst(codePointAt(string, 0))
            &amp;&amp; isPlainSafeLast(codePointAt(string, string.length - 1));

    if (singleLineOnly || forceQuotes) {
      // Case: no block styles.
      // Check for disallowed characters to rule out plain and single.
      for (i = 0; i &lt; string.length; char &gt;= 0x10000 ? i += 2 : i++) {
        char = codePointAt(string, i);
        if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain &amp;&amp; isPlainSafe(char, prevChar, inblock);
        prevChar = char;
      }
    } else {
      // Case: block styles permitted.
      for (i = 0; i &lt; string.length; char &gt;= 0x10000 ? i += 2 : i++) {
        char = codePointAt(string, i);
        if (char === CHAR_LINE_FEED) {
          hasLineBreak = true;
          // Check if any line can be folded.
          if (shouldTrackWidth) {
            hasFoldableLine = hasFoldableLine ||
              // Foldable line = too long, and not more-indented.
              (i - previousLineBreak - 1 &gt; lineWidth &amp;&amp;
               string[previousLineBreak + 1] !== &#039; &#039;);
            previousLineBreak = i;
          }
        } else if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain &amp;&amp; isPlainSafe(char, prevChar, inblock);
        prevChar = char;
      }
      // in case the end is missing a \n
      hasFoldableLine = hasFoldableLine || (shouldTrackWidth &amp;&amp;
        (i - previousLineBreak - 1 &gt; lineWidth &amp;&amp;
         string[previousLineBreak + 1] !== &#039; &#039;));
    }
    // Although every style can represent \n without escaping, prefer block styles
    // for multiline, since they&#039;re more readable and they don&#039;t add empty lines.
    // Also prefer folding a super-long line.
    if (!hasLineBreak &amp;&amp; !hasFoldableLine) {
      // Strings interpretable as another type have to be quoted;
      // e.g. the string &#039;true&#039; vs. the boolean true.
      if (plain &amp;&amp; !forceQuotes &amp;&amp; !testAmbiguousType(string)) {
        return STYLE_PLAIN;
      }
      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
    }
    // Edge case: block indentation indicator can only have one digit.
    if (indentPerLevel &gt; 9 &amp;&amp; needIndentIndicator(string)) {
      return STYLE_DOUBLE;
    }
    // At this point we know block styles are valid.
    // Prefer literal style unless we want to fold.
    if (!forceQuotes) {
      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }

  // Note: line breaking/folding is implemented for only the folded style.
  // NB. We drop the last trailing newline (if any) of a returned block scalar
  //  since the dumper adds its own newline. This always works:
  //    â€¢ No ending newline =&gt; unaffected; already using strip &quot;-&quot; chomping.
  //    â€¢ Ending newline    =&gt; removed then restored.
  //  Importantly, this keeps the &quot;+&quot; chomp indicator from gaining an extra line.
  function writeScalar(state, string, level, iskey, inblock) {
    state.dump = (function () {
      if (string.length === 0) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? &#039;&quot;&quot;&#039; : &quot;&#039;&#039;&quot;;
      }
      if (!state.noCompatMode) {
        if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
          return state.quotingType === QUOTING_TYPE_DOUBLE ? (&#039;&quot;&#039; + string + &#039;&quot;&#039;) : (&quot;&#039;&quot; + string + &quot;&#039;&quot;);
        }
      }

      var indent = state.indent * Math.max(1, level); // no 0-indent scalars
      // As indentation gets deeper, let the width decrease monotonically
      // to the lower bound min(state.lineWidth, 40).
      // Note that this implies
      //  state.lineWidth â‰¤ 40 + state.indent: width is fixed at the lower bound.
      //  state.lineWidth &gt; 40 + state.indent: width decreases until the lower bound.
      // This behaves better than a constant minimum width which disallows narrower options,
      // or an indent threshold which causes the width to suddenly increase.
      var lineWidth = state.lineWidth === -1
        ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

      // Without knowing if keys are implicit/explicit, assume implicit for safety.
      var singleLineOnly = iskey
        // No block styles in flow mode.
        || (state.flowLevel &gt; -1 &amp;&amp; level &gt;= state.flowLevel);
      function testAmbiguity(string) {
        return testImplicitResolving(state, string);
      }

      switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,
        testAmbiguity, state.quotingType, state.forceQuotes &amp;&amp; !iskey, inblock)) {

        case STYLE_PLAIN:
          return string;
        case STYLE_SINGLE:
          return &quot;&#039;&quot; + string.replace(/&#039;/g, &quot;&#039;&#039;&quot;) + &quot;&#039;&quot;;
        case STYLE_LITERAL:
          return &#039;|&#039; + blockHeader(string, state.indent)
            + dropEndingNewline(indentString(string, indent));
        case STYLE_FOLDED:
          return &#039;&gt;&#039; + blockHeader(string, state.indent)
            + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
        case STYLE_DOUBLE:
          return &#039;&quot;&#039; + escapeString(string) + &#039;&quot;&#039;;
        default:
          throw new exception(&#039;impossible error: invalid scalar style&#039;);
      }
    }());
  }

  // Pre-conditions: string is valid for a block scalar, 1 &lt;= indentPerLevel &lt;= 9.
  function blockHeader(string, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : &#039;&#039;;

    // note the special case: the string &#039;\n&#039; counts as a &quot;trailing&quot; empty line.
    var clip =          string[string.length - 1] === &#039;\n&#039;;
    var keep = clip &amp;&amp; (string[string.length - 2] === &#039;\n&#039; || string === &#039;\n&#039;);
    var chomp = keep ? &#039;+&#039; : (clip ? &#039;&#039; : &#039;-&#039;);

    return indentIndicator + chomp + &#039;\n&#039;;
  }

  // (See the note for writeScalar.)
  function dropEndingNewline(string) {
    return string[string.length - 1] === &#039;\n&#039; ? string.slice(0, -1) : string;
  }

  // Note: a long line without a suitable break point will exceed the width limit.
  // Pre-conditions: every char in str isPrintable, str.length &gt; 0, width &gt; 0.
  function foldString(string, width) {
    // In folded style, $k$ consecutive newlines output as $k+1$ newlinesâ€”
    // unless they&#039;re before or after a more-indented line, or at the very
    // beginning or end, in which case $k$ maps to $k$.
    // Therefore, parse each chunk as newline(s) followed by a content line.
    var lineRe = /(\n+)([^\n]*)/g;

    // first line (possibly an empty line)
    var result = (function () {
      var nextLF = string.indexOf(&#039;\n&#039;);
      nextLF = nextLF !== -1 ? nextLF : string.length;
      lineRe.lastIndex = nextLF;
      return foldLine(string.slice(0, nextLF), width);
    }());
    // If we haven&#039;t reached the first content line yet, don&#039;t add an extra \n.
    var prevMoreIndented = string[0] === &#039;\n&#039; || string[0] === &#039; &#039;;
    var moreIndented;

    // rest of the lines
    var match;
    while ((match = lineRe.exec(string))) {
      var prefix = match[1], line = match[2];
      moreIndented = (line[0] === &#039; &#039;);
      result += prefix
        + (!prevMoreIndented &amp;&amp; !moreIndented &amp;&amp; line !== &#039;&#039;
          ? &#039;\n&#039; : &#039;&#039;)
        + foldLine(line, width);
      prevMoreIndented = moreIndented;
    }

    return result;
  }

  // Greedy line breaking.
  // Picks the longest line under the limit each time,
  // otherwise settles for the shortest line over the limit.
  // NB. More-indented lines *cannot* be folded, as that would add an extra \n.
  function foldLine(line, width) {
    if (line === &#039;&#039; || line[0] === &#039; &#039;) return line;

    // Since a more-indented line adds a \n, breaks can&#039;t be followed by a space.
    var breakRe = / [^ ]/g; // note: the match index will always be &lt;= length-2.
    var match;
    // start is an inclusive index. end, curr, and next are exclusive.
    var start = 0, end, curr = 0, next = 0;
    var result = &#039;&#039;;

    // Invariants: 0 &lt;= start &lt;= length-1.
    //   0 &lt;= curr &lt;= next &lt;= max(0, length-2). curr - start &lt;= width.
    // Inside the loop:
    //   A match implies length &gt;= 2, so curr and next are &lt;= length-2.
    while ((match = breakRe.exec(line))) {
      next = match.index;
      // maintain invariant: curr - start &lt;= width
      if (next - start &gt; width) {
        end = (curr &gt; start) ? curr : next; // derive end &lt;= length-2
        result += &#039;\n&#039; + line.slice(start, end);
        // skip the space that was output as \n
        start = end + 1;                    // derive start &lt;= length-1
      }
      curr = next;
    }

    // By the invariants, start &lt;= length-1, so there is something left over.
    // It is either the whole string or a part starting from non-whitespace.
    result += &#039;\n&#039;;
    // Insert a break if the remainder is too long and there is a break available.
    if (line.length - start &gt; width &amp;&amp; curr &gt; start) {
      result += line.slice(start, curr) + &#039;\n&#039; + line.slice(curr + 1);
    } else {
      result += line.slice(start);
    }

    return result.slice(1); // drop extra \n joiner
  }

  // Escapes a double-quoted string.
  function escapeString(string) {
    var result = &#039;&#039;;
    var char = 0;
    var escapeSeq;

    for (var i = 0; i &lt; string.length; char &gt;= 0x10000 ? i += 2 : i++) {
      char = codePointAt(string, i);
      escapeSeq = ESCAPE_SEQUENCES[char];

      if (!escapeSeq &amp;&amp; isPrintable(char)) {
        result += string[i];
        if (char &gt;= 0x10000) result += string[i + 1];
      } else {
        result += escapeSeq || encodeHex(char);
      }
    }

    return result;
  }

  function writeFlowSequence(state, level, object) {
    var _result = &#039;&#039;,
        _tag    = state.tag,
        index,
        length,
        value;

    for (index = 0, length = object.length; index &lt; length; index += 1) {
      value = object[index];

      if (state.replacer) {
        value = state.replacer.call(object, String(index), value);
      }

      // Write only valid elements, put null instead of invalid elements.
      if (writeNode(state, level, value, false, false) ||
          (typeof value === &#039;undefined&#039; &amp;&amp;
           writeNode(state, level, null, false, false))) {

        if (_result !== &#039;&#039;) _result += &#039;,&#039; + (!state.condenseFlow ? &#039; &#039; : &#039;&#039;);
        _result += state.dump;
      }
    }

    state.tag = _tag;
    state.dump = &#039;[&#039; + _result + &#039;]&#039;;
  }

  function writeBlockSequence(state, level, object, compact) {
    var _result = &#039;&#039;,
        _tag    = state.tag,
        index,
        length,
        value;

    for (index = 0, length = object.length; index &lt; length; index += 1) {
      value = object[index];

      if (state.replacer) {
        value = state.replacer.call(object, String(index), value);
      }

      // Write only valid elements, put null instead of invalid elements.
      if (writeNode(state, level + 1, value, true, true, false, true) ||
          (typeof value === &#039;undefined&#039; &amp;&amp;
           writeNode(state, level + 1, null, true, true, false, true))) {

        if (!compact || _result !== &#039;&#039;) {
          _result += generateNextLine(state, level);
        }

        if (state.dump &amp;&amp; CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          _result += &#039;-&#039;;
        } else {
          _result += &#039;- &#039;;
        }

        _result += state.dump;
      }
    }

    state.tag = _tag;
    state.dump = _result || &#039;[]&#039;; // Empty sequence if no valid values.
  }

  function writeFlowMapping(state, level, object) {
    var _result       = &#039;&#039;,
        _tag          = state.tag,
        objectKeyList = Object.keys(object),
        index,
        length,
        objectKey,
        objectValue,
        pairBuffer;

    for (index = 0, length = objectKeyList.length; index &lt; length; index += 1) {

      pairBuffer = &#039;&#039;;
      if (_result !== &#039;&#039;) pairBuffer += &#039;, &#039;;

      if (state.condenseFlow) pairBuffer += &#039;&quot;&#039;;

      objectKey = objectKeyList[index];
      objectValue = object[objectKey];

      if (state.replacer) {
        objectValue = state.replacer.call(object, objectKey, objectValue);
      }

      if (!writeNode(state, level, objectKey, false, false)) {
        continue; // Skip this pair because of invalid key;
      }

      if (state.dump.length &gt; 1024) pairBuffer += &#039;? &#039;;

      pairBuffer += state.dump + (state.condenseFlow ? &#039;&quot;&#039; : &#039;&#039;) + &#039;:&#039; + (state.condenseFlow ? &#039;&#039; : &#039; &#039;);

      if (!writeNode(state, level, objectValue, false, false)) {
        continue; // Skip this pair because of invalid value.
      }

      pairBuffer += state.dump;

      // Both key and value are valid.
      _result += pairBuffer;
    }

    state.tag = _tag;
    state.dump = &#039;{&#039; + _result + &#039;}&#039;;
  }

  function writeBlockMapping(state, level, object, compact) {
    var _result       = &#039;&#039;,
        _tag          = state.tag,
        objectKeyList = Object.keys(object),
        index,
        length,
        objectKey,
        objectValue,
        explicitPair,
        pairBuffer;

    // Allow sorting keys so that the output file is deterministic
    if (state.sortKeys === true) {
      // Default sorting
      objectKeyList.sort();
    } else if (typeof state.sortKeys === &#039;function&#039;) {
      // Custom sort function
      objectKeyList.sort(state.sortKeys);
    } else if (state.sortKeys) {
      // Something is wrong
      throw new exception(&#039;sortKeys must be a boolean or a function&#039;);
    }

    for (index = 0, length = objectKeyList.length; index &lt; length; index += 1) {
      pairBuffer = &#039;&#039;;

      if (!compact || _result !== &#039;&#039;) {
        pairBuffer += generateNextLine(state, level);
      }

      objectKey = objectKeyList[index];
      objectValue = object[objectKey];

      if (state.replacer) {
        objectValue = state.replacer.call(object, objectKey, objectValue);
      }

      if (!writeNode(state, level + 1, objectKey, true, true, true)) {
        continue; // Skip this pair because of invalid key.
      }

      explicitPair = (state.tag !== null &amp;&amp; state.tag !== &#039;?&#039;) ||
                     (state.dump &amp;&amp; state.dump.length &gt; 1024);

      if (explicitPair) {
        if (state.dump &amp;&amp; CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += &#039;?&#039;;
        } else {
          pairBuffer += &#039;? &#039;;
        }
      }

      pairBuffer += state.dump;

      if (explicitPair) {
        pairBuffer += generateNextLine(state, level);
      }

      if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
        continue; // Skip this pair because of invalid value.
      }

      if (state.dump &amp;&amp; CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += &#039;:&#039;;
      } else {
        pairBuffer += &#039;: &#039;;
      }

      pairBuffer += state.dump;

      // Both key and value are valid.
      _result += pairBuffer;
    }

    state.tag = _tag;
    state.dump = _result || &#039;{}&#039;; // Empty mapping if no valid pairs.
  }

  function detectType(state, object, explicit) {
    var _result, typeList, index, length, type, style;

    typeList = explicit ? state.explicitTypes : state.implicitTypes;

    for (index = 0, length = typeList.length; index &lt; length; index += 1) {
      type = typeList[index];

      if ((type.instanceOf  || type.predicate) &amp;&amp;
          (!type.instanceOf || ((typeof object === &#039;object&#039;) &amp;&amp; (object instanceof type.instanceOf))) &amp;&amp;
          (!type.predicate  || type.predicate(object))) {

        if (explicit) {
          if (type.multi &amp;&amp; type.representName) {
            state.tag = type.representName(object);
          } else {
            state.tag = type.tag;
          }
        } else {
          state.tag = &#039;?&#039;;
        }

        if (type.represent) {
          style = state.styleMap[type.tag] || type.defaultStyle;

          if (_toString.call(type.represent) === &#039;[object Function]&#039;) {
            _result = type.represent(object, style);
          } else if (_hasOwnProperty.call(type.represent, style)) {
            _result = type.represent[style](object, style);
          } else {
            throw new exception(&#039;!&lt;&#039; + type.tag + &#039;&gt; tag resolver accepts not &quot;&#039; + style + &#039;&quot; style&#039;);
          }

          state.dump = _result;
        }

        return true;
      }
    }

    return false;
  }

  // Serializes `object` and writes it to global `result`.
  // Returns true on success, or false on invalid object.
  //
  function writeNode(state, level, object, block, compact, iskey, isblockseq) {
    state.tag = null;
    state.dump = object;

    if (!detectType(state, object, false)) {
      detectType(state, object, true);
    }

    var type = _toString.call(state.dump);
    var inblock = block;
    var tagStr;

    if (block) {
      block = (state.flowLevel &lt; 0 || state.flowLevel &gt; level);
    }

    var objectOrArray = type === &#039;[object Object]&#039; || type === &#039;[object Array]&#039;,
        duplicateIndex,
        duplicate;

    if (objectOrArray) {
      duplicateIndex = state.duplicates.indexOf(object);
      duplicate = duplicateIndex !== -1;
    }

    if ((state.tag !== null &amp;&amp; state.tag !== &#039;?&#039;) || duplicate || (state.indent !== 2 &amp;&amp; level &gt; 0)) {
      compact = false;
    }

    if (duplicate &amp;&amp; state.usedDuplicates[duplicateIndex]) {
      state.dump = &#039;*ref_&#039; + duplicateIndex;
    } else {
      if (objectOrArray &amp;&amp; duplicate &amp;&amp; !state.usedDuplicates[duplicateIndex]) {
        state.usedDuplicates[duplicateIndex] = true;
      }
      if (type === &#039;[object Object]&#039;) {
        if (block &amp;&amp; (Object.keys(state.dump).length !== 0)) {
          writeBlockMapping(state, level, state.dump, compact);
          if (duplicate) {
            state.dump = &#039;&amp;ref_&#039; + duplicateIndex + state.dump;
          }
        } else {
          writeFlowMapping(state, level, state.dump);
          if (duplicate) {
            state.dump = &#039;&amp;ref_&#039; + duplicateIndex + &#039; &#039; + state.dump;
          }
        }
      } else if (type === &#039;[object Array]&#039;) {
        if (block &amp;&amp; (state.dump.length !== 0)) {
          if (state.noArrayIndent &amp;&amp; !isblockseq &amp;&amp; level &gt; 0) {
            writeBlockSequence(state, level - 1, state.dump, compact);
          } else {
            writeBlockSequence(state, level, state.dump, compact);
          }
          if (duplicate) {
            state.dump = &#039;&amp;ref_&#039; + duplicateIndex + state.dump;
          }
        } else {
          writeFlowSequence(state, level, state.dump);
          if (duplicate) {
            state.dump = &#039;&amp;ref_&#039; + duplicateIndex + &#039; &#039; + state.dump;
          }
        }
      } else if (type === &#039;[object String]&#039;) {
        if (state.tag !== &#039;?&#039;) {
          writeScalar(state, state.dump, level, iskey, inblock);
        }
      } else if (type === &#039;[object Undefined]&#039;) {
        return false;
      } else {
        if (state.skipInvalid) return false;
        throw new exception(&#039;unacceptable kind of an object to dump &#039; + type);
      }

      if (state.tag !== null &amp;&amp; state.tag !== &#039;?&#039;) {
        // Need to encode all characters except those allowed by the spec:
        //
        // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */
        // [36] ns-hex-digit    ::=  ns-dec-digit
        //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */
        // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */
        // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | â€œ-â€
        // [39] ns-uri-char     ::=  â€œ%â€ ns-hex-digit ns-hex-digit | ns-word-char | â€œ#â€
        //                         | â€œ;â€ | â€œ/â€ | â€œ?â€ | â€œ:â€ | â€œ@â€ | â€œ&amp;â€ | â€œ=â€ | â€œ+â€ | â€œ$â€ | â€œ,â€
        //                         | â€œ_â€ | â€œ.â€ | â€œ!â€ | â€œ~â€ | â€œ*â€ | â€œ&#039;â€ | â€œ(â€ | â€œ)â€ | â€œ[â€ | â€œ]â€
        //
        // Also need to encode &#039;!&#039; because it has special meaning (end of tag prefix).
        //
        tagStr = encodeURI(
          state.tag[0] === &#039;!&#039; ? state.tag.slice(1) : state.tag
        ).replace(/!/g, &#039;%21&#039;);

        if (state.tag[0] === &#039;!&#039;) {
          tagStr = &#039;!&#039; + tagStr;
        } else if (tagStr.slice(0, 18) === &#039;tag:yaml.org,2002:&#039;) {
          tagStr = &#039;!!&#039; + tagStr.slice(18);
        } else {
          tagStr = &#039;!&lt;&#039; + tagStr + &#039;&gt;&#039;;
        }

        state.dump = tagStr + &#039; &#039; + state.dump;
      }
    }

    return true;
  }

  function getDuplicateReferences(object, state) {
    var objects = [],
        duplicatesIndexes = [],
        index,
        length;

    inspectNode(object, objects, duplicatesIndexes);

    for (index = 0, length = duplicatesIndexes.length; index &lt; length; index += 1) {
      state.duplicates.push(objects[duplicatesIndexes[index]]);
    }
    state.usedDuplicates = new Array(length);
  }

  function inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList,
        index,
        length;

    if (object !== null &amp;&amp; typeof object === &#039;object&#039;) {
      index = objects.indexOf(object);
      if (index !== -1) {
        if (duplicatesIndexes.indexOf(index) === -1) {
          duplicatesIndexes.push(index);
        }
      } else {
        objects.push(object);

        if (Array.isArray(object)) {
          for (index = 0, length = object.length; index &lt; length; index += 1) {
            inspectNode(object[index], objects, duplicatesIndexes);
          }
        } else {
          objectKeyList = Object.keys(object);

          for (index = 0, length = objectKeyList.length; index &lt; length; index += 1) {
            inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
          }
        }
      }
    }
  }

  function dump$1(input, options) {
    options = options || {};

    var state = new State(options);

    if (!state.noRefs) getDuplicateReferences(input, state);

    var value = input;

    if (state.replacer) {
      value = state.replacer.call({ &#039;&#039;: value }, &#039;&#039;, value);
    }

    if (writeNode(state, 0, value, true, true)) return state.dump + &#039;\n&#039;;

    return &#039;&#039;;
  }

  var dump_1 = dump$1;

  var dumper = {
  	dump: dump_1
  };

  function renamed(from, to) {
    return function () {
      throw new Error(&#039;Function yaml.&#039; + from + &#039; is removed in js-yaml 4. &#039; +
        &#039;Use yaml.&#039; + to + &#039; instead, which is now safe by default.&#039;);
    };
  }


  var Type                = type;
  var Schema              = schema;
  var FAILSAFE_SCHEMA     = failsafe;
  var JSON_SCHEMA         = json;
  var CORE_SCHEMA         = core;
  var DEFAULT_SCHEMA      = _default;
  var load                = loader.load;
  var loadAll             = loader.loadAll;
  var dump                = dumper.dump;
  var YAMLException       = exception;

  // Re-export all types in case user wants to create custom schema
  var types = {
    binary:    binary,
    float:     float,
    map:       map,
    null:      _null,
    pairs:     pairs,
    set:       set,
    timestamp: timestamp,
    bool:      bool,
    int:       int,
    merge:     merge,
    omap:      omap,
    seq:       seq,
    str:       str
  };

  // Removed functions from JS-YAML 3.0.x
  var safeLoad            = renamed(&#039;safeLoad&#039;, &#039;load&#039;);
  var safeLoadAll         = renamed(&#039;safeLoadAll&#039;, &#039;loadAll&#039;);
  var safeDump            = renamed(&#039;safeDump&#039;, &#039;dump&#039;);

  var jsYaml = {
  	Type: Type,
  	Schema: Schema,
  	FAILSAFE_SCHEMA: FAILSAFE_SCHEMA,
  	JSON_SCHEMA: JSON_SCHEMA,
  	CORE_SCHEMA: CORE_SCHEMA,
  	DEFAULT_SCHEMA: DEFAULT_SCHEMA,
  	load: load,
  	loadAll: loadAll,
  	dump: dump,
  	YAMLException: YAMLException,
  	types: types,
  	safeLoad: safeLoad,
  	safeLoadAll: safeLoadAll,
  	safeDump: safeDump
  };

  exports.CORE_SCHEMA = CORE_SCHEMA;
  exports.DEFAULT_SCHEMA = DEFAULT_SCHEMA;
  exports.FAILSAFE_SCHEMA = FAILSAFE_SCHEMA;
  exports.JSON_SCHEMA = JSON_SCHEMA;
  exports.Schema = Schema;
  exports.Type = Type;
  exports.YAMLException = YAMLException;
  exports.default = jsYaml;
  exports.dump = dump;
  exports.load = load;
  exports.loadAll = loadAll;
  exports.safeDump = safeDump;
  exports.safeLoad = safeLoad;
  exports.safeLoadAll = safeLoadAll;
  exports.types = types;

  Object.defineProperty(exports, &#039;__esModule&#039;, { value: true });

})));</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
