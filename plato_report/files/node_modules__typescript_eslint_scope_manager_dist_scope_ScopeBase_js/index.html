<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@typescript-eslint/scope-manager/dist/scope/ScopeBase.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@typescript-eslint/scope-manager/dist/scope/ScopeBase.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">64.07</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">363</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">82.10</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.86</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
var __classPrivateFieldSet = (this &amp;&amp; this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === &quot;m&quot;) throw new TypeError(&quot;Private method is not writable&quot;);
    if (kind === &quot;a&quot; &amp;&amp; !f) throw new TypeError(&quot;Private accessor was defined without a setter&quot;);
    if (typeof state === &quot;function&quot; ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(&quot;Cannot write private member to an object whose class did not declare it&quot;);
    return (kind === &quot;a&quot; ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this &amp;&amp; this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === &quot;a&quot; &amp;&amp; !f) throw new TypeError(&quot;Private accessor was defined without a getter&quot;);
    if (typeof state === &quot;function&quot; ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(&quot;Cannot read private member from an object whose class did not declare it&quot;);
    return kind === &quot;m&quot; ? f : kind === &quot;a&quot; ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ScopeBase_declaredVariables, _ScopeBase_dynamic, _ScopeBase_staticCloseRef, _ScopeBase_dynamicCloseRef, _ScopeBase_globalCloseRef;
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
exports.ScopeBase = void 0;
const types_1 = require(&quot;@typescript-eslint/types&quot;);
const assert_1 = require(&quot;../assert&quot;);
const definition_1 = require(&quot;../definition&quot;);
const ID_1 = require(&quot;../ID&quot;);
const Reference_1 = require(&quot;../referencer/Reference&quot;);
const variable_1 = require(&quot;../variable&quot;);
const ScopeType_1 = require(&quot;./ScopeType&quot;);
/**
 * Test if scope is strict
 */
function isStrictScope(scope, block, isMethodDefinition) {
    var _a;
    let body;
    // When upper scope is exists and strict, inner scope is also strict.
    if ((_a = scope.upper) === null || _a === void 0 ? void 0 : _a.isStrict) {
        return true;
    }
    if (isMethodDefinition) {
        return true;
    }
    if (scope.type === ScopeType_1.ScopeType.class ||
        scope.type === ScopeType_1.ScopeType.conditionalType ||
        scope.type === ScopeType_1.ScopeType.functionType ||
        scope.type === ScopeType_1.ScopeType.mappedType ||
        scope.type === ScopeType_1.ScopeType.module ||
        scope.type === ScopeType_1.ScopeType.tsEnum ||
        scope.type === ScopeType_1.ScopeType.tsModule ||
        scope.type === ScopeType_1.ScopeType.type) {
        return true;
    }
    if (scope.type === ScopeType_1.ScopeType.block || scope.type === ScopeType_1.ScopeType.switch) {
        return false;
    }
    if (scope.type === ScopeType_1.ScopeType.function) {
        const functionBody = block;
        switch (functionBody.type) {
            case types_1.AST_NODE_TYPES.ArrowFunctionExpression:
                if (functionBody.body.type !== types_1.AST_NODE_TYPES.BlockStatement) {
                    return false;
                }
                body = functionBody.body;
                break;
            case types_1.AST_NODE_TYPES.Program:
                body = functionBody;
                break;
            default:
                body = functionBody.body;
        }
        if (!body) {
            return false;
        }
    }
    else if (scope.type === ScopeType_1.ScopeType.global) {
        body = block;
    }
    else {
        return false;
    }
    // Search &#039;use strict&#039; directive.
    for (const stmt of body.body) {
        if (stmt.type !== types_1.AST_NODE_TYPES.ExpressionStatement) {
            break;
        }
        if (stmt.directive === &#039;use strict&#039;) {
            return true;
        }
        const expr = stmt.expression;
        if (expr.type !== types_1.AST_NODE_TYPES.Literal) {
            break;
        }
        if (expr.raw === &#039;&quot;use strict&quot;&#039; || expr.raw === &quot;&#039;use strict&#039;&quot;) {
            return true;
        }
        if (expr.value === &#039;use strict&#039;) {
            return true;
        }
    }
    return false;
}
/**
 * Register scope
 */
function registerScope(scopeManager, scope) {
    scopeManager.scopes.push(scope);
    const scopes = scopeManager.nodeToScope.get(scope.block);
    if (scopes) {
        scopes.push(scope);
    }
    else {
        scopeManager.nodeToScope.set(scope.block, [scope]);
    }
}
const generator = (0, ID_1.createIdGenerator)();
const VARIABLE_SCOPE_TYPES = new Set([
    ScopeType_1.ScopeType.classFieldInitializer,
    ScopeType_1.ScopeType.classStaticBlock,
    ScopeType_1.ScopeType.function,
    ScopeType_1.ScopeType.global,
    ScopeType_1.ScopeType.module,
    ScopeType_1.ScopeType.tsModule,
]);
class ScopeBase {
    constructor(scopeManager, type, upperScope, block, isMethodDefinition) {
        /**
         * A unique ID for this instance - primarily used to help debugging and testing
         */
        this.$id = generator();
        /**
         * The array of child scopes. This does not include grandchild scopes.
         * @public
         */
        this.childScopes = [];
        /**
         * A map of the variables for each node in this scope.
         * This is map is a pointer to the one in the parent ScopeManager instance
         */
        _ScopeBase_declaredVariables.set(this, void 0);
        /**
         * Generally, through the lexical scoping of JS you can always know which variable an identifier in the source code
         * refers to. There are a few exceptions to this rule. With `global` and `with` scopes you can only decide at runtime
         * which variable a reference refers to.
         * All those scopes are considered &quot;dynamic&quot;.
         */
        _ScopeBase_dynamic.set(this, void 0);
        /**
         * Whether this scope is created by a FunctionExpression.
         * @public
         */
        this.functionExpressionScope = false;
        /**
         * List of {@link Reference}s that are left to be resolved (i.e. which
         * need to be linked to the variable they refer to).
         */
        this.leftToResolve = [];
        /**
         * Any variable {@link Reference} found in this scope.
         * This includes occurrences of local variables as well as variables from parent scopes (including the global scope).
         * For local variables this also includes defining occurrences (like in a &#039;var&#039; statement).
         * In a &#039;function&#039; scope this does not include the occurrences of the formal parameter in the parameter list.
         * @public
         */
        this.references = [];
        /**
         * The map from variable names to variable objects.
         * @public
         */
        this.set = new Map();
        /**
         * The {@link Reference}s that are not resolved with this scope.
         * @public
         */
        this.through = [];
        /**
         * The scoped {@link Variable}s of this scope.
         * In the case of a &#039;function&#039; scope this includes the automatic argument `arguments` as its first element, as well
         * as all further formal arguments.
         * This does not include variables which are defined in child scopes.
         * @public
         */
        this.variables = [];
        _ScopeBase_staticCloseRef.set(this, (ref) =&gt; {
            const resolve = () =&gt; {
                const name = ref.identifier.name;
                const variable = this.set.get(name);
                if (!variable) {
                    return false;
                }
                if (!this.isValidResolution(ref, variable)) {
                    return false;
                }
                // make sure we don&#039;t match a type reference to a value variable
                const isValidTypeReference = ref.isTypeReference &amp;&amp; variable.isTypeVariable;
                const isValidValueReference = ref.isValueReference &amp;&amp; variable.isValueVariable;
                if (!isValidTypeReference &amp;&amp; !isValidValueReference) {
                    return false;
                }
                variable.references.push(ref);
                ref.resolved = variable;
                return true;
            };
            if (!resolve()) {
                this.delegateToUpperScope(ref);
            }
        });
        _ScopeBase_dynamicCloseRef.set(this, (ref) =&gt; {
            // notify all names are through to global
            let current = this;
            do {
                current.through.push(ref);
                current = current.upper;
            } while (current);
        });
        _ScopeBase_globalCloseRef.set(this, (ref, scopeManager) =&gt; {
            // let/const/class declarations should be resolved statically.
            // others should be resolved dynamically.
            if (this.shouldStaticallyCloseForGlobal(ref, scopeManager)) {
                __classPrivateFieldGet(this, _ScopeBase_staticCloseRef, &quot;f&quot;).call(this, ref);
            }
            else {
                __classPrivateFieldGet(this, _ScopeBase_dynamicCloseRef, &quot;f&quot;).call(this, ref);
            }
        });
        const upperScopeAsScopeBase = upperScope;
        this.type = type;
        __classPrivateFieldSet(this, _ScopeBase_dynamic, this.type === ScopeType_1.ScopeType.global || this.type === ScopeType_1.ScopeType.with, &quot;f&quot;);
        this.block = block;
        this.variableScope = this.isVariableScope()
            ? this
            : upperScopeAsScopeBase.variableScope;
        this.upper = upperScope;
        /**
         * Whether &#039;use strict&#039; is in effect in this scope.
         * @member {boolean} Scope#isStrict
         */
        this.isStrict = isStrictScope(this, block, isMethodDefinition);
        if (upperScopeAsScopeBase) {
            // this is guaranteed to be correct at runtime
            upperScopeAsScopeBase.childScopes.push(this);
        }
        __classPrivateFieldSet(this, _ScopeBase_declaredVariables, scopeManager.declaredVariables, &quot;f&quot;);
        registerScope(scopeManager, this);
    }
    isVariableScope() {
        return VARIABLE_SCOPE_TYPES.has(this.type);
    }
    shouldStaticallyClose() {
        return !__classPrivateFieldGet(this, _ScopeBase_dynamic, &quot;f&quot;);
    }
    shouldStaticallyCloseForGlobal(ref, scopeManager) {
        // On global scope, let/const/class declarations should be resolved statically.
        const name = ref.identifier.name;
        const variable = this.set.get(name);
        if (!variable) {
            return false;
        }
        // variable exists on the scope
        // in module mode, we can statically resolve everything, regardless of its decl type
        if (scopeManager.isModule()) {
            return true;
        }
        // in script mode, only certain cases should be statically resolved
        // Example:
        // a `var` decl is ignored by the runtime if it clashes with a global name
        // this means that we should not resolve the reference to the variable
        const defs = variable.defs;
        return (defs.length &gt; 0 &amp;&amp;
            defs.every(def =&gt; {
                var _a;
                if (def.type === definition_1.DefinitionType.Variable &amp;&amp;
                    ((_a = def.parent) === null || _a === void 0 ? void 0 : _a.type) === types_1.AST_NODE_TYPES.VariableDeclaration &amp;&amp;
                    def.parent.kind === &#039;var&#039;) {
                    return false;
                }
                return true;
            }));
    }
    close(scopeManager) {
        let closeRef;
        if (this.shouldStaticallyClose()) {
            closeRef = __classPrivateFieldGet(this, _ScopeBase_staticCloseRef, &quot;f&quot;);
        }
        else if (this.type !== &#039;global&#039;) {
            closeRef = __classPrivateFieldGet(this, _ScopeBase_dynamicCloseRef, &quot;f&quot;);
        }
        else {
            closeRef = __classPrivateFieldGet(this, _ScopeBase_globalCloseRef, &quot;f&quot;);
        }
        // Try Resolving all references in this scope.
        (0, assert_1.assert)(this.leftToResolve);
        this.leftToResolve.forEach(ref =&gt; closeRef(ref, scopeManager));
        this.leftToResolve = null;
        return this.upper;
    }
    /**
     * To override by function scopes.
     * References in default parameters isn&#039;t resolved to variables which are in their function body.
     */
    isValidResolution(_ref, _variable) {
        return true;
    }
    delegateToUpperScope(ref) {
        const upper = this.upper;
        if (upper === null || upper === void 0 ? void 0 : upper.leftToResolve) {
            upper.leftToResolve.push(ref);
        }
        this.through.push(ref);
    }
    addDeclaredVariablesOfNode(variable, node) {
        if (node == null) {
            return;
        }
        let variables = __classPrivateFieldGet(this, _ScopeBase_declaredVariables, &quot;f&quot;).get(node);
        if (variables == null) {
            variables = [];
            __classPrivateFieldGet(this, _ScopeBase_declaredVariables, &quot;f&quot;).set(node, variables);
        }
        if (!variables.includes(variable)) {
            variables.push(variable);
        }
    }
    defineVariable(nameOrVariable, set, variables, node, def) {
        const name = typeof nameOrVariable === &#039;string&#039; ? nameOrVariable : nameOrVariable.name;
        let variable = set.get(name);
        if (!variable) {
            variable =
                typeof nameOrVariable === &#039;string&#039;
                    ? new variable_1.Variable(name, this)
                    : nameOrVariable;
            set.set(name, variable);
            variables.push(variable);
        }
        if (def) {
            variable.defs.push(def);
            this.addDeclaredVariablesOfNode(variable, def.node);
            this.addDeclaredVariablesOfNode(variable, def.parent);
        }
        if (node) {
            variable.identifiers.push(node);
        }
    }
    defineIdentifier(node, def) {
        this.defineVariable(node.name, this.set, this.variables, node, def);
    }
    defineLiteralIdentifier(node, def) {
        this.defineVariable(node.value, this.set, this.variables, null, def);
    }
    referenceValue(node, assign = Reference_1.ReferenceFlag.Read, writeExpr, maybeImplicitGlobal, init = false) {
        var _a;
        const ref = new Reference_1.Reference(node, this, assign, writeExpr, maybeImplicitGlobal, init, Reference_1.ReferenceTypeFlag.Value);
        this.references.push(ref);
        (_a = this.leftToResolve) === null || _a === void 0 ? void 0 : _a.push(ref);
    }
    referenceType(node) {
        var _a;
        const ref = new Reference_1.Reference(node, this, Reference_1.ReferenceFlag.Read, null, null, false, Reference_1.ReferenceTypeFlag.Type);
        this.references.push(ref);
        (_a = this.leftToResolve) === null || _a === void 0 ? void 0 : _a.push(ref);
    }
    referenceDualValueType(node) {
        var _a;
        const ref = new Reference_1.Reference(node, this, Reference_1.ReferenceFlag.Read, null, null, false, Reference_1.ReferenceTypeFlag.Type | Reference_1.ReferenceTypeFlag.Value);
        this.references.push(ref);
        (_a = this.leftToResolve) === null || _a === void 0 ? void 0 : _a.push(ref);
    }
}
exports.ScopeBase = ScopeBase;
_ScopeBase_declaredVariables = new WeakMap(), _ScopeBase_dynamic = new WeakMap(), _ScopeBase_staticCloseRef = new WeakMap(), _ScopeBase_dynamicCloseRef = new WeakMap(), _ScopeBase_globalCloseRef = new WeakMap();
//# sourceMappingURL=ScopeBase.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
