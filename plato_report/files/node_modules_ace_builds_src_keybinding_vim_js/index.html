<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/ace-builds/src/keybinding-vim.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/ace-builds/src/keybinding-vim.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">57.28</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">6672</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">278.66</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">127.87</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">define(&quot;ace/ext/hardwrap&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/range&quot;,&quot;ace/editor&quot;,&quot;ace/config&quot;], function(require, exports, module){&quot;use strict&quot;;
var Range = require(&quot;../range&quot;).Range;
function hardWrap(editor, options) {
    var max = options.column || editor.getOption(&quot;printMarginColumn&quot;);
    var allowMerge = options.allowMerge != false;
    var row = Math.min(options.startRow, options.endRow);
    var endRow = Math.max(options.startRow, options.endRow);
    var session = editor.session;
    while (row &lt;= endRow) {
        var line = session.getLine(row);
        if (line.length &gt; max) {
            var space = findSpace(line, max, 5);
            if (space) {
                var indentation = /^\s*/.exec(line)[0];
                session.replace(new Range(row, space.start, row, space.end), &quot;\n&quot; + indentation);
            }
            endRow++;
        }
        else if (allowMerge &amp;&amp; /\S/.test(line) &amp;&amp; row != endRow) {
            var nextLine = session.getLine(row + 1);
            if (nextLine &amp;&amp; /\S/.test(nextLine)) {
                var trimmedLine = line.replace(/\s+$/, &quot;&quot;);
                var trimmedNextLine = nextLine.replace(/^\s+/, &quot;&quot;);
                var mergedLine = trimmedLine + &quot; &quot; + trimmedNextLine;
                var space = findSpace(mergedLine, max, 5);
                if (space &amp;&amp; space.start &gt; trimmedLine.length || mergedLine.length &lt; max) {
                    var replaceRange = new Range(row, trimmedLine.length, row + 1, nextLine.length - trimmedNextLine.length);
                    session.replace(replaceRange, &quot; &quot;);
                    row--;
                    endRow--;
                }
                else if (trimmedLine.length &lt; line.length) {
                    session.remove(new Range(row, trimmedLine.length, row, line.length));
                }
            }
        }
        row++;
    }
    function findSpace(line, max, min) {
        if (line.length &lt; max)
            return;
        var before = line.slice(0, max);
        var after = line.slice(max);
        var spaceAfter = /^(?:(\s+)|(\S+)(\s+))/.exec(after);
        var spaceBefore = /(?:(\s+)|(\s+)(\S+))$/.exec(before);
        var start = 0;
        var end = 0;
        if (spaceBefore &amp;&amp; !spaceBefore[2]) {
            start = max - spaceBefore[1].length;
            end = max;
        }
        if (spaceAfter &amp;&amp; !spaceAfter[2]) {
            if (!start)
                start = max;
            end = max + spaceAfter[1].length;
        }
        if (start) {
            return {
                start: start,
                end: end
            };
        }
        if (spaceBefore &amp;&amp; spaceBefore[2] &amp;&amp; spaceBefore.index &gt; min) {
            return {
                start: spaceBefore.index,
                end: spaceBefore.index + spaceBefore[2].length
            };
        }
        if (spaceAfter &amp;&amp; spaceAfter[2]) {
            start = max + spaceAfter[2].length;
            return {
                start: start,
                end: start + spaceAfter[3].length
            };
        }
    }
}
function wrapAfterInput(e) {
    if (e.command.name == &quot;insertstring&quot; &amp;&amp; /\S/.test(e.args)) {
        var editor = e.editor;
        var cursor = editor.selection.cursor;
        if (cursor.column &lt;= editor.renderer.$printMarginColumn)
            return;
        var lastDelta = editor.session.$undoManager.$lastDelta;
        hardWrap(editor, {
            startRow: cursor.row, endRow: cursor.row,
            allowMerge: false
        });
        if (lastDelta != editor.session.$undoManager.$lastDelta)
            editor.session.markUndoGroup();
    }
}
var Editor = require(&quot;../editor&quot;).Editor;
require(&quot;../config&quot;).defineOptions(Editor.prototype, &quot;editor&quot;, {
    hardWrap: {
        set: function (val) {
            if (val) {
                this.commands.on(&quot;afterExec&quot;, wrapAfterInput);
            }
            else {
                this.commands.off(&quot;afterExec&quot;, wrapAfterInput);
            }
        },
        value: false
    }
});
exports.hardWrap = hardWrap;

});

define(&quot;ace/keyboard/vim&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/range&quot;,&quot;ace/lib/event_emitter&quot;,&quot;ace/lib/dom&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/keys&quot;,&quot;ace/lib/event&quot;,&quot;ace/search&quot;,&quot;ace/lib/useragent&quot;,&quot;ace/search_highlight&quot;,&quot;ace/commands/multi_select_commands&quot;,&quot;ace/mode/text&quot;,&quot;ace/ext/hardwrap&quot;,&quot;ace/multi_select&quot;], function(require, exports, module){// CodeMirror, copyright (c) by Marijn Haverbeke and others
&#039;use strict&#039;;
function log() {
    var d = &quot;&quot;;
    function format(p) {
        if (typeof p != &quot;object&quot;)
            return p + &quot;&quot;;
        if (&quot;line&quot; in p) {
            return p.line + &quot;:&quot; + p.ch;
        }
        if (&quot;anchor&quot; in p) {
            return format(p.anchor) + &quot;-&gt;&quot; + format(p.head);
        }
        if (Array.isArray(p))
            return &quot;[&quot; + p.map(function (x) {
                return format(x);
            }) + &quot;]&quot;;
        return JSON.stringify(p);
    }
    for (var i = 0; i &lt; arguments.length; i++) {
        var p = arguments[i];
        var f = format(p);
        d += f + &quot;  &quot;;
    }
    console.log(d);
}
var Range = require(&quot;../range&quot;).Range;
var EventEmitter = require(&quot;../lib/event_emitter&quot;).EventEmitter;
var domLib = require(&quot;../lib/dom&quot;);
var oop = require(&quot;../lib/oop&quot;);
var KEYS = require(&quot;../lib/keys&quot;);
var event = require(&quot;../lib/event&quot;);
var Search = require(&quot;../search&quot;).Search;
var useragent = require(&quot;../lib/useragent&quot;);
var SearchHighlight = require(&quot;../search_highlight&quot;).SearchHighlight;
var multiSelectCommands = require(&quot;../commands/multi_select_commands&quot;);
var TextModeTokenRe = require(&quot;../mode/text&quot;).Mode.prototype.tokenRe;
var hardWrap = require(&quot;../ext/hardwrap&quot;).hardWrap;
require(&quot;../multi_select&quot;);
var CodeMirror = function (ace) {
    this.ace = ace;
    this.state = {};
    this.marks = {};
    this.options = {};
    this.$uid = 0;
    this.onChange = this.onChange.bind(this);
    this.onSelectionChange = this.onSelectionChange.bind(this);
    this.onBeforeEndOperation = this.onBeforeEndOperation.bind(this);
    this.ace.on(&#039;change&#039;, this.onChange);
    this.ace.on(&#039;changeSelection&#039;, this.onSelectionChange);
    this.ace.on(&#039;beforeEndOperation&#039;, this.onBeforeEndOperation);
};
CodeMirror.Pos = function (line, ch) {
    if (!(this instanceof Pos))
        return new Pos(line, ch);
    this.line = line;
    this.ch = ch;
};
CodeMirror.defineOption = function (name, val, setter) { };
CodeMirror.commands = {
    redo: function (cm) { cm.ace.redo(); },
    undo: function (cm) { cm.ace.undo(); },
    newlineAndIndent: function (cm) { cm.ace.insert(&quot;\n&quot;); },
    goLineLeft: function (cm) { cm.ace.selection.moveCursorLineStart(); },
    goLineRight: function (cm) { cm.ace.selection.moveCursorLineEnd(); }
};
CodeMirror.keyMap = {};
CodeMirror.addClass = CodeMirror.rmClass = function () { };
CodeMirror.e_stop = CodeMirror.e_preventDefault = event.stopEvent;
CodeMirror.keyName = function (e) {
    var key = (KEYS[e.keyCode] || e.key || &quot;&quot;);
    if (key.length == 1)
        key = key.toUpperCase();
    key = event.getModifierString(e).replace(/(^|-)\w/g, function (m) {
        return m.toUpperCase();
    }) + key;
    return key;
};
CodeMirror.keyMap[&#039;default&#039;] = function (key) {
    return function (cm) {
        var cmd = cm.ace.commands.commandKeyBinding[key.toLowerCase()];
        return cmd &amp;&amp; cm.ace.execCommand(cmd) !== false;
    };
};
CodeMirror.lookupKey = function lookupKey(key, map, handle) {
    if (!map)
        map = &quot;default&quot;;
    if (typeof map == &quot;string&quot;)
        map = CodeMirror.keyMap[map];
    var found = typeof map == &quot;function&quot; ? map(key) : map[key];
    if (found === false)
        return &quot;nothing&quot;;
    if (found === &quot;...&quot;)
        return &quot;multi&quot;;
    if (found != null &amp;&amp; handle(found))
        return &quot;handled&quot;;
    if (map.fallthrough) {
        if (!Array.isArray(map.fallthrough))
            return lookupKey(key, map.fallthrough, handle);
        for (var i = 0; i &lt; map.fallthrough.length; i++) {
            var result = lookupKey(key, map.fallthrough[i], handle);
            if (result)
                return result;
        }
    }
};
CodeMirror.findMatchingTag = function (cm, head) {
    return cm.findMatchingTag(head);
};
CodeMirror.findEnclosingTag = function (cm, head) {
};
CodeMirror.signal = function (o, name, e) { return o._signal(name, e); };
CodeMirror.on = event.addListener;
CodeMirror.off = event.removeListener;
CodeMirror.isWordChar = function (ch) {
    if (ch &lt; &quot;\x7f&quot;)
        return /^\w$/.test(ch);
    TextModeTokenRe.lastIndex = 0;
    return TextModeTokenRe.test(ch);
};
(function () {
    oop.implement(CodeMirror.prototype, EventEmitter);
    this.destroy = function () {
        this.ace.off(&#039;change&#039;, this.onChange);
        this.ace.off(&#039;changeSelection&#039;, this.onSelectionChange);
        this.ace.off(&#039;beforeEndOperation&#039;, this.onBeforeEndOperation);
        this.removeOverlay();
    };
    this.virtualSelectionMode = function () {
        return this.ace.inVirtualSelectionMode &amp;&amp; this.ace.selection.index;
    };
    this.onChange = function (delta) {
        var change = { text: delta.action[0] == &#039;i&#039; ? delta.lines : [] };
        var curOp = this.curOp = this.curOp || {};
        if (!curOp.changeHandlers)
            curOp.changeHandlers = this._eventRegistry[&quot;change&quot;] &amp;&amp; this._eventRegistry[&quot;change&quot;].slice();
        if (!curOp.lastChange) {
            curOp.lastChange = curOp.change = change;
        }
        else {
            curOp.lastChange.next = curOp.lastChange = change;
        }
        this.$updateMarkers(delta);
    };
    this.onSelectionChange = function () {
        var curOp = this.curOp = this.curOp || {};
        if (!curOp.cursorActivityHandlers)
            curOp.cursorActivityHandlers = this._eventRegistry[&quot;cursorActivity&quot;] &amp;&amp; this._eventRegistry[&quot;cursorActivity&quot;].slice();
        this.curOp.cursorActivity = true;
        if (this.ace.inMultiSelectMode) {
            this.ace.keyBinding.removeKeyboardHandler(multiSelectCommands.keyboardHandler);
        }
    };
    this.operation = function (fn, force) {
        if (!force &amp;&amp; this.curOp || force &amp;&amp; this.curOp &amp;&amp; this.curOp.force) {
            return fn();
        }
        if (force || !this.ace.curOp) {
            if (this.curOp)
                this.onBeforeEndOperation();
        }
        if (!this.ace.curOp) {
            var prevOp = this.ace.prevOp;
            this.ace.startOperation({
                command: { name: &quot;vim&quot;, scrollIntoView: &quot;cursor&quot; }
            });
        }
        var curOp = this.curOp = this.curOp || {};
        this.curOp.force = force;
        var result = fn();
        if (this.ace.curOp &amp;&amp; this.ace.curOp.command.name == &quot;vim&quot;) {
            if (this.state.dialog)
                this.ace.curOp.command.scrollIntoView = this.ace.curOp.vimDialogScroll;
            this.ace.endOperation();
            if (!curOp.cursorActivity &amp;&amp; !curOp.lastChange &amp;&amp; prevOp)
                this.ace.prevOp = prevOp;
        }
        if (force || !this.ace.curOp) {
            if (this.curOp)
                this.onBeforeEndOperation();
        }
        return result;
    };
    this.onBeforeEndOperation = function () {
        var op = this.curOp;
        if (op) {
            if (op.change) {
                this.signal(&quot;change&quot;, op.change, op);
            }
            if (op &amp;&amp; op.cursorActivity) {
                this.signal(&quot;cursorActivity&quot;, null, op);
            }
            this.curOp = null;
        }
    };
    this.signal = function (eventName, e, handlers) {
        var listeners = handlers ? handlers[eventName + &quot;Handlers&quot;]
            : (this._eventRegistry || {})[eventName];
        if (!listeners)
            return;
        listeners = listeners.slice();
        for (var i = 0; i &lt; listeners.length; i++)
            listeners[i](this, e);
    };
    this.firstLine = function () { return 0; };
    this.lastLine = function () { return this.ace.session.getLength() - 1; };
    this.lineCount = function () { return this.ace.session.getLength(); };
    this.setCursor = function (line, ch) {
        if (typeof line === &#039;object&#039;) {
            ch = line.ch;
            line = line.line;
        }
        var shouldScroll = !this.curOp &amp;&amp; !this.ace.inVirtualSelectionMode;
        if (!this.ace.inVirtualSelectionMode)
            this.ace.exitMultiSelectMode();
        this.ace.session.unfold({ row: line, column: ch });
        this.ace.selection.moveTo(line, ch);
        if (shouldScroll) {
            this.ace.renderer.scrollCursorIntoView();
            this.ace.endOperation();
        }
    };
    this.getCursor = function (p) {
        var sel = this.ace.selection;
        var pos = p == &#039;anchor&#039; ? (sel.isEmpty() ? sel.lead : sel.anchor) :
            p == &#039;head&#039; || !p ? sel.lead : sel.getRange()[p];
        return toCmPos(pos);
    };
    this.listSelections = function (p) {
        var ranges = this.ace.multiSelect.rangeList.ranges;
        if (!ranges.length || this.ace.inVirtualSelectionMode)
            return [{ anchor: this.getCursor(&#039;anchor&#039;), head: this.getCursor(&#039;head&#039;) }];
        return ranges.map(function (r) {
            return {
                anchor: this.clipPos(toCmPos(r.cursor == r.end ? r.start : r.end)),
                head: this.clipPos(toCmPos(r.cursor))
            };
        }, this);
    };
    this.setSelections = function (p, primIndex) {
        var sel = this.ace.multiSelect;
        var ranges = p.map(function (x) {
            var anchor = toAcePos(x.anchor);
            var head = toAcePos(x.head);
            var r = Range.comparePoints(anchor, head) &lt; 0
                ? new Range.fromPoints(anchor, head)
                : new Range.fromPoints(head, anchor);
            r.cursor = Range.comparePoints(r.start, head) ? r.end : r.start;
            return r;
        });
        if (this.ace.inVirtualSelectionMode) {
            this.ace.selection.fromOrientedRange(ranges[0]);
            return;
        }
        if (!primIndex) {
            ranges = ranges.reverse();
        }
        else if (ranges[primIndex]) {
            ranges.push(ranges.splice(primIndex, 1)[0]);
        }
        sel.toSingleRange(ranges[0].clone());
        var session = this.ace.session;
        for (var i = 0; i &lt; ranges.length; i++) {
            var range = session.$clipRangeToDocument(ranges[i]); // todo why ace doesn&#039;t do this?
            sel.addRange(range);
        }
    };
    this.setSelection = function (a, h, options) {
        var sel = this.ace.selection;
        sel.moveTo(a.line, a.ch);
        sel.selectTo(h.line, h.ch);
        if (options &amp;&amp; options.origin == &#039;*mouse&#039;) {
            this.onBeforeEndOperation();
        }
    };
    this.somethingSelected = function (p) {
        return !this.ace.selection.isEmpty();
    };
    this.clipPos = function (p) {
        var pos = this.ace.session.$clipPositionToDocument(p.line, p.ch);
        return toCmPos(pos);
    };
    this.foldCode = function (pos) {
        this.ace.session.$toggleFoldWidget(pos.line, {});
    };
    this.markText = function (cursor) {
        return { clear: function () { }, find: function () { } };
    };
    this.$updateMarkers = function (delta) {
        var isInsert = delta.action == &quot;insert&quot;;
        var start = delta.start;
        var end = delta.end;
        var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);
        var colShift = (end.column - start.column) * (isInsert ? 1 : -1);
        if (isInsert)
            end = start;
        for (var i in this.marks) {
            var point = this.marks[i];
            var cmp = Range.comparePoints(point, start);
            if (cmp &lt; 0) {
                continue; // delta starts after the range
            }
            if (cmp === 0) {
                if (isInsert) {
                    if (point.bias == 1) {
                        cmp = 1;
                    }
                    else {
                        point.bias = -1;
                        continue;
                    }
                }
            }
            var cmp2 = isInsert ? cmp : Range.comparePoints(point, end);
            if (cmp2 &gt; 0) {
                point.row += rowShift;
                point.column += point.row == end.row ? colShift : 0;
                continue;
            }
            if (!isInsert &amp;&amp; cmp2 &lt;= 0) {
                point.row = start.row;
                point.column = start.column;
                if (cmp2 === 0)
                    point.bias = 1;
            }
        }
    };
    var Marker = function (cm, id, row, column) {
        this.cm = cm;
        this.id = id;
        this.row = row;
        this.column = column;
        cm.marks[this.id] = this;
    };
    Marker.prototype.clear = function () { delete this.cm.marks[this.id]; };
    Marker.prototype.find = function () { return toCmPos(this); };
    this.setBookmark = function (cursor, options) {
        var bm = new Marker(this, this.$uid++, cursor.line, cursor.ch);
        if (!options || !options.insertLeft)
            bm.$insertRight = true;
        this.marks[bm.id] = bm;
        return bm;
    };
    this.moveH = function (increment, unit) {
        if (unit == &#039;char&#039;) {
            var sel = this.ace.selection;
            sel.clearSelection();
            sel.moveCursorBy(0, increment);
        }
    };
    this.findPosV = function (start, amount, unit, goalColumn) {
        if (unit == &#039;page&#039;) {
            var renderer = this.ace.renderer;
            var config = renderer.layerConfig;
            amount = amount * Math.floor(config.height / config.lineHeight);
            unit = &#039;line&#039;;
        }
        if (unit == &#039;line&#039;) {
            var screenPos = this.ace.session.documentToScreenPosition(start.line, start.ch);
            if (goalColumn != null)
                screenPos.column = goalColumn;
            screenPos.row += amount;
            screenPos.row = Math.min(Math.max(0, screenPos.row), this.ace.session.getScreenLength() - 1);
            var pos = this.ace.session.screenToDocumentPosition(screenPos.row, screenPos.column);
            return toCmPos(pos);
        }
        else {
            debugger;
        }
    };
    this.charCoords = function (pos, mode) {
        if (mode == &#039;div&#039; || !mode) {
            var sc = this.ace.session.documentToScreenPosition(pos.line, pos.ch);
            return { left: sc.column, top: sc.row };
        }
        if (mode == &#039;local&#039;) {
            var renderer = this.ace.renderer;
            var sc = this.ace.session.documentToScreenPosition(pos.line, pos.ch);
            var lh = renderer.layerConfig.lineHeight;
            var cw = renderer.layerConfig.characterWidth;
            var top = lh * sc.row;
            return { left: sc.column * cw, top: top, bottom: top + lh };
        }
    };
    this.coordsChar = function (pos, mode) {
        var renderer = this.ace.renderer;
        if (mode == &#039;local&#039;) {
            var row = Math.max(0, Math.floor(pos.top / renderer.lineHeight));
            var col = Math.max(0, Math.floor(pos.left / renderer.characterWidth));
            var ch = renderer.session.screenToDocumentPosition(row, col);
            return toCmPos(ch);
        }
        else if (mode == &#039;div&#039;) {
            throw &quot;not implemented&quot;;
        }
    };
    this.getSearchCursor = function (query, pos, caseFold) {
        var caseSensitive = false;
        var isRegexp = false;
        if (query instanceof RegExp &amp;&amp; !query.global) {
            caseSensitive = !query.ignoreCase;
            query = query.source;
            isRegexp = true;
        }
        if (query == &quot;\\n&quot;) {
            query = &quot;\n&quot;;
            isRegexp = false;
        }
        var search = new Search();
        if (pos.ch == undefined)
            pos.ch = Number.MAX_VALUE;
        var acePos = { row: pos.line, column: pos.ch };
        var cm = this;
        var last = null;
        return {
            findNext: function () { return this.find(false); },
            findPrevious: function () { return this.find(true); },
            find: function (back) {
                search.setOptions({
                    needle: query,
                    caseSensitive: caseSensitive,
                    wrap: false,
                    backwards: back,
                    regExp: isRegexp,
                    start: last || acePos
                });
                var range = search.find(cm.ace.session);
                last = range;
                return last &amp;&amp; [!last.isEmpty()];
            },
            from: function () { return last &amp;&amp; toCmPos(last.start); },
            to: function () { return last &amp;&amp; toCmPos(last.end); },
            replace: function (text) {
                if (last) {
                    last.end = cm.ace.session.doc.replace(last, text);
                }
            }
        };
    };
    this.scrollTo = function (x, y) {
        var renderer = this.ace.renderer;
        var config = renderer.layerConfig;
        var maxHeight = config.maxHeight;
        maxHeight -= (renderer.$size.scrollerHeight - renderer.lineHeight) * renderer.$scrollPastEnd;
        if (y != null)
            this.ace.session.setScrollTop(Math.max(0, Math.min(y, maxHeight)));
        if (x != null)
            this.ace.session.setScrollLeft(Math.max(0, Math.min(x, config.width)));
    };
    this.scrollInfo = function () { return 0; };
    this.scrollIntoView = function (pos, margin) {
        if (pos) {
            var renderer = this.ace.renderer;
            var viewMargin = { &quot;top&quot;: 0, &quot;bottom&quot;: margin };
            renderer.scrollCursorIntoView(toAcePos(pos), (renderer.lineHeight * 2) / renderer.$size.scrollerHeight, viewMargin);
        }
    };
    this.getLine = function (row) { return this.ace.session.getLine(row); };
    this.getRange = function (s, e) {
        return this.ace.session.getTextRange(new Range(s.line, s.ch, e.line, e.ch));
    };
    this.replaceRange = function (text, s, e) {
        if (!e)
            e = s;
        var range = new Range(s.line, s.ch, e.line, e.ch);
        this.ace.session.$clipRangeToDocument(range);
        return this.ace.session.replace(range, text);
    };
    this.replaceSelection =
        this.replaceSelections = function (p) {
            var sel = this.ace.selection;
            if (this.ace.inVirtualSelectionMode) {
                this.ace.session.replace(sel.getRange(), p[0] || &quot;&quot;);
                return;
            }
            sel.inVirtualSelectionMode = true;
            var ranges = sel.rangeList.ranges;
            if (!ranges.length)
                ranges = [this.ace.multiSelect.getRange()];
            for (var i = ranges.length; i--;)
                this.ace.session.replace(ranges[i], p[i] || &quot;&quot;);
            sel.inVirtualSelectionMode = false;
        };
    this.getSelection = function () {
        return this.ace.getSelectedText();
    };
    this.getSelections = function () {
        return this.listSelections().map(function (x) {
            return this.getRange(x.anchor, x.head);
        }, this);
    };
    this.getInputField = function () {
        return this.ace.textInput.getElement();
    };
    this.getWrapperElement = function () {
        return this.ace.container;
    };
    var optMap = {
        indentWithTabs: &quot;useSoftTabs&quot;,
        indentUnit: &quot;tabSize&quot;,
        tabSize: &quot;tabSize&quot;,
        firstLineNumber: &quot;firstLineNumber&quot;,
        readOnly: &quot;readOnly&quot;
    };
    this.setOption = function (name, val) {
        this.state[name] = val;
        switch (name) {
            case &#039;indentWithTabs&#039;:
                name = optMap[name];
                val = !val;
                break;
            case &#039;keyMap&#039;:
                this.state.$keyMap = val;
                return;
                break;
            default:
                name = optMap[name];
        }
        if (name)
            this.ace.setOption(name, val);
    };
    this.getOption = function (name) {
        var val;
        var aceOpt = optMap[name];
        if (aceOpt)
            val = this.ace.getOption(aceOpt);
        switch (name) {
            case &#039;indentWithTabs&#039;:
                name = optMap[name];
                return !val;
            case &#039;keyMap&#039;:
                return this.state.$keyMap || &#039;vim&#039;;
        }
        return aceOpt ? val : this.state[name];
    };
    this.toggleOverwrite = function (on) {
        this.state.overwrite = on;
        return this.ace.setOverwrite(on);
    };
    this.addOverlay = function (o) {
        if (!this.$searchHighlight || !this.$searchHighlight.session) {
            var highlight = new SearchHighlight(null, &quot;ace_highlight-marker&quot;, &quot;text&quot;);
            var marker = this.ace.session.addDynamicMarker(highlight);
            highlight.id = marker.id;
            highlight.session = this.ace.session;
            highlight.destroy = function (o) {
                highlight.session.off(&quot;change&quot;, highlight.updateOnChange);
                highlight.session.off(&quot;changeEditor&quot;, highlight.destroy);
                highlight.session.removeMarker(highlight.id);
                highlight.session = null;
            };
            highlight.updateOnChange = function (delta) {
                var row = delta.start.row;
                if (row == delta.end.row)
                    highlight.cache[row] = undefined;
                else
                    highlight.cache.splice(row, highlight.cache.length);
            };
            highlight.session.on(&quot;changeEditor&quot;, highlight.destroy);
            highlight.session.on(&quot;change&quot;, highlight.updateOnChange);
        }
        var re = new RegExp(o.query.source, &quot;gmi&quot;);
        this.$searchHighlight = o.highlight = highlight;
        this.$searchHighlight.setRegexp(re);
        this.ace.renderer.updateBackMarkers();
    };
    this.removeOverlay = function (o) {
        if (this.$searchHighlight &amp;&amp; this.$searchHighlight.session) {
            this.$searchHighlight.destroy();
        }
    };
    this.getScrollInfo = function () {
        var renderer = this.ace.renderer;
        var config = renderer.layerConfig;
        return {
            left: renderer.scrollLeft,
            top: renderer.scrollTop,
            height: config.maxHeight,
            width: config.width,
            clientHeight: config.height,
            clientWidth: config.width
        };
    };
    this.getValue = function () {
        return this.ace.getValue();
    };
    this.setValue = function (v) {
        return this.ace.setValue(v, -1);
    };
    this.getTokenTypeAt = function (pos) {
        var token = this.ace.session.getTokenAt(pos.line, pos.ch);
        return token &amp;&amp; /comment|string/.test(token.type) ? &quot;string&quot; : &quot;&quot;;
    };
    this.findMatchingBracket = function (pos) {
        var m = this.ace.session.findMatchingBracket(toAcePos(pos));
        return { to: m &amp;&amp; toCmPos(m) };
    };
    this.findMatchingTag = function (pos) {
        var m = this.ace.session.getMatchingTags(toAcePos(pos));
        if (!m)
            return;
        return {
            open: {
                from: toCmPos(m.openTag.start),
                to: toCmPos(m.openTag.end)
            },
            close: {
                from: toCmPos(m.closeTag.start),
                to: toCmPos(m.closeTag.end)
            }
        };
    };
    this.indentLine = function (line, method) {
        if (method === true)
            this.ace.session.indentRows(line, line, &quot;\t&quot;);
        else if (method === false)
            this.ace.session.outdentRows(new Range(line, 0, line, 0));
    };
    this.indexFromPos = function (pos) {
        return this.ace.session.doc.positionToIndex(toAcePos(pos));
    };
    this.posFromIndex = function (index) {
        return toCmPos(this.ace.session.doc.indexToPosition(index));
    };
    this.focus = function (index) {
        return this.ace.textInput.focus();
    };
    this.blur = function (index) {
        return this.ace.blur();
    };
    this.defaultTextHeight = function (index) {
        return this.ace.renderer.layerConfig.lineHeight;
    };
    this.scanForBracket = function (pos, dir, _, options) {
        var re = options.bracketRegex.source;
        var tokenRe = /paren|text|operator|tag/;
        if (dir == 1) {
            var m = this.ace.session.$findClosingBracket(re.slice(1, 2), toAcePos(pos), tokenRe);
        }
        else {
            var m = this.ace.session.$findOpeningBracket(re.slice(-2, -1), { row: pos.line, column: pos.ch + 1 }, tokenRe);
        }
        return m &amp;&amp; { pos: toCmPos(m) };
    };
    this.refresh = function () {
        return this.ace.resize(true);
    };
    this.getMode = function () {
        return { name: this.getOption(&quot;mode&quot;) };
    };
    this.execCommand = function (name) {
        if (CodeMirror.commands.hasOwnProperty(name))
            return CodeMirror.commands[name](this);
        if (name == &quot;indentAuto&quot;)
            return this.ace.execCommand(&quot;autoindent&quot;);
        console.log(name + &quot; is not implemented&quot;);
    };
    this.getLineNumber = function (handle) {
        return handle.row;
    };
    this.getLineHandle = function (row) {
        return { text: this.ace.session.getLine(row), row: row };
    };
}).call(CodeMirror.prototype);
function toAcePos(cmPos) {
    return { row: cmPos.line, column: cmPos.ch };
}
function toCmPos(acePos) {
    return new Pos(acePos.row, acePos.column);
}
var StringStream = CodeMirror.StringStream = function (string, tabSize) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
};
StringStream.prototype = {
    eol: function () { return this.pos &gt;= this.string.length; },
    sol: function () { return this.pos == this.lineStart; },
    peek: function () { return this.string.charAt(this.pos) || undefined; },
    next: function () {
        if (this.pos &lt; this.string.length)
            return this.string.charAt(this.pos++);
    },
    eat: function (match) {
        var ch = this.string.charAt(this.pos);
        if (typeof match == &quot;string&quot;)
            var ok = ch == match;
        else
            var ok = ch &amp;&amp; (match.test ? match.test(ch) : match(ch));
        if (ok) {
            ++this.pos;
            return ch;
        }
    },
    eatWhile: function (match) {
        var start = this.pos;
        while (this.eat(match)) { }
        return this.pos &gt; start;
    },
    eatSpace: function () {
        var start = this.pos;
        while (/[\s\u00a0]/.test(this.string.charAt(this.pos)))
            ++this.pos;
        return this.pos &gt; start;
    },
    skipToEnd: function () { this.pos = this.string.length; },
    skipTo: function (ch) {
        var found = this.string.indexOf(ch, this.pos);
        if (found &gt; -1) {
            this.pos = found;
            return true;
        }
    },
    backUp: function (n) { this.pos -= n; },
    column: function () {
        throw &quot;not implemented&quot;;
    },
    indentation: function () {
        throw &quot;not implemented&quot;;
    },
    match: function (pattern, consume, caseInsensitive) {
        if (typeof pattern == &quot;string&quot;) {
            var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };
            var substr = this.string.substr(this.pos, pattern.length);
            if (cased(substr) == cased(pattern)) {
                if (consume !== false)
                    this.pos += pattern.length;
                return true;
            }
        }
        else {
            var match = this.string.slice(this.pos).match(pattern);
            if (match &amp;&amp; match.index &gt; 0)
                return null;
            if (match &amp;&amp; consume !== false)
                this.pos += match[0].length;
            return match;
        }
    },
    current: function () { return this.string.slice(this.start, this.pos); },
    hideFirstChars: function (n, inner) {
        this.lineStart += n;
        try {
            return inner();
        }
        finally {
            this.lineStart -= n;
        }
    }
};
CodeMirror.defineExtension = function (name, fn) {
    CodeMirror.prototype[name] = fn;
};
domLib.importCssString(&quot;.normal-mode .ace_cursor{\n    border: none;\n    background-color: rgba(255,0,0,0.5);\n}\n.normal-mode .ace_hidden-cursors .ace_cursor{\n  background-color: transparent;\n  border: 1px solid red;\n  opacity: 0.7\n}\n.ace_dialog {\n  position: absolute;\n  left: 0; right: 0;\n  background: inherit;\n  z-index: 15;\n  padding: .1em .8em;\n  overflow: hidden;\n  color: inherit;\n}\n.ace_dialog-top {\n  border-bottom: 1px solid #444;\n  top: 0;\n}\n.ace_dialog-bottom {\n  border-top: 1px solid #444;\n  bottom: 0;\n}\n.ace_dialog input {\n  border: none;\n  outline: none;\n  background: transparent;\n  width: 20em;\n  color: inherit;\n  font-family: monospace;\n}&quot;, &quot;vimMode&quot;, false);
(function () {
    function dialogDiv(cm, template, bottom) {
        var wrap = cm.ace.container;
        var dialog;
        dialog = wrap.appendChild(document.createElement(&quot;div&quot;));
        if (bottom)
            dialog.className = &quot;ace_dialog ace_dialog-bottom&quot;;
        else
            dialog.className = &quot;ace_dialog ace_dialog-top&quot;;
        if (typeof template == &quot;string&quot;) {
            dialog.innerHTML = template;
        }
        else { // Assuming it&#039;s a detached DOM element.
            dialog.appendChild(template);
        }
        return dialog;
    }
    function closeNotification(cm, newVal) {
        if (cm.state.currentNotificationClose)
            cm.state.currentNotificationClose();
        cm.state.currentNotificationClose = newVal;
    }
    CodeMirror.defineExtension(&quot;openDialog&quot;, function (template, callback, options) {
        if (this.virtualSelectionMode())
            return;
        if (!options)
            options = {};
        closeNotification(this, null);
        var dialog = dialogDiv(this, template, options.bottom);
        var closed = false, me = this;
        this.state.dialog = dialog;
        function close(newVal) {
            if (typeof newVal == &#039;string&#039;) {
                inp.value = newVal;
            }
            else {
                if (closed)
                    return;
                if (newVal &amp;&amp; newVal.type == &quot;blur&quot;) {
                    if (document.activeElement === inp)
                        return;
                }
                if (me.state.dialog == dialog) {
                    me.state.dialog = null;
                    me.focus();
                }
                closed = true;
                dialog.remove();
                if (options.onClose)
                    options.onClose(dialog);
                var cm = me;
                if (cm.state.vim) {
                    cm.state.vim.status = null;
                    cm.ace._signal(&quot;changeStatus&quot;);
                    cm.ace.renderer.$loop.schedule(cm.ace.renderer.CHANGE_CURSOR);
                }
            }
        }
        var inp = dialog.getElementsByTagName(&quot;input&quot;)[0], button;
        if (inp) {
            if (options.value) {
                inp.value = options.value;
                if (options.selectValueOnOpen !== false)
                    inp.select();
            }
            if (options.onInput)
                CodeMirror.on(inp, &quot;input&quot;, function (e) { options.onInput(e, inp.value, close); });
            if (options.onKeyUp)
                CodeMirror.on(inp, &quot;keyup&quot;, function (e) { options.onKeyUp(e, inp.value, close); });
            CodeMirror.on(inp, &quot;keydown&quot;, function (e) {
                if (options &amp;&amp; options.onKeyDown &amp;&amp; options.onKeyDown(e, inp.value, close)) {
                    return;
                }
                if (e.keyCode == 13)
                    callback(inp.value);
                if (e.keyCode == 27 || (options.closeOnEnter !== false &amp;&amp; e.keyCode == 13)) {
                    CodeMirror.e_stop(e);
                    close();
                }
            });
            if (options.closeOnBlur !== false)
                CodeMirror.on(inp, &quot;blur&quot;, close);
            inp.focus();
        }
        else if (button = dialog.getElementsByTagName(&quot;button&quot;)[0]) {
            CodeMirror.on(button, &quot;click&quot;, function () {
                close();
                me.focus();
            });
            if (options.closeOnBlur !== false)
                CodeMirror.on(button, &quot;blur&quot;, close);
            button.focus();
        }
        return close;
    });
    CodeMirror.defineExtension(&quot;openNotification&quot;, function (template, options) {
        if (this.virtualSelectionMode())
            return;
        closeNotification(this, close);
        var dialog = dialogDiv(this, template, options &amp;&amp; options.bottom);
        var closed = false, doneTimer;
        var duration = options &amp;&amp; typeof options.duration !== &quot;undefined&quot; ? options.duration : 5000;
        function close() {
            if (closed)
                return;
            closed = true;
            clearTimeout(doneTimer);
            dialog.remove();
        }
        CodeMirror.on(dialog, &#039;click&#039;, function (e) {
            CodeMirror.e_preventDefault(e);
            close();
        });
        if (duration)
            doneTimer = setTimeout(close, duration);
        return close;
    });
})();
var Pos = CodeMirror.Pos;
function transformCursor(cm, range) {
    var vim = cm.state.vim;
    if (!vim || vim.insertMode)
        return range.head;
    var head = vim.sel.head;
    if (!head)
        return range.head;
    if (vim.visualBlock) {
        if (range.head.line != head.line) {
            return;
        }
    }
    if (range.from() == range.anchor &amp;&amp; !range.empty()) {
        if (range.head.line == head.line &amp;&amp; range.head.ch != head.ch)
            return new Pos(range.head.line, range.head.ch - 1);
    }
    return range.head;
}
function updateSelectionForSurrogateCharacters(cm, curStart, curEnd) {
    if (curStart.line === curEnd.line &amp;&amp; curStart.ch &gt;= curEnd.ch - 1) {
        var text = cm.getLine(curStart.line);
        var charCode = text.charCodeAt(curStart.ch);
        if (0xD800 &lt;= charCode &amp;&amp; charCode &lt;= 0xD8FF) {
            curEnd.ch += 1;
        }
    }
    return { start: curStart, end: curEnd };
}
var defaultKeymap = [
    { keys: &#039;&lt;Left&gt;&#039;, type: &#039;keyToKey&#039;, toKeys: &#039;h&#039; },
    { keys: &#039;&lt;Right&gt;&#039;, type: &#039;keyToKey&#039;, toKeys: &#039;l&#039; },
    { keys: &#039;&lt;Up&gt;&#039;, type: &#039;keyToKey&#039;, toKeys: &#039;k&#039; },
    { keys: &#039;&lt;Down&gt;&#039;, type: &#039;keyToKey&#039;, toKeys: &#039;j&#039; },
    { keys: &#039;g&lt;Up&gt;&#039;, type: &#039;keyToKey&#039;, toKeys: &#039;gk&#039; },
    { keys: &#039;g&lt;Down&gt;&#039;, type: &#039;keyToKey&#039;, toKeys: &#039;gj&#039; },
    { keys: &#039;&lt;Space&gt;&#039;, type: &#039;keyToKey&#039;, toKeys: &#039;l&#039; },
    { keys: &#039;&lt;BS&gt;&#039;, type: &#039;keyToKey&#039;, toKeys: &#039;h&#039;, context: &#039;normal&#039; },
    { keys: &#039;&lt;Del&gt;&#039;, type: &#039;keyToKey&#039;, toKeys: &#039;x&#039;, context: &#039;normal&#039; },
    { keys: &#039;&lt;C-Space&gt;&#039;, type: &#039;keyToKey&#039;, toKeys: &#039;W&#039; },
    { keys: &#039;&lt;C-BS&gt;&#039;, type: &#039;keyToKey&#039;, toKeys: &#039;B&#039;, context: &#039;normal&#039; },
    { keys: &#039;&lt;S-Space&gt;&#039;, type: &#039;keyToKey&#039;, toKeys: &#039;w&#039; },
    { keys: &#039;&lt;S-BS&gt;&#039;, type: &#039;keyToKey&#039;, toKeys: &#039;b&#039;, context: &#039;normal&#039; },
    { keys: &#039;&lt;C-n&gt;&#039;, type: &#039;keyToKey&#039;, toKeys: &#039;j&#039; },
    { keys: &#039;&lt;C-p&gt;&#039;, type: &#039;keyToKey&#039;, toKeys: &#039;k&#039; },
    { keys: &#039;&lt;C-[&gt;&#039;, type: &#039;keyToKey&#039;, toKeys: &#039;&lt;Esc&gt;&#039; },
    { keys: &#039;&lt;C-c&gt;&#039;, type: &#039;keyToKey&#039;, toKeys: &#039;&lt;Esc&gt;&#039; },
    { keys: &#039;&lt;C-[&gt;&#039;, type: &#039;keyToKey&#039;, toKeys: &#039;&lt;Esc&gt;&#039;, context: &#039;insert&#039; },
    { keys: &#039;&lt;C-c&gt;&#039;, type: &#039;keyToKey&#039;, toKeys: &#039;&lt;Esc&gt;&#039;, context: &#039;insert&#039; },
    { keys: &#039;&lt;C-Esc&gt;&#039;, type: &#039;keyToKey&#039;, toKeys: &#039;&lt;Esc&gt;&#039; },
    { keys: &#039;&lt;C-Esc&gt;&#039;, type: &#039;keyToKey&#039;, toKeys: &#039;&lt;Esc&gt;&#039;, context: &#039;insert&#039; },
    { keys: &#039;s&#039;, type: &#039;keyToKey&#039;, toKeys: &#039;cl&#039;, context: &#039;normal&#039; },
    { keys: &#039;s&#039;, type: &#039;keyToKey&#039;, toKeys: &#039;c&#039;, context: &#039;visual&#039; },
    { keys: &#039;S&#039;, type: &#039;keyToKey&#039;, toKeys: &#039;cc&#039;, context: &#039;normal&#039; },
    { keys: &#039;S&#039;, type: &#039;keyToKey&#039;, toKeys: &#039;VdO&#039;, context: &#039;visual&#039; },
    { keys: &#039;&lt;Home&gt;&#039;, type: &#039;keyToKey&#039;, toKeys: &#039;0&#039; },
    { keys: &#039;&lt;End&gt;&#039;, type: &#039;keyToKey&#039;, toKeys: &#039;$&#039; },
    { keys: &#039;&lt;PageUp&gt;&#039;, type: &#039;keyToKey&#039;, toKeys: &#039;&lt;C-b&gt;&#039; },
    { keys: &#039;&lt;PageDown&gt;&#039;, type: &#039;keyToKey&#039;, toKeys: &#039;&lt;C-f&gt;&#039; },
    { keys: &#039;&lt;CR&gt;&#039;, type: &#039;keyToKey&#039;, toKeys: &#039;j^&#039;, context: &#039;normal&#039; },
    { keys: &#039;&lt;Ins&gt;&#039;, type: &#039;keyToKey&#039;, toKeys: &#039;i&#039;, context: &#039;normal&#039; },
    { keys: &#039;&lt;Ins&gt;&#039;, type: &#039;action&#039;, action: &#039;toggleOverwrite&#039;, context: &#039;insert&#039; },
    { keys: &#039;H&#039;, type: &#039;motion&#039;, motion: &#039;moveToTopLine&#039;, motionArgs: { linewise: true, toJumplist: true } },
    { keys: &#039;M&#039;, type: &#039;motion&#039;, motion: &#039;moveToMiddleLine&#039;, motionArgs: { linewise: true, toJumplist: true } },
    { keys: &#039;L&#039;, type: &#039;motion&#039;, motion: &#039;moveToBottomLine&#039;, motionArgs: { linewise: true, toJumplist: true } },
    { keys: &#039;h&#039;, type: &#039;motion&#039;, motion: &#039;moveByCharacters&#039;, motionArgs: { forward: false } },
    { keys: &#039;l&#039;, type: &#039;motion&#039;, motion: &#039;moveByCharacters&#039;, motionArgs: { forward: true } },
    { keys: &#039;j&#039;, type: &#039;motion&#039;, motion: &#039;moveByLines&#039;, motionArgs: { forward: true, linewise: true } },
    { keys: &#039;k&#039;, type: &#039;motion&#039;, motion: &#039;moveByLines&#039;, motionArgs: { forward: false, linewise: true } },
    { keys: &#039;gj&#039;, type: &#039;motion&#039;, motion: &#039;moveByDisplayLines&#039;, motionArgs: { forward: true } },
    { keys: &#039;gk&#039;, type: &#039;motion&#039;, motion: &#039;moveByDisplayLines&#039;, motionArgs: { forward: false } },
    { keys: &#039;w&#039;, type: &#039;motion&#039;, motion: &#039;moveByWords&#039;, motionArgs: { forward: true, wordEnd: false } },
    { keys: &#039;W&#039;, type: &#039;motion&#039;, motion: &#039;moveByWords&#039;, motionArgs: { forward: true, wordEnd: false, bigWord: true } },
    { keys: &#039;e&#039;, type: &#039;motion&#039;, motion: &#039;moveByWords&#039;, motionArgs: { forward: true, wordEnd: true, inclusive: true } },
    { keys: &#039;E&#039;, type: &#039;motion&#039;, motion: &#039;moveByWords&#039;, motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true } },
    { keys: &#039;b&#039;, type: &#039;motion&#039;, motion: &#039;moveByWords&#039;, motionArgs: { forward: false, wordEnd: false } },
    { keys: &#039;B&#039;, type: &#039;motion&#039;, motion: &#039;moveByWords&#039;, motionArgs: { forward: false, wordEnd: false, bigWord: true } },
    { keys: &#039;ge&#039;, type: &#039;motion&#039;, motion: &#039;moveByWords&#039;, motionArgs: { forward: false, wordEnd: true, inclusive: true } },
    { keys: &#039;gE&#039;, type: &#039;motion&#039;, motion: &#039;moveByWords&#039;, motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true } },
    { keys: &#039;{&#039;, type: &#039;motion&#039;, motion: &#039;moveByParagraph&#039;, motionArgs: { forward: false, toJumplist: true } },
    { keys: &#039;}&#039;, type: &#039;motion&#039;, motion: &#039;moveByParagraph&#039;, motionArgs: { forward: true, toJumplist: true } },
    { keys: &#039;(&#039;, type: &#039;motion&#039;, motion: &#039;moveBySentence&#039;, motionArgs: { forward: false } },
    { keys: &#039;)&#039;, type: &#039;motion&#039;, motion: &#039;moveBySentence&#039;, motionArgs: { forward: true } },
    { keys: &#039;&lt;C-f&gt;&#039;, type: &#039;motion&#039;, motion: &#039;moveByPage&#039;, motionArgs: { forward: true } },
    { keys: &#039;&lt;C-b&gt;&#039;, type: &#039;motion&#039;, motion: &#039;moveByPage&#039;, motionArgs: { forward: false } },
    { keys: &#039;&lt;C-d&gt;&#039;, type: &#039;motion&#039;, motion: &#039;moveByScroll&#039;, motionArgs: { forward: true, explicitRepeat: true } },
    { keys: &#039;&lt;C-u&gt;&#039;, type: &#039;motion&#039;, motion: &#039;moveByScroll&#039;, motionArgs: { forward: false, explicitRepeat: true } },
    { keys: &#039;gg&#039;, type: &#039;motion&#039;, motion: &#039;moveToLineOrEdgeOfDocument&#039;, motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true } },
    { keys: &#039;G&#039;, type: &#039;motion&#039;, motion: &#039;moveToLineOrEdgeOfDocument&#039;, motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true } },
    { keys: &quot;g$&quot;, type: &quot;motion&quot;, motion: &quot;moveToEndOfDisplayLine&quot; },
    { keys: &quot;g^&quot;, type: &quot;motion&quot;, motion: &quot;moveToStartOfDisplayLine&quot; },
    { keys: &quot;g0&quot;, type: &quot;motion&quot;, motion: &quot;moveToStartOfDisplayLine&quot; },
    { keys: &#039;0&#039;, type: &#039;motion&#039;, motion: &#039;moveToStartOfLine&#039; },
    { keys: &#039;^&#039;, type: &#039;motion&#039;, motion: &#039;moveToFirstNonWhiteSpaceCharacter&#039; },
    { keys: &#039;+&#039;, type: &#039;motion&#039;, motion: &#039;moveByLines&#039;, motionArgs: { forward: true, toFirstChar: true } },
    { keys: &#039;-&#039;, type: &#039;motion&#039;, motion: &#039;moveByLines&#039;, motionArgs: { forward: false, toFirstChar: true } },
    { keys: &#039;_&#039;, type: &#039;motion&#039;, motion: &#039;moveByLines&#039;, motionArgs: { forward: true, toFirstChar: true, repeatOffset: -1 } },
    { keys: &#039;$&#039;, type: &#039;motion&#039;, motion: &#039;moveToEol&#039;, motionArgs: { inclusive: true } },
    { keys: &#039;%&#039;, type: &#039;motion&#039;, motion: &#039;moveToMatchedSymbol&#039;, motionArgs: { inclusive: true, toJumplist: true } },
    { keys: &#039;f&lt;character&gt;&#039;, type: &#039;motion&#039;, motion: &#039;moveToCharacter&#039;, motionArgs: { forward: true, inclusive: true } },
    { keys: &#039;F&lt;character&gt;&#039;, type: &#039;motion&#039;, motion: &#039;moveToCharacter&#039;, motionArgs: { forward: false } },
    { keys: &#039;t&lt;character&gt;&#039;, type: &#039;motion&#039;, motion: &#039;moveTillCharacter&#039;, motionArgs: { forward: true, inclusive: true } },
    { keys: &#039;T&lt;character&gt;&#039;, type: &#039;motion&#039;, motion: &#039;moveTillCharacter&#039;, motionArgs: { forward: false } },
    { keys: &#039;;&#039;, type: &#039;motion&#039;, motion: &#039;repeatLastCharacterSearch&#039;, motionArgs: { forward: true } },
    { keys: &#039;,&#039;, type: &#039;motion&#039;, motion: &#039;repeatLastCharacterSearch&#039;, motionArgs: { forward: false } },
    { keys: &#039;\&#039;&lt;character&gt;&#039;, type: &#039;motion&#039;, motion: &#039;goToMark&#039;, motionArgs: { toJumplist: true, linewise: true } },
    { keys: &#039;`&lt;character&gt;&#039;, type: &#039;motion&#039;, motion: &#039;goToMark&#039;, motionArgs: { toJumplist: true } },
    { keys: &#039;]`&#039;, type: &#039;motion&#039;, motion: &#039;jumpToMark&#039;, motionArgs: { forward: true } },
    { keys: &#039;[`&#039;, type: &#039;motion&#039;, motion: &#039;jumpToMark&#039;, motionArgs: { forward: false } },
    { keys: &#039;]\&#039;&#039;, type: &#039;motion&#039;, motion: &#039;jumpToMark&#039;, motionArgs: { forward: true, linewise: true } },
    { keys: &#039;[\&#039;&#039;, type: &#039;motion&#039;, motion: &#039;jumpToMark&#039;, motionArgs: { forward: false, linewise: true } },
    { keys: &#039;]p&#039;, type: &#039;action&#039;, action: &#039;paste&#039;, isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true } },
    { keys: &#039;[p&#039;, type: &#039;action&#039;, action: &#039;paste&#039;, isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true } },
    { keys: &#039;]&lt;character&gt;&#039;, type: &#039;motion&#039;, motion: &#039;moveToSymbol&#039;, motionArgs: { forward: true, toJumplist: true } },
    { keys: &#039;[&lt;character&gt;&#039;, type: &#039;motion&#039;, motion: &#039;moveToSymbol&#039;, motionArgs: { forward: false, toJumplist: true } },
    { keys: &#039;|&#039;, type: &#039;motion&#039;, motion: &#039;moveToColumn&#039; },
    { keys: &#039;o&#039;, type: &#039;motion&#039;, motion: &#039;moveToOtherHighlightedEnd&#039;, context: &#039;visual&#039; },
    { keys: &#039;O&#039;, type: &#039;motion&#039;, motion: &#039;moveToOtherHighlightedEnd&#039;, motionArgs: { sameLine: true }, context: &#039;visual&#039; },
    { keys: &#039;d&#039;, type: &#039;operator&#039;, operator: &#039;delete&#039; },
    { keys: &#039;y&#039;, type: &#039;operator&#039;, operator: &#039;yank&#039; },
    { keys: &#039;c&#039;, type: &#039;operator&#039;, operator: &#039;change&#039; },
    { keys: &#039;=&#039;, type: &#039;operator&#039;, operator: &#039;indentAuto&#039; },
    { keys: &#039;&gt;&#039;, type: &#039;operator&#039;, operator: &#039;indent&#039;, operatorArgs: { indentRight: true } },
    { keys: &#039;&lt;&#039;, type: &#039;operator&#039;, operator: &#039;indent&#039;, operatorArgs: { indentRight: false } },
    { keys: &#039;g~&#039;, type: &#039;operator&#039;, operator: &#039;changeCase&#039; },
    { keys: &#039;gu&#039;, type: &#039;operator&#039;, operator: &#039;changeCase&#039;, operatorArgs: { toLower: true }, isEdit: true },
    { keys: &#039;gU&#039;, type: &#039;operator&#039;, operator: &#039;changeCase&#039;, operatorArgs: { toLower: false }, isEdit: true },
    { keys: &#039;n&#039;, type: &#039;motion&#039;, motion: &#039;findNext&#039;, motionArgs: { forward: true, toJumplist: true } },
    { keys: &#039;N&#039;, type: &#039;motion&#039;, motion: &#039;findNext&#039;, motionArgs: { forward: false, toJumplist: true } },
    { keys: &#039;gn&#039;, type: &#039;motion&#039;, motion: &#039;findAndSelectNextInclusive&#039;, motionArgs: { forward: true } },
    { keys: &#039;gN&#039;, type: &#039;motion&#039;, motion: &#039;findAndSelectNextInclusive&#039;, motionArgs: { forward: false } },
    { keys: &#039;x&#039;, type: &#039;operatorMotion&#039;, operator: &#039;delete&#039;, motion: &#039;moveByCharacters&#039;, motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false } },
    { keys: &#039;X&#039;, type: &#039;operatorMotion&#039;, operator: &#039;delete&#039;, motion: &#039;moveByCharacters&#039;, motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true } },
    { keys: &#039;D&#039;, type: &#039;operatorMotion&#039;, operator: &#039;delete&#039;, motion: &#039;moveToEol&#039;, motionArgs: { inclusive: true }, context: &#039;normal&#039; },
    { keys: &#039;D&#039;, type: &#039;operator&#039;, operator: &#039;delete&#039;, operatorArgs: { linewise: true }, context: &#039;visual&#039; },
    { keys: &#039;Y&#039;, type: &#039;operatorMotion&#039;, operator: &#039;yank&#039;, motion: &#039;expandToLine&#039;, motionArgs: { linewise: true }, context: &#039;normal&#039; },
    { keys: &#039;Y&#039;, type: &#039;operator&#039;, operator: &#039;yank&#039;, operatorArgs: { linewise: true }, context: &#039;visual&#039; },
    { keys: &#039;C&#039;, type: &#039;operatorMotion&#039;, operator: &#039;change&#039;, motion: &#039;moveToEol&#039;, motionArgs: { inclusive: true }, context: &#039;normal&#039; },
    { keys: &#039;C&#039;, type: &#039;operator&#039;, operator: &#039;change&#039;, operatorArgs: { linewise: true }, context: &#039;visual&#039; },
    { keys: &#039;~&#039;, type: &#039;operatorMotion&#039;, operator: &#039;changeCase&#039;, motion: &#039;moveByCharacters&#039;, motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: &#039;normal&#039; },
    { keys: &#039;~&#039;, type: &#039;operator&#039;, operator: &#039;changeCase&#039;, context: &#039;visual&#039; },
    { keys: &#039;&lt;C-u&gt;&#039;, type: &#039;operatorMotion&#039;, operator: &#039;delete&#039;, motion: &#039;moveToStartOfLine&#039;, context: &#039;insert&#039; },
    { keys: &#039;&lt;C-w&gt;&#039;, type: &#039;operatorMotion&#039;, operator: &#039;delete&#039;, motion: &#039;moveByWords&#039;, motionArgs: { forward: false, wordEnd: false }, context: &#039;insert&#039; },
    { keys: &#039;&lt;C-w&gt;&#039;, type: &#039;idle&#039;, context: &#039;normal&#039; },
    { keys: &#039;&lt;C-i&gt;&#039;, type: &#039;action&#039;, action: &#039;jumpListWalk&#039;, actionArgs: { forward: true } },
    { keys: &#039;&lt;C-o&gt;&#039;, type: &#039;action&#039;, action: &#039;jumpListWalk&#039;, actionArgs: { forward: false } },
    { keys: &#039;&lt;C-e&gt;&#039;, type: &#039;action&#039;, action: &#039;scroll&#039;, actionArgs: { forward: true, linewise: true } },
    { keys: &#039;&lt;C-y&gt;&#039;, type: &#039;action&#039;, action: &#039;scroll&#039;, actionArgs: { forward: false, linewise: true } },
    { keys: &#039;a&#039;, type: &#039;action&#039;, action: &#039;enterInsertMode&#039;, isEdit: true, actionArgs: { insertAt: &#039;charAfter&#039; }, context: &#039;normal&#039; },
    { keys: &#039;A&#039;, type: &#039;action&#039;, action: &#039;enterInsertMode&#039;, isEdit: true, actionArgs: { insertAt: &#039;eol&#039; }, context: &#039;normal&#039; },
    { keys: &#039;A&#039;, type: &#039;action&#039;, action: &#039;enterInsertMode&#039;, isEdit: true, actionArgs: { insertAt: &#039;endOfSelectedArea&#039; }, context: &#039;visual&#039; },
    { keys: &#039;i&#039;, type: &#039;action&#039;, action: &#039;enterInsertMode&#039;, isEdit: true, actionArgs: { insertAt: &#039;inplace&#039; }, context: &#039;normal&#039; },
    { keys: &#039;gi&#039;, type: &#039;action&#039;, action: &#039;enterInsertMode&#039;, isEdit: true, actionArgs: { insertAt: &#039;lastEdit&#039; }, context: &#039;normal&#039; },
    { keys: &#039;I&#039;, type: &#039;action&#039;, action: &#039;enterInsertMode&#039;, isEdit: true, actionArgs: { insertAt: &#039;firstNonBlank&#039; }, context: &#039;normal&#039; },
    { keys: &#039;gI&#039;, type: &#039;action&#039;, action: &#039;enterInsertMode&#039;, isEdit: true, actionArgs: { insertAt: &#039;bol&#039; }, context: &#039;normal&#039; },
    { keys: &#039;I&#039;, type: &#039;action&#039;, action: &#039;enterInsertMode&#039;, isEdit: true, actionArgs: { insertAt: &#039;startOfSelectedArea&#039; }, context: &#039;visual&#039; },
    { keys: &#039;o&#039;, type: &#039;action&#039;, action: &#039;newLineAndEnterInsertMode&#039;, isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: &#039;normal&#039; },
    { keys: &#039;O&#039;, type: &#039;action&#039;, action: &#039;newLineAndEnterInsertMode&#039;, isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: &#039;normal&#039; },
    { keys: &#039;v&#039;, type: &#039;action&#039;, action: &#039;toggleVisualMode&#039; },
    { keys: &#039;V&#039;, type: &#039;action&#039;, action: &#039;toggleVisualMode&#039;, actionArgs: { linewise: true } },
    { keys: &#039;&lt;C-v&gt;&#039;, type: &#039;action&#039;, action: &#039;toggleVisualMode&#039;, actionArgs: { blockwise: true } },
    { keys: &#039;&lt;C-q&gt;&#039;, type: &#039;action&#039;, action: &#039;toggleVisualMode&#039;, actionArgs: { blockwise: true } },
    { keys: &#039;gv&#039;, type: &#039;action&#039;, action: &#039;reselectLastSelection&#039; },
    { keys: &#039;J&#039;, type: &#039;action&#039;, action: &#039;joinLines&#039;, isEdit: true },
    { keys: &#039;gJ&#039;, type: &#039;action&#039;, action: &#039;joinLines&#039;, actionArgs: { keepSpaces: true }, isEdit: true },
    { keys: &#039;p&#039;, type: &#039;action&#039;, action: &#039;paste&#039;, isEdit: true, actionArgs: { after: true, isEdit: true } },
    { keys: &#039;P&#039;, type: &#039;action&#039;, action: &#039;paste&#039;, isEdit: true, actionArgs: { after: false, isEdit: true } },
    { keys: &#039;r&lt;character&gt;&#039;, type: &#039;action&#039;, action: &#039;replace&#039;, isEdit: true },
    { keys: &#039;@&lt;character&gt;&#039;, type: &#039;action&#039;, action: &#039;replayMacro&#039; },
    { keys: &#039;q&lt;character&gt;&#039;, type: &#039;action&#039;, action: &#039;enterMacroRecordMode&#039; },
    { keys: &#039;R&#039;, type: &#039;action&#039;, action: &#039;enterInsertMode&#039;, isEdit: true, actionArgs: { replace: true }, context: &#039;normal&#039; },
    { keys: &#039;R&#039;, type: &#039;operator&#039;, operator: &#039;change&#039;, operatorArgs: { linewise: true, fullLine: true }, context: &#039;visual&#039;, exitVisualBlock: true },
    { keys: &#039;u&#039;, type: &#039;action&#039;, action: &#039;undo&#039;, context: &#039;normal&#039; },
    { keys: &#039;u&#039;, type: &#039;operator&#039;, operator: &#039;changeCase&#039;, operatorArgs: { toLower: true }, context: &#039;visual&#039;, isEdit: true },
    { keys: &#039;U&#039;, type: &#039;operator&#039;, operator: &#039;changeCase&#039;, operatorArgs: { toLower: false }, context: &#039;visual&#039;, isEdit: true },
    { keys: &#039;&lt;C-r&gt;&#039;, type: &#039;action&#039;, action: &#039;redo&#039; },
    { keys: &#039;m&lt;character&gt;&#039;, type: &#039;action&#039;, action: &#039;setMark&#039; },
    { keys: &#039;&quot;&lt;character&gt;&#039;, type: &#039;action&#039;, action: &#039;setRegister&#039; },
    { keys: &#039;zz&#039;, type: &#039;action&#039;, action: &#039;scrollToCursor&#039;, actionArgs: { position: &#039;center&#039; } },
    { keys: &#039;z.&#039;, type: &#039;action&#039;, action: &#039;scrollToCursor&#039;, actionArgs: { position: &#039;center&#039; }, motion: &#039;moveToFirstNonWhiteSpaceCharacter&#039; },
    { keys: &#039;zt&#039;, type: &#039;action&#039;, action: &#039;scrollToCursor&#039;, actionArgs: { position: &#039;top&#039; } },
    { keys: &#039;z&lt;CR&gt;&#039;, type: &#039;action&#039;, action: &#039;scrollToCursor&#039;, actionArgs: { position: &#039;top&#039; }, motion: &#039;moveToFirstNonWhiteSpaceCharacter&#039; },
    { keys: &#039;zb&#039;, type: &#039;action&#039;, action: &#039;scrollToCursor&#039;, actionArgs: { position: &#039;bottom&#039; } },
    { keys: &#039;z-&#039;, type: &#039;action&#039;, action: &#039;scrollToCursor&#039;, actionArgs: { position: &#039;bottom&#039; }, motion: &#039;moveToFirstNonWhiteSpaceCharacter&#039; },
    { keys: &#039;.&#039;, type: &#039;action&#039;, action: &#039;repeatLastEdit&#039; },
    { keys: &#039;&lt;C-a&gt;&#039;, type: &#039;action&#039;, action: &#039;incrementNumberToken&#039;, isEdit: true, actionArgs: { increase: true, backtrack: false } },
    { keys: &#039;&lt;C-x&gt;&#039;, type: &#039;action&#039;, action: &#039;incrementNumberToken&#039;, isEdit: true, actionArgs: { increase: false, backtrack: false } },
    { keys: &#039;&lt;C-t&gt;&#039;, type: &#039;action&#039;, action: &#039;indent&#039;, actionArgs: { indentRight: true }, context: &#039;insert&#039; },
    { keys: &#039;&lt;C-d&gt;&#039;, type: &#039;action&#039;, action: &#039;indent&#039;, actionArgs: { indentRight: false }, context: &#039;insert&#039; },
    { keys: &#039;a&lt;character&gt;&#039;, type: &#039;motion&#039;, motion: &#039;textObjectManipulation&#039; },
    { keys: &#039;i&lt;character&gt;&#039;, type: &#039;motion&#039;, motion: &#039;textObjectManipulation&#039;, motionArgs: { textObjectInner: true } },
    { keys: &#039;/&#039;, type: &#039;search&#039;, searchArgs: { forward: true, querySrc: &#039;prompt&#039;, toJumplist: true } },
    { keys: &#039;?&#039;, type: &#039;search&#039;, searchArgs: { forward: false, querySrc: &#039;prompt&#039;, toJumplist: true } },
    { keys: &#039;*&#039;, type: &#039;search&#039;, searchArgs: { forward: true, querySrc: &#039;wordUnderCursor&#039;, wholeWordOnly: true, toJumplist: true } },
    { keys: &#039;#&#039;, type: &#039;search&#039;, searchArgs: { forward: false, querySrc: &#039;wordUnderCursor&#039;, wholeWordOnly: true, toJumplist: true } },
    { keys: &#039;g*&#039;, type: &#039;search&#039;, searchArgs: { forward: true, querySrc: &#039;wordUnderCursor&#039;, toJumplist: true } },
    { keys: &#039;g#&#039;, type: &#039;search&#039;, searchArgs: { forward: false, querySrc: &#039;wordUnderCursor&#039;, toJumplist: true } },
    { keys: &#039;:&#039;, type: &#039;ex&#039; }
];
var defaultKeymapLength = defaultKeymap.length;
var defaultExCommandMap = [
    { name: &#039;colorscheme&#039;, shortName: &#039;colo&#039; },
    { name: &#039;map&#039; },
    { name: &#039;imap&#039;, shortName: &#039;im&#039; },
    { name: &#039;nmap&#039;, shortName: &#039;nm&#039; },
    { name: &#039;vmap&#039;, shortName: &#039;vm&#039; },
    { name: &#039;unmap&#039; },
    { name: &#039;write&#039;, shortName: &#039;w&#039; },
    { name: &#039;undo&#039;, shortName: &#039;u&#039; },
    { name: &#039;redo&#039;, shortName: &#039;red&#039; },
    { name: &#039;set&#039;, shortName: &#039;se&#039; },
    { name: &#039;setlocal&#039;, shortName: &#039;setl&#039; },
    { name: &#039;setglobal&#039;, shortName: &#039;setg&#039; },
    { name: &#039;sort&#039;, shortName: &#039;sor&#039; },
    { name: &#039;substitute&#039;, shortName: &#039;s&#039;, possiblyAsync: true },
    { name: &#039;nohlsearch&#039;, shortName: &#039;noh&#039; },
    { name: &#039;yank&#039;, shortName: &#039;y&#039; },
    { name: &#039;delmarks&#039;, shortName: &#039;delm&#039; },
    { name: &#039;registers&#039;, shortName: &#039;reg&#039;, excludeFromCommandHistory: true },
    { name: &#039;vglobal&#039;, shortName: &#039;v&#039; },
    { name: &#039;global&#039;, shortName: &#039;g&#039; }
];
function enterVimMode(cm) {
    cm.setOption(&#039;disableInput&#039;, true);
    cm.setOption(&#039;showCursorWhenSelecting&#039;, false);
    CodeMirror.signal(cm, &quot;vim-mode-change&quot;, { mode: &quot;normal&quot; });
    cm.on(&#039;cursorActivity&#039;, onCursorActivity);
    maybeInitVimState(cm);
    CodeMirror.on(cm.getInputField(), &#039;paste&#039;, getOnPasteFn(cm));
}
function leaveVimMode(cm) {
    cm.setOption(&#039;disableInput&#039;, false);
    cm.off(&#039;cursorActivity&#039;, onCursorActivity);
    CodeMirror.off(cm.getInputField(), &#039;paste&#039;, getOnPasteFn(cm));
    cm.state.vim = null;
    if (highlightTimeout)
        clearTimeout(highlightTimeout);
}
function detachVimMap(cm, next) {
    if (this == CodeMirror.keyMap.vim) {
        cm.options.$customCursor = null;
        CodeMirror.rmClass(cm.getWrapperElement(), &quot;cm-fat-cursor&quot;);
    }
    if (!next || next.attach != attachVimMap)
        leaveVimMode(cm);
}
function attachVimMap(cm, prev) {
    if (this == CodeMirror.keyMap.vim) {
        if (cm.curOp)
            cm.curOp.selectionChanged = true;
        cm.options.$customCursor = transformCursor;
        CodeMirror.addClass(cm.getWrapperElement(), &quot;cm-fat-cursor&quot;);
    }
    if (!prev || prev.attach != attachVimMap)
        enterVimMode(cm);
}
CodeMirror.defineOption(&#039;vimMode&#039;, false, function (cm, val, prev) {
    if (val &amp;&amp; cm.getOption(&quot;keyMap&quot;) != &quot;vim&quot;)
        cm.setOption(&quot;keyMap&quot;, &quot;vim&quot;);
    else if (!val &amp;&amp; prev != CodeMirror.Init &amp;&amp; /^vim/.test(cm.getOption(&quot;keyMap&quot;)))
        cm.setOption(&quot;keyMap&quot;, &quot;default&quot;);
});
function cmKey(key, cm) {
    if (!cm) {
        return undefined;
    }
    if (this[key]) {
        return this[key];
    }
    var vimKey = cmKeyToVimKey(key);
    if (!vimKey) {
        return false;
    }
    var cmd = vimApi.findKey(cm, vimKey);
    if (typeof cmd == &#039;function&#039;) {
        CodeMirror.signal(cm, &#039;vim-keypress&#039;, vimKey);
    }
    return cmd;
}
var modifiers = { Shift: &#039;S&#039;, Ctrl: &#039;C&#039;, Alt: &#039;A&#039;, Cmd: &#039;D&#039;, Mod: &#039;A&#039;, CapsLock: &#039;&#039; };
var specialKeys = { Enter: &#039;CR&#039;, Backspace: &#039;BS&#039;, Delete: &#039;Del&#039;, Insert: &#039;Ins&#039; };
function cmKeyToVimKey(key) {
    if (key.charAt(0) == &#039;\&#039;&#039;) {
        return key.charAt(1);
    }
    var pieces = key.split(/-(?!$)/);
    var lastPiece = pieces[pieces.length - 1];
    if (pieces.length == 1 &amp;&amp; pieces[0].length == 1) {
        return false;
    }
    else if (pieces.length == 2 &amp;&amp; pieces[0] == &#039;Shift&#039; &amp;&amp; lastPiece.length == 1) {
        return false;
    }
    var hasCharacter = false;
    for (var i = 0; i &lt; pieces.length; i++) {
        var piece = pieces[i];
        if (piece in modifiers) {
            pieces[i] = modifiers[piece];
        }
        else {
            hasCharacter = true;
        }
        if (piece in specialKeys) {
            pieces[i] = specialKeys[piece];
        }
    }
    if (!hasCharacter) {
        return false;
    }
    if (isUpperCase(lastPiece)) {
        pieces[pieces.length - 1] = lastPiece.toLowerCase();
    }
    return &#039;&lt;&#039; + pieces.join(&#039;-&#039;) + &#039;&gt;&#039;;
}
function getOnPasteFn(cm) {
    var vim = cm.state.vim;
    if (!vim.onPasteFn) {
        vim.onPasteFn = function () {
            if (!vim.insertMode) {
                cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));
                actions.enterInsertMode(cm, {}, vim);
            }
        };
    }
    return vim.onPasteFn;
}
var numberRegex = /[\d]/;
var wordCharTest = [CodeMirror.isWordChar, function (ch) {
        return ch &amp;&amp; !CodeMirror.isWordChar(ch) &amp;&amp; !/\s/.test(ch);
    }], bigWordCharTest = [function (ch) {
        return /\S/.test(ch);
    }];
function makeKeyRange(start, size) {
    var keys = [];
    for (var i = start; i &lt; start + size; i++) {
        keys.push(String.fromCharCode(i));
    }
    return keys;
}
var upperCaseAlphabet = makeKeyRange(65, 26);
var lowerCaseAlphabet = makeKeyRange(97, 26);
var numbers = makeKeyRange(48, 10);
var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, [&#039;&lt;&#039;, &#039;&gt;&#039;]);
var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, [&#039;-&#039;, &#039;&quot;&#039;, &#039;.&#039;, &#039;:&#039;, &#039;_&#039;, &#039;/&#039;, &#039;+&#039;]);
var upperCaseChars;
try {
    upperCaseChars = new RegExp(&quot;^[\\p{Lu}]$&quot;, &quot;u&quot;);
}
catch (_) {
    upperCaseChars = /^[A-Z]$/;
}
function isLine(cm, line) {
    return line &gt;= cm.firstLine() &amp;&amp; line &lt;= cm.lastLine();
}
function isLowerCase(k) {
    return (/^[a-z]$/).test(k);
}
function isMatchableSymbol(k) {
    return &#039;()[]{}&#039;.indexOf(k) != -1;
}
function isNumber(k) {
    return numberRegex.test(k);
}
function isUpperCase(k) {
    return upperCaseChars.test(k);
}
function isWhiteSpaceString(k) {
    return (/^\s*$/).test(k);
}
function isEndOfSentenceSymbol(k) {
    return &#039;.?!&#039;.indexOf(k) != -1;
}
function inArray(val, arr) {
    for (var i = 0; i &lt; arr.length; i++) {
        if (arr[i] == val) {
            return true;
        }
    }
    return false;
}
var options = {};
function defineOption(name, defaultValue, type, aliases, callback) {
    if (defaultValue === undefined &amp;&amp; !callback) {
        throw Error(&#039;defaultValue is required unless callback is provided&#039;);
    }
    if (!type) {
        type = &#039;string&#039;;
    }
    options[name] = {
        type: type,
        defaultValue: defaultValue,
        callback: callback
    };
    if (aliases) {
        for (var i = 0; i &lt; aliases.length; i++) {
            options[aliases[i]] = options[name];
        }
    }
    if (defaultValue) {
        setOption(name, defaultValue);
    }
}
function setOption(name, value, cm, cfg) {
    var option = options[name];
    cfg = cfg || {};
    var scope = cfg.scope;
    if (!option) {
        return new Error(&#039;Unknown option: &#039; + name);
    }
    if (option.type == &#039;boolean&#039;) {
        if (value &amp;&amp; value !== true) {
            return new Error(&#039;Invalid argument: &#039; + name + &#039;=&#039; + value);
        }
        else if (value !== false) {
            value = true;
        }
    }
    if (option.callback) {
        if (scope !== &#039;local&#039;) {
            option.callback(value, undefined);
        }
        if (scope !== &#039;global&#039; &amp;&amp; cm) {
            option.callback(value, cm);
        }
    }
    else {
        if (scope !== &#039;local&#039;) {
            option.value = option.type == &#039;boolean&#039; ? !!value : value;
        }
        if (scope !== &#039;global&#039; &amp;&amp; cm) {
            cm.state.vim.options[name] = { value: value };
        }
    }
}
function getOption(name, cm, cfg) {
    var option = options[name];
    cfg = cfg || {};
    var scope = cfg.scope;
    if (!option) {
        return new Error(&#039;Unknown option: &#039; + name);
    }
    if (option.callback) {
        var local = cm &amp;&amp; option.callback(undefined, cm);
        if (scope !== &#039;global&#039; &amp;&amp; local !== undefined) {
            return local;
        }
        if (scope !== &#039;local&#039;) {
            return option.callback();
        }
        return;
    }
    else {
        var local = (scope !== &#039;global&#039;) &amp;&amp; (cm &amp;&amp; cm.state.vim.options[name]);
        return (local || (scope !== &#039;local&#039;) &amp;&amp; option || {}).value;
    }
}
defineOption(&#039;filetype&#039;, undefined, &#039;string&#039;, [&#039;ft&#039;], function (name, cm) {
    if (cm === undefined) {
        return;
    }
    if (name === undefined) {
        var mode = cm.getOption(&#039;mode&#039;);
        return mode == &#039;null&#039; ? &#039;&#039; : mode;
    }
    else {
        var mode = name == &#039;&#039; ? &#039;null&#039; : name;
        cm.setOption(&#039;mode&#039;, mode);
    }
});
var createCircularJumpList = function () {
    var size = 100;
    var pointer = -1;
    var head = 0;
    var tail = 0;
    var buffer = new Array(size);
    function add(cm, oldCur, newCur) {
        var current = pointer % size;
        var curMark = buffer[current];
        function useNextSlot(cursor) {
            var next = ++pointer % size;
            var trashMark = buffer[next];
            if (trashMark) {
                trashMark.clear();
            }
            buffer[next] = cm.setBookmark(cursor);
        }
        if (curMark) {
            var markPos = curMark.find();
            if (markPos &amp;&amp; !cursorEqual(markPos, oldCur)) {
                useNextSlot(oldCur);
            }
        }
        else {
            useNextSlot(oldCur);
        }
        useNextSlot(newCur);
        head = pointer;
        tail = pointer - size + 1;
        if (tail &lt; 0) {
            tail = 0;
        }
    }
    function move(cm, offset) {
        pointer += offset;
        if (pointer &gt; head) {
            pointer = head;
        }
        else if (pointer &lt; tail) {
            pointer = tail;
        }
        var mark = buffer[(size + pointer) % size];
        if (mark &amp;&amp; !mark.find()) {
            var inc = offset &gt; 0 ? 1 : -1;
            var newCur;
            var oldCur = cm.getCursor();
            do {
                pointer += inc;
                mark = buffer[(size + pointer) % size];
                if (mark &amp;&amp;
                    (newCur = mark.find()) &amp;&amp;
                    !cursorEqual(oldCur, newCur)) {
                    break;
                }
            } while (pointer &lt; head &amp;&amp; pointer &gt; tail);
        }
        return mark;
    }
    function find(cm, offset) {
        var oldPointer = pointer;
        var mark = move(cm, offset);
        pointer = oldPointer;
        return mark &amp;&amp; mark.find();
    }
    return {
        cachedCursor: undefined,
        add: add,
        find: find,
        move: move
    };
};
var createInsertModeChanges = function (c) {
    if (c) {
        return {
            changes: c.changes,
            expectCursorActivityForChange: c.expectCursorActivityForChange
        };
    }
    return {
        changes: [],
        expectCursorActivityForChange: false
    };
};
function MacroModeState() {
    this.latestRegister = undefined;
    this.isPlaying = false;
    this.isRecording = false;
    this.replaySearchQueries = [];
    this.onRecordingDone = undefined;
    this.lastInsertModeChanges = createInsertModeChanges();
}
MacroModeState.prototype = {
    exitMacroRecordMode: function () {
        var macroModeState = vimGlobalState.macroModeState;
        if (macroModeState.onRecordingDone) {
            macroModeState.onRecordingDone(); // close dialog
        }
        macroModeState.onRecordingDone = undefined;
        macroModeState.isRecording = false;
    },
    enterMacroRecordMode: function (cm, registerName) {
        var register = vimGlobalState.registerController.getRegister(registerName);
        if (register) {
            register.clear();
            this.latestRegister = registerName;
            if (cm.openDialog) {
                var template = dom(&#039;span&#039;, { class: &#039;cm-vim-message&#039; }, &#039;recording @&#039; + registerName);
                this.onRecordingDone = cm.openDialog(template, null, { bottom: true });
            }
            this.isRecording = true;
        }
    }
};
function maybeInitVimState(cm) {
    if (!cm.state.vim) {
        cm.state.vim = {
            inputState: new InputState(),
            lastEditInputState: undefined,
            lastEditActionCommand: undefined,
            lastHPos: -1,
            lastHSPos: -1,
            lastMotion: null,
            marks: {},
            insertMode: false,
            insertModeRepeat: undefined,
            visualMode: false,
            visualLine: false,
            visualBlock: false,
            lastSelection: null,
            lastPastedText: null,
            sel: {},
            options: {}
        };
    }
    return cm.state.vim;
}
var vimGlobalState;
function resetVimGlobalState() {
    vimGlobalState = {
        searchQuery: null,
        searchIsReversed: false,
        lastSubstituteReplacePart: undefined,
        jumpList: createCircularJumpList(),
        macroModeState: new MacroModeState,
        lastCharacterSearch: { increment: 0, forward: true, selectedCharacter: &#039;&#039; },
        registerController: new RegisterController({}),
        searchHistoryController: new HistoryController(),
        exCommandHistoryController: new HistoryController()
    };
    for (var optionName in options) {
        var option = options[optionName];
        option.value = option.defaultValue;
    }
}
var lastInsertModeKeyTimer;
var vimApi = {
    enterVimMode: enterVimMode,
    leaveVimMode: leaveVimMode,
    buildKeyMap: function () {
    },
    getRegisterController: function () {
        return vimGlobalState.registerController;
    },
    resetVimGlobalState_: resetVimGlobalState,
    getVimGlobalState_: function () {
        return vimGlobalState;
    },
    maybeInitVimState_: maybeInitVimState,
    suppressErrorLogging: false,
    InsertModeKey: InsertModeKey,
    map: function (lhs, rhs, ctx) {
        exCommandDispatcher.map(lhs, rhs, ctx);
    },
    unmap: function (lhs, ctx) {
        return exCommandDispatcher.unmap(lhs, ctx);
    },
    noremap: function (lhs, rhs, ctx) {
        function toCtxArray(ctx) {
            return ctx ? [ctx] : [&#039;normal&#039;, &#039;insert&#039;, &#039;visual&#039;];
        }
        var ctxsToMap = toCtxArray(ctx);
        var actualLength = defaultKeymap.length, origLength = defaultKeymapLength;
        for (var i = actualLength - origLength; i &lt; actualLength &amp;&amp; ctxsToMap.length; i++) {
            var mapping = defaultKeymap[i];
            if (mapping.keys == rhs &amp;&amp;
                (!ctx || !mapping.context || mapping.context === ctx) &amp;&amp;
                mapping.type.substr(0, 2) !== &#039;ex&#039; &amp;&amp;
                mapping.type.substr(0, 3) !== &#039;key&#039;) {
                var newMapping = {};
                for (var key in mapping) {
                    newMapping[key] = mapping[key];
                }
                newMapping.keys = lhs;
                if (ctx &amp;&amp; !newMapping.context) {
                    newMapping.context = ctx;
                }
                this._mapCommand(newMapping);
                var mappedCtxs = toCtxArray(mapping.context);
                ctxsToMap = ctxsToMap.filter(function (el) { return mappedCtxs.indexOf(el) === -1; });
            }
        }
    },
    mapclear: function (ctx) {
        var actualLength = defaultKeymap.length, origLength = defaultKeymapLength;
        var userKeymap = defaultKeymap.slice(0, actualLength - origLength);
        defaultKeymap = defaultKeymap.slice(actualLength - origLength);
        if (ctx) {
            for (var i = userKeymap.length - 1; i &gt;= 0; i--) {
                var mapping = userKeymap[i];
                if (ctx !== mapping.context) {
                    if (mapping.context) {
                        this._mapCommand(mapping);
                    }
                    else {
                        var contexts = [&#039;normal&#039;, &#039;insert&#039;, &#039;visual&#039;];
                        for (var j in contexts) {
                            if (contexts[j] !== ctx) {
                                var newMapping = {};
                                for (var key in mapping) {
                                    newMapping[key] = mapping[key];
                                }
                                newMapping.context = contexts[j];
                                this._mapCommand(newMapping);
                            }
                        }
                    }
                }
            }
        }
    },
    setOption: setOption,
    getOption: getOption,
    defineOption: defineOption,
    defineEx: function (name, prefix, func) {
        if (!prefix) {
            prefix = name;
        }
        else if (name.indexOf(prefix) !== 0) {
            throw new Error(&#039;(Vim.defineEx) &quot;&#039; + prefix + &#039;&quot; is not a prefix of &quot;&#039; + name + &#039;&quot;, command not registered&#039;);
        }
        exCommands[name] = func;
        exCommandDispatcher.commandMap_[prefix] = { name: name, shortName: prefix, type: &#039;api&#039; };
    },
    handleKey: function (cm, key, origin) {
        var command = this.findKey(cm, key, origin);
        if (typeof command === &#039;function&#039;) {
            return command();
        }
    },
    multiSelectHandleKey: multiSelectHandleKey,
    findKey: function (cm, key, origin) {
        var vim = maybeInitVimState(cm);
        function handleMacroRecording() {
            var macroModeState = vimGlobalState.macroModeState;
            if (macroModeState.isRecording) {
                if (key == &#039;q&#039;) {
                    macroModeState.exitMacroRecordMode();
                    clearInputState(cm);
                    return true;
                }
                if (origin != &#039;mapping&#039;) {
                    logKey(macroModeState, key);
                }
            }
        }
        function handleEsc() {
            if (key == &#039;&lt;Esc&gt;&#039;) {
                if (vim.visualMode) {
                    exitVisualMode(cm);
                }
                else if (vim.insertMode) {
                    exitInsertMode(cm);
                }
                else {
                    return;
                }
                clearInputState(cm);
                return true;
            }
        }
        function doKeyToKey(keys) {
            var match;
            while (keys) {
                match = (/&lt;\w+-.+?&gt;|&lt;\w+&gt;|./).exec(keys);
                key = match[0];
                keys = keys.substring(match.index + key.length);
                vimApi.handleKey(cm, key, &#039;mapping&#039;);
            }
        }
        function handleKeyInsertMode() {
            if (handleEsc()) {
                return true;
            }
            var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;
            var keysAreChars = key.length == 1;
            var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, &#039;insert&#039;);
            while (keys.length &gt; 1 &amp;&amp; match.type != &#039;full&#039;) {
                var keys = vim.inputState.keyBuffer = keys.slice(1);
                var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, &#039;insert&#039;);
                if (thisMatch.type != &#039;none&#039;) {
                    match = thisMatch;
                }
            }
            if (match.type == &#039;none&#039;) {
                clearInputState(cm);
                return false;
            }
            else if (match.type == &#039;partial&#039;) {
                if (lastInsertModeKeyTimer) {
                    window.clearTimeout(lastInsertModeKeyTimer);
                }
                lastInsertModeKeyTimer = window.setTimeout(function () { if (vim.insertMode &amp;&amp; vim.inputState.keyBuffer) {
                    clearInputState(cm);
                } }, getOption(&#039;insertModeEscKeysTimeout&#039;));
                return !keysAreChars;
            }
            if (lastInsertModeKeyTimer) {
                window.clearTimeout(lastInsertModeKeyTimer);
            }
            if (keysAreChars) {
                var selections = cm.listSelections();
                for (var i = 0; i &lt; selections.length; i++) {
                    var here = selections[i].head;
                    cm.replaceRange(&#039;&#039;, offsetCursor(here, 0, -(keys.length - 1)), here, &#039;+input&#039;);
                }
                vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();
            }
            clearInputState(cm);
            return match.command;
        }
        function handleKeyNonInsertMode() {
            if (handleMacroRecording() || handleEsc()) {
                return true;
            }
            var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;
            if (/^[1-9]\d*$/.test(keys)) {
                return true;
            }
            var keysMatcher = /^(\d*)(.*)$/.exec(keys);
            if (!keysMatcher) {
                clearInputState(cm);
                return false;
            }
            var context = vim.visualMode ? &#039;visual&#039; :
                &#039;normal&#039;;
            var mainKey = keysMatcher[2] || keysMatcher[1];
            if (vim.inputState.operatorShortcut &amp;&amp; vim.inputState.operatorShortcut.slice(-1) == mainKey) {
                mainKey = vim.inputState.operatorShortcut;
            }
            var match = commandDispatcher.matchCommand(mainKey, defaultKeymap, vim.inputState, context);
            if (match.type == &#039;none&#039;) {
                clearInputState(cm);
                return false;
            }
            else if (match.type == &#039;partial&#039;) {
                return true;
            }
            else if (match.type == &#039;clear&#039;) {
                clearInputState(cm);
                return true;
            }
            vim.inputState.keyBuffer = &#039;&#039;;
            keysMatcher = /^(\d*)(.*)$/.exec(keys);
            if (keysMatcher[1] &amp;&amp; keysMatcher[1] != &#039;0&#039;) {
                vim.inputState.pushRepeatDigit(keysMatcher[1]);
            }
            return match.command;
        }
        var command;
        if (vim.insertMode) {
            command = handleKeyInsertMode();
        }
        else {
            command = handleKeyNonInsertMode();
        }
        if (command === false) {
            return undefined; //ace_patch
        }
        else if (command === true) {
            return function () { return true; };
        }
        else {
            return function () {
                if ((command.operator || command.isEdit) &amp;&amp; cm.getOption(&#039;readOnly&#039;))
                    return; // ace_patch
                return cm.operation(function () {
                    cm.curOp.isVimOp = true;
                    try {
                        if (command.type == &#039;keyToKey&#039;) {
                            doKeyToKey(command.toKeys);
                        }
                        else {
                            commandDispatcher.processCommand(cm, vim, command);
                        }
                    }
                    catch (e) {
                        cm.state.vim = undefined;
                        maybeInitVimState(cm);
                        if (!vimApi.suppressErrorLogging) {
                            console[&#039;log&#039;](e);
                        }
                        throw e;
                    }
                    return true;
                });
            };
        }
    },
    handleEx: function (cm, input) {
        exCommandDispatcher.processCommand(cm, input);
    },
    defineMotion: defineMotion,
    defineAction: defineAction,
    defineOperator: defineOperator,
    mapCommand: mapCommand,
    _mapCommand: _mapCommand,
    defineRegister: defineRegister,
    exitVisualMode: exitVisualMode,
    exitInsertMode: exitInsertMode
};
function InputState() {
    this.prefixRepeat = [];
    this.motionRepeat = [];
    this.operator = null;
    this.operatorArgs = null;
    this.motion = null;
    this.motionArgs = null;
    this.keyBuffer = []; // For matching multi-key commands.
    this.registerName = null; // Defaults to the unnamed register.
}
InputState.prototype.pushRepeatDigit = function (n) {
    if (!this.operator) {
        this.prefixRepeat = this.prefixRepeat.concat(n);
    }
    else {
        this.motionRepeat = this.motionRepeat.concat(n);
    }
};
InputState.prototype.getRepeat = function () {
    var repeat = 0;
    if (this.prefixRepeat.length &gt; 0 || this.motionRepeat.length &gt; 0) {
        repeat = 1;
        if (this.prefixRepeat.length &gt; 0) {
            repeat *= parseInt(this.prefixRepeat.join(&#039;&#039;), 10);
        }
        if (this.motionRepeat.length &gt; 0) {
            repeat *= parseInt(this.motionRepeat.join(&#039;&#039;), 10);
        }
    }
    return repeat;
};
function clearInputState(cm, reason) {
    cm.state.vim.inputState = new InputState();
    CodeMirror.signal(cm, &#039;vim-command-done&#039;, reason);
}
function Register(text, linewise, blockwise) {
    this.clear();
    this.keyBuffer = [text || &#039;&#039;];
    this.insertModeChanges = [];
    this.searchQueries = [];
    this.linewise = !!linewise;
    this.blockwise = !!blockwise;
}
Register.prototype = {
    setText: function (text, linewise, blockwise) {
        this.keyBuffer = [text || &#039;&#039;];
        this.linewise = !!linewise;
        this.blockwise = !!blockwise;
    },
    pushText: function (text, linewise) {
        if (linewise) {
            if (!this.linewise) {
                this.keyBuffer.push(&#039;\n&#039;);
            }
            this.linewise = true;
        }
        this.keyBuffer.push(text);
    },
    pushInsertModeChanges: function (changes) {
        this.insertModeChanges.push(createInsertModeChanges(changes));
    },
    pushSearchQuery: function (query) {
        this.searchQueries.push(query);
    },
    clear: function () {
        this.keyBuffer = [];
        this.insertModeChanges = [];
        this.searchQueries = [];
        this.linewise = false;
    },
    toString: function () {
        return this.keyBuffer.join(&#039;&#039;);
    }
};
function defineRegister(name, register) {
    var registers = vimGlobalState.registerController.registers;
    if (!name || name.length != 1) {
        throw Error(&#039;Register name must be 1 character&#039;);
    }
    registers[name] = register;
    validRegisters.push(name);
}
function RegisterController(registers) {
    this.registers = registers;
    this.unnamedRegister = registers[&#039;&quot;&#039;] = new Register();
    registers[&#039;.&#039;] = new Register();
    registers[&#039;:&#039;] = new Register();
    registers[&#039;/&#039;] = new Register();
    registers[&#039;+&#039;] = new Register();
}
RegisterController.prototype = {
    pushText: function (registerName, operator, text, linewise, blockwise) {
        if (registerName === &#039;_&#039;)
            return;
        if (linewise &amp;&amp; text.charAt(text.length - 1) !== &#039;\n&#039;) {
            text += &#039;\n&#039;;
        }
        var register = this.isValidRegister(registerName) ?
            this.getRegister(registerName) : null;
        if (!register) {
            switch (operator) {
                case &#039;yank&#039;:
                    this.registers[&#039;0&#039;] = new Register(text, linewise, blockwise);
                    break;
                case &#039;delete&#039;:
                case &#039;change&#039;:
                    if (text.indexOf(&#039;\n&#039;) == -1) {
                        this.registers[&#039;-&#039;] = new Register(text, linewise);
                    }
                    else {
                        this.shiftNumericRegisters_();
                        this.registers[&#039;1&#039;] = new Register(text, linewise);
                    }
                    break;
            }
            this.unnamedRegister.setText(text, linewise, blockwise);
            return;
        }
        var append = isUpperCase(registerName);
        if (append) {
            register.pushText(text, linewise);
        }
        else {
            register.setText(text, linewise, blockwise);
        }
        if (registerName === &#039;+&#039;) {
            navigator.clipboard.writeText(text);
        }
        this.unnamedRegister.setText(register.toString(), linewise);
    },
    getRegister: function (name) {
        if (!this.isValidRegister(name)) {
            return this.unnamedRegister;
        }
        name = name.toLowerCase();
        if (!this.registers[name]) {
            this.registers[name] = new Register();
        }
        return this.registers[name];
    },
    isValidRegister: function (name) {
        return name &amp;&amp; inArray(name, validRegisters);
    },
    shiftNumericRegisters_: function () {
        for (var i = 9; i &gt;= 2; i--) {
            this.registers[i] = this.getRegister(&#039;&#039; + (i - 1));
        }
    }
};
function HistoryController() {
    this.historyBuffer = [];
    this.iterator = 0;
    this.initialPrefix = null;
}
HistoryController.prototype = {
    nextMatch: function (input, up) {
        var historyBuffer = this.historyBuffer;
        var dir = up ? -1 : 1;
        if (this.initialPrefix === null)
            this.initialPrefix = input;
        for (var i = this.iterator + dir; up ? i &gt;= 0 : i &lt; historyBuffer.length; i += dir) {
            var element = historyBuffer[i];
            for (var j = 0; j &lt;= element.length; j++) {
                if (this.initialPrefix == element.substring(0, j)) {
                    this.iterator = i;
                    return element;
                }
            }
        }
        if (i &gt;= historyBuffer.length) {
            this.iterator = historyBuffer.length;
            return this.initialPrefix;
        }
        if (i &lt; 0)
            return input;
    },
    pushInput: function (input) {
        var index = this.historyBuffer.indexOf(input);
        if (index &gt; -1)
            this.historyBuffer.splice(index, 1);
        if (input.length)
            this.historyBuffer.push(input);
    },
    reset: function () {
        this.initialPrefix = null;
        this.iterator = this.historyBuffer.length;
    }
};
var commandDispatcher = {
    matchCommand: function (keys, keyMap, inputState, context) {
        var matches = commandMatches(keys, keyMap, context, inputState);
        if (!matches.full &amp;&amp; !matches.partial) {
            return { type: &#039;none&#039; };
        }
        else if (!matches.full &amp;&amp; matches.partial) {
            return { type: &#039;partial&#039; };
        }
        var bestMatch;
        for (var i = 0; i &lt; matches.full.length; i++) {
            var match = matches.full[i];
            if (!bestMatch) {
                bestMatch = match;
            }
        }
        if (bestMatch.keys.slice(-11) == &#039;&lt;character&gt;&#039;) {
            var character = lastChar(keys);
            if (!character || character.length &gt; 1)
                return { type: &#039;clear&#039; };
            inputState.selectedCharacter = character;
        }
        return { type: &#039;full&#039;, command: bestMatch };
    },
    processCommand: function (cm, vim, command) {
        vim.inputState.repeatOverride = command.repeatOverride;
        switch (command.type) {
            case &#039;motion&#039;:
                this.processMotion(cm, vim, command);
                break;
            case &#039;operator&#039;:
                this.processOperator(cm, vim, command);
                break;
            case &#039;operatorMotion&#039;:
                this.processOperatorMotion(cm, vim, command);
                break;
            case &#039;action&#039;:
                this.processAction(cm, vim, command);
                break;
            case &#039;search&#039;:
                this.processSearch(cm, vim, command);
                break;
            case &#039;ex&#039;:
            case &#039;keyToEx&#039;:
                this.processEx(cm, vim, command);
                break;
            default:
                break;
        }
    },
    processMotion: function (cm, vim, command) {
        vim.inputState.motion = command.motion;
        vim.inputState.motionArgs = copyArgs(command.motionArgs);
        this.evalInput(cm, vim);
    },
    processOperator: function (cm, vim, command) {
        var inputState = vim.inputState;
        if (inputState.operator) {
            if (inputState.operator == command.operator) {
                inputState.motion = &#039;expandToLine&#039;;
                inputState.motionArgs = { linewise: true };
                this.evalInput(cm, vim);
                return;
            }
            else {
                clearInputState(cm);
            }
        }
        inputState.operator = command.operator;
        inputState.operatorArgs = copyArgs(command.operatorArgs);
        if (command.keys.length &gt; 1) {
            inputState.operatorShortcut = command.keys;
        }
        if (command.exitVisualBlock) {
            vim.visualBlock = false;
            updateCmSelection(cm);
        }
        if (vim.visualMode) {
            this.evalInput(cm, vim);
        }
    },
    processOperatorMotion: function (cm, vim, command) {
        var visualMode = vim.visualMode;
        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);
        if (operatorMotionArgs) {
            if (visualMode &amp;&amp; operatorMotionArgs.visualLine) {
                vim.visualLine = true;
            }
        }
        this.processOperator(cm, vim, command);
        if (!visualMode) {
            this.processMotion(cm, vim, command);
        }
    },
    processAction: function (cm, vim, command) {
        var inputState = vim.inputState;
        var repeat = inputState.getRepeat();
        var repeatIsExplicit = !!repeat;
        var actionArgs = copyArgs(command.actionArgs) || {};
        if (inputState.selectedCharacter) {
            actionArgs.selectedCharacter = inputState.selectedCharacter;
        }
        if (command.operator) {
            this.processOperator(cm, vim, command);
        }
        if (command.motion) {
            this.processMotion(cm, vim, command);
        }
        if (command.motion || command.operator) {
            this.evalInput(cm, vim);
        }
        actionArgs.repeat = repeat || 1;
        actionArgs.repeatIsExplicit = repeatIsExplicit;
        actionArgs.registerName = inputState.registerName;
        clearInputState(cm);
        vim.lastMotion = null;
        if (command.isEdit) {
            this.recordLastEdit(vim, inputState, command);
        }
        actions[command.action](cm, actionArgs, vim);
    },
    processSearch: function (cm, vim, command) {
        if (!cm.getSearchCursor) {
            return;
        }
        var forward = command.searchArgs.forward;
        var wholeWordOnly = command.searchArgs.wholeWordOnly;
        getSearchState(cm).setReversed(!forward);
        var promptPrefix = (forward) ? &#039;/&#039; : &#039;?&#039;;
        var originalQuery = getSearchState(cm).getQuery();
        var originalScrollPos = cm.getScrollInfo();
        function handleQuery(query, ignoreCase, smartCase) {
            vimGlobalState.searchHistoryController.pushInput(query);
            vimGlobalState.searchHistoryController.reset();
            try {
                updateSearchQuery(cm, query, ignoreCase, smartCase);
            }
            catch (e) {
                showConfirm(cm, &#039;Invalid regex: &#039; + query);
                clearInputState(cm);
                return;
            }
            commandDispatcher.processMotion(cm, vim, {
                type: &#039;motion&#039;,
                motion: &#039;findNext&#039;,
                motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }
            });
        }
        function onPromptClose(query) {
            handleQuery(query, true /** ignoreCase */, true /** smartCase */);
            var macroModeState = vimGlobalState.macroModeState;
            if (macroModeState.isRecording) {
                logSearchQuery(macroModeState, query);
            }
        }
        function onPromptKeyUp(e, query, close) {
            var keyName = CodeMirror.keyName(e), up, offset;
            if (keyName == &#039;Up&#039; || keyName == &#039;Down&#039;) {
                up = keyName == &#039;Up&#039; ? true : false;
                offset = e.target ? e.target.selectionEnd : 0;
                query = vimGlobalState.searchHistoryController.nextMatch(query, up) || &#039;&#039;;
                close(query);
                if (offset &amp;&amp; e.target)
                    e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);
            }
            else {
                if (keyName != &#039;Left&#039; &amp;&amp; keyName != &#039;Right&#039; &amp;&amp; keyName != &#039;Ctrl&#039; &amp;&amp; keyName != &#039;Alt&#039; &amp;&amp; keyName != &#039;Shift&#039;)
                    vimGlobalState.searchHistoryController.reset();
            }
            var parsedQuery;
            try {
                parsedQuery = updateSearchQuery(cm, query, true /** ignoreCase */, true /** smartCase */);
            }
            catch (e) {
            }
            if (parsedQuery) {
                cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);
            }
            else {
                clearSearchHighlight(cm);
                cm.scrollTo(originalScrollPos.left, originalScrollPos.top);
            }
        }
        function onPromptKeyDown(e, query, close) {
            var keyName = CodeMirror.keyName(e);
            if (keyName == &#039;Esc&#039; || keyName == &#039;Ctrl-C&#039; || keyName == &#039;Ctrl-[&#039; ||
                (keyName == &#039;Backspace&#039; &amp;&amp; query == &#039;&#039;)) {
                vimGlobalState.searchHistoryController.pushInput(query);
                vimGlobalState.searchHistoryController.reset();
                updateSearchQuery(cm, originalQuery);
                clearSearchHighlight(cm);
                cm.scrollTo(originalScrollPos.left, originalScrollPos.top);
                CodeMirror.e_stop(e);
                clearInputState(cm);
                close();
                cm.focus();
            }
            else if (keyName == &#039;Up&#039; || keyName == &#039;Down&#039;) {
                CodeMirror.e_stop(e);
            }
            else if (keyName == &#039;Ctrl-U&#039;) {
                CodeMirror.e_stop(e);
                close(&#039;&#039;);
            }
        }
        switch (command.searchArgs.querySrc) {
            case &#039;prompt&#039;:
                var macroModeState = vimGlobalState.macroModeState;
                if (macroModeState.isPlaying) {
                    var query = macroModeState.replaySearchQueries.shift();
                    handleQuery(query, true /** ignoreCase */, false /** smartCase */);
                }
                else {
                    showPrompt(cm, {
                        onClose: onPromptClose,
                        prefix: promptPrefix,
                        desc: &#039;(JavaScript regexp)&#039;,
                        onKeyUp: onPromptKeyUp,
                        onKeyDown: onPromptKeyDown
                    });
                }
                break;
            case &#039;wordUnderCursor&#039;:
                var word = expandWordUnderCursor(cm, false /** inclusive */, true /** forward */, false /** bigWord */, true /** noSymbol */);
                var isKeyword = true;
                if (!word) {
                    word = expandWordUnderCursor(cm, false /** inclusive */, true /** forward */, false /** bigWord */, false /** noSymbol */);
                    isKeyword = false;
                }
                if (!word) {
                    return;
                }
                var query = cm.getLine(word.start.line).substring(word.start.ch, word.end.ch);
                if (isKeyword &amp;&amp; wholeWordOnly) {
                    query = &#039;\\b&#039; + query + &#039;\\b&#039;;
                }
                else {
                    query = escapeRegex(query);
                }
                vimGlobalState.jumpList.cachedCursor = cm.getCursor();
                cm.setCursor(word.start);
                handleQuery(query, true /** ignoreCase */, false /** smartCase */);
                break;
        }
    },
    processEx: function (cm, vim, command) {
        function onPromptClose(input) {
            vimGlobalState.exCommandHistoryController.pushInput(input);
            vimGlobalState.exCommandHistoryController.reset();
            exCommandDispatcher.processCommand(cm, input);
            if (cm.state.vim)
                clearInputState(cm);
        }
        function onPromptKeyDown(e, input, close) {
            var keyName = CodeMirror.keyName(e), up, offset;
            if (keyName == &#039;Esc&#039; || keyName == &#039;Ctrl-C&#039; || keyName == &#039;Ctrl-[&#039; ||
                (keyName == &#039;Backspace&#039; &amp;&amp; input == &#039;&#039;)) {
                vimGlobalState.exCommandHistoryController.pushInput(input);
                vimGlobalState.exCommandHistoryController.reset();
                CodeMirror.e_stop(e);
                clearInputState(cm);
                close();
                cm.focus();
            }
            if (keyName == &#039;Up&#039; || keyName == &#039;Down&#039;) {
                CodeMirror.e_stop(e);
                up = keyName == &#039;Up&#039; ? true : false;
                offset = e.target ? e.target.selectionEnd : 0;
                input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || &#039;&#039;;
                close(input);
                if (offset &amp;&amp; e.target)
                    e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);
            }
            else if (keyName == &#039;Ctrl-U&#039;) {
                CodeMirror.e_stop(e);
                close(&#039;&#039;);
            }
            else {
                if (keyName != &#039;Left&#039; &amp;&amp; keyName != &#039;Right&#039; &amp;&amp; keyName != &#039;Ctrl&#039; &amp;&amp; keyName != &#039;Alt&#039; &amp;&amp; keyName != &#039;Shift&#039;)
                    vimGlobalState.exCommandHistoryController.reset();
            }
        }
        if (command.type == &#039;keyToEx&#039;) {
            exCommandDispatcher.processCommand(cm, command.exArgs.input);
        }
        else {
            if (vim.visualMode) {
                showPrompt(cm, { onClose: onPromptClose, prefix: &#039;:&#039;, value: &#039;\&#039;&lt;,\&#039;&gt;&#039;,
                    onKeyDown: onPromptKeyDown, selectValueOnOpen: false });
            }
            else {
                showPrompt(cm, { onClose: onPromptClose, prefix: &#039;:&#039;,
                    onKeyDown: onPromptKeyDown });
            }
        }
    },
    evalInput: function (cm, vim) {
        var inputState = vim.inputState;
        var motion = inputState.motion;
        var motionArgs = inputState.motionArgs || {};
        var operator = inputState.operator;
        var operatorArgs = inputState.operatorArgs || {};
        var registerName = inputState.registerName;
        var sel = vim.sel;
        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head) : cm.getCursor(&#039;head&#039;));
        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor(&#039;anchor&#039;));
        var oldHead = copyCursor(origHead);
        var oldAnchor = copyCursor(origAnchor);
        var newHead, newAnchor;
        var repeat;
        if (operator) {
            this.recordLastEdit(vim, inputState);
        }
        if (inputState.repeatOverride !== undefined) {
            repeat = inputState.repeatOverride;
        }
        else {
            repeat = inputState.getRepeat();
        }
        if (repeat &gt; 0 &amp;&amp; motionArgs.explicitRepeat) {
            motionArgs.repeatIsExplicit = true;
        }
        else if (motionArgs.noRepeat ||
            (!motionArgs.explicitRepeat &amp;&amp; repeat === 0)) {
            repeat = 1;
            motionArgs.repeatIsExplicit = false;
        }
        if (inputState.selectedCharacter) {
            motionArgs.selectedCharacter = operatorArgs.selectedCharacter =
                inputState.selectedCharacter;
        }
        motionArgs.repeat = repeat;
        clearInputState(cm);
        if (motion) {
            var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);
            vim.lastMotion = motions[motion];
            if (!motionResult) {
                return;
            }
            if (motionArgs.toJumplist) {
                if (!operator &amp;&amp; cm.ace.curOp != null)
                    cm.ace.curOp.command.scrollIntoView = &quot;center-animate&quot;; // ace_patch
                var jumpList = vimGlobalState.jumpList;
                var cachedCursor = jumpList.cachedCursor;
                if (cachedCursor) {
                    recordJumpPosition(cm, cachedCursor, motionResult);
                    delete jumpList.cachedCursor;
                }
                else {
                    recordJumpPosition(cm, origHead, motionResult);
                }
            }
            if (motionResult instanceof Array) {
                newAnchor = motionResult[0];
                newHead = motionResult[1];
            }
            else {
                newHead = motionResult;
            }
            if (!newHead) {
                newHead = copyCursor(origHead);
            }
            if (vim.visualMode) {
                if (!(vim.visualBlock &amp;&amp; newHead.ch === Infinity)) {
                    newHead = clipCursorToContent(cm, newHead, oldHead);
                }
                if (newAnchor) {
                    newAnchor = clipCursorToContent(cm, newAnchor);
                }
                newAnchor = newAnchor || oldAnchor;
                sel.anchor = newAnchor;
                sel.head = newHead;
                updateCmSelection(cm);
                updateMark(cm, vim, &#039;&lt;&#039;, cursorIsBefore(newAnchor, newHead) ? newAnchor
                    : newHead);
                updateMark(cm, vim, &#039;&gt;&#039;, cursorIsBefore(newAnchor, newHead) ? newHead
                    : newAnchor);
            }
            else if (!operator) {
                if (cm.ace.curOp)
                    cm.ace.curOp.vimDialogScroll = &quot;center-animate&quot;; // ace_patch
                newHead = clipCursorToContent(cm, newHead, oldHead);
                cm.setCursor(newHead.line, newHead.ch);
            }
        }
        if (operator) {
            if (operatorArgs.lastSel) {
                newAnchor = oldAnchor;
                var lastSel = operatorArgs.lastSel;
                var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);
                var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);
                if (lastSel.visualLine) {
                    newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);
                }
                else if (lastSel.visualBlock) {
                    newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);
                }
                else if (lastSel.head.line == lastSel.anchor.line) {
                    newHead = new Pos(oldAnchor.line, oldAnchor.ch + chOffset);
                }
                else {
                    newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);
                }
                vim.visualMode = true;
                vim.visualLine = lastSel.visualLine;
                vim.visualBlock = lastSel.visualBlock;
                sel = vim.sel = {
                    anchor: newAnchor,
                    head: newHead
                };
                updateCmSelection(cm);
            }
            else if (vim.visualMode) {
                operatorArgs.lastSel = {
                    anchor: copyCursor(sel.anchor),
                    head: copyCursor(sel.head),
                    visualBlock: vim.visualBlock,
                    visualLine: vim.visualLine
                };
            }
            var curStart, curEnd, linewise, mode;
            var cmSel;
            if (vim.visualMode) {
                curStart = cursorMin(sel.head, sel.anchor);
                curEnd = cursorMax(sel.head, sel.anchor);
                linewise = vim.visualLine || operatorArgs.linewise;
                mode = vim.visualBlock ? &#039;block&#039; :
                    linewise ? &#039;line&#039; :
                        &#039;char&#039;;
                var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);
                cmSel = makeCmSelection(cm, {
                    anchor: newPositions.start,
                    head: newPositions.end
                }, mode);
                if (linewise) {
                    var ranges = cmSel.ranges;
                    if (mode == &#039;block&#039;) {
                        for (var i = 0; i &lt; ranges.length; i++) {
                            ranges[i].head.ch = lineLength(cm, ranges[i].head.line);
                        }
                    }
                    else if (mode == &#039;line&#039;) {
                        ranges[0].head = new Pos(ranges[0].head.line + 1, 0);
                    }
                }
            }
            else {
                curStart = copyCursor(newAnchor || oldAnchor);
                curEnd = copyCursor(newHead || oldHead);
                if (cursorIsBefore(curEnd, curStart)) {
                    var tmp = curStart;
                    curStart = curEnd;
                    curEnd = tmp;
                }
                linewise = motionArgs.linewise || operatorArgs.linewise;
                if (linewise) {
                    expandSelectionToLine(cm, curStart, curEnd);
                }
                else if (motionArgs.forward) {
                    clipToLine(cm, curStart, curEnd);
                }
                mode = &#039;char&#039;;
                var exclusive = !motionArgs.inclusive || linewise;
                var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);
                cmSel = makeCmSelection(cm, {
                    anchor: newPositions.start,
                    head: newPositions.end
                }, mode, exclusive);
            }
            cm.setSelections(cmSel.ranges, cmSel.primary);
            vim.lastMotion = null;
            operatorArgs.repeat = repeat; // For indent in visual mode.
            operatorArgs.registerName = registerName;
            operatorArgs.linewise = linewise;
            var operatorMoveTo = operators[operator](cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);
            if (vim.visualMode) {
                exitVisualMode(cm, operatorMoveTo != null);
            }
            if (operatorMoveTo) {
                cm.setCursor(operatorMoveTo);
            }
        }
    },
    recordLastEdit: function (vim, inputState, actionCommand) {
        var macroModeState = vimGlobalState.macroModeState;
        if (macroModeState.isPlaying) {
            return;
        }
        vim.lastEditInputState = inputState;
        vim.lastEditActionCommand = actionCommand;
        macroModeState.lastInsertModeChanges.changes = [];
        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;
        macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;
    }
};
var motions = {
    moveToTopLine: function (cm, _head, motionArgs) {
        var line = getUserVisibleLines(cm).top + motionArgs.repeat - 1;
        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));
    },
    moveToMiddleLine: function (cm) {
        var range = getUserVisibleLines(cm);
        var line = Math.floor((range.top + range.bottom) * 0.5);
        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));
    },
    moveToBottomLine: function (cm, _head, motionArgs) {
        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat + 1;
        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));
    },
    expandToLine: function (_cm, head, motionArgs) {
        var cur = head;
        return new Pos(cur.line + motionArgs.repeat - 1, Infinity);
    },
    findNext: function (cm, _head, motionArgs) {
        var state = getSearchState(cm);
        var query = state.getQuery();
        if (!query) {
            return;
        }
        var prev = !motionArgs.forward;
        prev = (state.isReversed()) ? !prev : prev;
        highlightSearchMatches(cm, query);
        return findNext(cm, prev /** prev */, query, motionArgs.repeat);
    },
    findAndSelectNextInclusive: function (cm, _head, motionArgs, vim, prevInputState) {
        var state = getSearchState(cm);
        var query = state.getQuery();
        if (!query) {
            return;
        }
        var prev = !motionArgs.forward;
        prev = (state.isReversed()) ? !prev : prev;
        var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim);
        if (!next) {
            return;
        }
        if (prevInputState.operator) {
            return next;
        }
        var from = next[0];
        var to = new Pos(next[1].line, next[1].ch - 1);
        if (vim.visualMode) {
            if (vim.visualLine || vim.visualBlock) {
                vim.visualLine = false;
                vim.visualBlock = false;
                CodeMirror.signal(cm, &quot;vim-mode-change&quot;, { mode: &quot;visual&quot;, subMode: &quot;&quot; });
            }
            var anchor = vim.sel.anchor;
            if (anchor) {
                if (state.isReversed()) {
                    if (motionArgs.forward) {
                        return [anchor, from];
                    }
                    return [anchor, to];
                }
                else {
                    if (motionArgs.forward) {
                        return [anchor, to];
                    }
                    return [anchor, from];
                }
            }
        }
        else {
            vim.visualMode = true;
            vim.visualLine = false;
            vim.visualBlock = false;
            CodeMirror.signal(cm, &quot;vim-mode-change&quot;, { mode: &quot;visual&quot;, subMode: &quot;&quot; });
        }
        return prev ? [to, from] : [from, to];
    },
    goToMark: function (cm, _head, motionArgs, vim) {
        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);
        if (pos) {
            return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;
        }
        return null;
    },
    moveToOtherHighlightedEnd: function (cm, _head, motionArgs, vim) {
        if (vim.visualBlock &amp;&amp; motionArgs.sameLine) {
            var sel = vim.sel;
            return [
                clipCursorToContent(cm, new Pos(sel.anchor.line, sel.head.ch)),
                clipCursorToContent(cm, new Pos(sel.head.line, sel.anchor.ch))
            ];
        }
        else {
            return ([vim.sel.head, vim.sel.anchor]);
        }
    },
    jumpToMark: function (cm, head, motionArgs, vim) {
        var best = head;
        for (var i = 0; i &lt; motionArgs.repeat; i++) {
            var cursor = best;
            for (var key in vim.marks) {
                if (!isLowerCase(key)) {
                    continue;
                }
                var mark = vim.marks[key].find();
                var isWrongDirection = (motionArgs.forward) ?
                    cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);
                if (isWrongDirection) {
                    continue;
                }
                if (motionArgs.linewise &amp;&amp; (mark.line == cursor.line)) {
                    continue;
                }
                var equal = cursorEqual(cursor, best);
                var between = (motionArgs.forward) ?
                    cursorIsBetween(cursor, mark, best) :
                    cursorIsBetween(best, mark, cursor);
                if (equal || between) {
                    best = mark;
                }
            }
        }
        if (motionArgs.linewise) {
            best = new Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));
        }
        return best;
    },
    moveByCharacters: function (_cm, head, motionArgs) {
        var cur = head;
        var repeat = motionArgs.repeat;
        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;
        return new Pos(cur.line, ch);
    },
    moveByLines: function (cm, head, motionArgs, vim) {
        var cur = head;
        var endCh = cur.ch;
        switch (vim.lastMotion) {
            case this.moveByLines:
            case this.moveByDisplayLines:
            case this.moveByScroll:
            case this.moveToColumn:
            case this.moveToEol:
                endCh = vim.lastHPos;
                break;
            default:
                vim.lastHPos = endCh;
        }
        var repeat = motionArgs.repeat + (motionArgs.repeatOffset || 0);
        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;
        var first = cm.firstLine();
        var last = cm.lastLine();
        if (line &lt; first &amp;&amp; cur.line == first) {
            return this.moveToStartOfLine(cm, head, motionArgs, vim);
        }
        else if (line &gt; last &amp;&amp; cur.line == last) {
            return moveToEol(cm, head, motionArgs, vim, true);
        }
        var fold = cm.ace.session.getFoldLine(line);
        if (fold) {
            if (motionArgs.forward) {
                if (line &gt; fold.start.row)
                    line = fold.end.row + 1;
            }
            else {
                line = fold.start.row;
            }
        }
        if (motionArgs.toFirstChar) {
            endCh = findFirstNonWhiteSpaceCharacter(cm.getLine(line));
            vim.lastHPos = endCh;
        }
        vim.lastHSPos = cm.charCoords(new Pos(line, endCh), &#039;div&#039;).left;
        return new Pos(line, endCh);
    },
    moveByDisplayLines: function (cm, head, motionArgs, vim) {
        var cur = head;
        switch (vim.lastMotion) {
            case this.moveByDisplayLines:
            case this.moveByScroll:
            case this.moveByLines:
            case this.moveToColumn:
            case this.moveToEol:
                break;
            default:
                vim.lastHSPos = cm.charCoords(cur, &#039;div&#039;).left;
        }
        var repeat = motionArgs.repeat;
        var res = cm.findPosV(cur, (motionArgs.forward ? repeat : -repeat), &#039;line&#039;, vim.lastHSPos);
        if (res.hitSide) {
            if (motionArgs.forward) {
                var lastCharCoords = cm.charCoords(res, &#039;div&#039;);
                var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };
                var res = cm.coordsChar(goalCoords, &#039;div&#039;);
            }
            else {
                var resCoords = cm.charCoords(new Pos(cm.firstLine(), 0), &#039;div&#039;);
                resCoords.left = vim.lastHSPos;
                res = cm.coordsChar(resCoords, &#039;div&#039;);
            }
        }
        vim.lastHPos = res.ch;
        return res;
    },
    moveByPage: function (cm, head, motionArgs) {
        var curStart = head;
        var repeat = motionArgs.repeat;
        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), &#039;page&#039;);
    },
    moveByParagraph: function (cm, head, motionArgs) {
        var dir = motionArgs.forward ? 1 : -1;
        return findParagraph(cm, head, motionArgs.repeat, dir);
    },
    moveBySentence: function (cm, head, motionArgs) {
        var dir = motionArgs.forward ? 1 : -1;
        return findSentence(cm, head, motionArgs.repeat, dir);
    },
    moveByScroll: function (cm, head, motionArgs, vim) {
        var scrollbox = cm.getScrollInfo();
        var curEnd = null;
        var repeat = motionArgs.repeat;
        if (!repeat) {
            repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());
        }
        var orig = cm.charCoords(head, &#039;local&#039;);
        motionArgs.repeat = repeat;
        curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);
        if (!curEnd) {
            return null;
        }
        var dest = cm.charCoords(curEnd, &#039;local&#039;);
        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);
        return curEnd;
    },
    moveByWords: function (cm, head, motionArgs) {
        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward, !!motionArgs.wordEnd, !!motionArgs.bigWord);
    },
    moveTillCharacter: function (cm, _head, motionArgs) {
        var repeat = motionArgs.repeat;
        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter);
        var increment = motionArgs.forward ? -1 : 1;
        recordLastCharacterSearch(increment, motionArgs);
        if (!curEnd)
            return null;
        curEnd.ch += increment;
        return curEnd;
    },
    moveToCharacter: function (cm, head, motionArgs) {
        var repeat = motionArgs.repeat;
        recordLastCharacterSearch(0, motionArgs);
        return moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;
    },
    moveToSymbol: function (cm, head, motionArgs) {
        var repeat = motionArgs.repeat;
        return findSymbol(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;
    },
    moveToColumn: function (cm, head, motionArgs, vim) {
        var repeat = motionArgs.repeat;
        vim.lastHPos = repeat - 1;
        vim.lastHSPos = cm.charCoords(head, &#039;div&#039;).left;
        return moveToColumn(cm, repeat);
    },
    moveToEol: function (cm, head, motionArgs, vim) {
        return moveToEol(cm, head, motionArgs, vim, false);
    },
    moveToFirstNonWhiteSpaceCharacter: function (cm, head) {
        var cursor = head;
        return new Pos(cursor.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));
    },
    moveToMatchedSymbol: function (cm, head) {
        var cursor = head;
        var line = cursor.line;
        var ch = cursor.ch;
        var lineText = cm.getLine(line);
        var symbol;
        for (; ch &lt; lineText.length; ch++) {
            symbol = lineText.charAt(ch);
            if (symbol &amp;&amp; isMatchableSymbol(symbol)) {
                var style = cm.getTokenTypeAt(new Pos(line, ch + 1));
                if (style !== &quot;string&quot; &amp;&amp; style !== &quot;comment&quot;) {
                    break;
                }
            }
        }
        if (ch &lt; lineText.length) {
            var re = /[&lt;&gt;]/.test(lineText[ch]) ? /[(){}[\]&lt;&gt;]/ : /[(){}[\]]/; //ace_patch?
            var matched = cm.findMatchingBracket(new Pos(line, ch + 1), { bracketRegex: re });
            return matched.to;
        }
        else {
            return cursor;
        }
    },
    moveToStartOfLine: function (_cm, head) {
        return new Pos(head.line, 0);
    },
    moveToLineOrEdgeOfDocument: function (cm, _head, motionArgs) {
        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();
        if (motionArgs.repeatIsExplicit) {
            lineNum = motionArgs.repeat - cm.getOption(&#039;firstLineNumber&#039;);
        }
        return new Pos(lineNum, findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));
    },
    moveToStartOfDisplayLine: function (cm) {
        cm.execCommand(&quot;goLineLeft&quot;);
        return cm.getCursor();
    },
    moveToEndOfDisplayLine: function (cm) {
        cm.execCommand(&quot;goLineRight&quot;);
        var head = cm.getCursor();
        if (head.sticky == &quot;before&quot;)
            head.ch--;
        return head;
    },
    textObjectManipulation: function (cm, head, motionArgs, vim) {
        var mirroredPairs = { &#039;(&#039;: &#039;)&#039;, &#039;)&#039;: &#039;(&#039;,
            &#039;{&#039;: &#039;}&#039;, &#039;}&#039;: &#039;{&#039;,
            &#039;[&#039;: &#039;]&#039;, &#039;]&#039;: &#039;[&#039;,
            &#039;&lt;&#039;: &#039;&gt;&#039;, &#039;&gt;&#039;: &#039;&lt;&#039; };
        var selfPaired = { &#039;\&#039;&#039;: true, &#039;&quot;&#039;: true, &#039;`&#039;: true };
        var character = motionArgs.selectedCharacter;
        if (character == &#039;b&#039;) {
            character = &#039;(&#039;;
        }
        else if (character == &#039;B&#039;) {
            character = &#039;{&#039;;
        }
        var inclusive = !motionArgs.textObjectInner;
        var tmp;
        if (mirroredPairs[character]) {
            tmp = selectCompanionObject(cm, head, character, inclusive);
        }
        else if (selfPaired[character]) {
            tmp = findBeginningAndEnd(cm, head, character, inclusive);
        }
        else if (character === &#039;W&#039;) {
            tmp = expandWordUnderCursor(cm, inclusive, true /** forward */, true /** bigWord */);
        }
        else if (character === &#039;w&#039;) {
            tmp = expandWordUnderCursor(cm, inclusive, true /** forward */, false /** bigWord */);
        }
        else if (character === &#039;p&#039;) {
            tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);
            motionArgs.linewise = true;
            if (vim.visualMode) {
                if (!vim.visualLine) {
                    vim.visualLine = true;
                }
            }
            else {
                var operatorArgs = vim.inputState.operatorArgs;
                if (operatorArgs) {
                    operatorArgs.linewise = true;
                }
                tmp.end.line--;
            }
        }
        else if (character === &#039;t&#039;) {
            tmp = expandTagUnderCursor(cm, head, inclusive);
        }
        else if (character === &#039;s&#039;) {
            var content = cm.getLine(head.line);
            if (head.ch &gt; 0 &amp;&amp; isEndOfSentenceSymbol(content[head.ch])) {
                head.ch -= 1;
            }
            var end = getSentence(cm, head, motionArgs.repeat, 1, inclusive);
            var start = getSentence(cm, head, motionArgs.repeat, -1, inclusive);
            if (isWhiteSpaceString(cm.getLine(start.line)[start.ch])
                &amp;&amp; isWhiteSpaceString(cm.getLine(end.line)[end.ch - 1])) {
                start = { line: start.line, ch: start.ch + 1 };
            }
            tmp = { start: start, end: end };
        }
        else {
            return null;
        }
        if (!cm.state.vim.visualMode) {
            return [tmp.start, tmp.end];
        }
        else {
            return expandSelection(cm, tmp.start, tmp.end);
        }
    },
    repeatLastCharacterSearch: function (cm, head, motionArgs) {
        var lastSearch = vimGlobalState.lastCharacterSearch;
        var repeat = motionArgs.repeat;
        var forward = motionArgs.forward === lastSearch.forward;
        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);
        cm.moveH(-increment, &#039;char&#039;);
        motionArgs.inclusive = forward ? true : false;
        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);
        if (!curEnd) {
            cm.moveH(increment, &#039;char&#039;);
            return head;
        }
        curEnd.ch += increment;
        return curEnd;
    }
};
function defineMotion(name, fn) {
    motions[name] = fn;
}
function fillArray(val, times) {
    var arr = [];
    for (var i = 0; i &lt; times; i++) {
        arr.push(val);
    }
    return arr;
}
var operators = {
    change: function (cm, args, ranges) {
        var finalHead, text;
        var vim = cm.state.vim;
        var anchor = ranges[0].anchor, head = ranges[0].head;
        if (!vim.visualMode) {
            text = cm.getRange(anchor, head);
            var lastState = vim.lastEditInputState || {};
            if (lastState.motion == &quot;moveByWords&quot; &amp;&amp; !isWhiteSpaceString(text)) {
                var match = (/\s+$/).exec(text);
                if (match &amp;&amp; lastState.motionArgs &amp;&amp; lastState.motionArgs.forward) {
                    head = offsetCursor(head, 0, -match[0].length);
                    text = text.slice(0, -match[0].length);
                }
            }
            var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);
            var wasLastLine = cm.firstLine() == cm.lastLine();
            if (head.line &gt; cm.lastLine() &amp;&amp; args.linewise &amp;&amp; !wasLastLine) {
                cm.replaceRange(&#039;&#039;, prevLineEnd, head);
            }
            else {
                cm.replaceRange(&#039;&#039;, anchor, head);
            }
            if (args.linewise) {
                if (!wasLastLine) {
                    cm.setCursor(prevLineEnd);
                    CodeMirror.commands.newlineAndIndent(cm);
                }
                anchor.ch = Number.MAX_VALUE;
            }
            finalHead = anchor;
        }
        else if (args.fullLine) {
            head.ch = Number.MAX_VALUE;
            head.line--;
            cm.setSelection(anchor, head);
            text = cm.getSelection();
            cm.replaceSelection(&quot;&quot;);
            finalHead = anchor;
        }
        else {
            text = cm.getSelection();
            var replacement = fillArray(&#039;&#039;, ranges.length);
            cm.replaceSelections(replacement);
            finalHead = cursorMin(ranges[0].head, ranges[0].anchor);
        }
        vimGlobalState.registerController.pushText(args.registerName, &#039;change&#039;, text, args.linewise, ranges.length &gt; 1);
        actions.enterInsertMode(cm, { head: finalHead }, cm.state.vim);
    },
    &#039;delete&#039;: function (cm, args, ranges) {
        var finalHead, text;
        var vim = cm.state.vim;
        if (!vim.visualBlock) {
            var anchor = ranges[0].anchor, head = ranges[0].head;
            if (args.linewise &amp;&amp;
                head.line != cm.firstLine() &amp;&amp;
                anchor.line == cm.lastLine() &amp;&amp;
                anchor.line == head.line - 1) {
                if (anchor.line == cm.firstLine()) {
                    anchor.ch = 0;
                }
                else {
                    anchor = new Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));
                }
            }
            text = cm.getRange(anchor, head);
            cm.replaceRange(&#039;&#039;, anchor, head);
            finalHead = anchor;
            if (args.linewise) {
                finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);
            }
        }
        else {
            text = cm.getSelection();
            var replacement = fillArray(&#039;&#039;, ranges.length);
            cm.replaceSelections(replacement);
            finalHead = cursorMin(ranges[0].head, ranges[0].anchor);
        }
        vimGlobalState.registerController.pushText(args.registerName, &#039;delete&#039;, text, args.linewise, vim.visualBlock);
        return clipCursorToContent(cm, finalHead);
    },
    indent: function (cm, args, ranges) {
        var vim = cm.state.vim;
        if (cm.indentMore) {
            var repeat = (vim.visualMode) ? args.repeat : 1;
            for (var j = 0; j &lt; repeat; j++) {
                if (args.indentRight)
                    cm.indentMore();
                else
                    cm.indentLess();
            }
        }
        else {
            var startLine = ranges[0].anchor.line;
            var endLine = vim.visualBlock ?
                ranges[ranges.length - 1].anchor.line :
                ranges[0].head.line;
            var repeat = (vim.visualMode) ? args.repeat : 1;
            if (args.linewise) {
                endLine--;
            }
            for (var i = startLine; i &lt;= endLine; i++) {
                for (var j = 0; j &lt; repeat; j++) {
                    cm.indentLine(i, args.indentRight);
                }
            }
        }
        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);
    },
    indentAuto: function (cm, _args, ranges) {
        if (ranges.length &gt; 1) { // ace_patch
            cm.setSelection(ranges[0].anchor, ranges[ranges.length - 1].head);
        }
        cm.execCommand(&quot;indentAuto&quot;);
        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);
    },
    changeCase: function (cm, args, ranges, oldAnchor, newHead) {
        var selections = cm.getSelections();
        var swapped = [];
        var toLower = args.toLower;
        for (var j = 0; j &lt; selections.length; j++) {
            var toSwap = selections[j];
            var text = &#039;&#039;;
            if (toLower === true) {
                text = toSwap.toLowerCase();
            }
            else if (toLower === false) {
                text = toSwap.toUpperCase();
            }
            else {
                for (var i = 0; i &lt; toSwap.length; i++) {
                    var character = toSwap.charAt(i);
                    text += isUpperCase(character) ? character.toLowerCase() :
                        character.toUpperCase();
                }
            }
            swapped.push(text);
        }
        cm.replaceSelections(swapped);
        if (args.shouldMoveCursor) {
            return newHead;
        }
        else if (!cm.state.vim.visualMode &amp;&amp; args.linewise &amp;&amp; ranges[0].anchor.line + 1 == ranges[0].head.line) {
            return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);
        }
        else if (args.linewise) {
            return oldAnchor;
        }
        else {
            return cursorMin(ranges[0].anchor, ranges[0].head);
        }
    },
    yank: function (cm, args, ranges, oldAnchor) {
        var vim = cm.state.vim;
        var text = cm.getSelection();
        var endPos = vim.visualMode
            ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)
            : oldAnchor;
        vimGlobalState.registerController.pushText(args.registerName, &#039;yank&#039;, text, args.linewise, vim.visualBlock);
        return endPos;
    }
};
function defineOperator(name, fn) {
    operators[name] = fn;
}
var actions = {
    jumpListWalk: function (cm, actionArgs, vim) {
        if (vim.visualMode) {
            return;
        }
        var repeat = actionArgs.repeat;
        var forward = actionArgs.forward;
        var jumpList = vimGlobalState.jumpList;
        var mark = jumpList.move(cm, forward ? repeat : -repeat);
        var markPos = mark ? mark.find() : undefined;
        markPos = markPos ? markPos : cm.getCursor();
        cm.setCursor(markPos);
        cm.ace.curOp.command.scrollIntoView = &quot;center-animate&quot;; // ace_patch
    },
    scroll: function (cm, actionArgs, vim) {
        if (vim.visualMode) {
            return;
        }
        var repeat = actionArgs.repeat || 1;
        var lineHeight = cm.defaultTextHeight();
        var top = cm.getScrollInfo().top;
        var delta = lineHeight * repeat;
        var newPos = actionArgs.forward ? top + delta : top - delta;
        var cursor = copyCursor(cm.getCursor());
        var cursorCoords = cm.charCoords(cursor, &#039;local&#039;);
        if (actionArgs.forward) {
            if (newPos &gt; cursorCoords.top) {
                cursor.line += (newPos - cursorCoords.top) / lineHeight;
                cursor.line = Math.ceil(cursor.line);
                cm.setCursor(cursor);
                cursorCoords = cm.charCoords(cursor, &#039;local&#039;);
                cm.scrollTo(null, cursorCoords.top);
            }
            else {
                cm.scrollTo(null, newPos);
            }
        }
        else {
            var newBottom = newPos + cm.getScrollInfo().clientHeight;
            if (newBottom &lt; cursorCoords.bottom) {
                cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;
                cursor.line = Math.floor(cursor.line);
                cm.setCursor(cursor);
                cursorCoords = cm.charCoords(cursor, &#039;local&#039;);
                cm.scrollTo(null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);
            }
            else {
                cm.scrollTo(null, newPos);
            }
        }
    },
    scrollToCursor: function (cm, actionArgs) {
        var lineNum = cm.getCursor().line;
        var charCoords = cm.charCoords(new Pos(lineNum, 0), &#039;local&#039;);
        var height = cm.getScrollInfo().clientHeight;
        var y = charCoords.top;
        switch (actionArgs.position) {
            case &#039;center&#039;:
                y = charCoords.bottom - height / 2;
                break;
            case &#039;bottom&#039;:
                var lineLastCharPos = new Pos(lineNum, cm.getLine(lineNum).length - 1);
                var lineLastCharCoords = cm.charCoords(lineLastCharPos, &#039;local&#039;);
                var lineHeight = lineLastCharCoords.bottom - y;
                y = y - height + lineHeight;
                break;
        }
        cm.scrollTo(null, y);
    },
    replayMacro: function (cm, actionArgs, vim) {
        var registerName = actionArgs.selectedCharacter;
        var repeat = actionArgs.repeat;
        var macroModeState = vimGlobalState.macroModeState;
        if (registerName == &#039;@&#039;) {
            registerName = macroModeState.latestRegister;
        }
        else {
            macroModeState.latestRegister = registerName;
        }
        while (repeat--) {
            executeMacroRegister(cm, vim, macroModeState, registerName);
        }
    },
    enterMacroRecordMode: function (cm, actionArgs) {
        var macroModeState = vimGlobalState.macroModeState;
        var registerName = actionArgs.selectedCharacter;
        if (vimGlobalState.registerController.isValidRegister(registerName)) {
            macroModeState.enterMacroRecordMode(cm, registerName);
        }
    },
    toggleOverwrite: function (cm) {
        if (!cm.state.overwrite) {
            cm.toggleOverwrite(true);
            cm.setOption(&#039;keyMap&#039;, &#039;vim-replace&#039;);
            CodeMirror.signal(cm, &quot;vim-mode-change&quot;, { mode: &quot;replace&quot; });
        }
        else {
            cm.toggleOverwrite(false);
            cm.setOption(&#039;keyMap&#039;, &#039;vim-insert&#039;);
            CodeMirror.signal(cm, &quot;vim-mode-change&quot;, { mode: &quot;insert&quot; });
        }
    },
    enterInsertMode: function (cm, actionArgs, vim) {
        if (cm.getOption(&#039;readOnly&#039;)) {
            return;
        }
        vim.insertMode = true;
        vim.insertModeRepeat = actionArgs &amp;&amp; actionArgs.repeat || 1;
        var insertAt = (actionArgs) ? actionArgs.insertAt : null;
        var sel = vim.sel;
        var head = actionArgs.head || cm.getCursor(&#039;head&#039;);
        var height = cm.listSelections().length;
        if (insertAt == &#039;eol&#039;) {
            head = new Pos(head.line, lineLength(cm, head.line));
        }
        else if (insertAt == &#039;bol&#039;) {
            head = new Pos(head.line, 0);
        }
        else if (insertAt == &#039;charAfter&#039;) {
            var newPosition = updateSelectionForSurrogateCharacters(cm, head, offsetCursor(head, 0, 1));
            head = newPosition.end;
        }
        else if (insertAt == &#039;firstNonBlank&#039;) {
            var newPosition = updateSelectionForSurrogateCharacters(cm, head, motions.moveToFirstNonWhiteSpaceCharacter(cm, head));
            head = newPosition.end;
        }
        else if (insertAt == &#039;startOfSelectedArea&#039;) {
            if (!vim.visualMode)
                return;
            if (!vim.visualBlock) {
                if (sel.head.line &lt; sel.anchor.line) {
                    head = sel.head;
                }
                else {
                    head = new Pos(sel.anchor.line, 0);
                }
            }
            else {
                head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.min(sel.head.ch, sel.anchor.ch));
                height = Math.abs(sel.head.line - sel.anchor.line) + 1;
            }
        }
        else if (insertAt == &#039;endOfSelectedArea&#039;) {
            if (!vim.visualMode)
                return;
            if (!vim.visualBlock) {
                if (sel.head.line &gt;= sel.anchor.line) {
                    head = offsetCursor(sel.head, 0, 1);
                }
                else {
                    head = new Pos(sel.anchor.line, 0);
                }
            }
            else {
                head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.max(sel.head.ch, sel.anchor.ch) + 1);
                height = Math.abs(sel.head.line - sel.anchor.line) + 1;
            }
        }
        else if (insertAt == &#039;inplace&#039;) {
            if (vim.visualMode) {
                return;
            }
        }
        else if (insertAt == &#039;lastEdit&#039;) {
            head = getLastEditPos(cm) || head;
        }
        cm.setOption(&#039;disableInput&#039;, false);
        if (actionArgs &amp;&amp; actionArgs.replace) {
            cm.toggleOverwrite(true);
            cm.setOption(&#039;keyMap&#039;, &#039;vim-replace&#039;);
            CodeMirror.signal(cm, &quot;vim-mode-change&quot;, { mode: &quot;replace&quot; });
        }
        else {
            cm.toggleOverwrite(false);
            cm.setOption(&#039;keyMap&#039;, &#039;vim-insert&#039;);
            CodeMirror.signal(cm, &quot;vim-mode-change&quot;, { mode: &quot;insert&quot; });
        }
        if (!vimGlobalState.macroModeState.isPlaying) {
            cm.on(&#039;change&#039;, onChange);
            CodeMirror.on(cm.getInputField(), &#039;keydown&#039;, onKeyEventTargetKeyDown);
        }
        if (vim.visualMode) {
            exitVisualMode(cm);
        }
        selectForInsert(cm, head, height);
    },
    toggleVisualMode: function (cm, actionArgs, vim) {
        var repeat = actionArgs.repeat;
        var anchor = cm.getCursor();
        var head;
        if (!vim.visualMode) {
            vim.visualMode = true;
            vim.visualLine = !!actionArgs.linewise;
            vim.visualBlock = !!actionArgs.blockwise;
            head = clipCursorToContent(cm, new Pos(anchor.line, anchor.ch + repeat - 1));
            var newPosition = updateSelectionForSurrogateCharacters(cm, anchor, head);
            vim.sel = {
                anchor: newPosition.start,
                head: newPosition.end
            };
            CodeMirror.signal(cm, &quot;vim-mode-change&quot;, { mode: &quot;visual&quot;, subMode: vim.visualLine ? &quot;linewise&quot; : vim.visualBlock ? &quot;blockwise&quot; : &quot;&quot; });
            updateCmSelection(cm);
            updateMark(cm, vim, &#039;&lt;&#039;, cursorMin(anchor, head));
            updateMark(cm, vim, &#039;&gt;&#039;, cursorMax(anchor, head));
        }
        else if (vim.visualLine ^ actionArgs.linewise ||
            vim.visualBlock ^ actionArgs.blockwise) {
            vim.visualLine = !!actionArgs.linewise;
            vim.visualBlock = !!actionArgs.blockwise;
            CodeMirror.signal(cm, &quot;vim-mode-change&quot;, { mode: &quot;visual&quot;, subMode: vim.visualLine ? &quot;linewise&quot; : vim.visualBlock ? &quot;blockwise&quot; : &quot;&quot; });
            updateCmSelection(cm);
        }
        else {
            exitVisualMode(cm);
        }
    },
    reselectLastSelection: function (cm, _actionArgs, vim) {
        var lastSelection = vim.lastSelection;
        if (vim.visualMode) {
            updateLastSelection(cm, vim);
        }
        if (lastSelection) {
            var anchor = lastSelection.anchorMark.find();
            var head = lastSelection.headMark.find();
            if (!anchor || !head) {
                return;
            }
            vim.sel = {
                anchor: anchor,
                head: head
            };
            vim.visualMode = true;
            vim.visualLine = lastSelection.visualLine;
            vim.visualBlock = lastSelection.visualBlock;
            updateCmSelection(cm);
            updateMark(cm, vim, &#039;&lt;&#039;, cursorMin(anchor, head));
            updateMark(cm, vim, &#039;&gt;&#039;, cursorMax(anchor, head));
            CodeMirror.signal(cm, &#039;vim-mode-change&#039;, {
                mode: &#039;visual&#039;,
                subMode: vim.visualLine ? &#039;linewise&#039; :
                    vim.visualBlock ? &#039;blockwise&#039; : &#039;&#039;
            });
        }
    },
    joinLines: function (cm, actionArgs, vim) {
        var curStart, curEnd;
        if (vim.visualMode) {
            curStart = cm.getCursor(&#039;anchor&#039;);
            curEnd = cm.getCursor(&#039;head&#039;);
            if (cursorIsBefore(curEnd, curStart)) {
                var tmp = curEnd;
                curEnd = curStart;
                curStart = tmp;
            }
            curEnd.ch = lineLength(cm, curEnd.line) - 1;
        }
        else {
            var repeat = Math.max(actionArgs.repeat, 2);
            curStart = cm.getCursor();
            curEnd = clipCursorToContent(cm, new Pos(curStart.line + repeat - 1, Infinity));
        }
        var finalCh = 0;
        for (var i = curStart.line; i &lt; curEnd.line; i++) {
            finalCh = lineLength(cm, curStart.line);
            var text = &#039;&#039;;
            var nextStartCh = 0;
            if (!actionArgs.keepSpaces) {
                var nextLine = cm.getLine(curStart.line + 1);
                nextStartCh = nextLine.search(/\S/);
                if (nextStartCh == -1) {
                    nextStartCh = nextLine.length;
                }
                else {
                    text = &quot; &quot;;
                }
            }
            cm.replaceRange(text, new Pos(curStart.line, finalCh), new Pos(curStart.line + 1, nextStartCh));
        }
        var curFinalPos = clipCursorToContent(cm, new Pos(curStart.line, finalCh));
        if (vim.visualMode) {
            exitVisualMode(cm, false);
        }
        cm.setCursor(curFinalPos);
    },
    newLineAndEnterInsertMode: function (cm, actionArgs, vim) {
        vim.insertMode = true;
        var insertAt = copyCursor(cm.getCursor());
        if (insertAt.line === cm.firstLine() &amp;&amp; !actionArgs.after) {
            cm.replaceRange(&#039;\n&#039;, new Pos(cm.firstLine(), 0));
            cm.setCursor(cm.firstLine(), 0);
        }
        else {
            insertAt.line = (actionArgs.after) ? insertAt.line :
                insertAt.line - 1;
            insertAt.ch = lineLength(cm, insertAt.line);
            cm.setCursor(insertAt);
            var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||
                CodeMirror.commands.newlineAndIndent;
            newlineFn(cm);
        }
        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);
    },
    paste: function (cm, actionArgs, vim) {
        var _this = this;
        var register = vimGlobalState.registerController.getRegister(actionArgs.registerName);
        if (actionArgs.registerName === &#039;+&#039;) {
            navigator.clipboard.readText().then(function (value) {
                _this.continuePaste(cm, actionArgs, vim, value, register);
            });
        }
        else {
            var text = register.toString();
            this.continuePaste(cm, actionArgs, vim, text, register);
        }
    },
    continuePaste: function (cm, actionArgs, vim, text, register) {
        var cur = copyCursor(cm.getCursor());
        if (!text) {
            return;
        }
        if (actionArgs.matchIndent) {
            var tabSize = cm.getOption(&quot;tabSize&quot;);
            var whitespaceLength = function (str) {
                var tabs = (str.split(&quot;\t&quot;).length - 1);
                var spaces = (str.split(&quot; &quot;).length - 1);
                return tabs * tabSize + spaces * 1;
            };
            var currentLine = cm.getLine(cm.getCursor().line);
            var indent = whitespaceLength(currentLine.match(/^\s*/)[0]);
            var chompedText = text.replace(/\n$/, &#039;&#039;);
            var wasChomped = text !== chompedText;
            var firstIndent = whitespaceLength(text.match(/^\s*/)[0]);
            var text = chompedText.replace(/^\s*/gm, function (wspace) {
                var newIndent = indent + (whitespaceLength(wspace) - firstIndent);
                if (newIndent &lt; 0) {
                    return &quot;&quot;;
                }
                else if (cm.getOption(&quot;indentWithTabs&quot;)) {
                    var quotient = Math.floor(newIndent / tabSize);
                    return Array(quotient + 1).join(&#039;\t&#039;);
                }
                else {
                    return Array(newIndent + 1).join(&#039; &#039;);
                }
            });
            text += wasChomped ? &quot;\n&quot; : &quot;&quot;;
        }
        if (actionArgs.repeat &gt; 1) {
            var text = Array(actionArgs.repeat + 1).join(text);
        }
        var linewise = register.linewise;
        var blockwise = register.blockwise;
        if (blockwise) {
            text = text.split(&#039;\n&#039;);
            if (linewise) {
                text.pop();
            }
            for (var i = 0; i &lt; text.length; i++) {
                text[i] = (text[i] == &#039;&#039;) ? &#039; &#039; : text[i];
            }
            cur.ch += actionArgs.after ? 1 : 0;
            cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);
        }
        else if (linewise) {
            if (vim.visualMode) {
                text = vim.visualLine ? text.slice(0, -1) : &#039;\n&#039; + text.slice(0, text.length - 1) + &#039;\n&#039;;
            }
            else if (actionArgs.after) {
                text = &#039;\n&#039; + text.slice(0, text.length - 1);
                cur.ch = lineLength(cm, cur.line);
            }
            else {
                cur.ch = 0;
            }
        }
        else {
            cur.ch += actionArgs.after ? 1 : 0;
        }
        var curPosFinal;
        var idx;
        if (vim.visualMode) {
            vim.lastPastedText = text;
            var lastSelectionCurEnd;
            var selectedArea = getSelectedAreaRange(cm, vim);
            var selectionStart = selectedArea[0];
            var selectionEnd = selectedArea[1];
            var selectedText = cm.getSelection();
            var selections = cm.listSelections();
            var emptyStrings = new Array(selections.length).join(&#039;1&#039;).split(&#039;1&#039;);
            if (vim.lastSelection) {
                lastSelectionCurEnd = vim.lastSelection.headMark.find();
            }
            vimGlobalState.registerController.unnamedRegister.setText(selectedText);
            if (blockwise) {
                cm.replaceSelections(emptyStrings);
                selectionEnd = new Pos(selectionStart.line + text.length - 1, selectionStart.ch);
                cm.setCursor(selectionStart);
                selectBlock(cm, selectionEnd);
                cm.replaceSelections(text);
                curPosFinal = selectionStart;
            }
            else if (vim.visualBlock) {
                cm.replaceSelections(emptyStrings);
                cm.setCursor(selectionStart);
                cm.replaceRange(text, selectionStart, selectionStart);
                curPosFinal = selectionStart;
            }
            else {
                cm.replaceRange(text, selectionStart, selectionEnd);
                curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);
            }
            if (lastSelectionCurEnd) {
                vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);
            }
            if (linewise) {
                curPosFinal.ch = 0;
            }
        }
        else {
            if (blockwise) {
                cm.setCursor(cur);
                for (var i = 0; i &lt; text.length; i++) {
                    var line = cur.line + i;
                    if (line &gt; cm.lastLine()) {
                        cm.replaceRange(&#039;\n&#039;, new Pos(line, 0));
                    }
                    var lastCh = lineLength(cm, line);
                    if (lastCh &lt; cur.ch) {
                        extendLineToColumn(cm, line, cur.ch);
                    }
                }
                cm.setCursor(cur);
                selectBlock(cm, new Pos(cur.line + text.length - 1, cur.ch));
                cm.replaceSelections(text);
                curPosFinal = cur;
            }
            else {
                cm.replaceRange(text, cur);
                if (linewise &amp;&amp; actionArgs.after) {
                    curPosFinal = new Pos(cur.line + 1, findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));
                }
                else if (linewise &amp;&amp; !actionArgs.after) {
                    curPosFinal = new Pos(cur.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));
                }
                else if (!linewise &amp;&amp; actionArgs.after) {
                    idx = cm.indexFromPos(cur);
                    curPosFinal = cm.posFromIndex(idx + text.length - 1);
                }
                else {
                    idx = cm.indexFromPos(cur);
                    curPosFinal = cm.posFromIndex(idx + text.length);
                }
            }
        }
        if (vim.visualMode) {
            exitVisualMode(cm, false);
        }
        cm.setCursor(curPosFinal);
    },
    undo: function (cm, actionArgs) {
        cm.operation(function () {
            repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();
            cm.setCursor(clipCursorToContent(cm, cm.getCursor(&#039;start&#039;)));
        });
    },
    redo: function (cm, actionArgs) {
        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();
    },
    setRegister: function (_cm, actionArgs, vim) {
        vim.inputState.registerName = actionArgs.selectedCharacter;
    },
    setMark: function (cm, actionArgs, vim) {
        var markName = actionArgs.selectedCharacter;
        updateMark(cm, vim, markName, cm.getCursor());
    },
    replace: function (cm, actionArgs, vim) {
        var replaceWith = actionArgs.selectedCharacter;
        var curStart = cm.getCursor();
        var replaceTo;
        var curEnd;
        var selections = cm.listSelections();
        if (vim.visualMode) {
            curStart = cm.getCursor(&#039;start&#039;);
            curEnd = cm.getCursor(&#039;end&#039;);
        }
        else {
            var line = cm.getLine(curStart.line);
            replaceTo = curStart.ch + actionArgs.repeat;
            if (replaceTo &gt; line.length) {
                replaceTo = line.length;
            }
            curEnd = new Pos(curStart.line, replaceTo);
        }
        var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);
        curStart = newPositions.start;
        curEnd = newPositions.end;
        if (replaceWith == &#039;\n&#039;) {
            if (!vim.visualMode)
                cm.replaceRange(&#039;&#039;, curStart, curEnd);
            (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);
        }
        else {
            var replaceWithStr = cm.getRange(curStart, curEnd);
            replaceWithStr = replaceWithStr.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, replaceWith);
            replaceWithStr = replaceWithStr.replace(/[^\n]/g, replaceWith);
            if (vim.visualBlock) {
                var spaces = new Array(cm.getOption(&quot;tabSize&quot;) + 1).join(&#039; &#039;);
                replaceWithStr = cm.getSelection();
                replaceWithStr = replaceWithStr.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, replaceWith);
                replaceWithStr = replaceWithStr.replace(/\t/g, spaces).replace(/[^\n]/g, replaceWith).split(&#039;\n&#039;);
                cm.replaceSelections(replaceWithStr);
            }
            else {
                cm.replaceRange(replaceWithStr, curStart, curEnd);
            }
            if (vim.visualMode) {
                curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?
                    selections[0].anchor : selections[0].head;
                cm.setCursor(curStart);
                exitVisualMode(cm, false);
            }
            else {
                cm.setCursor(offsetCursor(curEnd, 0, -1));
            }
        }
    },
    incrementNumberToken: function (cm, actionArgs) {
        var cur = cm.getCursor();
        var lineStr = cm.getLine(cur.line);
        var re = /(-?)(?:(0x)([\da-f]+)|(0b|0|)(\d+))/gi;
        var match;
        var start;
        var end;
        var numberStr;
        while ((match = re.exec(lineStr)) !== null) {
            start = match.index;
            end = start + match[0].length;
            if (cur.ch &lt; end)
                break;
        }
        if (!actionArgs.backtrack &amp;&amp; (end &lt;= cur.ch))
            return;
        if (match) {
            var baseStr = match[2] || match[4];
            var digits = match[3] || match[5];
            var increment = actionArgs.increase ? 1 : -1;
            var base = { &#039;0b&#039;: 2, &#039;0&#039;: 8, &#039;&#039;: 10, &#039;0x&#039;: 16 }[baseStr.toLowerCase()];
            var number = parseInt(match[1] + digits, base) + (increment * actionArgs.repeat);
            numberStr = number.toString(base);
            var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join(&#039;0&#039;) : &#039;&#039;;
            if (numberStr.charAt(0) === &#039;-&#039;) {
                numberStr = &#039;-&#039; + baseStr + zeroPadding + numberStr.substr(1);
            }
            else {
                numberStr = baseStr + zeroPadding + numberStr;
            }
            var from = new Pos(cur.line, start);
            var to = new Pos(cur.line, end);
            cm.replaceRange(numberStr, from, to);
        }
        else {
            return;
        }
        cm.setCursor(new Pos(cur.line, start + numberStr.length - 1));
    },
    repeatLastEdit: function (cm, actionArgs, vim) {
        var lastEditInputState = vim.lastEditInputState;
        if (!lastEditInputState) {
            return;
        }
        var repeat = actionArgs.repeat;
        if (repeat &amp;&amp; actionArgs.repeatIsExplicit) {
            vim.lastEditInputState.repeatOverride = repeat;
        }
        else {
            repeat = vim.lastEditInputState.repeatOverride || repeat;
        }
        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);
    },
    indent: function (cm, actionArgs) {
        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);
    },
    exitInsertMode: exitInsertMode
};
function defineAction(name, fn) {
    actions[name] = fn;
}
function clipCursorToContent(cm, cur, oldCur) {
    var vim = cm.state.vim;
    var includeLineBreak = vim.insertMode || vim.visualMode;
    var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine());
    var text = cm.getLine(line);
    var maxCh = text.length - 1 + !!includeLineBreak;
    var ch = Math.min(Math.max(0, cur.ch), maxCh);
    var charCode = text.charCodeAt(ch);
    if (0xDC00 &lt; charCode &amp;&amp; charCode &lt; 0xDFFF) {
        var direction = 1;
        if (oldCur &amp;&amp; oldCur.line == line) {
            if (oldCur.ch &gt; ch) {
                direction = -1;
            }
        }
        ch += direction;
        if (ch &gt; maxCh)
            ch -= 2;
    }
    return new Pos(line, ch);
}
function copyArgs(args) {
    var ret = {};
    for (var prop in args) {
        if (args.hasOwnProperty(prop)) {
            ret[prop] = args[prop];
        }
    }
    return ret;
}
function offsetCursor(cur, offsetLine, offsetCh) {
    if (typeof offsetLine === &#039;object&#039;) {
        offsetCh = offsetLine.ch;
        offsetLine = offsetLine.line;
    }
    return new Pos(cur.line + offsetLine, cur.ch + offsetCh);
}
function commandMatches(keys, keyMap, context, inputState) {
    var match, partial = [], full = [];
    for (var i = 0; i &lt; keyMap.length; i++) {
        var command = keyMap[i];
        if (context == &#039;insert&#039; &amp;&amp; command.context != &#039;insert&#039; ||
            command.context &amp;&amp; command.context != context ||
            inputState.operator &amp;&amp; command.type == &#039;action&#039; ||
            !(match = commandMatch(keys, command.keys))) {
            continue;
        }
        if (match == &#039;partial&#039;) {
            partial.push(command);
        }
        if (match == &#039;full&#039;) {
            full.push(command);
        }
    }
    return {
        partial: partial.length &amp;&amp; partial,
        full: full.length &amp;&amp; full
    };
}
function commandMatch(pressed, mapped) {
    if (mapped.slice(-11) == &#039;&lt;character&gt;&#039;) {
        var prefixLen = mapped.length - 11;
        var pressedPrefix = pressed.slice(0, prefixLen);
        var mappedPrefix = mapped.slice(0, prefixLen);
        return pressedPrefix == mappedPrefix &amp;&amp; pressed.length &gt; prefixLen ? &#039;full&#039; :
            mappedPrefix.indexOf(pressedPrefix) == 0 ? &#039;partial&#039; : false;
    }
    else {
        return pressed == mapped ? &#039;full&#039; :
            mapped.indexOf(pressed) == 0 ? &#039;partial&#039; : false;
    }
}
function lastChar(keys) {
    var match = /^.*(&lt;[^&gt;]+&gt;)$/.exec(keys);
    var selectedCharacter = match ? match[1] : keys.slice(-1);
    if (selectedCharacter.length &gt; 1) {
        switch (selectedCharacter) {
            case &#039;&lt;CR&gt;&#039;:
                selectedCharacter = &#039;\n&#039;;
                break;
            case &#039;&lt;Space&gt;&#039;:
                selectedCharacter = &#039; &#039;;
                break;
            default:
                selectedCharacter = &#039;&#039;;
                break;
        }
    }
    return selectedCharacter;
}
function repeatFn(cm, fn, repeat) {
    return function () {
        for (var i = 0; i &lt; repeat; i++) {
            fn(cm);
        }
    };
}
function copyCursor(cur) {
    return new Pos(cur.line, cur.ch);
}
function cursorEqual(cur1, cur2) {
    return cur1.ch == cur2.ch &amp;&amp; cur1.line == cur2.line;
}
function cursorIsBefore(cur1, cur2) {
    if (cur1.line &lt; cur2.line) {
        return true;
    }
    if (cur1.line == cur2.line &amp;&amp; cur1.ch &lt; cur2.ch) {
        return true;
    }
    return false;
}
function cursorMin(cur1, cur2) {
    if (arguments.length &gt; 2) {
        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));
    }
    return cursorIsBefore(cur1, cur2) ? cur1 : cur2;
}
function cursorMax(cur1, cur2) {
    if (arguments.length &gt; 2) {
        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));
    }
    return cursorIsBefore(cur1, cur2) ? cur2 : cur1;
}
function cursorIsBetween(cur1, cur2, cur3) {
    var cur1before2 = cursorIsBefore(cur1, cur2);
    var cur2before3 = cursorIsBefore(cur2, cur3);
    return cur1before2 &amp;&amp; cur2before3;
}
function lineLength(cm, lineNum) {
    return cm.getLine(lineNum).length;
}
function trim(s) {
    if (s.trim) {
        return s.trim();
    }
    return s.replace(/^\s+|\s+$/g, &#039;&#039;);
}
function escapeRegex(s) {
    return s.replace(/([.?*+$\[\]\/\\(){}|\-])/g, &#039;\\$1&#039;);
}
function extendLineToColumn(cm, lineNum, column) {
    var endCh = lineLength(cm, lineNum);
    var spaces = new Array(column - endCh + 1).join(&#039; &#039;);
    cm.setCursor(new Pos(lineNum, endCh));
    cm.replaceRange(spaces, cm.getCursor());
}
function selectBlock(cm, selectionEnd) {
    var selections = [], ranges = cm.listSelections();
    var head = copyCursor(cm.clipPos(selectionEnd));
    var isClipped = !cursorEqual(selectionEnd, head);
    var curHead = cm.getCursor(&#039;head&#039;);
    var primIndex = getIndex(ranges, curHead);
    var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);
    var max = ranges.length - 1;
    var index = max - primIndex &gt; primIndex ? max : 0;
    var base = ranges[index].anchor;
    var firstLine = Math.min(base.line, head.line);
    var lastLine = Math.max(base.line, head.line);
    var baseCh = base.ch, headCh = head.ch;
    var dir = ranges[index].head.ch - baseCh;
    var newDir = headCh - baseCh;
    if (dir &gt; 0 &amp;&amp; newDir &lt;= 0) {
        baseCh++;
        if (!isClipped) {
            headCh--;
        }
    }
    else if (dir &lt; 0 &amp;&amp; newDir &gt;= 0) {
        baseCh--;
        if (!wasClipped) {
            headCh++;
        }
    }
    else if (dir &lt; 0 &amp;&amp; newDir == -1) {
        baseCh--;
        headCh++;
    }
    for (var line = firstLine; line &lt;= lastLine; line++) {
        var range = { anchor: new Pos(line, baseCh), head: new Pos(line, headCh) };
        selections.push(range);
    }
    cm.setSelections(selections);
    selectionEnd.ch = headCh;
    base.ch = baseCh;
    return base;
}
function selectForInsert(cm, head, height) {
    var sel = [];
    for (var i = 0; i &lt; height; i++) {
        var lineHead = offsetCursor(head, i, 0);
        sel.push({ anchor: lineHead, head: lineHead });
    }
    cm.setSelections(sel, 0);
}
function getIndex(ranges, cursor, end) {
    for (var i = 0; i &lt; ranges.length; i++) {
        var atAnchor = end != &#039;head&#039; &amp;&amp; cursorEqual(ranges[i].anchor, cursor);
        var atHead = end != &#039;anchor&#039; &amp;&amp; cursorEqual(ranges[i].head, cursor);
        if (atAnchor || atHead) {
            return i;
        }
    }
    return -1;
}
function getSelectedAreaRange(cm, vim) {
    var lastSelection = vim.lastSelection;
    var getCurrentSelectedAreaRange = function () {
        var selections = cm.listSelections();
        var start = selections[0];
        var end = selections[selections.length - 1];
        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;
        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;
        return [selectionStart, selectionEnd];
    };
    var getLastSelectedAreaRange = function () {
        var selectionStart = cm.getCursor();
        var selectionEnd = cm.getCursor();
        var block = lastSelection.visualBlock;
        if (block) {
            var width = block.width;
            var height = block.height;
            selectionEnd = new Pos(selectionStart.line + height, selectionStart.ch + width);
            var selections = [];
            for (var i = selectionStart.line; i &lt; selectionEnd.line; i++) {
                var anchor = new Pos(i, selectionStart.ch);
                var head = new Pos(i, selectionEnd.ch);
                var range = { anchor: anchor, head: head };
                selections.push(range);
            }
            cm.setSelections(selections);
        }
        else {
            var start = lastSelection.anchorMark.find();
            var end = lastSelection.headMark.find();
            var line = end.line - start.line;
            var ch = end.ch - start.ch;
            selectionEnd = { line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch };
            if (lastSelection.visualLine) {
                selectionStart = new Pos(selectionStart.line, 0);
                selectionEnd = new Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));
            }
            cm.setSelection(selectionStart, selectionEnd);
        }
        return [selectionStart, selectionEnd];
    };
    if (!vim.visualMode) {
        return getLastSelectedAreaRange();
    }
    else {
        return getCurrentSelectedAreaRange();
    }
}
function updateLastSelection(cm, vim) {
    var anchor = vim.sel.anchor;
    var head = vim.sel.head;
    if (vim.lastPastedText) {
        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);
        vim.lastPastedText = null;
    }
    vim.lastSelection = { &#039;anchorMark&#039;: cm.setBookmark(anchor),
        &#039;headMark&#039;: cm.setBookmark(head),
        &#039;anchor&#039;: copyCursor(anchor),
        &#039;head&#039;: copyCursor(head),
        &#039;visualMode&#039;: vim.visualMode,
        &#039;visualLine&#039;: vim.visualLine,
        &#039;visualBlock&#039;: vim.visualBlock };
}
function expandSelection(cm, start, end) {
    var sel = cm.state.vim.sel;
    var head = sel.head;
    var anchor = sel.anchor;
    var tmp;
    if (cursorIsBefore(end, start)) {
        tmp = end;
        end = start;
        start = tmp;
    }
    if (cursorIsBefore(head, anchor)) {
        head = cursorMin(start, head);
        anchor = cursorMax(anchor, end);
    }
    else {
        anchor = cursorMin(start, anchor);
        head = cursorMax(head, end);
        head = offsetCursor(head, 0, -1);
        if (head.ch == -1 &amp;&amp; head.line != cm.firstLine()) {
            head = new Pos(head.line - 1, lineLength(cm, head.line - 1));
        }
    }
    return [anchor, head];
}
function updateCmSelection(cm, sel, mode) {
    var vim = cm.state.vim;
    sel = sel || vim.sel;
    var mode = mode ||
        vim.visualLine ? &#039;line&#039; : vim.visualBlock ? &#039;block&#039; : &#039;char&#039;;
    var cmSel = makeCmSelection(cm, sel, mode);
    cm.setSelections(cmSel.ranges, cmSel.primary);
}
function makeCmSelection(cm, sel, mode, exclusive) {
    var head = copyCursor(sel.head);
    var anchor = copyCursor(sel.anchor);
    if (mode == &#039;char&#039;) {
        var headOffset = !exclusive &amp;&amp; !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;
        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;
        head = offsetCursor(sel.head, 0, headOffset);
        anchor = offsetCursor(sel.anchor, 0, anchorOffset);
        return {
            ranges: [{ anchor: anchor, head: head }],
            primary: 0
        };
    }
    else if (mode == &#039;line&#039;) {
        if (!cursorIsBefore(sel.head, sel.anchor)) {
            anchor.ch = 0;
            var lastLine = cm.lastLine();
            if (head.line &gt; lastLine) {
                head.line = lastLine;
            }
            head.ch = lineLength(cm, head.line);
        }
        else {
            head.ch = 0;
            anchor.ch = lineLength(cm, anchor.line);
        }
        return {
            ranges: [{ anchor: anchor, head: head }],
            primary: 0
        };
    }
    else if (mode == &#039;block&#039;) {
        var top = Math.min(anchor.line, head.line), fromCh = anchor.ch, bottom = Math.max(anchor.line, head.line), toCh = head.ch;
        if (fromCh &lt; toCh) {
            toCh += 1;
        }
        else {
            fromCh += 1;
        }
        ;
        var height = bottom - top + 1;
        var primary = head.line == top ? 0 : height - 1;
        var ranges = [];
        for (var i = 0; i &lt; height; i++) {
            ranges.push({
                anchor: new Pos(top + i, fromCh),
                head: new Pos(top + i, toCh)
            });
        }
        return {
            ranges: ranges,
            primary: primary
        };
    }
}
function getHead(cm) {
    var cur = cm.getCursor(&#039;head&#039;);
    if (cm.getSelection().length == 1) {
        cur = cursorMin(cur, cm.getCursor(&#039;anchor&#039;));
    }
    return cur;
}
function exitVisualMode(cm, moveHead) {
    var vim = cm.state.vim;
    if (moveHead !== false) {
        cm.setCursor(clipCursorToContent(cm, vim.sel.head));
    }
    updateLastSelection(cm, vim);
    vim.visualMode = false;
    vim.visualLine = false;
    vim.visualBlock = false;
    if (!vim.insertMode)
        CodeMirror.signal(cm, &quot;vim-mode-change&quot;, { mode: &quot;normal&quot; });
}
function clipToLine(cm, curStart, curEnd) {
    var selection = cm.getRange(curStart, curEnd);
    if (/\n\s*$/.test(selection)) {
        var lines = selection.split(&#039;\n&#039;);
        lines.pop();
        var line;
        for (var line = lines.pop(); lines.length &gt; 0 &amp;&amp; line &amp;&amp; isWhiteSpaceString(line); line = lines.pop()) {
            curEnd.line--;
            curEnd.ch = 0;
        }
        if (line) {
            curEnd.line--;
            curEnd.ch = lineLength(cm, curEnd.line);
        }
        else {
            curEnd.ch = 0;
        }
    }
}
function expandSelectionToLine(_cm, curStart, curEnd) {
    curStart.ch = 0;
    curEnd.ch = 0;
    curEnd.line++;
}
function findFirstNonWhiteSpaceCharacter(text) {
    if (!text) {
        return 0;
    }
    var firstNonWS = text.search(/\S/);
    return firstNonWS == -1 ? text.length : firstNonWS;
}
function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {
    var cur = getHead(cm);
    var line = cm.getLine(cur.line);
    var idx = cur.ch;
    var test = noSymbol ? wordCharTest[0] : bigWordCharTest[0];
    while (!test(line.charAt(idx))) {
        idx++;
        if (idx &gt;= line.length) {
            return null;
        }
    }
    if (bigWord) {
        test = bigWordCharTest[0];
    }
    else {
        test = wordCharTest[0];
        if (!test(line.charAt(idx))) {
            test = wordCharTest[1];
        }
    }
    var end = idx, start = idx;
    while (test(line.charAt(end)) &amp;&amp; end &lt; line.length) {
        end++;
    }
    while (test(line.charAt(start)) &amp;&amp; start &gt;= 0) {
        start--;
    }
    start++;
    if (inclusive) {
        var wordEnd = end;
        while (/\s/.test(line.charAt(end)) &amp;&amp; end &lt; line.length) {
            end++;
        }
        if (wordEnd == end) {
            var wordStart = start;
            while (/\s/.test(line.charAt(start - 1)) &amp;&amp; start &gt; 0) {
                start--;
            }
            if (!start) {
                start = wordStart;
            }
        }
    }
    return { start: new Pos(cur.line, start), end: new Pos(cur.line, end) };
}
function expandTagUnderCursor(cm, head, inclusive) {
    var cur = head;
    if (!CodeMirror.findMatchingTag || !CodeMirror.findEnclosingTag) {
        return { start: cur, end: cur };
    }
    var tags = CodeMirror.findMatchingTag(cm, head) || CodeMirror.findEnclosingTag(cm, head);
    if (!tags || !tags.open || !tags.close) {
        return { start: cur, end: cur };
    }
    if (inclusive) {
        return { start: tags.open.from, end: tags.close.to };
    }
    return { start: tags.open.to, end: tags.close.from };
}
function recordJumpPosition(cm, oldCur, newCur) {
    if (!cursorEqual(oldCur, newCur)) {
        vimGlobalState.jumpList.add(cm, oldCur, newCur);
    }
}
function recordLastCharacterSearch(increment, args) {
    vimGlobalState.lastCharacterSearch.increment = increment;
    vimGlobalState.lastCharacterSearch.forward = args.forward;
    vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;
}
var symbolToMode = {
    &#039;(&#039;: &#039;bracket&#039;, &#039;)&#039;: &#039;bracket&#039;, &#039;{&#039;: &#039;bracket&#039;, &#039;}&#039;: &#039;bracket&#039;,
    &#039;[&#039;: &#039;section&#039;, &#039;]&#039;: &#039;section&#039;,
    &#039;*&#039;: &#039;comment&#039;, &#039;/&#039;: &#039;comment&#039;,
    &#039;m&#039;: &#039;method&#039;, &#039;M&#039;: &#039;method&#039;,
    &#039;#&#039;: &#039;preprocess&#039;
};
var findSymbolModes = {
    bracket: {
        isComplete: function (state) {
            if (state.nextCh === state.symb) {
                state.depth++;
                if (state.depth &gt;= 1)
                    return true;
            }
            else if (state.nextCh === state.reverseSymb) {
                state.depth--;
            }
            return false;
        }
    },
    section: {
        init: function (state) {
            state.curMoveThrough = true;
            state.symb = (state.forward ? &#039;]&#039; : &#039;[&#039;) === state.symb ? &#039;{&#039; : &#039;}&#039;;
        },
        isComplete: function (state) {
            return state.index === 0 &amp;&amp; state.nextCh === state.symb;
        }
    },
    comment: {
        isComplete: function (state) {
            var found = state.lastCh === &#039;*&#039; &amp;&amp; state.nextCh === &#039;/&#039;;
            state.lastCh = state.nextCh;
            return found;
        }
    },
    method: {
        init: function (state) {
            state.symb = (state.symb === &#039;m&#039; ? &#039;{&#039; : &#039;}&#039;);
            state.reverseSymb = state.symb === &#039;{&#039; ? &#039;}&#039; : &#039;{&#039;;
        },
        isComplete: function (state) {
            if (state.nextCh === state.symb)
                return true;
            return false;
        }
    },
    preprocess: {
        init: function (state) {
            state.index = 0;
        },
        isComplete: function (state) {
            if (state.nextCh === &#039;#&#039;) {
                var token = state.lineText.match(/^#(\w+)/)[1];
                if (token === &#039;endif&#039;) {
                    if (state.forward &amp;&amp; state.depth === 0) {
                        return true;
                    }
                    state.depth++;
                }
                else if (token === &#039;if&#039;) {
                    if (!state.forward &amp;&amp; state.depth === 0) {
                        return true;
                    }
                    state.depth--;
                }
                if (token === &#039;else&#039; &amp;&amp; state.depth === 0)
                    return true;
            }
            return false;
        }
    }
};
function findSymbol(cm, repeat, forward, symb) {
    var cur = copyCursor(cm.getCursor());
    var increment = forward ? 1 : -1;
    var endLine = forward ? cm.lineCount() : -1;
    var curCh = cur.ch;
    var line = cur.line;
    var lineText = cm.getLine(line);
    var state = {
        lineText: lineText,
        nextCh: lineText.charAt(curCh),
        lastCh: null,
        index: curCh,
        symb: symb,
        reverseSymb: (forward ? { &#039;)&#039;: &#039;(&#039;, &#039;}&#039;: &#039;{&#039; } : { &#039;(&#039;: &#039;)&#039;, &#039;{&#039;: &#039;}&#039; })[symb],
        forward: forward,
        depth: 0,
        curMoveThrough: false
    };
    var mode = symbolToMode[symb];
    if (!mode)
        return cur;
    var init = findSymbolModes[mode].init;
    var isComplete = findSymbolModes[mode].isComplete;
    if (init) {
        init(state);
    }
    while (line !== endLine &amp;&amp; repeat) {
        state.index += increment;
        state.nextCh = state.lineText.charAt(state.index);
        if (!state.nextCh) {
            line += increment;
            state.lineText = cm.getLine(line) || &#039;&#039;;
            if (increment &gt; 0) {
                state.index = 0;
            }
            else {
                var lineLen = state.lineText.length;
                state.index = (lineLen &gt; 0) ? (lineLen - 1) : 0;
            }
            state.nextCh = state.lineText.charAt(state.index);
        }
        if (isComplete(state)) {
            cur.line = line;
            cur.ch = state.index;
            repeat--;
        }
    }
    if (state.nextCh || state.curMoveThrough) {
        return new Pos(line, state.index);
    }
    return cur;
}
function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {
    var lineNum = cur.line;
    var pos = cur.ch;
    var line = cm.getLine(lineNum);
    var dir = forward ? 1 : -1;
    var charTests = bigWord ? bigWordCharTest : wordCharTest;
    if (emptyLineIsWord &amp;&amp; line == &#039;&#039;) {
        lineNum += dir;
        line = cm.getLine(lineNum);
        if (!isLine(cm, lineNum)) {
            return null;
        }
        pos = (forward) ? 0 : line.length;
    }
    while (true) {
        if (emptyLineIsWord &amp;&amp; line == &#039;&#039;) {
            return { from: 0, to: 0, line: lineNum };
        }
        var stop = (dir &gt; 0) ? line.length : -1;
        var wordStart = stop, wordEnd = stop;
        while (pos != stop) {
            var foundWord = false;
            for (var i = 0; i &lt; charTests.length &amp;&amp; !foundWord; ++i) {
                if (charTests[i](line.charAt(pos))) {
                    wordStart = pos;
                    while (pos != stop &amp;&amp; charTests[i](line.charAt(pos))) {
                        pos += dir;
                    }
                    wordEnd = pos;
                    foundWord = wordStart != wordEnd;
                    if (wordStart == cur.ch &amp;&amp; lineNum == cur.line &amp;&amp;
                        wordEnd == wordStart + dir) {
                        continue;
                    }
                    else {
                        return {
                            from: Math.min(wordStart, wordEnd + 1),
                            to: Math.max(wordStart, wordEnd),
                            line: lineNum
                        };
                    }
                }
            }
            if (!foundWord) {
                pos += dir;
            }
        }
        lineNum += dir;
        if (!isLine(cm, lineNum)) {
            return null;
        }
        line = cm.getLine(lineNum);
        pos = (dir &gt; 0) ? 0 : line.length;
    }
}
function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {
    var curStart = copyCursor(cur);
    var words = [];
    if (forward &amp;&amp; !wordEnd || !forward &amp;&amp; wordEnd) {
        repeat++;
    }
    var emptyLineIsWord = !(forward &amp;&amp; wordEnd);
    for (var i = 0; i &lt; repeat; i++) {
        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);
        if (!word) {
            var eodCh = lineLength(cm, cm.lastLine());
            words.push(forward
                ? { line: cm.lastLine(), from: eodCh, to: eodCh }
                : { line: 0, from: 0, to: 0 });
            break;
        }
        words.push(word);
        cur = new Pos(word.line, forward ? (word.to - 1) : word.from);
    }
    var shortCircuit = words.length != repeat;
    var firstWord = words[0];
    var lastWord = words.pop();
    if (forward &amp;&amp; !wordEnd) {
        if (!shortCircuit &amp;&amp; (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {
            lastWord = words.pop();
        }
        return new Pos(lastWord.line, lastWord.from);
    }
    else if (forward &amp;&amp; wordEnd) {
        return new Pos(lastWord.line, lastWord.to - 1);
    }
    else if (!forward &amp;&amp; wordEnd) {
        if (!shortCircuit &amp;&amp; (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {
            lastWord = words.pop();
        }
        return new Pos(lastWord.line, lastWord.to);
    }
    else {
        return new Pos(lastWord.line, lastWord.from);
    }
}
function moveToEol(cm, head, motionArgs, vim, keepHPos) {
    var cur = head;
    var retval = new Pos(cur.line + motionArgs.repeat - 1, Infinity);
    var end = cm.clipPos(retval);
    end.ch--;
    if (!keepHPos) {
        vim.lastHPos = Infinity;
        vim.lastHSPos = cm.charCoords(end, &#039;div&#039;).left;
    }
    return retval;
}
function moveToCharacter(cm, repeat, forward, character) {
    var cur = cm.getCursor();
    var start = cur.ch;
    var idx;
    for (var i = 0; i &lt; repeat; i++) {
        var line = cm.getLine(cur.line);
        idx = charIdxInLine(start, line, character, forward, true);
        if (idx == -1) {
            return null;
        }
        start = idx;
    }
    return new Pos(cm.getCursor().line, idx);
}
function moveToColumn(cm, repeat) {
    var line = cm.getCursor().line;
    return clipCursorToContent(cm, new Pos(line, repeat - 1));
}
function updateMark(cm, vim, markName, pos) {
    if (!inArray(markName, validMarks)) {
        return;
    }
    if (vim.marks[markName]) {
        vim.marks[markName].clear();
    }
    vim.marks[markName] = cm.setBookmark(pos);
}
function charIdxInLine(start, line, character, forward, includeChar) {
    var idx;
    if (forward) {
        idx = line.indexOf(character, start + 1);
        if (idx != -1 &amp;&amp; !includeChar) {
            idx -= 1;
        }
    }
    else {
        idx = line.lastIndexOf(character, start - 1);
        if (idx != -1 &amp;&amp; !includeChar) {
            idx += 1;
        }
    }
    return idx;
}
function findParagraph(cm, head, repeat, dir, inclusive) {
    var line = head.line;
    var min = cm.firstLine();
    var max = cm.lastLine();
    var start, end, i = line;
    function isEmpty(i) { return !/\S/.test(cm.getLine(i)); } // ace_patch
    function isBoundary(i, dir, any) {
        if (any) {
            return isEmpty(i) != isEmpty(i + dir);
        }
        return !isEmpty(i) &amp;&amp; isEmpty(i + dir);
    }
    function skipFold(i) {
        dir = dir &gt; 0 ? 1 : -1;
        var foldLine = cm.ace.session.getFoldLine(i);
        if (foldLine) {
            if (i + dir &gt; foldLine.start.row &amp;&amp; i + dir &lt; foldLine.end.row)
                dir = (dir &gt; 0 ? foldLine.end.row : foldLine.start.row) - i;
        }
    }
    if (dir) {
        while (min &lt;= i &amp;&amp; i &lt;= max &amp;&amp; repeat &gt; 0) {
            skipFold(i);
            if (isBoundary(i, dir)) {
                repeat--;
            }
            i += dir;
        }
        return new Pos(i, 0);
    }
    var vim = cm.state.vim;
    if (vim.visualLine &amp;&amp; isBoundary(line, 1, true)) {
        var anchor = vim.sel.anchor;
        if (isBoundary(anchor.line, -1, true)) {
            if (!inclusive || anchor.line != line) {
                line += 1;
            }
        }
    }
    var startState = isEmpty(line);
    for (i = line; i &lt;= max &amp;&amp; repeat; i++) {
        if (isBoundary(i, 1, true)) {
            if (!inclusive || isEmpty(i) != startState) {
                repeat--;
            }
        }
    }
    end = new Pos(i, 0);
    if (i &gt; max &amp;&amp; !startState) {
        startState = true;
    }
    else {
        inclusive = false;
    }
    for (i = line; i &gt; min; i--) {
        if (!inclusive || isEmpty(i) == startState || i == line) {
            if (isBoundary(i, -1, true)) {
                break;
            }
        }
    }
    start = new Pos(i, 0);
    return { start: start, end: end };
}
function getSentence(cm, cur, repeat, dir, inclusive /*includes whitespace*/) {
    function nextChar(curr) {
        if (curr.pos + curr.dir &lt; 0 || curr.pos + curr.dir &gt;= curr.line.length) {
            curr.line = null;
        }
        else {
            curr.pos += curr.dir;
        }
    }
    function forward(cm, ln, pos, dir) {
        var line = cm.getLine(ln);
        var curr = {
            line: line,
            ln: ln,
            pos: pos,
            dir: dir,
        };
        if (curr.line === &quot;&quot;) {
            return { ln: curr.ln, pos: curr.pos };
        }
        var lastSentencePos = curr.pos;
        nextChar(curr);
        while (curr.line !== null) {
            lastSentencePos = curr.pos;
            if (isEndOfSentenceSymbol(curr.line[curr.pos])) {
                if (!inclusive) {
                    return { ln: curr.ln, pos: curr.pos + 1 };
                }
                else {
                    nextChar(curr);
                    while (curr.line !== null) {
                        if (isWhiteSpaceString(curr.line[curr.pos])) {
                            lastSentencePos = curr.pos;
                            nextChar(curr);
                        }
                        else {
                            break;
                        }
                    }
                    return { ln: curr.ln, pos: lastSentencePos + 1 };
                }
            }
            nextChar(curr);
        }
        return { ln: curr.ln, pos: lastSentencePos + 1 };
    }
    function reverse(cm, ln, pos, dir) {
        var line = cm.getLine(ln);
        var curr = {
            line: line,
            ln: ln,
            pos: pos,
            dir: dir,
        };
        if (curr.line === &quot;&quot;) {
            return { ln: curr.ln, pos: curr.pos };
        }
        var lastSentencePos = curr.pos;
        nextChar(curr);
        while (curr.line !== null) {
            if (!isWhiteSpaceString(curr.line[curr.pos]) &amp;&amp; !isEndOfSentenceSymbol(curr.line[curr.pos])) {
                lastSentencePos = curr.pos;
            }
            else if (isEndOfSentenceSymbol(curr.line[curr.pos])) {
                if (!inclusive) {
                    return { ln: curr.ln, pos: lastSentencePos };
                }
                else {
                    if (isWhiteSpaceString(curr.line[curr.pos + 1])) {
                        return { ln: curr.ln, pos: curr.pos + 1 };
                    }
                    else {
                        return { ln: curr.ln, pos: lastSentencePos };
                    }
                }
            }
            nextChar(curr);
        }
        curr.line = line;
        if (inclusive &amp;&amp; isWhiteSpaceString(curr.line[curr.pos])) {
            return { ln: curr.ln, pos: curr.pos };
        }
        else {
            return { ln: curr.ln, pos: lastSentencePos };
        }
    }
    var curr_index = {
        ln: cur.line,
        pos: cur.ch,
    };
    while (repeat &gt; 0) {
        if (dir &lt; 0) {
            curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);
        }
        else {
            curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);
        }
        repeat--;
    }
    return new Pos(curr_index.ln, curr_index.pos);
}
function findSentence(cm, cur, repeat, dir) {
    function nextChar(cm, idx) {
        if (idx.pos + idx.dir &lt; 0 || idx.pos + idx.dir &gt;= idx.line.length) {
            idx.ln += idx.dir;
            if (!isLine(cm, idx.ln)) {
                idx.line = null;
                idx.ln = null;
                idx.pos = null;
                return;
            }
            idx.line = cm.getLine(idx.ln);
            idx.pos = (idx.dir &gt; 0) ? 0 : idx.line.length - 1;
        }
        else {
            idx.pos += idx.dir;
        }
    }
    function forward(cm, ln, pos, dir) {
        var line = cm.getLine(ln);
        var stop = (line === &quot;&quot;);
        var curr = {
            line: line,
            ln: ln,
            pos: pos,
            dir: dir,
        };
        var last_valid = {
            ln: curr.ln,
            pos: curr.pos,
        };
        var skip_empty_lines = (curr.line === &quot;&quot;);
        nextChar(cm, curr);
        while (curr.line !== null) {
            last_valid.ln = curr.ln;
            last_valid.pos = curr.pos;
            if (curr.line === &quot;&quot; &amp;&amp; !skip_empty_lines) {
                return { ln: curr.ln, pos: curr.pos, };
            }
            else if (stop &amp;&amp; curr.line !== &quot;&quot; &amp;&amp; !isWhiteSpaceString(curr.line[curr.pos])) {
                return { ln: curr.ln, pos: curr.pos, };
            }
            else if (isEndOfSentenceSymbol(curr.line[curr.pos])
                &amp;&amp; !stop
                &amp;&amp; (curr.pos === curr.line.length - 1
                    || isWhiteSpaceString(curr.line[curr.pos + 1]))) {
                stop = true;
            }
            nextChar(cm, curr);
        }
        var line = cm.getLine(last_valid.ln);
        last_valid.pos = 0;
        for (var i = line.length - 1; i &gt;= 0; --i) {
            if (!isWhiteSpaceString(line[i])) {
                last_valid.pos = i;
                break;
            }
        }
        return last_valid;
    }
    function reverse(cm, ln, pos, dir) {
        var line = cm.getLine(ln);
        var curr = {
            line: line,
            ln: ln,
            pos: pos,
            dir: dir,
        };
        var last_valid = {
            ln: curr.ln,
            pos: null,
        };
        var skip_empty_lines = (curr.line === &quot;&quot;);
        nextChar(cm, curr);
        while (curr.line !== null) {
            if (curr.line === &quot;&quot; &amp;&amp; !skip_empty_lines) {
                if (last_valid.pos !== null) {
                    return last_valid;
                }
                else {
                    return { ln: curr.ln, pos: curr.pos };
                }
            }
            else if (isEndOfSentenceSymbol(curr.line[curr.pos])
                &amp;&amp; last_valid.pos !== null
                &amp;&amp; !(curr.ln === last_valid.ln &amp;&amp; curr.pos + 1 === last_valid.pos)) {
                return last_valid;
            }
            else if (curr.line !== &quot;&quot; &amp;&amp; !isWhiteSpaceString(curr.line[curr.pos])) {
                skip_empty_lines = false;
                last_valid = { ln: curr.ln, pos: curr.pos };
            }
            nextChar(cm, curr);
        }
        var line = cm.getLine(last_valid.ln);
        last_valid.pos = 0;
        for (var i = 0; i &lt; line.length; ++i) {
            if (!isWhiteSpaceString(line[i])) {
                last_valid.pos = i;
                break;
            }
        }
        return last_valid;
    }
    var curr_index = {
        ln: cur.line,
        pos: cur.ch,
    };
    while (repeat &gt; 0) {
        if (dir &lt; 0) {
            curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);
        }
        else {
            curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);
        }
        repeat--;
    }
    return new Pos(curr_index.ln, curr_index.pos);
}
function selectCompanionObject(cm, head, symb, inclusive) {
    var cur = head, start, end;
    var bracketRegexp = ({
        &#039;(&#039;: /[()]/, &#039;)&#039;: /[()]/,
        &#039;[&#039;: /[[\]]/, &#039;]&#039;: /[[\]]/,
        &#039;{&#039;: /[{}]/, &#039;}&#039;: /[{}]/,
        &#039;&lt;&#039;: /[&lt;&gt;]/, &#039;&gt;&#039;: /[&lt;&gt;]/
    })[symb];
    var openSym = ({
        &#039;(&#039;: &#039;(&#039;, &#039;)&#039;: &#039;(&#039;,
        &#039;[&#039;: &#039;[&#039;, &#039;]&#039;: &#039;[&#039;,
        &#039;{&#039;: &#039;{&#039;, &#039;}&#039;: &#039;{&#039;,
        &#039;&lt;&#039;: &#039;&lt;&#039;, &#039;&gt;&#039;: &#039;&lt;&#039;
    })[symb];
    var curChar = cm.getLine(cur.line).charAt(cur.ch);
    var offset = curChar === openSym ? 1 : 0;
    start = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), -1, undefined, { &#039;bracketRegex&#039;: bracketRegexp });
    end = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), 1, undefined, { &#039;bracketRegex&#039;: bracketRegexp });
    if (!start || !end) {
        return { start: cur, end: cur };
    }
    start = start.pos;
    end = end.pos;
    if ((start.line == end.line &amp;&amp; start.ch &gt; end.ch)
        || (start.line &gt; end.line)) {
        var tmp = start;
        start = end;
        end = tmp;
    }
    if (inclusive) {
        end.ch += 1;
    }
    else {
        start.ch += 1;
    }
    return { start: start, end: end };
}
function findBeginningAndEnd(cm, head, symb, inclusive) {
    var cur = copyCursor(head);
    var line = cm.getLine(cur.line);
    var chars = line.split(&#039;&#039;);
    var start, end, i, len;
    var firstIndex = chars.indexOf(symb);
    if (cur.ch &lt; firstIndex) {
        cur.ch = firstIndex;
    }
    else if (firstIndex &lt; cur.ch &amp;&amp; chars[cur.ch] == symb) {
        end = cur.ch; // assign end to the current cursor
        --cur.ch; // make sure to look backwards
    }
    if (chars[cur.ch] == symb &amp;&amp; !end) {
        start = cur.ch + 1; // assign start to ahead of the cursor
    }
    else {
        for (i = cur.ch; i &gt; -1 &amp;&amp; !start; i--) {
            if (chars[i] == symb) {
                start = i + 1;
            }
        }
    }
    if (start &amp;&amp; !end) {
        for (i = start, len = chars.length; i &lt; len &amp;&amp; !end; i++) {
            if (chars[i] == symb) {
                end = i;
            }
        }
    }
    if (!start || !end) {
        return { start: cur, end: cur };
    }
    if (inclusive) {
        --start;
        ++end;
    }
    return {
        start: new Pos(cur.line, start),
        end: new Pos(cur.line, end)
    };
}
defineOption(&#039;pcre&#039;, true, &#039;boolean&#039;);
function SearchState() { }
SearchState.prototype = {
    getQuery: function () {
        return vimGlobalState.query;
    },
    setQuery: function (query) {
        vimGlobalState.query = query;
    },
    getOverlay: function () {
        return this.searchOverlay;
    },
    setOverlay: function (overlay) {
        this.searchOverlay = overlay;
    },
    isReversed: function () {
        return vimGlobalState.isReversed;
    },
    setReversed: function (reversed) {
        vimGlobalState.isReversed = reversed;
    },
    getScrollbarAnnotate: function () {
        return this.annotate;
    },
    setScrollbarAnnotate: function (annotate) {
        this.annotate = annotate;
    }
};
function getSearchState(cm) {
    var vim = cm.state.vim;
    return vim.searchState_ || (vim.searchState_ = new SearchState());
}
function splitBySlash(argString) {
    return splitBySeparator(argString, &#039;/&#039;);
}
function findUnescapedSlashes(argString) {
    return findUnescapedSeparators(argString, &#039;/&#039;);
}
function splitBySeparator(argString, separator) {
    var slashes = findUnescapedSeparators(argString, separator) || [];
    if (!slashes.length)
        return [];
    var tokens = [];
    if (slashes[0] !== 0)
        return;
    for (var i = 0; i &lt; slashes.length; i++) {
        if (typeof slashes[i] == &#039;number&#039;)
            tokens.push(argString.substring(slashes[i] + 1, slashes[i + 1]));
    }
    return tokens;
}
function findUnescapedSeparators(str, separator) {
    if (!separator)
        separator = &#039;/&#039;;
    var escapeNextChar = false;
    var slashes = [];
    for (var i = 0; i &lt; str.length; i++) {
        var c = str.charAt(i);
        if (!escapeNextChar &amp;&amp; c == separator) {
            slashes.push(i);
        }
        escapeNextChar = !escapeNextChar &amp;&amp; (c == &#039;\\&#039;);
    }
    return slashes;
}
function translateRegex(str) {
    var specials = &#039;|(){&#039;;
    var unescape = &#039;}&#039;;
    var escapeNextChar = false;
    var out = [];
    for (var i = -1; i &lt; str.length; i++) {
        var c = str.charAt(i) || &#039;&#039;;
        var n = str.charAt(i + 1) || &#039;&#039;;
        var specialComesNext = (n &amp;&amp; specials.indexOf(n) != -1);
        if (escapeNextChar) {
            if (c !== &#039;\\&#039; || !specialComesNext) {
                out.push(c);
            }
            escapeNextChar = false;
        }
        else {
            if (c === &#039;\\&#039;) {
                escapeNextChar = true;
                if (n &amp;&amp; unescape.indexOf(n) != -1) {
                    specialComesNext = true;
                }
                if (!specialComesNext || n === &#039;\\&#039;) {
                    out.push(c);
                }
            }
            else {
                out.push(c);
                if (specialComesNext &amp;&amp; n !== &#039;\\&#039;) {
                    out.push(&#039;\\&#039;);
                }
            }
        }
    }
    return out.join(&#039;&#039;);
}
var charUnescapes = { &#039;\\n&#039;: &#039;\n&#039;, &#039;\\r&#039;: &#039;\r&#039;, &#039;\\t&#039;: &#039;\t&#039; };
function translateRegexReplace(str) {
    var escapeNextChar = false;
    var out = [];
    for (var i = -1; i &lt; str.length; i++) {
        var c = str.charAt(i) || &#039;&#039;;
        var n = str.charAt(i + 1) || &#039;&#039;;
        if (charUnescapes[c + n]) {
            out.push(charUnescapes[c + n]);
            i++;
        }
        else if (escapeNextChar) {
            out.push(c);
            escapeNextChar = false;
        }
        else {
            if (c === &#039;\\&#039;) {
                escapeNextChar = true;
                if ((isNumber(n) || n === &#039;$&#039;)) {
                    out.push(&#039;$&#039;);
                }
                else if (n !== &#039;/&#039; &amp;&amp; n !== &#039;\\&#039;) {
                    out.push(&#039;\\&#039;);
                }
            }
            else {
                if (c === &#039;$&#039;) {
                    out.push(&#039;$&#039;);
                }
                out.push(c);
                if (n === &#039;/&#039;) {
                    out.push(&#039;\\&#039;);
                }
            }
        }
    }
    return out.join(&#039;&#039;);
}
var unescapes = { &#039;\\/&#039;: &#039;/&#039;, &#039;\\\\&#039;: &#039;\\&#039;, &#039;\\n&#039;: &#039;\n&#039;, &#039;\\r&#039;: &#039;\r&#039;, &#039;\\t&#039;: &#039;\t&#039;, &#039;\\&amp;&#039;: &#039;&amp;&#039; };
function unescapeRegexReplace(str) {
    var stream = new CodeMirror.StringStream(str);
    var output = [];
    while (!stream.eol()) {
        while (stream.peek() &amp;&amp; stream.peek() != &#039;\\&#039;) {
            output.push(stream.next());
        }
        var matched = false;
        for (var matcher in unescapes) {
            if (stream.match(matcher, true)) {
                matched = true;
                output.push(unescapes[matcher]);
                break;
            }
        }
        if (!matched) {
            output.push(stream.next());
        }
    }
    return output.join(&#039;&#039;);
}
function parseQuery(query, ignoreCase, smartCase) {
    var lastSearchRegister = vimGlobalState.registerController.getRegister(&#039;/&#039;);
    lastSearchRegister.setText(query);
    if (query instanceof RegExp) {
        return query;
    }
    var slashes = findUnescapedSlashes(query);
    var regexPart;
    var forceIgnoreCase;
    if (!slashes.length) {
        regexPart = query;
    }
    else {
        regexPart = query.substring(0, slashes[0]);
        var flagsPart = query.substring(slashes[0]);
        forceIgnoreCase = (flagsPart.indexOf(&#039;i&#039;) != -1);
    }
    if (!regexPart) {
        return null;
    }
    if (!getOption(&#039;pcre&#039;)) {
        regexPart = translateRegex(regexPart);
    }
    if (smartCase) {
        ignoreCase = (/^[^A-Z]*$/).test(regexPart);
    }
    var regexp = new RegExp(regexPart, (ignoreCase || forceIgnoreCase) ? &#039;im&#039; : &#039;m&#039;);
    return regexp;
}
function dom(n) {
    if (typeof n === &#039;string&#039;)
        n = document.createElement(n);
    for (var a, i = 1; i &lt; arguments.length; i++) {
        if (!(a = arguments[i]))
            continue;
        if (typeof a !== &#039;object&#039;)
            a = document.createTextNode(a);
        if (a.nodeType)
            n.appendChild(a);
        else
            for (var key in a) {
                if (!Object.prototype.hasOwnProperty.call(a, key))
                    continue;
                if (key[0] === &#039;$&#039;)
                    n.style[key.slice(1)] = a[key];
                else
                    n.setAttribute(key, a[key]);
            }
    }
    return n;
}
function showConfirm(cm, template) {
    var pre = dom(&#039;div&#039;, { $color: &#039;red&#039;, $whiteSpace: &#039;pre&#039;, class: &#039;cm-vim-message&#039; }, template);
    if (cm.openNotification) {
        cm.openNotification(pre, { bottom: true, duration: 5000 });
    }
    else {
        alert(pre.innerText);
    }
}
function makePrompt(prefix, desc) {
    return dom(document.createDocumentFragment(), dom(&#039;span&#039;, { $fontFamily: &#039;monospace&#039;, $whiteSpace: &#039;pre&#039; }, prefix, dom(&#039;input&#039;, { type: &#039;text&#039;, autocorrect: &#039;off&#039;,
        autocapitalize: &#039;off&#039;, spellcheck: &#039;false&#039; })), desc &amp;&amp; dom(&#039;span&#039;, { $color: &#039;#888&#039; }, desc));
}
function showPrompt(cm, options) {
    var template = makePrompt(options.prefix, options.desc);
    if (cm.openDialog) {
        cm.openDialog(template, options.onClose, {
            onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,
            bottom: true, selectValueOnOpen: false, value: options.value
        });
    }
    else {
        var shortText = &#039;&#039;;
        if (typeof options.prefix != &quot;string&quot; &amp;&amp; options.prefix)
            shortText += options.prefix.textContent;
        if (options.desc)
            shortText += &quot; &quot; + options.desc;
        options.onClose(prompt(shortText, &#039;&#039;));
    }
}
function regexEqual(r1, r2) {
    if (r1 instanceof RegExp &amp;&amp; r2 instanceof RegExp) {
        var props = [&#039;global&#039;, &#039;multiline&#039;, &#039;ignoreCase&#039;, &#039;source&#039;];
        for (var i = 0; i &lt; props.length; i++) {
            var prop = props[i];
            if (r1[prop] !== r2[prop]) {
                return false;
            }
        }
        return true;
    }
    return false;
}
function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {
    if (!rawQuery) {
        return;
    }
    var state = getSearchState(cm);
    var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);
    if (!query) {
        return;
    }
    highlightSearchMatches(cm, query);
    if (regexEqual(query, state.getQuery())) {
        return query;
    }
    state.setQuery(query);
    return query;
}
function searchOverlay(query) {
    if (query.source.charAt(0) == &#039;^&#039;) {
        var matchSol = true;
    }
    return {
        token: function (stream) {
            if (matchSol &amp;&amp; !stream.sol()) {
                stream.skipToEnd();
                return;
            }
            var match = stream.match(query, false);
            if (match) {
                if (match[0].length == 0) {
                    stream.next();
                    return &#039;searching&#039;;
                }
                if (!stream.sol()) {
                    stream.backUp(1);
                    if (!query.exec(stream.next() + match[0])) {
                        stream.next();
                        return null;
                    }
                }
                stream.match(query);
                return &#039;searching&#039;;
            }
            while (!stream.eol()) {
                stream.next();
                if (stream.match(query, false))
                    break;
            }
        },
        query: query
    };
}
var highlightTimeout = 0;
function highlightSearchMatches(cm, query) {
    clearTimeout(highlightTimeout);
    highlightTimeout = setTimeout(function () {
        if (!cm.state.vim)
            return;
        var searchState = getSearchState(cm);
        var overlay = searchState.getOverlay();
        if (!overlay || query != overlay.query) {
            if (overlay) {
                cm.removeOverlay(overlay);
            }
            overlay = searchOverlay(query);
            cm.addOverlay(overlay);
            if (cm.showMatchesOnScrollbar) {
                if (searchState.getScrollbarAnnotate()) {
                    searchState.getScrollbarAnnotate().clear();
                }
                searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));
            }
            searchState.setOverlay(overlay);
        }
    }, 50);
}
function findNext(cm, prev, query, repeat) {
    if (repeat === undefined) {
        repeat = 1;
    }
    return cm.operation(function () {
        var pos = cm.getCursor();
        var cursor = cm.getSearchCursor(query, pos);
        for (var i = 0; i &lt; repeat; i++) {
            var found = cursor.find(prev);
            if (i == 0 &amp;&amp; found &amp;&amp; cursorEqual(cursor.from(), pos)) {
                var lastEndPos = prev ? cursor.from() : cursor.to();
                found = cursor.find(prev);
                if (found &amp;&amp; !found[0] &amp;&amp; cursorEqual(cursor.from(), lastEndPos)) {
                    if (cm.getLine(lastEndPos.line).length == lastEndPos.ch)
                        found = cursor.find(prev);
                }
            }
            if (!found) {
                cursor = cm.getSearchCursor(query, (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));
                if (!cursor.find(prev)) {
                    return;
                }
            }
        }
        return cursor.from();
    });
}
function findNextFromAndToInclusive(cm, prev, query, repeat, vim) {
    if (repeat === undefined) {
        repeat = 1;
    }
    return cm.operation(function () {
        var pos = cm.getCursor();
        var cursor = cm.getSearchCursor(query, pos);
        var found = cursor.find(!prev);
        if (!vim.visualMode &amp;&amp; found &amp;&amp; cursorEqual(cursor.from(), pos)) {
            cursor.find(!prev);
        }
        for (var i = 0; i &lt; repeat; i++) {
            found = cursor.find(prev);
            if (!found) {
                cursor = cm.getSearchCursor(query, (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));
                if (!cursor.find(prev)) {
                    return;
                }
            }
        }
        return [cursor.from(), cursor.to()];
    });
}
function clearSearchHighlight(cm) {
    var state = getSearchState(cm);
    cm.removeOverlay(getSearchState(cm).getOverlay());
    state.setOverlay(null);
    if (state.getScrollbarAnnotate()) {
        state.getScrollbarAnnotate().clear();
        state.setScrollbarAnnotate(null);
    }
}
function isInRange(pos, start, end) {
    if (typeof pos != &#039;number&#039;) {
        pos = pos.line;
    }
    if (start instanceof Array) {
        return inArray(pos, start);
    }
    else {
        if (typeof end == &#039;number&#039;) {
            return (pos &gt;= start &amp;&amp; pos &lt;= end);
        }
        else {
            return pos == start;
        }
    }
}
function getUserVisibleLines(cm) {
    var renderer = cm.ace.renderer;
    return {
        top: renderer.getFirstFullyVisibleRow(),
        bottom: renderer.getLastFullyVisibleRow()
    };
}
function getMarkPos(cm, vim, markName) {
    if (markName == &#039;\&#039;&#039; || markName == &#039;`&#039;) {
        return vimGlobalState.jumpList.find(cm, -1) || new Pos(0, 0);
    }
    else if (markName == &#039;.&#039;) {
        return getLastEditPos(cm);
    }
    var mark = vim.marks[markName];
    return mark &amp;&amp; mark.find();
}
function getLastEditPos(cm) {
    var undoManager = cm.ace.session.$undoManager;
    if (undoManager &amp;&amp; undoManager.$lastDelta)
        return toCmPos(undoManager.$lastDelta.end);
}
var ExCommandDispatcher = function () {
    this.buildCommandMap_();
};
ExCommandDispatcher.prototype = {
    processCommand: function (cm, input, opt_params) {
        var that = this;
        cm.operation(function () {
            cm.curOp.isVimOp = true;
            that._processCommand(cm, input, opt_params);
        });
    },
    _processCommand: function (cm, input, opt_params) {
        var vim = cm.state.vim;
        var commandHistoryRegister = vimGlobalState.registerController.getRegister(&#039;:&#039;);
        var previousCommand = commandHistoryRegister.toString();
        if (vim.visualMode) {
            exitVisualMode(cm);
        }
        var inputStream = new CodeMirror.StringStream(input);
        commandHistoryRegister.setText(input);
        var params = opt_params || {};
        params.input = input;
        try {
            this.parseInput_(cm, inputStream, params);
        }
        catch (e) {
            showConfirm(cm, e.toString());
            throw e;
        }
        var command;
        var commandName;
        if (!params.commandName) {
            if (params.line !== undefined) {
                commandName = &#039;move&#039;;
            }
        }
        else {
            command = this.matchCommand_(params.commandName);
            if (command) {
                commandName = command.name;
                if (command.excludeFromCommandHistory) {
                    commandHistoryRegister.setText(previousCommand);
                }
                this.parseCommandArgs_(inputStream, params, command);
                if (command.type == &#039;exToKey&#039;) {
                    for (var i = 0; i &lt; command.toKeys.length; i++) {
                        vimApi.handleKey(cm, command.toKeys[i], &#039;mapping&#039;);
                    }
                    return;
                }
                else if (command.type == &#039;exToEx&#039;) {
                    this.processCommand(cm, command.toInput);
                    return;
                }
            }
        }
        if (!commandName) {
            showConfirm(cm, &#039;Not an editor command &quot;:&#039; + input + &#039;&quot;&#039;);
            return;
        }
        try {
            exCommands[commandName](cm, params);
            if ((!command || !command.possiblyAsync) &amp;&amp; params.callback) {
                params.callback();
            }
        }
        catch (e) {
            showConfirm(cm, e.toString());
            throw e;
        }
    },
    parseInput_: function (cm, inputStream, result) {
        inputStream.eatWhile(&#039;:&#039;);
        if (inputStream.eat(&#039;%&#039;)) {
            result.line = cm.firstLine();
            result.lineEnd = cm.lastLine();
        }
        else {
            result.line = this.parseLineSpec_(cm, inputStream);
            if (result.line !== undefined &amp;&amp; inputStream.eat(&#039;,&#039;)) {
                result.lineEnd = this.parseLineSpec_(cm, inputStream);
            }
        }
        var commandMatch = inputStream.match(/^(\w+|!!|@@|[!#&amp;*&lt;=&gt;@~])/);
        if (commandMatch) {
            result.commandName = commandMatch[1];
        }
        else {
            result.commandName = inputStream.match(/.*/)[0];
        }
        return result;
    },
    parseLineSpec_: function (cm, inputStream) {
        var numberMatch = inputStream.match(/^(\d+)/);
        if (numberMatch) {
            return parseInt(numberMatch[1], 10) - 1;
        }
        switch (inputStream.next()) {
            case &#039;.&#039;:
                return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);
            case &#039;$&#039;:
                return this.parseLineSpecOffset_(inputStream, cm.lastLine());
            case &#039;\&#039;&#039;:
                var markName = inputStream.next();
                var markPos = getMarkPos(cm, cm.state.vim, markName);
                if (!markPos)
                    throw new Error(&#039;Mark not set&#039;);
                return this.parseLineSpecOffset_(inputStream, markPos.line);
            case &#039;-&#039;:
            case &#039;+&#039;:
                inputStream.backUp(1);
                return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);
            default:
                inputStream.backUp(1);
                return undefined;
        }
    },
    parseLineSpecOffset_: function (inputStream, line) {
        var offsetMatch = inputStream.match(/^([+-])?(\d+)/);
        if (offsetMatch) {
            var offset = parseInt(offsetMatch[2], 10);
            if (offsetMatch[1] == &quot;-&quot;) {
                line -= offset;
            }
            else {
                line += offset;
            }
        }
        return line;
    },
    parseCommandArgs_: function (inputStream, params, command) {
        if (inputStream.eol()) {
            return;
        }
        params.argString = inputStream.match(/.*/)[0];
        var delim = command.argDelimiter || /\s+/;
        var args = trim(params.argString).split(delim);
        if (args.length &amp;&amp; args[0]) {
            params.args = args;
        }
    },
    matchCommand_: function (commandName) {
        for (var i = commandName.length; i &gt; 0; i--) {
            var prefix = commandName.substring(0, i);
            if (this.commandMap_[prefix]) {
                var command = this.commandMap_[prefix];
                if (command.name.indexOf(commandName) === 0) {
                    return command;
                }
            }
        }
        return null;
    },
    buildCommandMap_: function () {
        this.commandMap_ = {};
        for (var i = 0; i &lt; defaultExCommandMap.length; i++) {
            var command = defaultExCommandMap[i];
            var key = command.shortName || command.name;
            this.commandMap_[key] = command;
        }
    },
    map: function (lhs, rhs, ctx) {
        if (lhs != &#039;:&#039; &amp;&amp; lhs.charAt(0) == &#039;:&#039;) {
            if (ctx) {
                throw Error(&#039;Mode not supported for ex mappings&#039;);
            }
            var commandName = lhs.substring(1);
            if (rhs != &#039;:&#039; &amp;&amp; rhs.charAt(0) == &#039;:&#039;) {
                this.commandMap_[commandName] = {
                    name: commandName,
                    type: &#039;exToEx&#039;,
                    toInput: rhs.substring(1),
                    user: true
                };
            }
            else {
                this.commandMap_[commandName] = {
                    name: commandName,
                    type: &#039;exToKey&#039;,
                    toKeys: rhs,
                    user: true
                };
            }
        }
        else {
            if (rhs != &#039;:&#039; &amp;&amp; rhs.charAt(0) == &#039;:&#039;) {
                var mapping = {
                    keys: lhs,
                    type: &#039;keyToEx&#039;,
                    exArgs: { input: rhs.substring(1) }
                };
                if (ctx) {
                    mapping.context = ctx;
                }
                defaultKeymap.unshift(mapping);
            }
            else {
                var mapping = {
                    keys: lhs,
                    type: &#039;keyToKey&#039;,
                    toKeys: rhs
                };
                if (ctx) {
                    mapping.context = ctx;
                }
                defaultKeymap.unshift(mapping);
            }
        }
    },
    unmap: function (lhs, ctx) {
        if (lhs != &#039;:&#039; &amp;&amp; lhs.charAt(0) == &#039;:&#039;) {
            if (ctx) {
                throw Error(&#039;Mode not supported for ex mappings&#039;);
            }
            var commandName = lhs.substring(1);
            if (this.commandMap_[commandName] &amp;&amp; this.commandMap_[commandName].user) {
                delete this.commandMap_[commandName];
                return true;
            }
        }
        else {
            var keys = lhs;
            for (var i = 0; i &lt; defaultKeymap.length; i++) {
                if (keys == defaultKeymap[i].keys
                    &amp;&amp; defaultKeymap[i].context === ctx) {
                    defaultKeymap.splice(i, 1);
                    return true;
                }
            }
        }
    }
};
var exCommands = {
    colorscheme: function (cm, params) {
        if (!params.args || params.args.length &lt; 1) {
            showConfirm(cm, cm.getOption(&#039;theme&#039;));
            return;
        }
        cm.setOption(&#039;theme&#039;, params.args[0]);
    },
    map: function (cm, params, ctx) {
        var mapArgs = params.args;
        if (!mapArgs || mapArgs.length &lt; 2) {
            if (cm) {
                showConfirm(cm, &#039;Invalid mapping: &#039; + params.input);
            }
            return;
        }
        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);
    },
    imap: function (cm, params) { this.map(cm, params, &#039;insert&#039;); },
    nmap: function (cm, params) { this.map(cm, params, &#039;normal&#039;); },
    vmap: function (cm, params) { this.map(cm, params, &#039;visual&#039;); },
    unmap: function (cm, params, ctx) {
        var mapArgs = params.args;
        if (!mapArgs || mapArgs.length &lt; 1 || !exCommandDispatcher.unmap(mapArgs[0], ctx)) {
            if (cm) {
                showConfirm(cm, &#039;No such mapping: &#039; + params.input);
            }
        }
    },
    move: function (cm, params) {
        commandDispatcher.processCommand(cm, cm.state.vim, {
            type: &#039;motion&#039;,
            motion: &#039;moveToLineOrEdgeOfDocument&#039;,
            motionArgs: { forward: false, explicitRepeat: true,
                linewise: true },
            repeatOverride: params.line + 1
        });
    },
    set: function (cm, params) {
        var setArgs = params.args;
        var setCfg = params.setCfg || {};
        if (!setArgs || setArgs.length &lt; 1) {
            if (cm) {
                showConfirm(cm, &#039;Invalid mapping: &#039; + params.input);
            }
            return;
        }
        var expr = setArgs[0].split(&#039;=&#039;);
        var optionName = expr[0];
        var value = expr[1];
        var forceGet = false;
        if (optionName.charAt(optionName.length - 1) == &#039;?&#039;) {
            if (value) {
                throw Error(&#039;Trailing characters: &#039; + params.argString);
            }
            optionName = optionName.substring(0, optionName.length - 1);
            forceGet = true;
        }
        if (value === undefined &amp;&amp; optionName.substring(0, 2) == &#039;no&#039;) {
            optionName = optionName.substring(2);
            value = false;
        }
        var optionIsBoolean = options[optionName] &amp;&amp; options[optionName].type == &#039;boolean&#039;;
        if (optionIsBoolean &amp;&amp; value == undefined) {
            value = true;
        }
        if (!optionIsBoolean &amp;&amp; value === undefined || forceGet) {
            var oldValue = getOption(optionName, cm, setCfg);
            if (oldValue instanceof Error) {
                showConfirm(cm, oldValue.message);
            }
            else if (oldValue === true || oldValue === false) {
                showConfirm(cm, &#039; &#039; + (oldValue ? &#039;&#039; : &#039;no&#039;) + optionName);
            }
            else {
                showConfirm(cm, &#039;  &#039; + optionName + &#039;=&#039; + oldValue);
            }
        }
        else {
            var setOptionReturn = setOption(optionName, value, cm, setCfg);
            if (setOptionReturn instanceof Error) {
                showConfirm(cm, setOptionReturn.message);
            }
        }
    },
    setlocal: function (cm, params) {
        params.setCfg = { scope: &#039;local&#039; };
        this.set(cm, params);
    },
    setglobal: function (cm, params) {
        params.setCfg = { scope: &#039;global&#039; };
        this.set(cm, params);
    },
    registers: function (cm, params) {
        var regArgs = params.args;
        var registers = vimGlobalState.registerController.registers;
        var regInfo = &#039;----------Registers----------\n\n&#039;;
        if (!regArgs) {
            for (var registerName in registers) {
                var text = registers[registerName].toString();
                if (text.length) {
                    regInfo += &#039;&quot;&#039; + registerName + &#039;    &#039; + text + &#039;\n&#039;;
                }
            }
        }
        else {
            var registerName;
            regArgs = regArgs.join(&#039;&#039;);
            for (var i = 0; i &lt; regArgs.length; i++) {
                registerName = regArgs.charAt(i);
                if (!vimGlobalState.registerController.isValidRegister(registerName)) {
                    continue;
                }
                var register = registers[registerName] || new Register();
                regInfo += &#039;&quot;&#039; + registerName + &#039;    &#039; + register.toString() + &#039;\n&#039;;
            }
        }
        showConfirm(cm, regInfo);
    },
    sort: function (cm, params) {
        var reverse, ignoreCase, unique, number, pattern;
        function parseArgs() {
            if (params.argString) {
                var args = new CodeMirror.StringStream(params.argString);
                if (args.eat(&#039;!&#039;)) {
                    reverse = true;
                }
                if (args.eol()) {
                    return;
                }
                if (!args.eatSpace()) {
                    return &#039;Invalid arguments&#039;;
                }
                var opts = args.match(/([dinuox]+)?\s*(\/.+\/)?\s*/);
                if (!opts &amp;&amp; !args.eol()) {
                    return &#039;Invalid arguments&#039;;
                }
                if (opts[1]) {
                    ignoreCase = opts[1].indexOf(&#039;i&#039;) != -1;
                    unique = opts[1].indexOf(&#039;u&#039;) != -1;
                    var decimal = opts[1].indexOf(&#039;d&#039;) != -1 || opts[1].indexOf(&#039;n&#039;) != -1 &amp;&amp; 1;
                    var hex = opts[1].indexOf(&#039;x&#039;) != -1 &amp;&amp; 1;
                    var octal = opts[1].indexOf(&#039;o&#039;) != -1 &amp;&amp; 1;
                    if (decimal + hex + octal &gt; 1) {
                        return &#039;Invalid arguments&#039;;
                    }
                    number = decimal &amp;&amp; &#039;decimal&#039; || hex &amp;&amp; &#039;hex&#039; || octal &amp;&amp; &#039;octal&#039;;
                }
                if (opts[2]) {
                    pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? &#039;i&#039; : &#039;&#039;);
                }
            }
        }
        var err = parseArgs();
        if (err) {
            showConfirm(cm, err + &#039;: &#039; + params.argString);
            return;
        }
        var lineStart = params.line || cm.firstLine();
        var lineEnd = params.lineEnd || params.line || cm.lastLine();
        if (lineStart == lineEnd) {
            return;
        }
        var curStart = new Pos(lineStart, 0);
        var curEnd = new Pos(lineEnd, lineLength(cm, lineEnd));
        var text = cm.getRange(curStart, curEnd).split(&#039;\n&#039;);
        var numberRegex = pattern ? pattern :
            (number == &#039;decimal&#039;) ? /(-?)([\d]+)/ :
                (number == &#039;hex&#039;) ? /(-?)(?:0x)?([0-9a-f]+)/i :
                    (number == &#039;octal&#039;) ? /([0-7]+)/ : null;
        var radix = (number == &#039;decimal&#039;) ? 10 : (number == &#039;hex&#039;) ? 16 : (number == &#039;octal&#039;) ? 8 : null;
        var numPart = [], textPart = [];
        if (number || pattern) {
            for (var i = 0; i &lt; text.length; i++) {
                var matchPart = pattern ? text[i].match(pattern) : null;
                if (matchPart &amp;&amp; matchPart[0] != &#039;&#039;) {
                    numPart.push(matchPart);
                }
                else if (!pattern &amp;&amp; numberRegex.exec(text[i])) {
                    numPart.push(text[i]);
                }
                else {
                    textPart.push(text[i]);
                }
            }
        }
        else {
            textPart = text;
        }
        function compareFn(a, b) {
            if (reverse) {
                var tmp;
                tmp = a;
                a = b;
                b = tmp;
            }
            if (ignoreCase) {
                a = a.toLowerCase();
                b = b.toLowerCase();
            }
            var anum = number &amp;&amp; numberRegex.exec(a);
            var bnum = number &amp;&amp; numberRegex.exec(b);
            if (!anum) {
                return a &lt; b ? -1 : 1;
            }
            anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);
            bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);
            return anum - bnum;
        }
        function comparePatternFn(a, b) {
            if (reverse) {
                var tmp;
                tmp = a;
                a = b;
                b = tmp;
            }
            if (ignoreCase) {
                a[0] = a[0].toLowerCase();
                b[0] = b[0].toLowerCase();
            }
            return (a[0] &lt; b[0]) ? -1 : 1;
        }
        numPart.sort(pattern ? comparePatternFn : compareFn);
        if (pattern) {
            for (var i = 0; i &lt; numPart.length; i++) {
                numPart[i] = numPart[i].input;
            }
        }
        else if (!number) {
            textPart.sort(compareFn);
        }
        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);
        if (unique) { // Remove duplicate lines
            var textOld = text;
            var lastLine;
            text = [];
            for (var i = 0; i &lt; textOld.length; i++) {
                if (textOld[i] != lastLine) {
                    text.push(textOld[i]);
                }
                lastLine = textOld[i];
            }
        }
        cm.replaceRange(text.join(&#039;\n&#039;), curStart, curEnd);
    },
    vglobal: function (cm, params) {
        this.global(cm, params);
    },
    global: function (cm, params) {
        var argString = params.argString;
        if (!argString) {
            showConfirm(cm, &#039;Regular Expression missing from global&#039;);
            return;
        }
        var inverted = params.commandName[0] === &#039;v&#039;;
        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();
        var lineEnd = params.lineEnd || params.line || cm.lastLine();
        var tokens = splitBySlash(argString);
        var regexPart = argString, cmd;
        if (tokens.length) {
            regexPart = tokens[0];
            cmd = tokens.slice(1, tokens.length).join(&#039;/&#039;);
        }
        if (regexPart) {
            try {
                updateSearchQuery(cm, regexPart, true /** ignoreCase */, true /** smartCase */);
            }
            catch (e) {
                showConfirm(cm, &#039;Invalid regex: &#039; + regexPart);
                return;
            }
        }
        var query = getSearchState(cm).getQuery();
        var matchedLines = [];
        for (var i = lineStart; i &lt;= lineEnd; i++) {
            var line = cm.getLineHandle(i);
            var matched = query.test(line.text);
            if (matched !== inverted) {
                matchedLines.push(cmd ? line : line.text);
            }
        }
        if (!cmd) {
            showConfirm(cm, matchedLines.join(&#039;\n&#039;));
            return;
        }
        var index = 0;
        var nextCommand = function () {
            if (index &lt; matchedLines.length) {
                var line = matchedLines[index++];
                var lineNum = cm.getLineNumber(line);
                if (lineNum == null) {
                    nextCommand();
                    return;
                }
                var command = (lineNum + 1) + cmd;
                exCommandDispatcher.processCommand(cm, command, {
                    callback: nextCommand
                });
            }
        };
        nextCommand();
    },
    substitute: function (cm, params) {
        if (!cm.getSearchCursor) {
            throw new Error(&#039;Search feature not available. Requires searchcursor.js or &#039; +
                &#039;any other getSearchCursor implementation.&#039;);
        }
        var argString = params.argString;
        var tokens = argString ? splitBySeparator(argString, argString[0]) : [];
        var regexPart, replacePart = &#039;&#039;, trailing, flagsPart, count;
        var confirm = false; // Whether to confirm each replace.
        var global = false; // True to replace all instances on a line, false to replace only 1.
        if (tokens.length) {
            regexPart = tokens[0];
            if (getOption(&#039;pcre&#039;) &amp;&amp; regexPart !== &#039;&#039;) {
                regexPart = new RegExp(regexPart).source; //normalize not escaped characters
            }
            replacePart = tokens[1];
            if (replacePart !== undefined) {
                if (getOption(&#039;pcre&#039;)) {
                    replacePart = unescapeRegexReplace(replacePart.replace(/([^\\])&amp;/g, &quot;$1$$&amp;&quot;));
                }
                else {
                    replacePart = translateRegexReplace(replacePart);
                }
                vimGlobalState.lastSubstituteReplacePart = replacePart;
            }
            trailing = tokens[2] ? tokens[2].split(&#039; &#039;) : [];
        }
        else {
            if (argString &amp;&amp; argString.length) {
                showConfirm(cm, &#039;Substitutions should be of the form &#039; +
                    &#039;:s/pattern/replace/&#039;);
                return;
            }
        }
        if (trailing) {
            flagsPart = trailing[0];
            count = parseInt(trailing[1]);
            if (flagsPart) {
                if (flagsPart.indexOf(&#039;c&#039;) != -1) {
                    confirm = true;
                }
                if (flagsPart.indexOf(&#039;g&#039;) != -1) {
                    global = true;
                }
                if (getOption(&#039;pcre&#039;)) {
                    regexPart = regexPart + &#039;/&#039; + flagsPart;
                }
                else {
                    regexPart = regexPart.replace(/\//g, &quot;\\/&quot;) + &#039;/&#039; + flagsPart;
                }
            }
        }
        if (regexPart) {
            try {
                updateSearchQuery(cm, regexPart, true /** ignoreCase */, true /** smartCase */);
            }
            catch (e) {
                showConfirm(cm, &#039;Invalid regex: &#039; + regexPart);
                return;
            }
        }
        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;
        if (replacePart === undefined) {
            showConfirm(cm, &#039;No previous substitute regular expression&#039;);
            return;
        }
        var state = getSearchState(cm);
        var query = state.getQuery();
        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;
        var lineEnd = params.lineEnd || lineStart;
        if (lineStart == cm.firstLine() &amp;&amp; lineEnd == cm.lastLine()) {
            lineEnd = Infinity;
        }
        if (count) {
            lineStart = lineEnd;
            lineEnd = lineStart + count - 1;
        }
        var startPos = clipCursorToContent(cm, new Pos(lineStart, 0));
        var cursor = cm.getSearchCursor(query, startPos);
        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);
    },
    redo: CodeMirror.commands.redo,
    undo: CodeMirror.commands.undo,
    write: function (cm) {
        if (CodeMirror.commands.save) {
            CodeMirror.commands.save(cm);
        }
        else if (cm.save) {
            cm.save();
        }
    },
    nohlsearch: function (cm) {
        clearSearchHighlight(cm);
    },
    yank: function (cm) {
        var cur = copyCursor(cm.getCursor());
        var line = cur.line;
        var lineText = cm.getLine(line);
        vimGlobalState.registerController.pushText(&#039;0&#039;, &#039;yank&#039;, lineText, true, true);
    },
    delmarks: function (cm, params) {
        if (!params.argString || !trim(params.argString)) {
            showConfirm(cm, &#039;Argument required&#039;);
            return;
        }
        var state = cm.state.vim;
        var stream = new CodeMirror.StringStream(trim(params.argString));
        while (!stream.eol()) {
            stream.eatSpace();
            var count = stream.pos;
            if (!stream.match(/[a-zA-Z]/, false)) {
                showConfirm(cm, &#039;Invalid argument: &#039; + params.argString.substring(count));
                return;
            }
            var sym = stream.next();
            if (stream.match(&#039;-&#039;, true)) {
                if (!stream.match(/[a-zA-Z]/, false)) {
                    showConfirm(cm, &#039;Invalid argument: &#039; + params.argString.substring(count));
                    return;
                }
                var startMark = sym;
                var finishMark = stream.next();
                if (isLowerCase(startMark) &amp;&amp; isLowerCase(finishMark) ||
                    isUpperCase(startMark) &amp;&amp; isUpperCase(finishMark)) {
                    var start = startMark.charCodeAt(0);
                    var finish = finishMark.charCodeAt(0);
                    if (start &gt;= finish) {
                        showConfirm(cm, &#039;Invalid argument: &#039; + params.argString.substring(count));
                        return;
                    }
                    for (var j = 0; j &lt;= finish - start; j++) {
                        var mark = String.fromCharCode(start + j);
                        delete state.marks[mark];
                    }
                }
                else {
                    showConfirm(cm, &#039;Invalid argument: &#039; + startMark + &#039;-&#039;);
                    return;
                }
            }
            else {
                delete state.marks[sym];
            }
        }
    }
};
var exCommandDispatcher = new ExCommandDispatcher();
function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query, replaceWith, callback) {
    cm.state.vim.exMode = true;
    var done = false;
    var lastPos, modifiedLineNumber, joined;
    function replaceAll() {
        cm.operation(function () {
            while (!done) {
                replace();
                next();
            }
            stop();
        });
    }
    function replace() {
        var text = cm.getRange(searchCursor.from(), searchCursor.to());
        var newText = text.replace(query, replaceWith);
        var unmodifiedLineNumber = searchCursor.to().line;
        searchCursor.replace(newText);
        modifiedLineNumber = searchCursor.to().line;
        lineEnd += modifiedLineNumber - unmodifiedLineNumber;
        joined = modifiedLineNumber &lt; unmodifiedLineNumber;
    }
    function findNextValidMatch() {
        var lastMatchTo = lastPos &amp;&amp; copyCursor(searchCursor.to());
        var match = searchCursor.findNext();
        if (match &amp;&amp; !match[0] &amp;&amp; lastMatchTo &amp;&amp; cursorEqual(searchCursor.from(), lastMatchTo)) {
            match = searchCursor.findNext();
        }
        return match;
    }
    function next() {
        while (findNextValidMatch() &amp;&amp;
            isInRange(searchCursor.from(), lineStart, lineEnd)) {
            if (!global &amp;&amp; searchCursor.from().line == modifiedLineNumber &amp;&amp; !joined) {
                continue;
            }
            cm.scrollIntoView(searchCursor.from(), 30);
            cm.setSelection(searchCursor.from(), searchCursor.to());
            lastPos = searchCursor.from();
            done = false;
            return;
        }
        done = true;
    }
    function stop(close) {
        if (close) {
            close();
        }
        cm.focus();
        if (lastPos) {
            cm.setCursor(lastPos);
            var vim = cm.state.vim;
            vim.exMode = false;
            vim.lastHPos = vim.lastHSPos = lastPos.ch;
        }
        if (callback) {
            callback();
        }
    }
    function onPromptKeyDown(e, _value, close) {
        CodeMirror.e_stop(e);
        var keyName = CodeMirror.keyName(e);
        switch (keyName) {
            case &#039;Y&#039;:
                replace();
                next();
                break;
            case &#039;N&#039;:
                next();
                break;
            case &#039;A&#039;:
                var savedCallback = callback;
                callback = undefined;
                cm.operation(replaceAll);
                callback = savedCallback;
                break;
            case &#039;L&#039;:
                replace();
            case &#039;Q&#039;:
            case &#039;Esc&#039;:
            case &#039;Ctrl-C&#039;:
            case &#039;Ctrl-[&#039;:
                stop(close);
                break;
        }
        if (done) {
            stop(close);
        }
        return true;
    }
    next();
    if (done) {
        showConfirm(cm, &#039;No matches for &#039; + query.source);
        return;
    }
    if (!confirm) {
        replaceAll();
        if (callback) {
            callback();
        }
        return;
    }
    showPrompt(cm, {
        prefix: dom(&#039;span&#039;, &#039;replace with &#039;, dom(&#039;strong&#039;, replaceWith), &#039; (y/n/a/q/l)&#039;),
        onKeyDown: onPromptKeyDown
    });
}
CodeMirror.keyMap.vim = {
    attach: attachVimMap,
    detach: detachVimMap,
    call: cmKey
};
function exitInsertMode(cm) {
    var vim = cm.state.vim;
    var macroModeState = vimGlobalState.macroModeState;
    var insertModeChangeRegister = vimGlobalState.registerController.getRegister(&#039;.&#039;);
    var isPlaying = macroModeState.isPlaying;
    var lastChange = macroModeState.lastInsertModeChanges;
    if (!isPlaying) {
        cm.off(&#039;change&#039;, onChange);
        CodeMirror.off(cm.getInputField(), &#039;keydown&#039;, onKeyEventTargetKeyDown);
    }
    if (!isPlaying &amp;&amp; vim.insertModeRepeat &gt; 1) {
        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1, true /** repeatForInsert */);
        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;
    }
    delete vim.insertModeRepeat;
    vim.insertMode = false;
    cm.setCursor(cm.getCursor().line, cm.getCursor().ch - 1);
    cm.setOption(&#039;keyMap&#039;, &#039;vim&#039;);
    cm.setOption(&#039;disableInput&#039;, true);
    cm.toggleOverwrite(false); // exit replace mode if we were in it.
    insertModeChangeRegister.setText(lastChange.changes.join(&#039;&#039;));
    CodeMirror.signal(cm, &quot;vim-mode-change&quot;, { mode: &quot;normal&quot; });
    if (macroModeState.isRecording) {
        logInsertModeChange(macroModeState);
    }
}
function _mapCommand(command) {
    defaultKeymap.unshift(command);
}
function mapCommand(keys, type, name, args, extra) {
    var command = { keys: keys, type: type };
    command[type] = name;
    command[type + &quot;Args&quot;] = args;
    for (var key in extra)
        command[key] = extra[key];
    _mapCommand(command);
}
defineOption(&#039;insertModeEscKeysTimeout&#039;, 200, &#039;number&#039;);
CodeMirror.keyMap[&#039;vim-insert&#039;] = {
    fallthrough: [&#039;default&#039;],
    attach: attachVimMap,
    detach: detachVimMap,
    call: cmKey
};
CodeMirror.keyMap[&#039;vim-replace&#039;] = {
    &#039;Backspace&#039;: &#039;goCharLeft&#039;,
    fallthrough: [&#039;vim-insert&#039;],
    attach: attachVimMap,
    detach: detachVimMap,
    call: cmKey
};
function executeMacroRegister(cm, vim, macroModeState, registerName) {
    var register = vimGlobalState.registerController.getRegister(registerName);
    if (registerName == &#039;:&#039;) {
        if (register.keyBuffer[0]) {
            exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);
        }
        macroModeState.isPlaying = false;
        return;
    }
    var keyBuffer = register.keyBuffer;
    var imc = 0;
    macroModeState.isPlaying = true;
    macroModeState.replaySearchQueries = register.searchQueries.slice(0);
    for (var i = 0; i &lt; keyBuffer.length; i++) {
        var text = keyBuffer[i];
        var match, key;
        while (text) {
            match = (/&lt;\w+-.+?&gt;|&lt;\w+&gt;|./).exec(text);
            key = match[0];
            text = text.substring(match.index + key.length);
            vimApi.handleKey(cm, key, &#039;macro&#039;);
            if (vim.insertMode) {
                var changes = register.insertModeChanges[imc++].changes;
                vimGlobalState.macroModeState.lastInsertModeChanges.changes =
                    changes;
                repeatInsertModeChanges(cm, changes, 1);
                exitInsertMode(cm);
            }
        }
    }
    macroModeState.isPlaying = false;
}
function logKey(macroModeState, key) {
    if (macroModeState.isPlaying) {
        return;
    }
    var registerName = macroModeState.latestRegister;
    var register = vimGlobalState.registerController.getRegister(registerName);
    if (register) {
        register.pushText(key);
    }
}
function logInsertModeChange(macroModeState) {
    if (macroModeState.isPlaying) {
        return;
    }
    var registerName = macroModeState.latestRegister;
    var register = vimGlobalState.registerController.getRegister(registerName);
    if (register &amp;&amp; register.pushInsertModeChanges) {
        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);
    }
}
function logSearchQuery(macroModeState, query) {
    if (macroModeState.isPlaying) {
        return;
    }
    var registerName = macroModeState.latestRegister;
    var register = vimGlobalState.registerController.getRegister(registerName);
    if (register &amp;&amp; register.pushSearchQuery) {
        register.pushSearchQuery(query);
    }
}
function onChange(cm, changeObj) {
    var macroModeState = vimGlobalState.macroModeState;
    var lastChange = macroModeState.lastInsertModeChanges;
    if (!macroModeState.isPlaying) {
        while (changeObj) {
            lastChange.expectCursorActivityForChange = true;
            if (lastChange.ignoreCount &gt; 1) {
                lastChange.ignoreCount--;
            }
            else if (changeObj.origin == &#039;+input&#039; || changeObj.origin == &#039;paste&#039;
                || changeObj.origin === undefined /* only in testing */) {
                var selectionCount = cm.listSelections().length;
                if (selectionCount &gt; 1)
                    lastChange.ignoreCount = selectionCount;
                var text = changeObj.text.join(&#039;\n&#039;);
                if (lastChange.maybeReset) {
                    lastChange.changes = [];
                    lastChange.maybeReset = false;
                }
                if (text) {
                    if (cm.state.overwrite &amp;&amp; !/\n/.test(text)) {
                        lastChange.changes.push([text]);
                    }
                    else {
                        lastChange.changes.push(text);
                    }
                }
            }
            changeObj = changeObj.next;
        }
    }
}
function onCursorActivity(cm) {
    var vim = cm.state.vim;
    if (vim.insertMode) {
        var macroModeState = vimGlobalState.macroModeState;
        if (macroModeState.isPlaying) {
            return;
        }
        var lastChange = macroModeState.lastInsertModeChanges;
        if (lastChange.expectCursorActivityForChange) {
            lastChange.expectCursorActivityForChange = false;
        }
        else {
            lastChange.maybeReset = true;
        }
    }
    else if (!cm.curOp.isVimOp) {
        handleExternalSelection(cm, vim);
    }
}
function handleExternalSelection(cm, vim, keepHPos) {
    var anchor = cm.getCursor(&#039;anchor&#039;);
    var head = cm.getCursor(&#039;head&#039;);
    if (vim.visualMode &amp;&amp; !cm.somethingSelected()) {
        exitVisualMode(cm, false);
    }
    else if (!vim.visualMode &amp;&amp; !vim.insertMode &amp;&amp; cm.somethingSelected()) {
        vim.visualMode = true;
        vim.visualLine = false;
        CodeMirror.signal(cm, &quot;vim-mode-change&quot;, { mode: &quot;visual&quot; });
    }
    if (vim.visualMode) {
        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;
        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;
        head = offsetCursor(head, 0, headOffset);
        anchor = offsetCursor(anchor, 0, anchorOffset);
        vim.sel = {
            anchor: anchor,
            head: head
        };
        updateMark(cm, vim, &#039;&lt;&#039;, cursorMin(head, anchor));
        updateMark(cm, vim, &#039;&gt;&#039;, cursorMax(head, anchor));
    }
    else if (!vim.insertMode &amp;&amp; !keepHPos) {
        vim.lastHPos = cm.getCursor().ch;
    }
}
function InsertModeKey(keyName) {
    this.keyName = keyName;
}
function onKeyEventTargetKeyDown(e) {
    var macroModeState = vimGlobalState.macroModeState;
    var lastChange = macroModeState.lastInsertModeChanges;
    var keyName = CodeMirror.keyName(e);
    if (!keyName) {
        return;
    }
    function onKeyFound() {
        if (lastChange.maybeReset) {
            lastChange.changes = [];
            lastChange.maybeReset = false;
        }
        lastChange.changes.push(new InsertModeKey(keyName));
        return true;
    }
    if (keyName.indexOf(&#039;Delete&#039;) != -1 || keyName.indexOf(&#039;Backspace&#039;) != -1) {
        CodeMirror.lookupKey(keyName, &#039;vim-insert&#039;, onKeyFound);
    }
}
function repeatLastEdit(cm, vim, repeat, repeatForInsert) {
    var macroModeState = vimGlobalState.macroModeState;
    macroModeState.isPlaying = true;
    var isAction = !!vim.lastEditActionCommand;
    var cachedInputState = vim.inputState;
    function repeatCommand() {
        if (isAction) {
            commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);
        }
        else {
            commandDispatcher.evalInput(cm, vim);
        }
    }
    function repeatInsert(repeat) {
        if (macroModeState.lastInsertModeChanges.changes.length &gt; 0) {
            repeat = !vim.lastEditActionCommand ? 1 : repeat;
            var changeObject = macroModeState.lastInsertModeChanges;
            repeatInsertModeChanges(cm, changeObject.changes, repeat);
        }
    }
    vim.inputState = vim.lastEditInputState;
    if (isAction &amp;&amp; vim.lastEditActionCommand.interlaceInsertRepeat) {
        for (var i = 0; i &lt; repeat; i++) {
            repeatCommand();
            repeatInsert(1);
        }
    }
    else {
        if (!repeatForInsert) {
            repeatCommand();
        }
        repeatInsert(repeat);
    }
    vim.inputState = cachedInputState;
    if (vim.insertMode &amp;&amp; !repeatForInsert) {
        exitInsertMode(cm);
    }
    macroModeState.isPlaying = false;
}
function repeatInsertModeChanges(cm, changes, repeat) {
    function keyHandler(binding) {
        if (typeof binding == &#039;string&#039;) {
            CodeMirror.commands[binding](cm);
        }
        else {
            binding(cm);
        }
        return true;
    }
    var head = cm.getCursor(&#039;head&#039;);
    var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;
    if (visualBlock) {
        selectForInsert(cm, head, visualBlock + 1);
        repeat = cm.listSelections().length;
        cm.setCursor(head);
    }
    for (var i = 0; i &lt; repeat; i++) {
        if (visualBlock) {
            cm.setCursor(offsetCursor(head, i, 0));
        }
        for (var j = 0; j &lt; changes.length; j++) {
            var change = changes[j];
            if (change instanceof InsertModeKey) {
                CodeMirror.lookupKey(change.keyName, &#039;vim-insert&#039;, keyHandler);
            }
            else if (typeof change == &quot;string&quot;) {
                cm.replaceSelection(change);
            }
            else {
                var start = cm.getCursor();
                var end = offsetCursor(start, 0, change[0].length);
                cm.replaceRange(change[0], start, end);
                cm.setCursor(end);
            }
        }
    }
    if (visualBlock) {
        cm.setCursor(offsetCursor(head, 0, 1));
    }
}
resetVimGlobalState();
CodeMirror.Vim = vimApi;
var specialKey = { &#039;return&#039;: &#039;CR&#039;, backspace: &#039;BS&#039;, &#039;delete&#039;: &#039;Del&#039;, esc: &#039;Esc&#039;,
    left: &#039;Left&#039;, right: &#039;Right&#039;, up: &#039;Up&#039;, down: &#039;Down&#039;, space: &#039;Space&#039;, insert: &#039;Ins&#039;,
    home: &#039;Home&#039;, end: &#039;End&#039;, pageup: &#039;PageUp&#039;, pagedown: &#039;PageDown&#039;, enter: &#039;CR&#039;
};
function lookupKey(hashId, key, e) {
    if (key.length &gt; 1 &amp;&amp; key[0] == &quot;n&quot;) {
        key = key.replace(&quot;numpad&quot;, &quot;&quot;);
    }
    key = specialKey[key] || key;
    var name = &#039;&#039;;
    if (e.ctrlKey) {
        name += &#039;C-&#039;;
    }
    if (e.altKey) {
        name += &#039;A-&#039;;
    }
    if ((name || key.length &gt; 1) &amp;&amp; e.shiftKey) {
        name += &#039;S-&#039;;
    }
    name += key;
    if (name.length &gt; 1) {
        name = &#039;&lt;&#039; + name + &#039;&gt;&#039;;
    }
    return name;
}
var handleKey = vimApi.handleKey.bind(vimApi);
vimApi.handleKey = function (cm, key, origin) {
    return cm.operation(function () {
        return handleKey(cm, key, origin);
    }, true);
};
function cloneVimState(state) {
    var n = new state.constructor();
    Object.keys(state).forEach(function (key) {
        var o = state[key];
        if (Array.isArray(o))
            o = o.slice();
        else if (o &amp;&amp; typeof o == &quot;object&quot; &amp;&amp; o.constructor != Object)
            o = cloneVimState(o);
        n[key] = o;
    });
    if (state.sel) {
        n.sel = {
            head: state.sel.head &amp;&amp; copyCursor(state.sel.head),
            anchor: state.sel.anchor &amp;&amp; copyCursor(state.sel.anchor)
        };
    }
    return n;
}
function multiSelectHandleKey(cm, key, origin) {
    var isHandled = false;
    var vim = vimApi.maybeInitVimState_(cm);
    var visualBlock = vim.visualBlock || vim.wasInVisualBlock;
    var wasMultiselect = cm.ace.inMultiSelectMode;
    if (vim.wasInVisualBlock &amp;&amp; !wasMultiselect) {
        vim.wasInVisualBlock = false;
    }
    else if (wasMultiselect &amp;&amp; vim.visualBlock) {
        vim.wasInVisualBlock = true;
    }
    if (key == &#039;&lt;Esc&gt;&#039; &amp;&amp; !vim.insertMode &amp;&amp; !vim.visualMode &amp;&amp; wasMultiselect) {
        cm.ace.exitMultiSelectMode();
    }
    else if (visualBlock || !wasMultiselect || cm.ace.inVirtualSelectionMode) {
        isHandled = vimApi.handleKey(cm, key, origin);
    }
    else {
        var old = cloneVimState(vim);
        cm.operation(function () {
            cm.ace.forEachSelection(function () {
                var sel = cm.ace.selection;
                cm.state.vim.lastHPos = sel.$desiredColumn == null ? sel.lead.column : sel.$desiredColumn;
                var head = cm.getCursor(&quot;head&quot;);
                var anchor = cm.getCursor(&quot;anchor&quot;);
                var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;
                var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;
                head = offsetCursor(head, 0, headOffset);
                anchor = offsetCursor(anchor, 0, anchorOffset);
                cm.state.vim.sel.head = head;
                cm.state.vim.sel.anchor = anchor;
                isHandled = handleKey(cm, key, origin);
                sel.$desiredColumn = cm.state.vim.lastHPos == -1 ? null : cm.state.vim.lastHPos;
                if (cm.virtualSelectionMode()) {
                    cm.state.vim = cloneVimState(old);
                }
            });
            if (cm.curOp.cursorActivity &amp;&amp; !isHandled)
                cm.curOp.cursorActivity = false;
        }, true);
    }
    if (isHandled &amp;&amp; !vim.visualMode &amp;&amp; !vim.insert &amp;&amp; vim.visualMode != cm.somethingSelected()) {
        handleExternalSelection(cm, vim, true);
    }
    return isHandled;
}
exports.CodeMirror = CodeMirror;
var getVim = vimApi.maybeInitVimState_;
exports.handler = {
    $id: &quot;ace/keyboard/vim&quot;,
    drawCursor: function (element, pixelPos, config, sel, session) {
        var vim = this.state.vim || {};
        var w = config.characterWidth;
        var h = config.lineHeight;
        var top = pixelPos.top;
        var left = pixelPos.left;
        if (!vim.insertMode) {
            var isbackwards = !sel.cursor
                ? session.selection.isBackwards() || session.selection.isEmpty()
                : Range.comparePoints(sel.cursor, sel.start) &lt;= 0;
            if (!isbackwards &amp;&amp; left &gt; w)
                left -= w;
        }
        if (!vim.insertMode &amp;&amp; vim.status) {
            h = h / 2;
            top += h;
        }
        domLib.translate(element, left, top);
        domLib.setStyle(element.style, &quot;width&quot;, w + &quot;px&quot;);
        domLib.setStyle(element.style, &quot;height&quot;, h + &quot;px&quot;);
    },
    $getDirectionForHighlight: function (editor) {
        var cm = editor.state.cm;
        var vim = getVim(cm);
        if (!vim.insertMode) {
            return editor.session.selection.isBackwards() || editor.session.selection.isEmpty();
        }
    },
    handleKeyboard: function (data, hashId, key, keyCode, e) {
        var editor = data.editor;
        var cm = editor.state.cm;
        var vim = getVim(cm);
        if (keyCode == -1)
            return;
        if (!vim.insertMode) {
            if (hashId == -1) {
                if (key.charCodeAt(0) &gt; 0xFF) {
                    if (data.inputKey) {
                        key = data.inputKey;
                        if (key &amp;&amp; data.inputHash == 4)
                            key = key.toUpperCase();
                    }
                }
                data.inputChar = key;
            }
            else if (hashId == 4 || hashId == 0) {
                if (data.inputKey == key &amp;&amp; data.inputHash == hashId &amp;&amp; data.inputChar) {
                    key = data.inputChar;
                    hashId = -1;
                }
                else {
                    data.inputChar = null;
                    data.inputKey = key;
                    data.inputHash = hashId;
                }
            }
            else {
                data.inputChar = data.inputKey = null;
            }
        }
        if (cm.state.overwrite &amp;&amp; vim.insertMode &amp;&amp; key == &quot;backspace&quot; &amp;&amp; hashId == 0) {
            return { command: &quot;gotoleft&quot; };
        }
        if (key == &quot;c&quot; &amp;&amp; hashId == 1) { // key == &quot;ctrl-c&quot;
            if (!useragent.isMac &amp;&amp; editor.getCopyText()) {
                editor.once(&quot;copy&quot;, function () {
                    if (vim.insertMode)
                        editor.selection.clearSelection();
                    else
                        cm.operation(function () { exitVisualMode(cm); });
                });
                return { command: &quot;null&quot;, passEvent: true };
            }
        }
        if (key == &quot;esc&quot; &amp;&amp; !vim.insertMode &amp;&amp; !vim.visualMode &amp;&amp; !cm.ace.inMultiSelectMode) {
            var searchState = getSearchState(cm);
            var overlay = searchState.getOverlay();
            if (overlay)
                cm.removeOverlay(overlay);
        }
        if (hashId == -1 || hashId &amp; 1 || hashId === 0 &amp;&amp; key.length &gt; 1) {
            var insertMode = vim.insertMode;
            var name = lookupKey(hashId, key, e || {});
            if (vim.status == null)
                vim.status = &quot;&quot;;
            var isHandled = multiSelectHandleKey(cm, name, &#039;user&#039;);
            vim = getVim(cm); // may be changed by multiSelectHandleKey
            if (isHandled &amp;&amp; vim.status != null)
                vim.status += name;
            else if (vim.status == null)
                vim.status = &quot;&quot;;
            cm._signal(&quot;changeStatus&quot;);
            if (!isHandled &amp;&amp; (hashId != -1 || insertMode))
                return;
            return { command: &quot;null&quot;, passEvent: !isHandled };
        }
    },
    attach: function (editor) {
        if (!editor.state)
            editor.state = {};
        var cm = new CodeMirror(editor);
        editor.state.cm = cm;
        editor.$vimModeHandler = this;
        CodeMirror.keyMap.vim.attach(cm);
        getVim(cm).status = null;
        cm.on(&#039;vim-command-done&#039;, function () {
            if (cm.virtualSelectionMode())
                return;
            getVim(cm).status = null;
            cm.ace._signal(&quot;changeStatus&quot;);
            cm.ace.session.markUndoGroup();
        });
        cm.on(&quot;changeStatus&quot;, function () {
            cm.ace.renderer.updateCursor();
            cm.ace._signal(&quot;changeStatus&quot;);
        });
        cm.on(&quot;vim-mode-change&quot;, function () {
            if (cm.virtualSelectionMode())
                return;
            updateInputMode();
            cm._signal(&quot;changeStatus&quot;);
        });
        function updateInputMode() {
            var isIntsert = getVim(cm).insertMode;
            cm.ace.renderer.setStyle(&quot;normal-mode&quot;, !isIntsert);
            editor.textInput.setCommandMode(!isIntsert);
            editor.renderer.$keepTextAreaAtCursor = isIntsert;
            editor.renderer.$blockCursor = !isIntsert;
        }
        updateInputMode();
        editor.renderer.$cursorLayer.drawCursor = this.drawCursor.bind(cm);
    },
    detach: function (editor) {
        var cm = editor.state.cm;
        CodeMirror.keyMap.vim.detach(cm);
        cm.destroy();
        editor.state.cm = null;
        editor.$vimModeHandler = null;
        editor.renderer.$cursorLayer.drawCursor = null;
        editor.renderer.setStyle(&quot;normal-mode&quot;, false);
        editor.textInput.setCommandMode(false);
        editor.renderer.$keepTextAreaAtCursor = true;
    },
    getStatusText: function (editor) {
        var cm = editor.state.cm;
        var vim = getVim(cm);
        if (vim.insertMode)
            return &quot;INSERT&quot;;
        var status = &quot;&quot;;
        if (vim.visualMode) {
            status += &quot;VISUAL&quot;;
            if (vim.visualLine)
                status += &quot; LINE&quot;;
            if (vim.visualBlock)
                status += &quot; BLOCK&quot;;
        }
        if (vim.status)
            status += (status ? &quot; &quot; : &quot;&quot;) + vim.status;
        return status;
    }
};
vimApi.defineOption({
    name: &quot;wrap&quot;,
    set: function (value, cm) {
        if (cm) {
            cm.ace.setOption(&quot;wrap&quot;, value);
        }
    },
    type: &quot;boolean&quot;
}, false);
vimApi.defineEx(&#039;write&#039;, &#039;w&#039;, function () {
    console.log(&#039;:write is not implemented&#039;);
});
defaultKeymap.push({ keys: &#039;zc&#039;, type: &#039;action&#039;, action: &#039;fold&#039;, actionArgs: { open: false } }, { keys: &#039;zC&#039;, type: &#039;action&#039;, action: &#039;fold&#039;, actionArgs: { open: false, all: true } }, { keys: &#039;zo&#039;, type: &#039;action&#039;, action: &#039;fold&#039;, actionArgs: { open: true } }, { keys: &#039;zO&#039;, type: &#039;action&#039;, action: &#039;fold&#039;, actionArgs: { open: true, all: true } }, { keys: &#039;za&#039;, type: &#039;action&#039;, action: &#039;fold&#039;, actionArgs: { toggle: true } }, { keys: &#039;zA&#039;, type: &#039;action&#039;, action: &#039;fold&#039;, actionArgs: { toggle: true, all: true } }, { keys: &#039;zf&#039;, type: &#039;action&#039;, action: &#039;fold&#039;, actionArgs: { open: true, all: true } }, { keys: &#039;zd&#039;, type: &#039;action&#039;, action: &#039;fold&#039;, actionArgs: { open: true, all: true } }, { keys: &#039;&lt;C-A-k&gt;&#039;, type: &#039;action&#039;, action: &#039;aceCommand&#039;, actionArgs: { name: &quot;addCursorAbove&quot; } }, { keys: &#039;&lt;C-A-j&gt;&#039;, type: &#039;action&#039;, action: &#039;aceCommand&#039;, actionArgs: { name: &quot;addCursorBelow&quot; } }, { keys: &#039;&lt;C-A-S-k&gt;&#039;, type: &#039;action&#039;, action: &#039;aceCommand&#039;, actionArgs: { name: &quot;addCursorAboveSkipCurrent&quot; } }, { keys: &#039;&lt;C-A-S-j&gt;&#039;, type: &#039;action&#039;, action: &#039;aceCommand&#039;, actionArgs: { name: &quot;addCursorBelowSkipCurrent&quot; } }, { keys: &#039;&lt;C-A-h&gt;&#039;, type: &#039;action&#039;, action: &#039;aceCommand&#039;, actionArgs: { name: &quot;selectMoreBefore&quot; } }, { keys: &#039;&lt;C-A-l&gt;&#039;, type: &#039;action&#039;, action: &#039;aceCommand&#039;, actionArgs: { name: &quot;selectMoreAfter&quot; } }, { keys: &#039;&lt;C-A-S-h&gt;&#039;, type: &#039;action&#039;, action: &#039;aceCommand&#039;, actionArgs: { name: &quot;selectNextBefore&quot; } }, { keys: &#039;&lt;C-A-S-l&gt;&#039;, type: &#039;action&#039;, action: &#039;aceCommand&#039;, actionArgs: { name: &quot;selectNextAfter&quot; } });
defaultKeymap.push({
    keys: &#039;gq&#039;,
    type: &#039;operator&#039;,
    operator: &#039;hardWrap&#039;
});
vimApi.defineOperator(&quot;hardWrap&quot;, function (cm, operatorArgs, ranges, oldAnchor, newHead) {
    var anchor = ranges[0].anchor.line;
    var head = ranges[0].head.line;
    if (operatorArgs.linewise)
        head--;
    hardWrap(cm.ace, { startRow: anchor, endRow: head });
    return Pos(head, 0);
});
defineOption(&#039;textwidth&#039;, undefined, &#039;number&#039;, [&#039;tw&#039;], function (width, cm) {
    if (cm === undefined) {
        return;
    }
    if (width === undefined) {
        var value = cm.ace.getOption(&#039;printMarginColumn&#039;);
        return value;
    }
    else {
        var column = Math.round(width);
        if (column &gt; 1) {
            cm.ace.setOption(&#039;printMarginColumn&#039;, column);
        }
    }
});
actions.aceCommand = function (cm, actionArgs, vim) {
    cm.vimCmd = actionArgs;
    if (cm.ace.inVirtualSelectionMode)
        cm.ace.on(&quot;beforeEndOperation&quot;, delayedExecAceCommand);
    else
        delayedExecAceCommand(null, cm.ace);
};
function delayedExecAceCommand(op, ace) {
    ace.off(&quot;beforeEndOperation&quot;, delayedExecAceCommand);
    var cmd = ace.state.cm.vimCmd;
    if (cmd) {
        ace.execCommand(cmd.exec ? cmd : cmd.name, cmd.args);
    }
    ace.curOp = ace.prevOp;
}
actions.fold = function (cm, actionArgs, vim) {
    cm.ace.execCommand([&#039;toggleFoldWidget&#039;, &#039;toggleFoldWidget&#039;, &#039;foldOther&#039;, &#039;unfoldall&#039;
    ][(actionArgs.all ? 2 : 0) + (actionArgs.open ? 1 : 0)]);
};
exports.handler.defaultKeymap = defaultKeymap;
exports.handler.actions = actions;
exports.Vim = vimApi;

});                (function() {
                    window.require([&quot;ace/keyboard/vim&quot;], function(m) {
                        if (typeof module == &quot;object&quot; &amp;&amp; typeof exports == &quot;object&quot; &amp;&amp; module) {
                            module.exports = m;
                        }
                    });
                })();</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
